declare module "mekanism.common.content.network.InventoryNetwork" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$TransporterStack, $TransporterStack$$Type} from "mekanism.common.content.transporter.TransporterStack"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Long2ObjectMap, $Long2ObjectMap$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectMap"
import {$InventoryNetwork$AcceptorData, $InventoryNetwork$AcceptorData$$Type} from "mekanism.common.content.network.InventoryNetwork$AcceptorData"
import {$ChunkAccess, $ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$LogisticalTransporterBase, $LogisticalTransporterBase$$Type} from "mekanism.common.content.network.transmitter.LogisticalTransporterBase"
import {$DynamicNetwork, $DynamicNetwork$$Type} from "mekanism.common.lib.transmitter.DynamicNetwork"
import {$TransitRequest, $TransitRequest$$Type} from "mekanism.common.lib.inventory.TransitRequest"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Set, $Set$$Type} from "java.util.Set"

export class $InventoryNetwork extends $DynamicNetwork<($IItemHandler), ($InventoryNetwork), ($LogisticalTransporterBase)> {

constructor(networkID: $UUID$$Type)
constructor(networks: $Collection$$Type<($InventoryNetwork$$Type)>)

public "toString"(): string
public "commit"(): void
public "deregister"(): void
public "calculateAcceptors"(request: $TransitRequest$$Type, stack: $TransporterStack$$Type, chunkMap: $Long2ObjectMap$$Type<($ChunkAccess$$Type)>, additionalFlowingStacks: $Map$$Type<($GlobalPos$$Type), ($Set$$Type<($TransporterStack$$Type)>)>): $List<($InventoryNetwork$AcceptorData)>
public "getTextComponent"(): $Component
get "textComponent"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryNetwork$$Type = ($InventoryNetwork);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryNetwork_ = $InventoryNetwork$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.type.ChemicalInputCache" {
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$ChemicalStackIngredient, $ChemicalStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ChemicalStackIngredient"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$InputIngredient, $InputIngredient$$Type} from "mekanism.api.recipes.ingredients.InputIngredient"
import {$Chemical, $Chemical$$Type} from "mekanism.api.chemical.Chemical"
import {$BaseInputCache, $BaseInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.BaseInputCache"

export class $ChemicalInputCache<RECIPE extends $MekanismRecipe<(any)>> extends $BaseInputCache<($Chemical), ($ChemicalStack), ($ChemicalStackIngredient), (RECIPE)> {

constructor()

public "isEmpty"(input: any): boolean
public "isEmpty"(input: $ChemicalStack$$Type): boolean
public "mapInputs"(recipe: $MekanismRecipe$$Type<(any)>, inputIngredient: $InputIngredient$$Type<(any)>): boolean
public "mapInputs"(recipe: RECIPE, inputIngredient: $ChemicalStackIngredient$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalInputCache$$Type<RECIPE> = ($ChemicalInputCache<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalInputCache_<RECIPE> = $ChemicalInputCache$$Type<(RECIPE)>;
}}
declare module "mekanism.common.tile.interfaces.IFluidContainerManager" {
import {$IFluidContainerManager$ContainerEditMode, $IFluidContainerManager$ContainerEditMode$$Type} from "mekanism.common.tile.interfaces.IFluidContainerManager$ContainerEditMode"
import {$IHasMode, $IHasMode$$Type} from "mekanism.common.tile.interfaces.IHasMode"

export interface $IFluidContainerManager extends $IHasMode {

 "getContainerEditMode"(): $IFluidContainerManager$ContainerEditMode
 "nextMode"(): void
 "previousMode"(): void
get "containerEditMode"(): $IFluidContainerManager$ContainerEditMode
}

export namespace $IFluidContainerManager {
const probejs$$marker: never
}
export class $IFluidContainerManager$$Static implements $IFluidContainerManager {


 "getContainerEditMode"(): $IFluidContainerManager$ContainerEditMode
 "nextMode"(): void
 "previousMode"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFluidContainerManager$$Type = ($IFluidContainerManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFluidContainerManager_ = $IFluidContainerManager$$Type;
}}
declare module "mekanism.common.tile.laser.TileEntityBasicLaser" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$LaserEnergyContainer, $LaserEnergyContainer$$Type} from "mekanism.common.capabilities.energy.LaserEnergyContainer"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityBasicLaser extends $TileEntityMekanism {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "saveAdditional"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "loadAdditional"(nbt: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
/**
 * 
 * @deprecated
 */
public "removeComponentsFromTag"(tag: $CompoundTag$$Type): void
public "getEnergyContainer"(): $LaserEnergyContainer
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "energyContainer"(): $LaserEnergyContainer
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityBasicLaser$$Type = ($TileEntityBasicLaser);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityBasicLaser_ = $TileEntityBasicLaser$$Type;
}}
declare module "mekanism.common.attachments.containers.chemical.ComponentBackedChemicalHandler" {
import {$IMekanismChemicalHandler, $IMekanismChemicalHandler$$Type} from "mekanism.api.chemical.IMekanismChemicalHandler"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$AttachedChemicals, $AttachedChemicals$$Type} from "mekanism.common.attachments.containers.chemical.AttachedChemicals"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$ComponentBackedHandler, $ComponentBackedHandler$$Type} from "mekanism.common.attachments.containers.ComponentBackedHandler"

export class $ComponentBackedChemicalHandler extends $ComponentBackedHandler<($ChemicalStack), ($IChemicalTank), ($AttachedChemicals)> implements $IMekanismChemicalHandler {

constructor(attachedTo: $ItemStack$$Type, totalTanks: integer)

public "getChemicalTank"(tank: integer, side: $Direction$$Type): $IChemicalTank
public "getCountChemicalTanks"(side: $Direction$$Type): integer
public "insertChemical"(stack: $ChemicalStack$$Type, side: $Direction$$Type, action: $Action$$Type): $ChemicalStack
public "extractChemical"(amount: long, side: $Direction$$Type, action: $Action$$Type): $ChemicalStack
public "extractChemical"(stack: $ChemicalStack$$Type, side: $Direction$$Type, action: $Action$$Type): $ChemicalStack
public "getChemicalTanks"(side: $Direction$$Type): $List<($IChemicalTank)>
public "getChemicalInTank"(tank: integer, side: $Direction$$Type): $ChemicalStack
public "isValid"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Direction$$Type): boolean
public "getChemicalTankCapacity"(arg0: integer, arg1: $Direction$$Type): long
public "setChemicalInTank"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Direction$$Type): void
public "insertChemical"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: integer, arg1: long, arg2: $Direction$$Type, arg3: $Action$$Type): $ChemicalStack
public "canHandleChemicals"(): boolean
public "isValid"(arg0: integer, arg1: $ChemicalStack$$Type): boolean
public "getSideFor"(): $Direction
public "getChemicalTankCapacity"(arg0: integer): long
public "setChemicalInTank"(arg0: integer, arg1: $ChemicalStack$$Type): void
public "insertChemical"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: integer, arg1: long, arg2: $Action$$Type): $ChemicalStack
public "getChemicalTanks"(): integer
public "getChemicalInTank"(arg0: integer): $ChemicalStack
public "spliterator"(): $Spliterator<(T)>
public "insertChemical"(arg0: $ChemicalStack$$Type, arg1: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: long, arg1: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: $ChemicalStack$$Type, arg1: $Action$$Type): $ChemicalStack
public "remove"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$$Type<(E)>): $List<(E)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$$Type<(E)>): boolean
public "removeAll"(arg0: $Collection$$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$$Type<(any)>): boolean
public "reversed"(): $SequencedCollection<(any)>
public "containsAll"(arg0: $Collection$$Type<(any)>): boolean
get "sideFor"(): $Direction
get "chemicalTanks"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBackedChemicalHandler$$Type = ($ComponentBackedChemicalHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBackedChemicalHandler_ = $ComponentBackedChemicalHandler$$Type;
}}
declare module "mekanism.common.inventory.slot.OutputInventorySlot" {
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$BasicInventorySlot, $BasicInventorySlot$$Type} from "mekanism.common.inventory.slot.BasicInventorySlot"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $OutputInventorySlot extends $BasicInventorySlot {
static readonly "alwaysTrue": $Predicate<($ItemStack)>
static readonly "alwaysFalse": $Predicate<($ItemStack)>
static readonly "alwaysTrueBi": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($ItemStack), ($AutomationType)>


public static "at"(listener: $IContentsListener$$Type, x: integer, y: integer): $OutputInventorySlot
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $Tag
public "createContainerSlot"(): $Slot
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OutputInventorySlot$$Type = ($OutputInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OutputInventorySlot_ = $OutputInventorySlot$$Type;
}}
declare module "mekanism.common.content.qio.QIOFrequency$QIOItemTypeData" {
import {$QIOFrequency, $QIOFrequency$$Type} from "mekanism.common.content.qio.QIOFrequency"
import {$HashedItem, $HashedItem$$Type} from "mekanism.common.lib.inventory.HashedItem"

export class $QIOFrequency$QIOItemTypeData {

constructor(this$0: $QIOFrequency$$Type, itemType: $HashedItem$$Type)

public "getCount"(): long
get "count"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOFrequency$QIOItemTypeData$$Type = ($QIOFrequency$QIOItemTypeData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOFrequency$QIOItemTypeData_ = $QIOFrequency$QIOItemTypeData$$Type;
}}
declare module "mekanism.common.lib.radial.IGenericRadialModeItem" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IRadialMode, $IRadialMode$$Type} from "mekanism.api.radial.mode.IRadialMode"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$IModeItem, $IModeItem$$Type} from "mekanism.common.item.interfaces.IModeItem"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"
import {$RadialData, $RadialData$$Type} from "mekanism.api.radial.RadialData"

export interface $IGenericRadialModeItem extends $IModeItem {

 "setMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, player: $Player$$Type, radialData: $RadialData$$Type<(M)>, mode: M): void
 "getMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, radialData: $RadialData$$Type<(M)>): M
 "getRadialData"(stack: $ItemStack$$Type): $RadialData<(any)>
 "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
 "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
 "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
}

export namespace $IGenericRadialModeItem {
function displayModeChange(player: $Player$$Type): void
function isModeItem(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
function isModeItem(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
const probejs$$marker: never
}
export class $IGenericRadialModeItem$$Static implements $IGenericRadialModeItem {


 "setMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, player: $Player$$Type, radialData: $RadialData$$Type<(M)>, mode: M): void
 "getMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, radialData: $RadialData$$Type<(M)>): M
 "getRadialData"(stack: $ItemStack$$Type): $RadialData<(any)>
 "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
static "displayModeChange"(player: $Player$$Type): void
 "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
 "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGenericRadialModeItem$$Type = ($IGenericRadialModeItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGenericRadialModeItem_ = $IGenericRadialModeItem$$Type;
}}
declare module "mekanism.common.attachments.containers.item.ComponentBackedItemHandler" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$AttachedItems, $AttachedItems$$Type} from "mekanism.common.attachments.containers.item.AttachedItems"
import {$IMekanismInventory, $IMekanismInventory$$Type} from "mekanism.api.inventory.IMekanismInventory"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$ComponentBackedHandler, $ComponentBackedHandler$$Type} from "mekanism.common.attachments.containers.ComponentBackedHandler"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"

export class $ComponentBackedItemHandler extends $ComponentBackedHandler<($ItemStack), ($IInventorySlot), ($AttachedItems)> implements $IMekanismInventory {

constructor(attachedTo: $ItemStack$$Type, totalSlots: integer)

public "getSlots"(side: $Direction$$Type): integer
public "getStackInSlot"(slot: integer, side: $Direction$$Type): $ItemStack
public "getInventorySlots"(side: $Direction$$Type): $List<($IInventorySlot)>
public "getInventorySlot"(slot: integer, side: $Direction$$Type): $IInventorySlot
public "isInventoryEmpty"(side: $Direction$$Type): boolean
public "extractItem"(arg0: integer, arg1: integer, arg2: $Direction$$Type, arg3: $Action$$Type): $ItemStack
public "getSlotLimit"(arg0: integer, arg1: $Direction$$Type): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $ItemStack
public "hasInventory"(): boolean
public "isInventoryEmpty"(): boolean
public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "getInventorySideFor"(): $Direction
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "spliterator"(): $Spliterator<(T)>
public "remove"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$$Type<(E)>): $List<(E)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$$Type<(E)>): boolean
public "removeAll"(arg0: $Collection$$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$$Type<(any)>): boolean
public "reversed"(): $SequencedCollection<(any)>
public "containsAll"(arg0: $Collection$$Type<(any)>): boolean
public "kjs$self"(): $IItemHandler
public "getStackInSlot"(arg0: integer): $ItemStack
public "getSlots"(): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isMutable"(): boolean
public "getBlock"(arg0: $Level$$Type): $BlockContainerJS
public "asContainer"(): $Container
public "getHeight"(): integer
public "setChanged"(): void
public "insertItem"(arg0: $ItemStack$$Type, arg1: boolean): $ItemStack
public "getAllItems"(): $List<($ItemStack)>
public "countNonEmpty"(): integer
public "countNonEmpty"(arg0: $ItemPredicate$$Type): integer
public "getWidth"(): integer
public "isEmpty"(): boolean
public "find"(): integer
public "find"(arg0: $ItemPredicate$$Type): integer
public "clear"(arg0: $ItemPredicate$$Type): void
public "clear"(): void
public "count"(arg0: $ItemPredicate$$Type): integer
public "count"(): integer
get "inventoryEmpty"(): boolean
get "slots"(): integer
get "inventorySideFor"(): $Direction
get "empty"(): boolean
get "slots"(): integer
get "mutable"(): boolean
get "height"(): integer
get "allItems"(): $List<($ItemStack)>
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBackedItemHandler$$Type = ($ComponentBackedItemHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBackedItemHandler_ = $ComponentBackedItemHandler$$Type;
}}
declare module "mekanism.common.item.ItemEnergized" {
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$$Type} from "mekanism.common.registration.impl.CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemEnergized extends $Item implements $CreativeTabDeferredRegister$ICustomCreativeTabContents {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "getBarWidth"(stack: $ItemStack$$Type): integer
public "getBarColor"(stack: $ItemStack$$Type): integer
public "isBarVisible"(stack: $ItemStack$$Type): boolean
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$$Type, newStack: $ItemStack$$Type, slotChanged: boolean): boolean
public "shouldCauseBlockBreakReset"(oldStack: $ItemStack$$Type, newStack: $ItemStack$$Type): boolean
public "addItems"(tabOutput: $Consumer$$Type<($ItemStack)>): void
public "addDefault"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEnergized$$Type = ($ItemEnergized);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemEnergized_ = $ItemEnergized$$Type;
}}
declare module "mekanism.common.block.states.IFluidLogType" {
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"

export interface $IFluidLogType {

 "isEmpty"(): boolean
 "getFluid"(): $Fluid

(): $Fluid$$Type
get "empty"(): boolean
get "fluid"(): $Fluid
}

export namespace $IFluidLogType {
const probejs$$marker: never
}
export class $IFluidLogType$$Static implements $IFluidLogType {


 "isEmpty"(): boolean
 "getFluid"(): $Fluid
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFluidLogType$$Type = (() => $Fluid$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFluidLogType_ = $IFluidLogType$$Type;
}}
declare module "mekanism.common.lib.multiblock.MultiblockManager" {
import {$IStructureValidator, $IStructureValidator$$Type} from "mekanism.common.lib.multiblock.IStructureValidator"
import {$MultiblockCache, $MultiblockCache$$Type} from "mekanism.common.lib.multiblock.MultiblockCache"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Set, $Set$$Type} from "java.util.Set"
import {$MultiblockData, $MultiblockData$$Type} from "mekanism.common.lib.multiblock.MultiblockData"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $MultiblockManager<T extends $MultiblockData> {

constructor(name: string, cacheSupplier: $Supplier$$Type<($MultiblockCache$$Type<(T)>)>, validatorSupplier: $Supplier$$Type<($IStructureValidator$$Type<(T)>)>)

public "getName"(): string
public static "reset"(): void
public "toString"(): string
public "getCache"(multiblockID: $UUID$$Type): $MultiblockCache<(T)>
public "isCompatible"(tile: $BlockEntity$$Type): boolean
public static "createOrLoadAll"(): void
public "getNameLower"(): string
public "createCache"(): $MultiblockCache<(T)>
public "replaceCaches"(staleIds: $Set$$Type<($UUID$$Type)>, id: $UUID$$Type, cache: $MultiblockCache$$Type<(T)>): void
public "createValidator"(): $IStructureValidator<(T)>
public "getUniqueInventoryID"(): $UUID
public "handleDirtyMultiblock"(multiblock: T): void
public "trackCache"(id: $UUID$$Type, cache: $MultiblockCache$$Type<(T)>): void
get "name"(): string
get "nameLower"(): string
get "uniqueInventoryID"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockManager$$Type<T> = ($MultiblockManager<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockManager_<T> = $MultiblockManager$$Type<(T)>;
}}
declare module "mekanism.common.registration.MekanismDeferredHolder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$INamedEntry, $INamedEntry$$Type} from "mekanism.common.registration.INamedEntry"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$DeferredHolder, $DeferredHolder$$Type} from "net.neoforged.neoforge.registries.DeferredHolder"

export class $MekanismDeferredHolder<R, T extends R> extends $DeferredHolder<(R), (T)> implements $INamedEntry {

constructor(key: $ResourceKey$$Type<(R)>)
constructor(registryKey: $ResourceKey$$Type<($Registry<(R)>)>, valueName: $ResourceLocation$$Type)

public "getName"(): string
public "getId"(): $ResourceLocation
public static "direct"<T>(arg0: T): $Holder<(T)>
get "name"(): string
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismDeferredHolder$$Type<R, T> = ($MekanismDeferredHolder<(R), (T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismDeferredHolder_<R, T> = $MekanismDeferredHolder$$Type<(R), (T)>;
}}
declare module "mekanism.common.capabilities.IOffsetCapability" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$Vec3i, $Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"

export interface $IOffsetCapability {

 "getOffsetCapabilityIfEnabled"<T>(capability: $BlockCapability$$Type<(T), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): T
 "isOffsetCapabilityDisabled"(capability: $BlockCapability$$Type<(any), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): boolean
 "getOffsetCapability"<T>(capability: $BlockCapability$$Type<(T), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): T

(capability: $BlockCapability<(T), ($Direction)>, side: $Direction, offset: $Vec3i): T
}

export namespace $IOffsetCapability {
const probejs$$marker: never
}
export class $IOffsetCapability$$Static implements $IOffsetCapability {


 "getOffsetCapabilityIfEnabled"<T>(capability: $BlockCapability$$Type<(T), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): T
 "isOffsetCapabilityDisabled"(capability: $BlockCapability$$Type<(any), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): boolean
 "getOffsetCapability"<T>(capability: $BlockCapability$$Type<(T), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IOffsetCapability$$Type = ((capability: $BlockCapability<(T), ($Direction)>, side: $Direction, offset: $Vec3i) => T);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IOffsetCapability_ = $IOffsetCapability$$Type;
}}
declare module "mekanism.common.tile.component.ITileComponent" {
import {$BlockEntity$DataComponentInput, $BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List, $List$$Type} from "java.util.List"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$DataComponentMap$Builder, $DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export interface $ITileComponent {

 "write"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
 "read"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
 "removed"(): void
 "deserialize"(componentTag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
 "serialize"(provider: $HolderLookup$Provider$$Type): $CompoundTag
 "applyImplicitComponents"(input: $BlockEntity$DataComponentInput$$Type): void
 "collectImplicitComponents"(builder: $DataComponentMap$Builder$$Type): void
 "invalidate"(): void
 "addToUpdateTag"(updateTag: $CompoundTag$$Type): void
 "readFromUpdateTag"(updateTag: $CompoundTag$$Type): void
 "trackForMainContainer"(container: $MekanismContainer$$Type): void
 "getComponentKey"(): string
 "addRemapEntries"(remapEntries: $List$$Type<($DataComponentType$$Type<(any)>)>): void
get "componentKey"(): string
}

export namespace $ITileComponent {
const probejs$$marker: never
}
export class $ITileComponent$$Static implements $ITileComponent {


 "write"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
 "read"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
 "removed"(): void
 "deserialize"(componentTag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
 "serialize"(provider: $HolderLookup$Provider$$Type): $CompoundTag
 "applyImplicitComponents"(input: $BlockEntity$DataComponentInput$$Type): void
 "collectImplicitComponents"(builder: $DataComponentMap$Builder$$Type): void
 "invalidate"(): void
 "addToUpdateTag"(updateTag: $CompoundTag$$Type): void
 "readFromUpdateTag"(updateTag: $CompoundTag$$Type): void
 "trackForMainContainer"(container: $MekanismContainer$$Type): void
 "getComponentKey"(): string
 "addRemapEntries"(remapEntries: $List$$Type<($DataComponentType$$Type<(any)>)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileComponent$$Type = ($ITileComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileComponent_ = $ITileComponent$$Type;
}}
declare module "mekanism.common.registration.impl.RecipeTypeDeferredRegister" {
import {$MekanismDeferredRegister, $MekanismDeferredRegister$$Type} from "mekanism.common.registration.MekanismDeferredRegister"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$IInputRecipeCache, $IInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.IInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$RecipeType, $RecipeType$$Type} from "net.minecraft.world.item.crafting.RecipeType"
import {$RecipeTypeRegistryObject, $RecipeTypeRegistryObject$$Type} from "mekanism.common.registration.impl.RecipeTypeRegistryObject"
import {$MekanismRecipeType, $MekanismRecipeType$$Type} from "mekanism.common.recipe.MekanismRecipeType"
import {$DeferredHolder, $DeferredHolder$$Type} from "net.neoforged.neoforge.registries.DeferredHolder"

export class $RecipeTypeDeferredRegister extends $MekanismDeferredRegister<($RecipeType<(any)>)> {

constructor(modid: string)

public "registerMek"<VANILLA_INPUT extends $RecipeInput, RECIPE extends $MekanismRecipe<(VANILLA_INPUT)>, INPUT_CACHE extends $IInputRecipeCache>(name: string, func: $Function$$Type<($ResourceLocation), ($MekanismRecipeType$$Type<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>)>): $RecipeTypeRegistryObject<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>
public "register"(name: string, sup: $Supplier$$Type<(any)>): $DeferredHolder<(any), (any)>
public "register"(name: string, func: $Function$$Type<(any), (any)>): $DeferredHolder<(any), (any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeTypeDeferredRegister$$Type = ($RecipeTypeDeferredRegister);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeTypeDeferredRegister_ = $RecipeTypeDeferredRegister$$Type;
}}
declare module "mekanism.common.attachments.containers.chemical.ChemicalTanksBuilder" {
import {$IMekanismRecipeTypeProvider, $IMekanismRecipeTypeProvider$$Type} from "mekanism.common.recipe.IMekanismRecipeTypeProvider"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Chemical, $Chemical$$Type} from "mekanism.api.chemical.Chemical"
import {$IBasicContainerCreator, $IBasicContainerCreator$$Type} from "mekanism.common.attachments.containers.creator.IBasicContainerCreator"
import {$AttachedChemicals, $AttachedChemicals$$Type} from "mekanism.common.attachments.containers.chemical.AttachedChemicals"
import {$ContainsRecipe, $ContainsRecipe$$Type} from "mekanism.common.attachments.containers.ContainsRecipe"
import {$LongSupplier, $LongSupplier$$Type} from "java.util.function.LongSupplier"
import {$BaseContainerCreator, $BaseContainerCreator$$Type} from "mekanism.common.attachments.containers.creator.BaseContainerCreator"
import {$ComponentBackedChemicalTank, $ComponentBackedChemicalTank$$Type} from "mekanism.common.attachments.containers.chemical.ComponentBackedChemicalTank"
import {$IInputRecipeCache, $IInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.IInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"

export class $ChemicalTanksBuilder {


public static "builder"(): $ChemicalTanksBuilder
public "build"(): $BaseContainerCreator<($AttachedChemicals), ($ComponentBackedChemicalTank)>
public "addInternalStorage"(rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, isValid: $Predicate$$Type<($Chemical)>): $ChemicalTanksBuilder
public "addBasic"(capacity: $LongSupplier$$Type): $ChemicalTanksBuilder
public "addBasic"<VANILLA_INPUT extends $RecipeInput, RECIPE extends $MekanismRecipe<(VANILLA_INPUT)>, INPUT_CACHE extends $IInputRecipeCache>(capacity: long, recipeType: $IMekanismRecipeTypeProvider$$Type<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>, containsRecipe: $ContainsRecipe$$Type<(INPUT_CACHE), ($ChemicalStack)>): $ChemicalTanksBuilder
public "addBasic"(capacity: long): $ChemicalTanksBuilder
public "addBasic"(capacity: long, isValid: $Predicate$$Type<($Chemical)>): $ChemicalTanksBuilder
public "addBasic"(capacity: $LongSupplier$$Type, isValid: $Predicate$$Type<($Chemical)>): $ChemicalTanksBuilder
public "addTank"(tank: $IBasicContainerCreator$$Type<($ComponentBackedChemicalTank$$Type)>): $ChemicalTanksBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalTanksBuilder$$Type = ($ChemicalTanksBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalTanksBuilder_ = $ChemicalTanksBuilder$$Type;
}}
declare module "mekanism.common.lib.multiblock.MultiblockCache" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$IExtendedFluidTank, $IExtendedFluidTank$$Type} from "mekanism.api.fluid.IExtendedFluidTank"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IMekanismFluidHandler, $IMekanismFluidHandler$$Type} from "mekanism.api.fluid.IMekanismFluidHandler"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$IMekanismHeatHandler, $IMekanismHeatHandler$$Type} from "mekanism.api.heat.IMekanismHeatHandler"
import {$IEnergyContainer, $IEnergyContainer$$Type} from "mekanism.api.energy.IEnergyContainer"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$IHeatCapacitor, $IHeatCapacitor$$Type} from "mekanism.api.heat.IHeatCapacitor"
import {$MultiblockData, $MultiblockData$$Type} from "mekanism.common.lib.multiblock.MultiblockData"
import {$IMekanismChemicalHandler, $IMekanismChemicalHandler$$Type} from "mekanism.api.chemical.IMekanismChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler$FluidAction"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$MultiblockCache$RejectContents, $MultiblockCache$RejectContents$$Type} from "mekanism.common.lib.multiblock.MultiblockCache$RejectContents"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IMekanismStrictEnergyHandler, $IMekanismStrictEnergyHandler$$Type} from "mekanism.api.energy.IMekanismStrictEnergyHandler"
import {$IMekanismInventory, $IMekanismInventory$$Type} from "mekanism.api.inventory.IMekanismInventory"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"

export class $MultiblockCache<T extends $MultiblockData> implements $IMekanismInventory, $IMekanismFluidHandler, $IMekanismStrictEnergyHandler, $IMekanismHeatHandler, $IMekanismChemicalHandler {

constructor()

public "load"(provider: $HolderLookup$Provider$$Type, nbtTags: $CompoundTag$$Type): void
public "apply"(provider: $HolderLookup$Provider$$Type, data: T): void
public "merge"(mergeCache: $MultiblockCache$$Type<(T)>, rejectContents: $MultiblockCache$RejectContents$$Type): void
public "save"(provider: $HolderLookup$Provider$$Type, nbtTags: $CompoundTag$$Type): void
public "sync"(data: T): void
public "getEnergyContainers"(side: $Direction$$Type): $List<($IEnergyContainer)>
public "getChemicalTanks"(side: $Direction$$Type): $List<($IChemicalTank)>
public "getInventorySlots"(side: $Direction$$Type): $List<($IInventorySlot)>
public "onContentsChanged"(): void
public "getFluidTanks"(side: $Direction$$Type): $List<($IExtendedFluidTank)>
public "getHeatCapacitors"(side: $Direction$$Type): $List<($IHeatCapacitor)>
public "getSlots"(arg0: $Direction$$Type): integer
public "getStackInSlot"(arg0: integer, arg1: $Direction$$Type): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: $Direction$$Type, arg3: $Action$$Type): $ItemStack
public "getSlotLimit"(arg0: integer, arg1: $Direction$$Type): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $ItemStack
public "getInventorySlot"(arg0: integer, arg1: $Direction$$Type): $IInventorySlot
public "hasInventory"(): boolean
public "isInventoryEmpty"(arg0: $Direction$$Type): boolean
public "isInventoryEmpty"(): boolean
public "getFluidTank"(arg0: integer, arg1: $Direction$$Type): $IExtendedFluidTank
public "getTanks"(arg0: $Direction$$Type): integer
public "getTankCapacity"(arg0: integer, arg1: $Direction$$Type): integer
public "getFluidInTank"(arg0: integer, arg1: $Direction$$Type): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type): void
public "canHandleFluid"(): boolean
public "extractFluid"(arg0: integer, arg1: $Direction$$Type, arg2: $Action$$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Direction$$Type, arg3: $Action$$Type): $FluidStack
public "insertFluid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $FluidStack
public "getEnergyContainerCount"(arg0: $Direction$$Type): integer
public "getMaxEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "extractEnergy"(arg0: long, arg1: $Direction$$Type, arg2: $Action$$Type): long
public "extractEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type, arg3: $Action$$Type): long
public "getNeededEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "getEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "setEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type): void
public "canHandleEnergy"(): boolean
public "getEnergyContainer"(arg0: integer, arg1: $Direction$$Type): $IEnergyContainer
public "insertEnergy"(arg0: long, arg1: $Direction$$Type, arg2: $Action$$Type): long
public "insertEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type, arg3: $Action$$Type): long
public "getTemperature"(arg0: integer, arg1: $Direction$$Type): double
public "getHeatCapacitor"(arg0: integer, arg1: $Direction$$Type): $IHeatCapacitor
public "getHeatCapacity"(arg0: integer, arg1: $Direction$$Type): double
public "canHandleHeat"(): boolean
public "getTotalInverseInsulation"(arg0: $Direction$$Type): double
public "getTotalTemperature"(arg0: $Direction$$Type): double
public "getTotalHeatCapacity"(arg0: $Direction$$Type): double
public "getInverseConduction"(arg0: integer, arg1: $Direction$$Type): double
public "getHeatCapacitorCount"(arg0: $Direction$$Type): integer
public "getInverseInsulation"(arg0: integer, arg1: $Direction$$Type): double
public "getTotalInverseConductionCoefficient"(arg0: $Direction$$Type): double
public "handleHeat"(arg0: double, arg1: $Direction$$Type): void
public "handleHeat"(arg0: integer, arg1: double, arg2: $Direction$$Type): void
public "isValid"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Direction$$Type): boolean
public "getChemicalTank"(arg0: integer, arg1: $Direction$$Type): $IChemicalTank
public "getCountChemicalTanks"(arg0: $Direction$$Type): integer
public "getChemicalTankCapacity"(arg0: integer, arg1: $Direction$$Type): long
public "setChemicalInTank"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Direction$$Type): void
public "insertChemical"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $ChemicalStack
public "insertChemical"(arg0: $ChemicalStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: integer, arg1: long, arg2: $Direction$$Type, arg3: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: long, arg1: $Direction$$Type, arg2: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: $ChemicalStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $ChemicalStack
public "canHandleChemicals"(): boolean
public "getChemicalInTank"(arg0: integer, arg1: $Direction$$Type): $ChemicalStack
public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "getInventorySideFor"(): $Direction
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "getTanks"(): integer
public "getTankCapacity"(arg0: integer): integer
public "getFluidInTank"(arg0: integer): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$$Type): void
public "getFluidSideFor"(): $Direction
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Action$$Type): $FluidStack
public "insertFluid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Action$$Type): $FluidStack
public "getEnergyContainerCount"(): integer
public "getMaxEnergy"(arg0: integer): long
public "extractEnergy"(arg0: integer, arg1: long, arg2: $Action$$Type): long
public "getNeededEnergy"(arg0: integer): long
public "getEnergy"(arg0: integer): long
public "setEnergy"(arg0: integer, arg1: long): void
public "insertEnergy"(arg0: integer, arg1: long, arg2: $Action$$Type): long
public "getEnergySideFor"(): $Direction
public "getTemperature"(arg0: integer): double
public "getHeatCapacity"(arg0: integer): double
public "getHeatSideFor"(): $Direction
public "getTotalTemperature"(): double
public "getTotalHeatCapacity"(): double
public "getInverseConduction"(arg0: integer): double
public "getHeatCapacitorCount"(): integer
public "getTotalInverseConduction"(): double
public "handleHeat"(arg0: double): void
public "handleHeat"(arg0: integer, arg1: double): void
public "isValid"(arg0: integer, arg1: $ChemicalStack$$Type): boolean
public "getSideFor"(): $Direction
public "getChemicalTankCapacity"(arg0: integer): long
public "setChemicalInTank"(arg0: integer, arg1: $ChemicalStack$$Type): void
public "insertChemical"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: integer, arg1: long, arg2: $Action$$Type): $ChemicalStack
public "getChemicalTanks"(): integer
public "getChemicalInTank"(arg0: integer): $ChemicalStack
/**
 * 
 * @deprecated
 */
public "fill"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): integer
/**
 * 
 * @deprecated
 */
public "drain"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Action$$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$$Type, arg1: $Action$$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$$Type, arg1: $Action$$Type): $FluidStack
public "extractEnergy"(arg0: long, arg1: $Action$$Type): long
public "insertEnergy"(arg0: long, arg1: $Action$$Type): long
public "insertChemical"(arg0: $ChemicalStack$$Type, arg1: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: long, arg1: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: $ChemicalStack$$Type, arg1: $Action$$Type): $ChemicalStack
public "kjs$self"(): $IItemHandler
public "getStackInSlot"(arg0: integer): $ItemStack
public "getSlots"(): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isMutable"(): boolean
public "getBlock"(arg0: $Level$$Type): $BlockContainerJS
public "asContainer"(): $Container
public "getHeight"(): integer
public "setChanged"(): void
public "insertItem"(arg0: $ItemStack$$Type, arg1: boolean): $ItemStack
public "getAllItems"(): $List<($ItemStack)>
public "countNonEmpty"(): integer
public "countNonEmpty"(arg0: $ItemPredicate$$Type): integer
public "getWidth"(): integer
public "isEmpty"(): boolean
public "find"(): integer
public "find"(arg0: $ItemPredicate$$Type): integer
public "clear"(arg0: $ItemPredicate$$Type): void
public "clear"(): void
public "count"(arg0: $ItemPredicate$$Type): integer
public "count"(): integer
get "inventoryEmpty"(): boolean
get "slots"(): integer
get "inventorySideFor"(): $Direction
get "tanks"(): integer
get "fluidSideFor"(): $Direction
get "energyContainerCount"(): integer
get "energySideFor"(): $Direction
get "heatSideFor"(): $Direction
get "totalTemperature"(): double
get "totalHeatCapacity"(): double
get "heatCapacitorCount"(): integer
get "totalInverseConduction"(): double
get "sideFor"(): $Direction
get "chemicalTanks"(): integer
get "slots"(): integer
get "mutable"(): boolean
get "height"(): integer
get "allItems"(): $List<($ItemStack)>
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockCache$$Type<T> = ($MultiblockCache<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockCache_<T> = $MultiblockCache$$Type<(T)>;
}}
declare module "mekanism.common.tile.transmitter.TileEntityLogisticalTransporter" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$TransmitterModelData, $TransmitterModelData$$Type} from "mekanism.client.model.data.TransmitterModelData"
import {$IConfigurable, $IConfigurable$$Type} from "mekanism.api.IConfigurable"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TileEntityLogisticalTransporterBase, $TileEntityLogisticalTransporterBase$$Type} from "mekanism.common.tile.transmitter.TileEntityLogisticalTransporterBase"
import {$LogisticalTransporterBase, $LogisticalTransporterBase$$Type} from "mekanism.common.content.network.transmitter.LogisticalTransporterBase"
import {$TransmitterType, $TransmitterType$$Type} from "mekanism.common.block.states.TransmitterType"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ModelProperty, $ModelProperty$$Type} from "net.neoforged.neoforge.client.model.data.ModelProperty"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$TileEntityTransmitter, $TileEntityTransmitter$$Type} from "mekanism.common.tile.transmitter.TileEntityTransmitter"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityLogisticalTransporter extends $TileEntityLogisticalTransporterBase {
static readonly "CONFIGURABLE_PROVIDER": $ICapabilityProvider<($TileEntityTransmitter), ($Direction), ($IConfigurable)>
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "getTransmitter"(): $LogisticalTransporterBase
public "getTransmitterType"(): $TransmitterType
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
get "transmitter"(): $LogisticalTransporterBase
get "transmitterType"(): $TransmitterType
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityLogisticalTransporter$$Type = ($TileEntityLogisticalTransporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityLogisticalTransporter_ = $TileEntityLogisticalTransporter$$Type;
}}
declare module "mekanism.common.tile.multiblock.TileEntityInductionProvider" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$InductionProviderTier, $InductionProviderTier$$Type} from "mekanism.common.tier.InductionProviderTier"
import {$TileEntityInternalMultiblock, $TileEntityInternalMultiblock$$Type} from "mekanism.common.tile.prefab.TileEntityInternalMultiblock"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityInductionProvider extends $TileEntityInternalMultiblock {
 "tier": $InductionProviderTier
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityInductionProvider$$Type = ($TileEntityInductionProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityInductionProvider_ = $TileEntityInductionProvider$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.InputRecipeCache$SingleItem" {
import {$SingleInputRecipeCache, $SingleInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.SingleInputRecipeCache"
import {$ItemStackIngredient, $ItemStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ItemStackIngredient"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$ItemInputCache, $ItemInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.ItemInputCache"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$MekanismRecipeType, $MekanismRecipeType$$Type} from "mekanism.common.recipe.MekanismRecipeType"

export class $InputRecipeCache$SingleItem<RECIPE extends ($MekanismRecipe<(any)>) & ($Predicate<($ItemStack)>)> extends $SingleInputRecipeCache<($ItemStack), ($ItemStackIngredient), (RECIPE), ($ItemInputCache<(RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$$Type<(any), (RECIPE), (any)>, inputExtractor: $Function$$Type<(RECIPE), ($ItemStackIngredient$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$SingleItem$$Type<RECIPE> = ($InputRecipeCache$SingleItem<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$SingleItem_<RECIPE> = $InputRecipeCache$SingleItem$$Type<(RECIPE)>;
}}
declare module "mekanism.common.tile.interfaces.ISideConfiguration" {
import {$TileComponentConfig, $TileComponentConfig$$Type} from "mekanism.common.tile.component.TileComponentConfig"
import {$DataType, $DataType$$Type} from "mekanism.common.tile.component.config.DataType"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$TileComponentEjector, $TileComponentEjector$$Type} from "mekanism.common.tile.component.TileComponentEjector"

export interface $ISideConfiguration {

 "getConfig"(): $TileComponentConfig
 "getDirection"(): $Direction
 "getActiveDataType"(container: any): $DataType
 "getEjector"(): $TileComponentEjector
get "config"(): $TileComponentConfig
get "direction"(): $Direction
get "ejector"(): $TileComponentEjector
}

export namespace $ISideConfiguration {
const probejs$$marker: never
}
export class $ISideConfiguration$$Static implements $ISideConfiguration {


 "getConfig"(): $TileComponentConfig
 "getDirection"(): $Direction
 "getActiveDataType"(container: any): $DataType
 "getEjector"(): $TileComponentEjector
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISideConfiguration$$Type = ($ISideConfiguration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISideConfiguration_ = $ISideConfiguration$$Type;
}}
declare module "mekanism.common.item.block.ItemBlockEnergyCube" {
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$$Type} from "mekanism.common.registration.impl.CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$AttachedSideConfig, $AttachedSideConfig$$Type} from "mekanism.common.attachments.component.AttachedSideConfig"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockEnergyCube, $BlockEnergyCube$$Type} from "mekanism.common.block.BlockEnergyCube"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemLike, $ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemBlockEnergyCube extends $ItemBlockTooltip<($BlockEnergyCube)> implements $CreativeTabDeferredRegister$ICustomCreativeTabContents {
static readonly "SIDE_CONFIG": $AttachedSideConfig
static readonly "ALL_INPUT": $AttachedSideConfig
static readonly "ALL_OUTPUT": $AttachedSideConfig
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockEnergyCube$$Type, properties: $Item$Properties$$Type)

public "addDefault"(): boolean
public "getTier"(): $ITier
public "getBarWidth"(stack: $ItemStack$$Type): integer
public "getBarColor"(stack: $ItemStack$$Type): integer
public "isBarVisible"(stack: $ItemStack$$Type): boolean
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "addItems"(tabOutput: $Consumer$$Type<($ItemStack)>): void
public static "withEnergyCubeSideConfig"(item: $ItemLike$$Type, config: $AttachedSideConfig$$Type): $ItemStack
get "tier"(): $ITier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockEnergyCube$$Type = ($ItemBlockEnergyCube);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockEnergyCube_ = $ItemBlockEnergyCube$$Type;
}}
declare module "mekanism.common.attachments.component.AttachedSideConfig" {
import {$IPersistentConfigInfo, $IPersistentConfigInfo$$Type} from "mekanism.common.tile.component.config.IPersistentConfigInfo"
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$TransmissionType, $TransmissionType$$Type} from "mekanism.common.lib.transmitter.TransmissionType"
import {$ConfigInfo, $ConfigInfo$$Type} from "mekanism.common.tile.component.config.ConfigInfo"
import {$AttachedSideConfig$LightConfigInfo, $AttachedSideConfig$LightConfigInfo$$Type} from "mekanism.common.attachments.component.AttachedSideConfig$LightConfigInfo"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $AttachedSideConfig extends $Record {
static readonly "CODEC": $Codec<($AttachedSideConfig)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($AttachedSideConfig)>
static readonly "ELECTRIC_MACHINE": $AttachedSideConfig
static readonly "EXTRA_MACHINE": $AttachedSideConfig
static readonly "ADVANCED_MACHINE": $AttachedSideConfig
static readonly "ADVANCED_MACHINE_INPUT_ONLY": $AttachedSideConfig
static readonly "CRYSTALLIZER": $AttachedSideConfig
static readonly "DISSOLUTION": $AttachedSideConfig
static readonly "CHEMICAL_INFUSING": $AttachedSideConfig
static readonly "PIGMENT_MIXER": $AttachedSideConfig
static readonly "CHEMICAL_OUT_MACHINE": $AttachedSideConfig
static readonly "PAINTING": $AttachedSideConfig
static readonly "WASHER": $AttachedSideConfig
static readonly "SEPARATOR": $AttachedSideConfig
static readonly "CENTRIFUGE": $AttachedSideConfig
static readonly "SNA": $AttachedSideConfig
static readonly "LIQUIFIER": $AttachedSideConfig
static readonly "REACTION": $AttachedSideConfig
static readonly "ROTARY": $AttachedSideConfig

constructor(configInfo: $Map$$Type<(any), (any)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "create"(configInfo: $Map$$Type<($TransmissionType$$Type), ($ConfigInfo$$Type)>): $AttachedSideConfig
public "getConfig"(transmissionType: $TransmissionType$$Type): $IPersistentConfigInfo
public static "getStoredConfigInfo"(stack: $ItemStack$$Type, fallback: $AttachedSideConfig$$Type, transmissionType: $TransmissionType$$Type): $IPersistentConfigInfo
public "configInfo"(): $Map<($TransmissionType), ($AttachedSideConfig$LightConfigInfo)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedSideConfig$$Type = ({"configInfo"?: $Map$$Type<($TransmissionType$$Type), ($AttachedSideConfig$LightConfigInfo$$Type)>}) | ([configInfo?: $Map$$Type<($TransmissionType$$Type), ($AttachedSideConfig$LightConfigInfo$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttachedSideConfig_ = $AttachedSideConfig$$Type;
}}
declare module "mekanism.common.item.block.machine.ItemBlockFactory" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockFactoryMachine$BlockFactory, $BlockFactoryMachine$BlockFactory$$Type} from "mekanism.common.block.prefab.BlockFactoryMachine$BlockFactory"

export class $ItemBlockFactory extends $ItemBlockTooltip<($BlockTile<(any), (any)>)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockFactoryMachine$BlockFactory$$Type<(any)>, properties: $Item$Properties$$Type)

public "getTier"(): $ITier
get "tier"(): $ITier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockFactory$$Type = ($ItemBlockFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockFactory_ = $ItemBlockFactory$$Type;
}}
declare module "mekanism.common.tile.interfaces.IHasMode" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IHasMode {

 "nextMode"(): void
 "previousMode"(): void
}

export namespace $IHasMode {
const probejs$$marker: never
}
export class $IHasMode$$Static implements $IHasMode {


 "nextMode"(): void
 "previousMode"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHasMode$$Type = ($IHasMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHasMode_ = $IHasMode$$Type;
}}
declare module "mekanism.common.world.OreRetrogenFeature" {
import {$GeodeConfiguration, $GeodeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration, $VegetationPatchConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature, $SeagrassFeature$$Type} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration, $SpringConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration, $ReplaceSphereConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig, $TwistingVinesConfig$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration, $BlockStateConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration, $BlockPileConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$EndGatewayConfiguration, $EndGatewayConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$UnderwaterMagmaConfiguration, $UnderwaterMagmaConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$LakeFeature$Configuration, $LakeFeature$Configuration$$Type} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$RootSystemConfiguration, $RootSystemConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature, $BonusChestFeature$$Type} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration, $OreConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig, $NetherForestVegetationConfig$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration, $RandomBooleanFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration, $CountConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration, $RandomPatchConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration, $RandomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration, $HugeMushroomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration, $SimpleBlockConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$DeltaFeatureConfiguration, $DeltaFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$MultifaceGrowthConfiguration, $MultifaceGrowthConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$LayerConfiguration, $LayerConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ReplaceBlockConfiguration, $ReplaceBlockConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$ProbabilityFeatureConfiguration, $ProbabilityFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$Feature, $Feature$$Type} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration, $BlockColumnConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration, $FossilFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration, $LargeDripstoneConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration, $ColumnFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$SpikeConfiguration, $SpikeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$ResizableOreFeature, $ResizableOreFeature$$Type} from "mekanism.common.world.ResizableOreFeature"
import {$HugeFungusConfiguration, $HugeFungusConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration, $TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$PointedDripstoneConfiguration, $PointedDripstoneConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$DiskConfiguration, $DiskConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$SimpleRandomFeatureConfiguration, $SimpleRandomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$SculkPatchConfiguration, $SculkPatchConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$DripstoneClusterConfiguration, $DripstoneClusterConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $OreRetrogenFeature extends $ResizableOreFeature {
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreRetrogenFeature$$Type = ($OreRetrogenFeature);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OreRetrogenFeature_ = $OreRetrogenFeature$$Type;
}}
declare module "mekanism.common.registration.impl.ContainerTypeRegistryObject" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$MekanismDeferredHolder, $MekanismDeferredHolder$$Type} from "mekanism.common.registration.MekanismDeferredHolder"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ILangEntry, $ILangEntry$$Type} from "mekanism.api.text.ILangEntry"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$MenuProvider, $MenuProvider$$Type} from "net.minecraft.world.MenuProvider"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$MenuType, $MenuType$$Type} from "net.minecraft.world.inventory.MenuType"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"

export class $ContainerTypeRegistryObject<CONTAINER extends $AbstractContainerMenu> extends $MekanismDeferredHolder<($MenuType<(any)>), ($MenuType<(CONTAINER)>)> {

constructor(key: $ResourceLocation$$Type)
constructor(key: $ResourceKey$$Type<($MenuType<(any)>)>)

public "getProvider"(name: $Component$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type): $MenuProvider
public "getProvider"(name: $ILangEntry$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type): $MenuProvider
public "getProvider"(name: $Component$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type, resetMousePosition: boolean): $MenuProvider
public "getProvider"(name: $ILangEntry$$Type, object: any): $MenuProvider
public "getProvider"(name: $ILangEntry$$Type, object: any, resetMousePosition: boolean): $MenuProvider
public "getProvider"(name: $Component$$Type, object: any, resetMousePosition: boolean): $MenuProvider
public "tryOpenGui"(player: $ServerPlayer$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type): void
public "getId"(): $ResourceLocation
public static "direct"<T>(arg0: T): $Holder<(T)>
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerTypeRegistryObject$$Type<CONTAINER> = ($ContainerTypeRegistryObject<(CONTAINER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContainerTypeRegistryObject_<CONTAINER> = $ContainerTypeRegistryObject$$Type<(CONTAINER)>;
}}
declare module "mekanism.common.item.interfaces.IDroppableContents$IDroppableAttachmentContents" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IDroppableContents, $IDroppableContents$$Type} from "mekanism.common.item.interfaces.IDroppableContents"
import {$List, $List$$Type} from "java.util.List"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"

export interface $IDroppableContents$IDroppableAttachmentContents extends $IDroppableContents {

 "canContentsDrop"(stack: $ItemStack$$Type): boolean
 "getDroppedSlots"(stack: $ItemStack$$Type): $List<($IInventorySlot)>
 "getScalar"(stack: $ItemStack$$Type): integer

(stack: $ItemStack): boolean
}

export namespace $IDroppableContents$IDroppableAttachmentContents {
const probejs$$marker: never
}
export class $IDroppableContents$IDroppableAttachmentContents$$Static implements $IDroppableContents$IDroppableAttachmentContents {


 "canContentsDrop"(stack: $ItemStack$$Type): boolean
 "getDroppedSlots"(stack: $ItemStack$$Type): $List<($IInventorySlot)>
 "getScalar"(stack: $ItemStack$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDroppableContents$IDroppableAttachmentContents$$Type = ((stack: $ItemStack) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDroppableContents$IDroppableAttachmentContents_ = $IDroppableContents$IDroppableAttachmentContents$$Type;
}}
declare module "mekanism.common.inventory.container.slot.IVirtualSlot" {
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IGUIWindow, $IGUIWindow$$Type} from "mekanism.common.inventory.container.IGUIWindow"
import {$IntSupplier, $IntSupplier$$Type} from "java.util.function.IntSupplier"

export interface $IVirtualSlot {

 "getSlot"(): $Slot
 "updateRenderInfo"(stackToRender: $ItemStack$$Type, shouldDrawOverlay: boolean, tooltipOverride: string): void
 "getStackToRender"(): $ItemStack
 "getTooltipOverride"(): string
 "getLinkedWindow"(): $IGUIWindow
 "shouldDrawOverlay"(): boolean
 "updatePosition"(window: $IGUIWindow$$Type, xPositionSupplier: $IntSupplier$$Type, yPositionSupplier: $IntSupplier$$Type): void
 "getActualX"(): integer
 "getActualY"(): integer
get "slot"(): $Slot
get "stackToRender"(): $ItemStack
get "tooltipOverride"(): string
get "linkedWindow"(): $IGUIWindow
get "actualX"(): integer
get "actualY"(): integer
}

export namespace $IVirtualSlot {
const probejs$$marker: never
}
export class $IVirtualSlot$$Static implements $IVirtualSlot {


 "getSlot"(): $Slot
 "updateRenderInfo"(stackToRender: $ItemStack$$Type, shouldDrawOverlay: boolean, tooltipOverride: string): void
 "getStackToRender"(): $ItemStack
 "getTooltipOverride"(): string
 "getLinkedWindow"(): $IGUIWindow
 "shouldDrawOverlay"(): boolean
 "updatePosition"(window: $IGUIWindow$$Type, xPositionSupplier: $IntSupplier$$Type, yPositionSupplier: $IntSupplier$$Type): void
 "getActualX"(): integer
 "getActualY"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IVirtualSlot$$Type = ($IVirtualSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IVirtualSlot_ = $IVirtualSlot$$Type;
}}
declare module "mekanism.common.lib.multiblock.IInternalMultiblock" {
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$MultiblockData, $MultiblockData$$Type} from "mekanism.common.lib.multiblock.MultiblockData"

export interface $IInternalMultiblock {

 "setMultiblock"(multiblock: $MultiblockData$$Type): void
 "getMultiblock"(): $MultiblockData
 "getMultiblockUUID"(): $UUID
 "hasFormedMultiblock"(): boolean
set "multiblock"(value: $MultiblockData$$Type)
get "multiblock"(): $MultiblockData
get "multiblockUUID"(): $UUID
}

export namespace $IInternalMultiblock {
const probejs$$marker: never
}
export class $IInternalMultiblock$$Static implements $IInternalMultiblock {


 "setMultiblock"(multiblock: $MultiblockData$$Type): void
 "getMultiblock"(): $MultiblockData
 "getMultiblockUUID"(): $UUID
 "hasFormedMultiblock"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInternalMultiblock$$Type = ($IInternalMultiblock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInternalMultiblock_ = $IInternalMultiblock$$Type;
}}
declare module "mekanism.common.item.block.ItemBlockTooltip" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent, $RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$IHasDescription, $IHasDescription$$Type} from "mekanism.common.block.interfaces.IHasDescription"
import {$IEventBus, $IEventBus$$Type} from "net.neoforged.bus.api.IEventBus"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$IAttachmentAware, $IAttachmentAware$$Type} from "mekanism.common.attachments.IAttachmentAware"
import {$ItemBlockMekanism, $ItemBlockMekanism$$Type} from "mekanism.common.item.block.ItemBlockMekanism"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$ICapabilityAware, $ICapabilityAware$$Type} from "mekanism.common.capabilities.ICapabilityAware"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ItemBlockTooltip<BLOCK extends ($Block) & ($IHasDescription)> extends $ItemBlockMekanism<(BLOCK)> implements $ICapabilityAware, $IAttachmentAware {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: BLOCK, properties: $Item$Properties$$Type)
constructor(block: BLOCK, hasDetails: boolean, properties: $Item$Properties$$Type)

public "onDestroyed"(item: $ItemEntity$$Type, damageSource: $DamageSource$$Type): void
public "placeBlock"(context: $BlockPlaceContext$$Type, state: $BlockState$$Type): boolean
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$$Type, newStack: $ItemStack$$Type, slotChanged: boolean): boolean
public "shouldCauseBlockBreakReset"(oldStack: $ItemStack$$Type, newStack: $ItemStack$$Type): boolean
public "attachAttachments"(eventBus: $IEventBus$$Type): void
public "attachCapabilities"(event: $RegisterCapabilitiesEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockTooltip$$Type<BLOCK> = ($ItemBlockTooltip<(BLOCK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockTooltip_<BLOCK> = $ItemBlockTooltip$$Type<(BLOCK)>;
}}
declare module "mekanism.common.block.prefab.BlockTile$BlockTileModel" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IStateFluidLoggable, $IStateFluidLoggable$$Type} from "mekanism.common.block.states.IStateFluidLoggable"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IFluidLogType, $IFluidLogType$$Type} from "mekanism.common.block.states.IFluidLogType"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$EnumProperty, $EnumProperty$$Type} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor, $LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $BlockTile$BlockTileModel<TILE extends $TileEntityMekanism, BLOCK extends $BlockTypeTile<(TILE)>> extends $BlockTile<(TILE), (BLOCK)> implements $IStateFluidLoggable {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(type: BLOCK, propertiesModifier: $UnaryOperator$$Type<($BlockBehaviour$Properties)>)
constructor(type: BLOCK, properties: $BlockBehaviour$Properties$$Type)

public "setState"(state: $BlockState$$Type, fluid: $Fluid$$Type): $BlockState
public "isValidFluid"(fluid: $Fluid$$Type): boolean
public "canPlaceLiquid"(player: $Player$$Type, world: $BlockGetter$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluid: $Fluid$$Type): boolean
public "getPickupSound"(state: $BlockState$$Type): $Optional<($SoundEvent)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "pickupBlock"(player: $Player$$Type, world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type): $ItemStack
public "placeLiquid"(world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluidState: $FluidState$$Type): boolean
public "getFluid"(state: $BlockState$$Type): $FluidState
public "getFluidLightLevel"(state: $BlockState$$Type): integer
public "updateFluids"(state: $BlockState$$Type, world: $LevelAccessor$$Type, currentPos: $BlockPos$$Type): void
public "getFluidLoggedProperty"(): $EnumProperty<($IFluidLogType)>
public "asHolder"(): $Holder<(any)>
get "pickupSound"(): $Optional<($SoundEvent)>
get "fluidLoggedProperty"(): $EnumProperty<($IFluidLogType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTile$BlockTileModel$$Type<TILE, BLOCK> = ($BlockTile$BlockTileModel<(TILE), (BLOCK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTile$BlockTileModel_<TILE, BLOCK> = $BlockTile$BlockTileModel$$Type<(TILE), (BLOCK)>;
}}
declare module "mekanism.common.tile.interfaces.IComparatorSupport" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IComparatorSupport {

 "supportsComparator"(): boolean
 "getCurrentRedstoneLevel"(): integer
 "getRedstoneLevel"(): integer
get "currentRedstoneLevel"(): integer
get "redstoneLevel"(): integer
}

export namespace $IComparatorSupport {
const probejs$$marker: never
}
export class $IComparatorSupport$$Static implements $IComparatorSupport {


 "supportsComparator"(): boolean
 "getCurrentRedstoneLevel"(): integer
 "getRedstoneLevel"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IComparatorSupport$$Type = ($IComparatorSupport);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IComparatorSupport_ = $IComparatorSupport$$Type;
}}
declare module "mekanism.common.content.transporter.TransporterStack$Path" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"

export class $TransporterStack$Path extends $Enum<($TransporterStack$Path)> {
static readonly "DEST": $TransporterStack$Path
static readonly "HOME": $TransporterStack$Path
static readonly "NONE": $TransporterStack$Path
static readonly "BY_ID": $IntFunction<($TransporterStack$Path)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($TransporterStack$Path)>


public static "values"(): ($TransporterStack$Path)[]
public static "valueOf"(name: string): $TransporterStack$Path
public "noTarget"(): boolean
public "hasTarget"(): boolean
public "isHome"(): boolean
get "home"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransporterStack$Path$$Type = (("dest") | ("home") | ("none"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransporterStack$Path_ = $TransporterStack$Path$$Type;
}}
declare module "mekanism.common.item.ItemPortableQIODashboard" {
import {$IColoredItem, $IColoredItem$$Type} from "mekanism.common.item.interfaces.IColoredItem"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent, $RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List, $List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$IGuiItem, $IGuiItem$$Type} from "mekanism.common.item.interfaces.IGuiItem"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$PortableQIODashboardContainer, $PortableQIODashboardContainer$$Type} from "mekanism.common.inventory.container.item.PortableQIODashboardContainer"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Map, $Map$$Type} from "java.util.Map"
import {$QIOFrequency, $QIOFrequency$$Type} from "mekanism.common.content.qio.QIOFrequency"
import {$FrequencyAware, $FrequencyAware$$Type} from "mekanism.common.attachments.FrequencyAware"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ContainerTypeRegistryObject, $ContainerTypeRegistryObject$$Type} from "mekanism.common.registration.impl.ContainerTypeRegistryObject"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$IFrequencyItem, $IFrequencyItem$$Type} from "mekanism.common.lib.frequency.IFrequencyItem"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"
import {$ICapabilityAware, $ICapabilityAware$$Type} from "mekanism.common.capabilities.ICapabilityAware"

export class $ItemPortableQIODashboard extends $Item implements $IFrequencyItem, $IGuiItem, $IColoredItem, $ICapabilityAware {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "use"(world: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "onDestroyed"(item: $ItemEntity$$Type, damageSource: $DamageSource$$Type): void
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$$Type, newStack: $ItemStack$$Type, slotChanged: boolean): boolean
public "inventoryTick"(stack: $ItemStack$$Type, level: $Level$$Type, entity: $Entity$$Type, slotId: integer, isSelected: boolean): void
public "getFrequencyComponent"(): $DataComponentType<($FrequencyAware<($QIOFrequency)>)>
public "attachCapabilities"(event: $RegisterCapabilitiesEvent$$Type): void
public "getFrequencyType"(): $FrequencyType<(any)>
public "getContainerType"(): $ContainerTypeRegistryObject<($PortableQIODashboardContainer)>
public "syncColorWithFrequency"<FREQ extends $Frequency>(stack: $ItemStack$$Type): void
get "frequencyComponent"(): $DataComponentType<($FrequencyAware<($QIOFrequency)>)>
get "frequencyType"(): $FrequencyType<(any)>
get "containerType"(): $ContainerTypeRegistryObject<($PortableQIODashboardContainer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPortableQIODashboard$$Type = ($ItemPortableQIODashboard);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPortableQIODashboard_ = $ItemPortableQIODashboard$$Type;
}}
declare module "mekanism.common.lib.frequency.IFrequencyItem" {
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"

export interface $IFrequencyItem {

 "getFrequencyType"(): $FrequencyType<(any)>

(): $FrequencyType$$Type<(any)>
get "frequencyType"(): $FrequencyType<(any)>
}

export namespace $IFrequencyItem {
const probejs$$marker: never
}
export class $IFrequencyItem$$Static implements $IFrequencyItem {


 "getFrequencyType"(): $FrequencyType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFrequencyItem$$Type = (() => $FrequencyType$$Type<(any)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFrequencyItem_ = $IFrequencyItem$$Type;
}}
declare module "mekanism.common.lib.math.voxel.IShape" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IShape {

}

export namespace $IShape {
const probejs$$marker: never
}
export class $IShape$$Static implements $IShape {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IShape$$Type = ($IShape);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IShape_ = $IShape$$Type;
}}
declare module "mekanism.common.inventory.container.QIOItemViewerContainer$ListSortType" {
import {$TranslatableEnum, $TranslatableEnum$$Type} from "net.neoforged.neoforge.common.TranslatableEnum"
import {$GuiComponents$IDropdownEnum, $GuiComponents$IDropdownEnum$$Type} from "mekanism.common.inventory.GuiComponents$IDropdownEnum"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$QIOItemViewerContainer$SortDirection, $QIOItemViewerContainer$SortDirection$$Type} from "mekanism.common.inventory.container.QIOItemViewerContainer$SortDirection"
import {$ISlotClickHandler$IScrollableSlot, $ISlotClickHandler$IScrollableSlot$$Type} from "mekanism.common.inventory.ISlotClickHandler$IScrollableSlot"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export class $QIOItemViewerContainer$ListSortType extends $Enum<($QIOItemViewerContainer$ListSortType)> implements $GuiComponents$IDropdownEnum<($QIOItemViewerContainer$ListSortType)>, $TranslatableEnum {
static readonly "NAME": $QIOItemViewerContainer$ListSortType
static readonly "SIZE": $QIOItemViewerContainer$ListSortType
static readonly "MOD": $QIOItemViewerContainer$ListSortType
static readonly "REGISTRY_NAME": $QIOItemViewerContainer$ListSortType


public static "values"(): ($QIOItemViewerContainer$ListSortType)[]
public static "valueOf"(name: string): $QIOItemViewerContainer$ListSortType
public "sort"(list: $List$$Type<($ISlotClickHandler$IScrollableSlot$$Type)>, direction: $QIOItemViewerContainer$SortDirection$$Type): void
public "getTooltip"(): $Component
public "getTranslatedName"(): $Component
public "getShortName"(): $Component
public "getIcon"(): $ResourceLocation
get "tooltip"(): $Component
get "translatedName"(): $Component
get "shortName"(): $Component
get "icon"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOItemViewerContainer$ListSortType$$Type = (("name") | ("size") | ("mod") | ("registry_name"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOItemViewerContainer$ListSortType_ = $QIOItemViewerContainer$ListSortType$$Type;
}}
declare module "mekanism.common.lib.multiblock.IMultiblock" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$Structure, $Structure$$Type} from "mekanism.common.lib.multiblock.Structure"
import {$FormationProtocol, $FormationProtocol$$Type} from "mekanism.common.lib.multiblock.FormationProtocol"
import {$MultiblockManager, $MultiblockManager$$Type} from "mekanism.common.lib.multiblock.MultiblockManager"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$IMultiblockBase, $IMultiblockBase$$Type} from "mekanism.common.lib.multiblock.IMultiblockBase"
import {$MultiblockData, $MultiblockData$$Type} from "mekanism.common.lib.multiblock.MultiblockData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"

export interface $IMultiblock<T extends $MultiblockData> extends $IMultiblockBase {

 "getManager"(): $MultiblockManager<(T)>
 "getStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
 "getStructure"(): $Structure
 "resetCache"(): void
 "getMultiblock"(): T
 "canBeMaster"(): boolean
 "hasStructure"(structure: $Structure$$Type): boolean
 "getDefaultData"(): T
 "createMultiblock"(): T
 "getCacheID"(): $UUID
 "setStructure"(structure: $Structure$$Type): void
 "setStructure"(manager: $MultiblockManager$$Type<(any)>, structure: $Structure$$Type): void
 "isMaster"(): boolean
 "createFormationProtocol"(): $FormationProtocol<(T)>
 "getMultiblockData"(manager: $MultiblockManager$$Type<(any)>): $MultiblockData
 "resetStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
 "setMultiblockData"(manager: $MultiblockManager$$Type<(any)>, multiblockData: $MultiblockData$$Type): void
 "resetForFormed"(): void
 "onActivate"(player: $Player$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type): $ItemInteractionResult
 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
get "manager"(): $MultiblockManager<(T)>
get "structure"(): $Structure
get "multiblock"(): T
get "defaultData"(): T
get "cacheID"(): $UUID
set "structure"(value: $Structure$$Type)
get "master"(): boolean
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}

export namespace $IMultiblock {
const probejs$$marker: never
}
export class $IMultiblock$$Static<T extends $MultiblockData> implements $IMultiblock {


 "getManager"(): $MultiblockManager<(T)>
 "getStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
 "getStructure"(): $Structure
 "resetCache"(): void
 "getMultiblock"(): T
 "canBeMaster"(): boolean
 "hasStructure"(structure: $Structure$$Type): boolean
 "getDefaultData"(): T
 "createMultiblock"(): T
 "getCacheID"(): $UUID
 "setStructure"(structure: $Structure$$Type): void
 "setStructure"(manager: $MultiblockManager$$Type<(any)>, structure: $Structure$$Type): void
 "isMaster"(): boolean
 "createFormationProtocol"(): $FormationProtocol<(T)>
 "getMultiblockData"(manager: $MultiblockManager$$Type<(any)>): $MultiblockData
 "resetStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
 "setMultiblockData"(manager: $MultiblockManager$$Type<(any)>, multiblockData: $MultiblockData$$Type): void
 "resetForFormed"(): void
 "onActivate"(player: $Player$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type): $ItemInteractionResult
 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMultiblock$$Type<T> = ($IMultiblock<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMultiblock_<T> = $IMultiblock$$Type<(T)>;
}}
declare module "mekanism.common.item.ItemRefinedGlowstoneIngot" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemRefinedGlowstoneIngot extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "isPiglinCurrency"(stack: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemRefinedGlowstoneIngot$$Type = ($ItemRefinedGlowstoneIngot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemRefinedGlowstoneIngot_ = $ItemRefinedGlowstoneIngot$$Type;
}}
declare module "mekanism.common.item.gear.ItemCanteen" {
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$$Type} from "mekanism.common.registration.impl.CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$UseAnim, $UseAnim$$Type} from "net.minecraft.world.item.UseAnim"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $ItemCanteen extends $Item implements $CreativeTabDeferredRegister$ICustomCreativeTabContents {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "use"(worldIn: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "getBarWidth"(stack: $ItemStack$$Type): integer
public "getBarColor"(stack: $ItemStack$$Type): integer
public "isBarVisible"(stack: $ItemStack$$Type): boolean
public "finishUsingItem"(stack: $ItemStack$$Type, world: $Level$$Type, entityLiving: $LivingEntity$$Type): $ItemStack
public "getUseAnimation"(stack: $ItemStack$$Type): $UseAnim
public "getUseDuration"(stack: $ItemStack$$Type, entity: $LivingEntity$$Type): integer
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "addItems"(tabOutput: $Consumer$$Type<($ItemStack)>): void
public "addDefault"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemCanteen$$Type = ($ItemCanteen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemCanteen_ = $ItemCanteen$$Type;
}}
declare module "mekanism.common.world.ResizableDiskConfig" {
import {$DiskConfiguration, $DiskConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature, $ConfiguredFeature$$Type} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$FeatureConfiguration, $FeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$RuleBasedBlockStateProvider, $RuleBasedBlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.RuleBasedBlockStateProvider"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$IntSupplier, $IntSupplier$$Type} from "java.util.function.IntSupplier"

export class $ResizableDiskConfig extends $Record implements $FeatureConfiguration {
static readonly "CODEC": $Codec<($ResizableDiskConfig)>

constructor(stateProvider: $RuleBasedBlockStateProvider$$Type, target: $BlockPredicate$$Type, radius: $IntProvider$$Type)
constructor(stateProvider: $RuleBasedBlockStateProvider$$Type, target: $BlockPredicate$$Type, radius: $IntProvider$$Type, halfHeight: $IntSupplier$$Type)

public "equals"(o: any): boolean
public "target"(): $BlockPredicate
public "toString"(): string
public "hashCode"(): integer
public "radius"(): $IntProvider
public "halfHeight"(): $IntSupplier
public "stateProvider"(): $RuleBasedBlockStateProvider
public "asVanillaConfig"(): $DiskConfiguration
public "getFeatures"(): $Stream<($ConfiguredFeature<(any), (any)>)>
get "features"(): $Stream<($ConfiguredFeature<(any), (any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResizableDiskConfig$$Type = ({"target"?: $BlockPredicate$$Type, "halfHeight"?: $IntSupplier$$Type, "stateProvider"?: $RuleBasedBlockStateProvider$$Type, "radius"?: $IntProvider$$Type}) | ([target?: $BlockPredicate$$Type, halfHeight?: $IntSupplier$$Type, stateProvider?: $RuleBasedBlockStateProvider$$Type, radius?: $IntProvider$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResizableDiskConfig_ = $ResizableDiskConfig$$Type;
}}
declare module "mekanism.common.tile.transmitter.TileEntityLogisticalTransporterBase" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$TransmitterModelData, $TransmitterModelData$$Type} from "mekanism.client.model.data.TransmitterModelData"
import {$IConfigurable, $IConfigurable$$Type} from "mekanism.api.IConfigurable"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LogisticalTransporterBase, $LogisticalTransporterBase$$Type} from "mekanism.common.content.network.transmitter.LogisticalTransporterBase"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$ModelProperty, $ModelProperty$$Type} from "net.neoforged.neoforge.client.model.data.ModelProperty"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$ConnectionType, $ConnectionType$$Type} from "mekanism.common.lib.transmitter.ConnectionType"
import {$TileEntityTransmitter, $TileEntityTransmitter$$Type} from "mekanism.common.tile.transmitter.TileEntityTransmitter"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityLogisticalTransporterBase extends $TileEntityTransmitter {
static readonly "CONFIGURABLE_PROVIDER": $ICapabilityProvider<($TileEntityTransmitter), ($Direction), ($IConfigurable)>
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string


public "sideChanged"(side: $Direction$$Type, old: $ConnectionType$$Type, type: $ConnectionType$$Type): void
public "onUpdateServer"(): void
public static "tickClient"(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, transmitter: $TileEntityLogisticalTransporterBase$$Type): void
public "getTransmitter"(): $LogisticalTransporterBase
public "blockRemoved"(): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
get "transmitter"(): $LogisticalTransporterBase
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityLogisticalTransporterBase$$Type = ($TileEntityLogisticalTransporterBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityLogisticalTransporterBase_ = $TileEntityLogisticalTransporterBase$$Type;
}}
declare module "mekanism.common.registration.impl.BlockRegistryObject" {
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$DoubleWrappedRegistryObject, $DoubleWrappedRegistryObject$$Type} from "mekanism.common.registration.DoubleWrappedRegistryObject"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$ItemRegistryObject, $ItemRegistryObject$$Type} from "mekanism.common.registration.impl.ItemRegistryObject"
import {$DeferredHolder, $DeferredHolder$$Type} from "net.neoforged.neoforge.registries.DeferredHolder"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $BlockRegistryObject<BLOCK extends $Block, ITEM extends $Item> extends $DoubleWrappedRegistryObject<($Block), (BLOCK), ($Item), (ITEM)> implements $IBlockProvider {

constructor(blockRegistryObject: $DeferredHolder$$Type<($Block$$Type), (BLOCK)>, itemRegistryObject: $DeferredHolder$$Type<($Item$$Type), (ITEM)>)

public "getBlock"(): BLOCK
public "asItem"(): ITEM
public "forItemHolder"(consumer: $Consumer$$Type<($ItemRegistryObject<(ITEM)>)>): $BlockRegistryObject<(BLOCK), (ITEM)>
public "getTranslationKey"(): string
public "defaultState"(): $BlockState
public "getRegistryName"(): $ResourceLocation
public "getItemStack"(): $ItemStack
public "getItemStack"(arg0: integer): $ItemStack
public "getTextComponent"(): $Component
get "block"(): BLOCK
get "translationKey"(): string
get "registryName"(): $ResourceLocation
get "itemStack"(): $ItemStack
get "textComponent"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRegistryObject$$Type<BLOCK, ITEM> = ($BlockRegistryObject<(BLOCK), (ITEM)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockRegistryObject_<BLOCK, ITEM> = $BlockRegistryObject$$Type<(BLOCK), (ITEM)>;
}}
declare module "mekanism.common.lib.multiblock.FormationProtocol$FormationChecker" {
import {$Long2ObjectMap, $Long2ObjectMap$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectMap"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ChunkAccess, $ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export interface $FormationProtocol$FormationChecker<NODE> {

 "check"(level: $Level$$Type, chunkMap: $Long2ObjectMap$$Type<($ChunkAccess$$Type)>, start: $BlockPos$$Type, node: NODE, toCheck: $BlockPos$$Type): boolean

(level: $Level, chunkMap: $Long2ObjectMap<($ChunkAccess)>, start: $BlockPos, node: NODE, toCheck: $BlockPos): boolean
}

export namespace $FormationProtocol$FormationChecker {
const probejs$$marker: never
}
export class $FormationProtocol$FormationChecker$$Static<NODE> implements $FormationProtocol$FormationChecker {


 "check"(level: $Level$$Type, chunkMap: $Long2ObjectMap$$Type<($ChunkAccess$$Type)>, start: $BlockPos$$Type, node: NODE, toCheck: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FormationProtocol$FormationChecker$$Type<NODE> = ((level: $Level, chunkMap: $Long2ObjectMap<($ChunkAccess)>, start: $BlockPos, node: NODE, toCheck: $BlockPos) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FormationProtocol$FormationChecker_<NODE> = $FormationProtocol$FormationChecker$$Type<(NODE)>;
}}
declare module "mekanism.common.tile.component.config.ConfigInfo" {
import {$IPersistentConfigInfo, $IPersistentConfigInfo$$Type} from "mekanism.common.tile.component.config.IPersistentConfigInfo"
import {$ISlotInfo, $ISlotInfo$$Type} from "mekanism.common.tile.component.config.slot.ISlotInfo"
import {$List, $List$$Type} from "java.util.List"
import {$DataType, $DataType$$Type} from "mekanism.common.tile.component.config.DataType"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$RelativeSide, $RelativeSide$$Type} from "mekanism.api.RelativeSide"

export class $ConfigInfo implements $IPersistentConfigInfo {

constructor()

public "supports"(type: $DataType$$Type): boolean
public "getDataType"(side: $RelativeSide$$Type): $DataType
public "incrementDataType"(relativeSide: $RelativeSide$$Type): $DataType
public "getSideConfig"(): $Set<($Map$Entry<($RelativeSide), ($DataType)>)>
public "getSlotInfo"(side: $RelativeSide$$Type): $ISlotInfo
public "getSlotInfo"(dataType: $DataType$$Type): $ISlotInfo
public "isSideEnabled"(side: $RelativeSide$$Type): boolean
public "addSlotInfo"(dataType: $DataType$$Type, info: $ISlotInfo$$Type): void
public "setCanEject"(canEject: boolean): void
public "addDisabledSides"(...sides: ($RelativeSide$$Type)[]): void
public "isEjecting"(): boolean
public "getDataTypeForContainer"(container: any): $List<($DataType)>
public "getSupportedDataTypes"(): $Set<($DataType)>
public "decrementDataType"(relativeSide: $RelativeSide$$Type): $DataType
public "setDataType"(dataType: $DataType$$Type, side: $RelativeSide$$Type): boolean
public "setEjecting"(ejecting: boolean): void
public "canEject"(): boolean
get "sideConfig"(): $Set<($Map$Entry<($RelativeSide), ($DataType)>)>
get "ejecting"(): boolean
get "supportedDataTypes"(): $Set<($DataType)>
set "ejecting"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigInfo$$Type = ($ConfigInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigInfo_ = $ConfigInfo$$Type;
}}
declare module "mekanism.common.item.ItemTierInstaller" {
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$UseOnContext, $UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$BaseTier, $BaseTier$$Type} from "mekanism.api.tier.BaseTier"

export class $ItemTierInstaller extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(fromTier: $BaseTier$$Type, toTier: $BaseTier$$Type, properties: $Item$Properties$$Type)

public "getName"(stack: $ItemStack$$Type): $Component
public "getFromTier"(): $BaseTier
public "useOn"(context: $UseOnContext$$Type): $InteractionResult
public "getToTier"(): $BaseTier
get "fromTier"(): $BaseTier
get "toTier"(): $BaseTier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTierInstaller$$Type = ($ItemTierInstaller);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTierInstaller_ = $ItemTierInstaller$$Type;
}}
declare module "mekanism.common.capabilities.holder.IHolder" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"

export interface $IHolder {

 "canExtract"(direction: $Direction$$Type): boolean
 "canInsert"(direction: $Direction$$Type): boolean
}

export namespace $IHolder {
const probejs$$marker: never
}
export class $IHolder$$Static implements $IHolder {


 "canExtract"(direction: $Direction$$Type): boolean
 "canInsert"(direction: $Direction$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHolder$$Type = ($IHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHolder_ = $IHolder$$Type;
}}
declare module "mekanism.common.attachments.containers.item.ComponentBackedBinInventorySlot" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$ContainerType, $ContainerType$$Type} from "mekanism.common.attachments.containers.ContainerType"
import {$ComponentBackedInventorySlot, $ComponentBackedInventorySlot$$Type} from "mekanism.common.attachments.containers.item.ComponentBackedInventorySlot"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$AttachedItems, $AttachedItems$$Type} from "mekanism.common.attachments.containers.item.AttachedItems"

export class $ComponentBackedBinInventorySlot extends $ComponentBackedInventorySlot {


public static "create"(ignored: $ContainerType$$Type<(any), (any), (any)>, attachedTo: $ItemStack$$Type, tankIndex: integer): $ComponentBackedBinInventorySlot
public "extractItem"(amount: integer, action: $Action$$Type, automationType: $AutomationType$$Type): $ItemStack
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $Tag$$Type): void
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $CompoundTag$$Type): void
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $Tag
public "insertItem"(attachedItems: $AttachedItems$$Type, current: $ItemStack$$Type, stack: $ItemStack$$Type, action: $Action$$Type, automationType: $AutomationType$$Type): $ItemStack
public "getBottomStack"(): $ItemStack
public "getLockStack"(): $ItemStack
public "setLockStack"(stack: $ItemStack$$Type): void
get "bottomStack"(): $ItemStack
get "lockStack"(): $ItemStack
set "lockStack"(value: $ItemStack$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBackedBinInventorySlot$$Type = ($ComponentBackedBinInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBackedBinInventorySlot_ = $ComponentBackedBinInventorySlot$$Type;
}}
declare module "mekanism.common.attachments.containers.heat.AttachedHeat" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$HeatCapacitorData, $HeatCapacitorData$$Type} from "mekanism.common.attachments.containers.heat.HeatCapacitorData"
import {$IAttachedContainers, $IAttachedContainers$$Type} from "mekanism.common.attachments.containers.IAttachedContainers"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $AttachedHeat extends $Record implements $IAttachedContainers<($HeatCapacitorData), ($AttachedHeat)> {
static readonly "EMPTY": $AttachedHeat
static readonly "CODEC": $Codec<($AttachedHeat)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($AttachedHeat)>

constructor(containers: $List$$Type<(any)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "create"(containers: $List$$Type<(any)>): $IAttachedContainers<(any), (any)>
public "containers"(): $List<($HeatCapacitorData)>
public "getEmptyStack"(): any
public "size"(): integer
public "get"(index: integer): $HeatCapacitorData
public "isEmpty"(): boolean
public "iterator"(): $Iterator<($HeatCapacitorData)>
public "spliterator"(): $Spliterator<($HeatCapacitorData)>
public "forEach"(action: $Consumer$$Type<($HeatCapacitorData)>): void
public "getOrDefault"(index: integer): $HeatCapacitorData
public "with"(index: integer, data: $HeatCapacitorData$$Type): $AttachedHeat
[Symbol.iterator](): IterableIterator<$HeatCapacitorData>;
get "emptyStack"(): any
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedHeat$$Type = ({"containers"?: $List$$Type<($HeatCapacitorData$$Type)>}) | ([containers?: $List$$Type<($HeatCapacitorData$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttachedHeat_ = $AttachedHeat$$Type;
}}
declare module "mekanism.common.registration.DoubleWrappedRegistryObject" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$INamedEntry, $INamedEntry$$Type} from "mekanism.common.registration.INamedEntry"
import {$DeferredHolder, $DeferredHolder$$Type} from "net.neoforged.neoforge.registries.DeferredHolder"

export class $DoubleWrappedRegistryObject<PRIMARY_REGISTRY, PRIMARY extends PRIMARY_REGISTRY, SECONDARY_REGISTRY, SECONDARY extends SECONDARY_REGISTRY> implements $INamedEntry {

constructor(primaryRO: $DeferredHolder$$Type<(PRIMARY_REGISTRY), (PRIMARY)>, secondaryRO: $DeferredHolder$$Type<(SECONDARY_REGISTRY), (SECONDARY)>)

public "getName"(): string
public "getId"(): $ResourceLocation
public "getPrimary"(): PRIMARY
public "getSecondary"(): SECONDARY
get "name"(): string
get "id"(): $ResourceLocation
get "primary"(): PRIMARY
get "secondary"(): SECONDARY
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleWrappedRegistryObject$$Type<PRIMARY_REGISTRY, PRIMARY, SECONDARY_REGISTRY, SECONDARY> = ($DoubleWrappedRegistryObject<(PRIMARY_REGISTRY), (PRIMARY), (SECONDARY_REGISTRY), (SECONDARY)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleWrappedRegistryObject_<PRIMARY_REGISTRY, PRIMARY, SECONDARY_REGISTRY, SECONDARY> = $DoubleWrappedRegistryObject$$Type<(PRIMARY_REGISTRY), (PRIMARY), (SECONDARY_REGISTRY), (SECONDARY)>;
}}
declare module "mekanism.common.upgrade.BinUpgradeData" {
import {$BinInventorySlot, $BinInventorySlot$$Type} from "mekanism.common.inventory.slot.BinInventorySlot"
import {$IUpgradeData, $IUpgradeData$$Type} from "mekanism.common.upgrade.IUpgradeData"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $BinUpgradeData extends $Record implements $IUpgradeData {

constructor(redstone: boolean, binSlot: $BinInventorySlot$$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "redstone"(): boolean
public "binSlot"(): $BinInventorySlot
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinUpgradeData$$Type = ({"redstone"?: boolean, "binSlot"?: $BinInventorySlot$$Type}) | ([redstone?: boolean, binSlot?: $BinInventorySlot$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinUpgradeData_ = $BinUpgradeData$$Type;
}}
declare module "mekanism.common.inventory.container.ISecurityContainer" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"

export interface $ISecurityContainer {

 "canPlayerAccess"(player: $Player$$Type): boolean

(player: $Player): boolean
}

export namespace $ISecurityContainer {
const probejs$$marker: never
}
export class $ISecurityContainer$$Static implements $ISecurityContainer {


 "canPlayerAccess"(player: $Player$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISecurityContainer$$Type = ((player: $Player) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISecurityContainer_ = $ISecurityContainer$$Type;
}}
declare module "mekanism.common.content.blocktype.FactoryType" {
import {$Machine$FactoryMachine, $Machine$FactoryMachine$$Type} from "mekanism.common.content.blocktype.Machine$FactoryMachine"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$IHasTranslationKey$IHasEnumNameTranslationKey, $IHasTranslationKey$IHasEnumNameTranslationKey$$Type} from "mekanism.api.text.IHasTranslationKey$IHasEnumNameTranslationKey"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockRegistryObject, $BlockRegistryObject$$Type} from "mekanism.common.registration.impl.BlockRegistryObject"

export class $FactoryType extends $Enum<($FactoryType)> implements $IHasTranslationKey$IHasEnumNameTranslationKey {
static readonly "SMELTING": $FactoryType
static readonly "ENRICHING": $FactoryType
static readonly "CRUSHING": $FactoryType
static readonly "COMPRESSING": $FactoryType
static readonly "COMBINING": $FactoryType
static readonly "PURIFYING": $FactoryType
static readonly "INJECTING": $FactoryType
static readonly "INFUSING": $FactoryType
static readonly "SAWING": $FactoryType


public static "values"(): ($FactoryType)[]
public static "valueOf"(name: string): $FactoryType
public "getTranslationKey"(): string
public "getRegistryNameComponentCapitalized"(): string
public "getBaseMachine"(): $Machine$FactoryMachine<(any)>
public "getBaseBlock"(): $BlockRegistryObject<(any), (any)>
public "getRegistryNameComponent"(): string
public "getTranslatedName"(): $Component
get "translationKey"(): string
get "registryNameComponentCapitalized"(): string
get "baseMachine"(): $Machine$FactoryMachine<(any)>
get "baseBlock"(): $BlockRegistryObject<(any), (any)>
get "registryNameComponent"(): string
get "translatedName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryType$$Type = (("smelting") | ("enriching") | ("crushing") | ("compressing") | ("combining") | ("purifying") | ("injecting") | ("infusing") | ("sawing"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FactoryType_ = $FactoryType$$Type;
}}
declare module "mekanism.common.attachments.containers.chemical.AttachedChemicals" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$IAttachedContainers, $IAttachedContainers$$Type} from "mekanism.common.attachments.containers.IAttachedContainers"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $AttachedChemicals extends $Record implements $IAttachedContainers<($ChemicalStack), ($AttachedChemicals)> {
static readonly "EMPTY": $AttachedChemicals
static readonly "ACTUAL_CODEC": $Codec<($AttachedChemicals)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($AttachedChemicals)>
/**
 * 
 * @deprecated
 */
static readonly "GAS_CODEC": $Codec<($AttachedChemicals)>
/**
 * 
 * @deprecated
 */
static readonly "INFUSE_CODEC": $Codec<($AttachedChemicals)>
/**
 * 
 * @deprecated
 */
static readonly "PIGMENT_CODEC": $Codec<($AttachedChemicals)>
/**
 * 
 * @deprecated
 */
static readonly "SLURRY_CODEC": $Codec<($AttachedChemicals)>
static readonly "CODEC": $Codec<($AttachedChemicals)>

constructor(containers: $List$$Type<(any)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "create"(containers: integer): $AttachedChemicals
public "create"(containers: $List$$Type<($ChemicalStack$$Type)>): $AttachedChemicals
public "containers"(): $List<($ChemicalStack)>
public "getEmptyStack"(): $ChemicalStack
public "size"(): integer
public "get"(index: integer): $ChemicalStack
public "isEmpty"(): boolean
public "iterator"(): $Iterator<($ChemicalStack)>
public "spliterator"(): $Spliterator<($ChemicalStack)>
public "forEach"(action: $Consumer$$Type<($ChemicalStack)>): void
public "getOrDefault"(index: integer): $ChemicalStack
public "with"(index: integer, data: $ChemicalStack$$Type): $AttachedChemicals
[Symbol.iterator](): IterableIterator<$ChemicalStack>;
get "emptyStack"(): $ChemicalStack
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedChemicals$$Type = ({"containers"?: $List$$Type<($ChemicalStack$$Type)>}) | ([containers?: $List$$Type<($ChemicalStack$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttachedChemicals_ = $AttachedChemicals$$Type;
}}
declare module "mekanism.common.tile.TileEntityPersonalBarrel" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TileEntityPersonalStorage, $TileEntityPersonalStorage$$Type} from "mekanism.common.tile.TileEntityPersonalStorage"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityPersonalBarrel extends $TileEntityPersonalStorage {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(pos: $BlockPos$$Type, state: $BlockState$$Type)

public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityPersonalBarrel$$Type = ($TileEntityPersonalBarrel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityPersonalBarrel_ = $TileEntityPersonalBarrel$$Type;
}}
declare module "mekanism.common.tile.component.config.slot.BaseSlotInfo" {
import {$ISlotInfo, $ISlotInfo$$Type} from "mekanism.common.tile.component.config.slot.ISlotInfo"

export class $BaseSlotInfo implements $ISlotInfo {


public "canInput"(): boolean
public "canOutput"(): boolean
public "isEmpty"(): boolean
public "isEnabled"(): boolean
get "empty"(): boolean
get "enabled"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseSlotInfo$$Type = ($BaseSlotInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseSlotInfo_ = $BaseSlotInfo$$Type;
}}
declare module "mekanism.common.item.block.ItemBlockInductionProvider" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$TileEntityInductionProvider, $TileEntityInductionProvider$$Type} from "mekanism.common.tile.multiblock.TileEntityInductionProvider"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"

export class $ItemBlockInductionProvider extends $ItemBlockTooltip<($BlockTile<($TileEntityInductionProvider), ($BlockTypeTile<($TileEntityInductionProvider)>)>)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockTile$$Type<($TileEntityInductionProvider$$Type), ($BlockTypeTile$$Type<($TileEntityInductionProvider$$Type)>)>, properties: $Item$Properties$$Type)

public "getTier"(): $ITier
get "tier"(): $ITier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockInductionProvider$$Type = ($ItemBlockInductionProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockInductionProvider_ = $ItemBlockInductionProvider$$Type;
}}
declare module "mekanism.common.integration.computer.TableType$FieldType" {
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $TableType$FieldType extends $Record {
static readonly "CODEC": $Codec<($TableType$FieldType)>

constructor(description: string, javaType: $Class$$Type<(any)>, type: string, javaExtra: ($Class$$Type<(any)>)[])

public "type"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "description"(): string
public "javaType"(): $Class<(any)>
public "javaExtra"(): ($Class<(any)>)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TableType$FieldType$$Type = ({"javaType"?: $Class$$Type<(never)>, "javaExtra"?: ($Class$$Type<(never)>)[], "type"?: string, "description"?: string}) | ([javaType?: $Class$$Type<(never)>, javaExtra?: ($Class$$Type<(never)>)[], type?: string, description?: string]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TableType$FieldType_ = $TableType$FieldType$$Type;
}}
declare module "mekanism.common.tier.InductionCellTier" {
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$BaseTier, $BaseTier$$Type} from "mekanism.api.tier.BaseTier"
import {$CachedLongValue, $CachedLongValue$$Type} from "mekanism.common.config.value.CachedLongValue"

export class $InductionCellTier extends $Enum<($InductionCellTier)> implements $ITier {
static readonly "BASIC": $InductionCellTier
static readonly "ADVANCED": $InductionCellTier
static readonly "ELITE": $InductionCellTier
static readonly "ULTIMATE": $InductionCellTier


public static "values"(): ($InductionCellTier)[]
public static "valueOf"(name: string): $InductionCellTier
public "getMaxEnergy"(): long
public "getBaseMaxEnergy"(): long
public "getBaseTier"(): $BaseTier
public "setConfigReference"(storageReference: $CachedLongValue$$Type): void
get "maxEnergy"(): long
get "baseMaxEnergy"(): long
get "baseTier"(): $BaseTier
set "configReference"(value: $CachedLongValue$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InductionCellTier$$Type = (("basic") | ("advanced") | ("elite") | ("ultimate"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InductionCellTier_ = $InductionCellTier$$Type;
}}
declare module "mekanism.common.lib.math.voxel.VoxelCuboid$WallRelative" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $VoxelCuboid$WallRelative extends $Enum<($VoxelCuboid$WallRelative)> {
static readonly "SIDE": $VoxelCuboid$WallRelative
static readonly "EDGE": $VoxelCuboid$WallRelative
static readonly "CORNER": $VoxelCuboid$WallRelative
static readonly "INVALID": $VoxelCuboid$WallRelative


public static "values"(): ($VoxelCuboid$WallRelative)[]
public static "valueOf"(name: string): $VoxelCuboid$WallRelative
public "isOnCorner"(): boolean
public "isWall"(): boolean
public "isOnEdge"(): boolean
get "onCorner"(): boolean
get "wall"(): boolean
get "onEdge"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VoxelCuboid$WallRelative$$Type = (("side") | ("edge") | ("corner") | ("invalid"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VoxelCuboid$WallRelative_ = $VoxelCuboid$WallRelative$$Type;
}}
declare module "mekanism.common.advancements.triggers.UnboxCardboardBoxTrigger" {
import {$SimpleCriterionTrigger, $SimpleCriterionTrigger$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$UnboxCardboardBoxTrigger$TriggerInstance, $UnboxCardboardBoxTrigger$TriggerInstance$$Type} from "mekanism.common.advancements.triggers.UnboxCardboardBoxTrigger$TriggerInstance"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"

export class $UnboxCardboardBoxTrigger extends $SimpleCriterionTrigger<($UnboxCardboardBoxTrigger$TriggerInstance)> {

constructor()

public "trigger"(player: $ServerPlayer$$Type): void
public "codec"(): $Codec<($UnboxCardboardBoxTrigger$TriggerInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnboxCardboardBoxTrigger$$Type = ($UnboxCardboardBoxTrigger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnboxCardboardBoxTrigger_ = $UnboxCardboardBoxTrigger$$Type;
}}
declare module "mekanism.common.inventory.container.item.PortableQIODashboardContainer" {
import {$ContainerListener, $ContainerListener$$Type} from "net.minecraft.world.inventory.ContainerListener"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$QIOFrequency, $QIOFrequency$$Type} from "mekanism.common.content.qio.QIOFrequency"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$List, $List$$Type} from "java.util.List"
import {$ContainerSynchronizer, $ContainerSynchronizer$$Type} from "net.minecraft.world.inventory.ContainerSynchronizer"
import {$Inventory, $Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$MenuType, $MenuType$$Type} from "net.minecraft.world.inventory.MenuType"
import {$Set, $Set$$Type} from "java.util.Set"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"
import {$QIOItemViewerContainer, $QIOItemViewerContainer$$Type} from "mekanism.common.inventory.container.QIOItemViewerContainer"

export class $PortableQIODashboardContainer extends $QIOItemViewerContainer {
static readonly "SLOTS_X_MIN": integer
static readonly "SLOTS_X_MAX": integer
static readonly "SLOTS_Y_MIN": integer
static readonly "SLOTS_Y_MAX": integer
static readonly "SLOTS_START_Y": integer
static readonly "BASE_Y_OFFSET": integer
static readonly "TRANSPORTER_CONFIG_WINDOW": integer
static readonly "SIDE_CONFIG_WINDOW": integer
static readonly "UPGRADE_WINDOW": integer
static readonly "SKIN_SELECT_WINDOW": integer
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
 "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
readonly "remoteSlots": $NonNullList<($ItemStack)>
 "remoteCarried": $ItemStack
 "stateId": integer
 "menuType": $MenuType<(any)>
 "containerId": integer
 "quickcraftType": integer
 "quickcraftStatus": integer
readonly "quickcraftSlots": $Set<($Slot)>
readonly "containerListeners": $List<($ContainerListener)>
 "synchronizer": $ContainerSynchronizer

constructor(id: integer, inv: $Inventory$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type, remote: boolean)

public "getStack"(): $ItemStack
public "getFrequency"(): $QIOFrequency
public "clicked"(slotId: integer, dragType: integer, clickType: $ClickType$$Type, player: $Player$$Type): void
public "stillValid"(player: $Player$$Type): boolean
public "getHand"(): $InteractionHand
public "shiftClickIntoFrequency"(): boolean
public "toggleTargetDirection"(): void
public "canPlayerAccess"(player: $Player$$Type): boolean
public "recreate"(): $PortableQIODashboardContainer
get "stack"(): $ItemStack
get "frequency"(): $QIOFrequency
get "hand"(): $InteractionHand
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PortableQIODashboardContainer$$Type = ($PortableQIODashboardContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PortableQIODashboardContainer_ = $PortableQIODashboardContainer$$Type;
}}
declare module "mekanism.common.content.teleporter.TeleporterFrequency" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$IColorableFrequency, $IColorableFrequency$$Type} from "mekanism.common.lib.frequency.IColorableFrequency"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$Set, $Set$$Type} from "java.util.Set"
import {$SecurityMode, $SecurityMode$$Type} from "mekanism.api.security.SecurityMode"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$EnumColor, $EnumColor$$Type} from "mekanism.api.text.EnumColor"

export class $TeleporterFrequency extends $Frequency implements $IColorableFrequency {
static readonly "CODEC": $Codec<($TeleporterFrequency)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($TeleporterFrequency)>

constructor(n: string, uuid: $UUID$$Type, securityMode: $SecurityMode$$Type)

public "update"(tile: $BlockEntity$$Type): boolean
public "setColor"(color: $EnumColor$$Type): void
public "getColor"(): $EnumColor
public "getClosestCoords"(pos: $GlobalPos$$Type): $GlobalPos
public "getActiveCoords"(): $Set<($GlobalPos)>
public "getSyncHash"(): integer
public "onDeactivate"(tile: $BlockEntity$$Type): boolean
set "color"(value: $EnumColor$$Type)
get "color"(): $EnumColor
get "activeCoords"(): $Set<($GlobalPos)>
get "syncHash"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TeleporterFrequency$$Type = ($TeleporterFrequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TeleporterFrequency_ = $TeleporterFrequency$$Type;
}}
declare module "mekanism.common.inventory.container.slot.IInsertableSlot" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$SelectedWindowData, $SelectedWindowData$$Type} from "mekanism.common.inventory.container.SelectedWindowData"
import {$Action, $Action$$Type} from "mekanism.api.Action"

export interface $IInsertableSlot {

 "exists"(windowData: $SelectedWindowData$$Type): boolean
 "insertItem"(stack: $ItemStack$$Type, action: $Action$$Type): $ItemStack
 "canMergeWith"(stack: $ItemStack$$Type): boolean

(stack: $ItemStack, action: $Action): $ItemStack$$Type
}

export namespace $IInsertableSlot {
const probejs$$marker: never
}
export class $IInsertableSlot$$Static implements $IInsertableSlot {


 "exists"(windowData: $SelectedWindowData$$Type): boolean
 "insertItem"(stack: $ItemStack$$Type, action: $Action$$Type): $ItemStack
 "canMergeWith"(stack: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInsertableSlot$$Type = ((stack: $ItemStack, action: $Action) => $ItemStack$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInsertableSlot_ = $IInsertableSlot$$Type;
}}
declare module "mekanism.common.particle.LaserParticleData" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ParticleType, $ParticleType$$Type} from "net.minecraft.core.particles.ParticleType"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $LaserParticleData extends $Record implements $ParticleOptions {
static readonly "CODEC": $MapCodec<($LaserParticleData)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($LaserParticleData)>

constructor(direction: $Direction$$Type, distance: double, energyScale: float)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getType"(): $ParticleType<(any)>
public "distance"(): double
public "direction"(): $Direction
public "energyScale"(): float
get "type"(): $ParticleType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LaserParticleData$$Type = ({"energyScale"?: float, "direction"?: $Direction$$Type, "distance"?: double}) | ([energyScale?: float, direction?: $Direction$$Type, distance?: double]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LaserParticleData_ = $LaserParticleData$$Type;
}}
declare module "mekanism.common.tile.prefab.TileEntityInternalMultiblock" {
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$MultiblockData, $MultiblockData$$Type} from "mekanism.common.lib.multiblock.MultiblockData"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IInternalMultiblock, $IInternalMultiblock$$Type} from "mekanism.common.lib.multiblock.IInternalMultiblock"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"

export class $TileEntityInternalMultiblock extends $TileEntityMekanism implements $IInternalMultiblock {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "setMultiblock"(multiblock: $MultiblockData$$Type): void
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "onNeighborChange"(block: $Block$$Type, neighborPos: $BlockPos$$Type): void
public "getMultiblock"(): $MultiblockData
public "getMultiblockUUID"(): $UUID
public "blockRemoved"(): void
public "hasFormedMultiblock"(): boolean
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
set "multiblock"(value: $MultiblockData$$Type)
get "multiblock"(): $MultiblockData
get "multiblockUUID"(): $UUID
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityInternalMultiblock$$Type = ($TileEntityInternalMultiblock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityInternalMultiblock_ = $TileEntityInternalMultiblock$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.type.ItemInputCache" {
import {$ItemStackIngredient, $ItemStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ItemStackIngredient"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ComponentSensitiveInputCache, $ComponentSensitiveInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.ComponentSensitiveInputCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$InputIngredient, $InputIngredient$$Type} from "mekanism.api.recipes.ingredients.InputIngredient"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemInputCache<RECIPE extends $MekanismRecipe<(any)>> extends $ComponentSensitiveInputCache<($Item), ($ItemStack), ($ItemStackIngredient), (RECIPE)> {

constructor()

public "isEmpty"(input: any): boolean
public "isEmpty"(input: $ItemStack$$Type): boolean
public "mapInputs"(recipe: RECIPE, inputIngredient: $ItemStackIngredient$$Type): boolean
public "mapInputs"(recipe: $MekanismRecipe$$Type<(any)>, inputIngredient: $InputIngredient$$Type<(any)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemInputCache$$Type<RECIPE> = ($ItemInputCache<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemInputCache_<RECIPE> = $ItemInputCache$$Type<(RECIPE)>;
}}
declare module "mekanism.common.block.basic.BlockBin" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$TileEntityBin, $TileEntityBin$$Type} from "mekanism.common.tile.TileEntityBin"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockBin extends $BlockTile<($TileEntityBin), ($BlockTypeTile<($TileEntityBin)>)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(type: $BlockTypeTile$$Type<($TileEntityBin$$Type)>, propertiesModifier: $UnaryOperator$$Type<($BlockBehaviour$Properties)>)

public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBin$$Type = ($BlockBin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBin_ = $BlockBin$$Type;
}}
declare module "mekanism.common.attachments.containers.energy.AttachedEnergy" {
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$IAttachedContainers, $IAttachedContainers$$Type} from "mekanism.common.attachments.containers.IAttachedContainers"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $AttachedEnergy extends $Record implements $IAttachedContainers<(long), ($AttachedEnergy)> {
static readonly "EMPTY": $AttachedEnergy
static readonly "CODEC": $Codec<($AttachedEnergy)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($AttachedEnergy)>

constructor(containers: $List$$Type<(any)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "create"(containers: $List$$Type<(any)>): $IAttachedContainers<(any), (any)>
public static "create"(containers: integer): $AttachedEnergy
public "containers"(): $List<(long)>
public "getEmptyStack"(): any
public "size"(): integer
public "get"(index: integer): long
public "isEmpty"(): boolean
public "iterator"(): $Iterator<(long)>
public "spliterator"(): $Spliterator<(long)>
public "forEach"(action: $Consumer$$Type<(long)>): void
public "getOrDefault"(index: integer): long
public "with"(index: integer, data: long): $AttachedEnergy
[Symbol.iterator](): IterableIterator<long>;
get "emptyStack"(): any
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedEnergy$$Type = ({"containers"?: $List$$Type<(long)>}) | ([containers?: $List$$Type<(long)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttachedEnergy_ = $AttachedEnergy$$Type;
}}
declare module "mekanism.common.block.BlockOre" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$OreType, $OreType$$Type} from "mekanism.common.resource.ore.OreType"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IHasDescription, $IHasDescription$$Type} from "mekanism.common.block.interfaces.IHasDescription"
import {$ILangEntry, $ILangEntry$$Type} from "mekanism.api.text.ILangEntry"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$LevelAccessor, $LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockOre extends $Block implements $IHasDescription {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(ore: $OreType$$Type)
constructor(ore: $OreType$$Type, properties: $BlockBehaviour$Properties$$Type)

public "getDescription"(): $ILangEntry
public "getExpDrop"(state: $BlockState$$Type, level: $LevelAccessor$$Type, pos: $BlockPos$$Type, blockEntity: $BlockEntity$$Type, breaker: $Entity$$Type, tool: $ItemStack$$Type): integer
public "getDescriptionTranslationKey"(): string
public "asHolder"(): $Holder<(any)>
get "description"(): $ILangEntry
get "descriptionTranslationKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockOre$$Type = ($BlockOre);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockOre_ = $BlockOre$$Type;
}}
declare module "mekanism.common.tile.component.config.slot.ISlotInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ISlotInfo {

 "isEmpty"(): boolean
 "isEnabled"(): boolean
 "canInput"(): boolean
 "canOutput"(): boolean
get "empty"(): boolean
get "enabled"(): boolean
}

export namespace $ISlotInfo {
const probejs$$marker: never
}
export class $ISlotInfo$$Static implements $ISlotInfo {


 "isEmpty"(): boolean
 "isEnabled"(): boolean
 "canInput"(): boolean
 "canOutput"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISlotInfo$$Type = ($ISlotInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISlotInfo_ = $ISlotInfo$$Type;
}}
declare module "mekanism.common.capabilities.heat.VariableHeatCapacitor" {
import {$DoubleSupplier, $DoubleSupplier$$Type} from "java.util.function.DoubleSupplier"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$BasicHeatCapacitor, $BasicHeatCapacitor$$Type} from "mekanism.common.capabilities.heat.BasicHeatCapacitor"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $VariableHeatCapacitor extends $BasicHeatCapacitor {


public static "create"(heatCapacity: double, ambientTempSupplier: $DoubleSupplier$$Type, listener: $IContentsListener$$Type): $VariableHeatCapacitor
public static "create"(heatCapacity: double, conductionCoefficient: $DoubleSupplier$$Type, insulationCoefficient: $DoubleSupplier$$Type, ambientTempSupplier: $DoubleSupplier$$Type, listener: $IContentsListener$$Type): $VariableHeatCapacitor
public "getInverseConduction"(): double
public "getInverseInsulation"(): double
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $Tag
get "inverseConduction"(): double
get "inverseInsulation"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariableHeatCapacitor$$Type = ($VariableHeatCapacitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariableHeatCapacitor_ = $VariableHeatCapacitor$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.InputRecipeCache$SingleFluid" {
import {$SingleInputRecipeCache, $SingleInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.SingleInputRecipeCache"
import {$FluidStackIngredient, $FluidStackIngredient$$Type} from "mekanism.api.recipes.ingredients.FluidStackIngredient"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$MekanismRecipeType, $MekanismRecipeType$$Type} from "mekanism.common.recipe.MekanismRecipeType"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidInputCache, $FluidInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.FluidInputCache"

export class $InputRecipeCache$SingleFluid<RECIPE extends ($MekanismRecipe<(any)>) & ($Predicate<($FluidStack)>)> extends $SingleInputRecipeCache<($FluidStack), ($FluidStackIngredient), (RECIPE), ($FluidInputCache<(RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$$Type<(any), (RECIPE), (any)>, inputExtractor: $Function$$Type<(RECIPE), ($FluidStackIngredient$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$SingleFluid$$Type<RECIPE> = ($InputRecipeCache$SingleFluid<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$SingleFluid_<RECIPE> = $InputRecipeCache$SingleFluid$$Type<(RECIPE)>;
}}
declare module "mekanism.common.inventory.ISlotClickHandler$IScrollableSlot" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$HashedItem, $HashedItem$$Type} from "mekanism.common.lib.inventory.HashedItem"

export interface $ISlotClickHandler$IScrollableSlot {

 "count"(): long
 "getDisplayName"(): string
 "item"(): $HashedItem
 "getModID"(): string
 "getRegistryName"(): $ResourceLocation
 "itemUUID"(): $UUID
get "displayName"(): string
get "modID"(): string
get "registryName"(): $ResourceLocation
}

export namespace $ISlotClickHandler$IScrollableSlot {
const probejs$$marker: never
}
export class $ISlotClickHandler$IScrollableSlot$$Static implements $ISlotClickHandler$IScrollableSlot {


 "count"(): long
 "getDisplayName"(): string
 "item"(): $HashedItem
 "getModID"(): string
 "getRegistryName"(): $ResourceLocation
 "itemUUID"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISlotClickHandler$IScrollableSlot$$Type = ($ISlotClickHandler$IScrollableSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISlotClickHandler$IScrollableSlot_ = $ISlotClickHandler$IScrollableSlot$$Type;
}}
declare module "mekanism.common.lib.radial.IRadialModeItem" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IRadialMode, $IRadialMode$$Type} from "mekanism.api.radial.mode.IRadialMode"
import {$IModeItem$IAttachmentBasedModeItem, $IModeItem$IAttachmentBasedModeItem$$Type} from "mekanism.common.item.interfaces.IModeItem$IAttachmentBasedModeItem"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$IGenericRadialModeItem, $IGenericRadialModeItem$$Type} from "mekanism.common.lib.radial.IGenericRadialModeItem"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"
import {$RadialData, $RadialData$$Type} from "mekanism.api.radial.RadialData"

export interface $IRadialModeItem<MODE extends $IRadialMode> extends $IGenericRadialModeItem, $IModeItem$IAttachmentBasedModeItem<(MODE)> {

 "setMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, player: $Player$$Type, radialData: $RadialData$$Type<(M)>, mode: M): void
 "getMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, radialData: $RadialData$$Type<(M)>): M
 "getRadialData"(stack: $ItemStack$$Type): $RadialData<(MODE)>
 "setMode"(stack: $ItemStack$$Type, player: $Player$$Type, mode: MODE): void
 "getMode"(stack: $ItemStack$$Type): MODE
 "getDefaultMode"(): MODE
 "getModeDataType"(): $DataComponentType<(MODE)>
 "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
 "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
 "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
get "defaultMode"(): MODE
get "modeDataType"(): $DataComponentType<(MODE)>
}

export namespace $IRadialModeItem {
function displayModeChange(player: $Player$$Type): void
function isModeItem(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
function isModeItem(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
const probejs$$marker: never
}
export class $IRadialModeItem$$Static<MODE extends $IRadialMode> implements $IRadialModeItem {


 "setMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, player: $Player$$Type, radialData: $RadialData$$Type<(M)>, mode: M): void
 "getMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, radialData: $RadialData$$Type<(M)>): M
 "getRadialData"(stack: $ItemStack$$Type): $RadialData<(MODE)>
 "setMode"(stack: $ItemStack$$Type, player: $Player$$Type, mode: MODE): void
 "getMode"(stack: $ItemStack$$Type): MODE
 "getDefaultMode"(): MODE
 "getModeDataType"(): $DataComponentType<(MODE)>
 "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
static "displayModeChange"(player: $Player$$Type): void
 "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
 "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRadialModeItem$$Type<MODE> = ($IRadialModeItem<(MODE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRadialModeItem_<MODE> = $IRadialModeItem$$Type<(MODE)>;
}}
declare module "mekanism.common.tile.transmitter.TileEntityPressurizedTube" {
import {$IConfigurable, $IConfigurable$$Type} from "mekanism.api.IConfigurable"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$ConnectionType, $ConnectionType$$Type} from "mekanism.common.lib.transmitter.ConnectionType"
import {$TileEntityTransmitter, $TileEntityTransmitter$$Type} from "mekanism.common.tile.transmitter.TileEntityTransmitter"
import {$IComputerTile, $IComputerTile$$Type} from "mekanism.common.integration.computer.IComputerTile"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$TransmitterModelData, $TransmitterModelData$$Type} from "mekanism.client.model.data.TransmitterModelData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TransmitterType, $TransmitterType$$Type} from "mekanism.common.block.states.TransmitterType"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ITileRadioactive, $ITileRadioactive$$Type} from "mekanism.common.tile.interfaces.ITileRadioactive"
import {$ModelProperty, $ModelProperty$$Type} from "net.neoforged.neoforge.client.model.data.ModelProperty"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$Transmitter, $Transmitter$$Type} from "mekanism.common.content.network.transmitter.Transmitter"
import {$BoundMethodHolder, $BoundMethodHolder$$Type} from "mekanism.common.integration.computer.BoundMethodHolder"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"

export class $TileEntityPressurizedTube extends $TileEntityTransmitter implements $IComputerTile, $ITileRadioactive {
static readonly "CONFIGURABLE_PROVIDER": $ICapabilityProvider<($TileEntityTransmitter), ($Direction), ($IConfigurable)>
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "getUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "sideChanged"(side: $Direction$$Type, old: $ConnectionType$$Type, type: $ConnectionType$$Type): void
public "getRadiationScale"(): float
public "getComputerName"(): string
public "getRadiationParticleCount"(): integer
public "getTransmitter"(): $Transmitter<(any), (any), (any)>
public "redstoneChanged"(powered: boolean): void
public "getTransmitterType"(): $TransmitterType
public "isComputerCapabilityPersistent"(): boolean
public "hasComputerSupport"(): boolean
public "getComputerMethods"(holder: $BoundMethodHolder$$Type): void
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
get "radiationScale"(): float
get "computerName"(): string
get "radiationParticleCount"(): integer
get "transmitter"(): $Transmitter<(any), (any), (any)>
get "transmitterType"(): $TransmitterType
get "computerCapabilityPersistent"(): boolean
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityPressurizedTube$$Type = ($TileEntityPressurizedTube);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityPressurizedTube_ = $TileEntityPressurizedTube$$Type;
}}
declare module "mekanism.common.inventory.container.ITrackableContainer" {
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"

export interface $ITrackableContainer {

 "addContainerTrackers"(container: $MekanismContainer$$Type): void

(container: $MekanismContainer): void
}

export namespace $ITrackableContainer {
const probejs$$marker: never
}
export class $ITrackableContainer$$Static implements $ITrackableContainer {


 "addContainerTrackers"(container: $MekanismContainer$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITrackableContainer$$Type = ((container: $MekanismContainer) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITrackableContainer_ = $ITrackableContainer$$Type;
}}
declare module "mekanism.common.inventory.container.QIOItemViewerContainer$SortDirection" {
import {$GuiComponents$IToggleEnum, $GuiComponents$IToggleEnum$$Type} from "mekanism.common.inventory.GuiComponents$IToggleEnum"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$IHasTranslationKey$IHasEnumNameTranslationKey, $IHasTranslationKey$IHasEnumNameTranslationKey$$Type} from "mekanism.api.text.IHasTranslationKey$IHasEnumNameTranslationKey"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export class $QIOItemViewerContainer$SortDirection extends $Enum<($QIOItemViewerContainer$SortDirection)> implements $GuiComponents$IToggleEnum<($QIOItemViewerContainer$SortDirection)>, $IHasTranslationKey$IHasEnumNameTranslationKey {
static readonly "ASCENDING": $QIOItemViewerContainer$SortDirection
static readonly "DESCENDING": $QIOItemViewerContainer$SortDirection


public static "values"(): ($QIOItemViewerContainer$SortDirection)[]
public static "valueOf"(name: string): $QIOItemViewerContainer$SortDirection
public "isAscending"(): boolean
public "getIcon"(): $ResourceLocation
public "getTooltip"(): $Component
public "getTranslationKey"(): string
public "getTranslatedName"(): $Component
get "ascending"(): boolean
get "icon"(): $ResourceLocation
get "tooltip"(): $Component
get "translationKey"(): string
get "translatedName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOItemViewerContainer$SortDirection$$Type = (("ascending") | ("descending"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOItemViewerContainer$SortDirection_ = $QIOItemViewerContainer$SortDirection$$Type;
}}
declare module "mekanism.common.inventory.container.slot.SlotOverlay" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $SlotOverlay extends $Enum<($SlotOverlay)> {
static readonly "MINUS": $SlotOverlay
static readonly "PLUS": $SlotOverlay
static readonly "POWER": $SlotOverlay
static readonly "INPUT": $SlotOverlay
static readonly "OUTPUT": $SlotOverlay
static readonly "CHECK": $SlotOverlay
static readonly "X": $SlotOverlay
static readonly "FORMULA": $SlotOverlay
static readonly "UPGRADE": $SlotOverlay
static readonly "SELECT": $SlotOverlay
static readonly "MODULE": $SlotOverlay


public static "values"(): ($SlotOverlay)[]
public static "valueOf"(name: string): $SlotOverlay
public "getWidth"(): integer
public "getTexture"(): $ResourceLocation
public "getHeight"(): integer
get "width"(): integer
get "texture"(): $ResourceLocation
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotOverlay$$Type = (("minus") | ("plus") | ("power") | ("input") | ("output") | ("check") | ("x") | ("formula") | ("upgrade") | ("select") | ("module"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotOverlay_ = $SlotOverlay$$Type;
}}
declare module "mekanism.common.tile.component.TileComponentChunkLoader" {
import {$ITileComponent, $ITileComponent$$Type} from "mekanism.common.tile.component.ITileComponent"
import {$BlockEntity$DataComponentInput, $BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List, $List$$Type} from "java.util.List"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$DataComponentMap$Builder, $DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IChunkLoader, $IChunkLoader$$Type} from "mekanism.common.lib.chunkloading.IChunkLoader"
import {$TicketController, $TicketController$$Type} from "net.neoforged.neoforge.common.world.chunk.TicketController"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $TileComponentChunkLoader<T extends ($TileEntityMekanism) & ($IChunkLoader)> implements $ITileComponent {
static readonly "TICKET_CONTROLLER": $TicketController

constructor(tile: T)
constructor(tile: T, forceTicks: boolean)

public "write"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "read"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "removed"(): void
public "deserialize"(componentTag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "serialize"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "tickServer"(): void
public "canOperate"(): boolean
public "getComponentKey"(): string
public "refreshChunkTickets"(): void
public "applyImplicitComponents"(input: $BlockEntity$DataComponentInput$$Type): void
public "collectImplicitComponents"(builder: $DataComponentMap$Builder$$Type): void
public "invalidate"(): void
public "addToUpdateTag"(updateTag: $CompoundTag$$Type): void
public "readFromUpdateTag"(updateTag: $CompoundTag$$Type): void
public "trackForMainContainer"(container: $MekanismContainer$$Type): void
public "addRemapEntries"(remapEntries: $List$$Type<($DataComponentType$$Type<(any)>)>): void
get "componentKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileComponentChunkLoader$$Type<T> = ($TileComponentChunkLoader<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileComponentChunkLoader_<T> = $TileComponentChunkLoader$$Type<(T)>;
}}
declare module "mekanism.common.inventory.container.item.MekanismItemContainer" {
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ContainerListener, $ContainerListener$$Type} from "net.minecraft.world.inventory.ContainerListener"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$MenuType, $MenuType$$Type} from "net.minecraft.world.inventory.MenuType"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$ContainerSynchronizer, $ContainerSynchronizer$$Type} from "net.minecraft.world.inventory.ContainerSynchronizer"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"

export class $MekanismItemContainer extends $MekanismContainer {
static readonly "BASE_Y_OFFSET": integer
static readonly "TRANSPORTER_CONFIG_WINDOW": integer
static readonly "SIDE_CONFIG_WINDOW": integer
static readonly "UPGRADE_WINDOW": integer
static readonly "SKIN_SELECT_WINDOW": integer
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
 "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
readonly "remoteSlots": $NonNullList<($ItemStack)>
 "remoteCarried": $ItemStack
 "stateId": integer
 "menuType": $MenuType<(any)>
 "containerId": integer
 "quickcraftType": integer
 "quickcraftStatus": integer
readonly "quickcraftSlots": $Set<($Slot)>
readonly "containerListeners": $List<($ContainerListener)>
 "synchronizer": $ContainerSynchronizer


public "stillValid"(player: $Player$$Type): boolean
public "canPlayerAccess"(player: $Player$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismItemContainer$$Type = ($MekanismItemContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismItemContainer_ = $MekanismItemContainer$$Type;
}}
declare module "mekanism.common.lib.collection.HashList" {
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$List, $List$$Type} from "java.util.List"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$LinkedHashSet, $LinkedHashSet$$Type} from "java.util.LinkedHashSet"
import {$Set, $Set$$Type} from "java.util.Set"

export class $HashList<T> extends $LinkedHashSet<(T)> {

constructor(initialCapacity: integer)
constructor(toCopy: $Collection$$Type<(T)>)
constructor()

public "remove"(i: integer): T
public "remove"(o: any): boolean
public "size"(): integer
public "get"(i: integer): T
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "clone"(): any
public "indexOf"(obj: T): integer
public "clear"(): void
public "replace"(existing: T, replacement: T): boolean
public "add"(value: T): boolean
public "add"(i: integer, value: T): void
public "toArray"(): (any)[]
public "iterator"(): $Iterator<(T)>
public "elements"(): $List<(T)>
public "set"(i: integer, value: T): T
public "swap"(source: integer, target: integer, postSwap: $BiConsumer$$Type<(T), (T)>): void
public "getOrNull"(index: integer): T
public "reversed"(): $SequencedCollection<(any)>
public static "copyOf"<E>(arg0: $Collection$$Type<(E)>): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public static "of"<E>(...arg0: (E)[]): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $Set<(E)>
public static "of"<E>(arg0: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E): $Set<(E)>
public "addAll"(arg0: $Collection$$Type<(E)>): boolean
public "removeAll"(arg0: $Collection$$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$$Type<(any)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HashList$$Type<T> = ($HashList<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HashList_<T> = $HashList$$Type<(T)>;
}}
declare module "mekanism.common.lib.frequency.FrequencyType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$SecurityFrequency, $SecurityFrequency$$Type} from "mekanism.common.lib.security.SecurityFrequency"
import {$TeleporterFrequency, $TeleporterFrequency$$Type} from "mekanism.common.content.teleporter.TeleporterFrequency"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$InventoryFrequency, $InventoryFrequency$$Type} from "mekanism.common.content.entangloporter.InventoryFrequency"
import {$QIOFrequency, $QIOFrequency$$Type} from "mekanism.common.content.qio.QIOFrequency"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$IdentitySerializer, $IdentitySerializer$$Type} from "mekanism.common.lib.frequency.IdentitySerializer"
import {$SecurityMode, $SecurityMode$$Type} from "mekanism.api.security.SecurityMode"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$FrequencyManager, $FrequencyManager$$Type} from "mekanism.common.lib.frequency.FrequencyManager"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$$Type} from "mekanism.common.lib.frequency.Frequency$FrequencyIdentity"
import {$FrequencyManagerWrapper, $FrequencyManagerWrapper$$Type} from "mekanism.common.lib.frequency.FrequencyManagerWrapper"

export class $FrequencyType<FREQ extends $Frequency> {
static readonly "CODEC": $Codec<($FrequencyType<(any)>)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($FrequencyType<(any)>)>
static readonly "TELEPORTER": $FrequencyType<($TeleporterFrequency)>
static readonly "INVENTORY": $FrequencyType<($InventoryFrequency)>
static readonly "SECURITY": $FrequencyType<($SecurityFrequency)>
static readonly "QIO": $FrequencyType<($QIOFrequency)>


public "getName"(): string
public "equals"(obj: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "load"<FREQ extends $Frequency>(tag: $CompoundTag$$Type): $FrequencyType<(FREQ)>
public static "clear"(): void
public static "init"(): void
public "create"(buffer: $RegistryFriendlyByteBuf$$Type): FREQ
public "create"(key: any, ownerUUID: $UUID$$Type, securityMode: $SecurityMode$$Type): FREQ
public "create"(provider: $HolderLookup$Provider$$Type, identityTag: $CompoundTag$$Type): FREQ
public "getManager"(owner: $UUID$$Type, securityMode: $SecurityMode$$Type): $FrequencyManager<(FREQ)>
public "getManager"(identity: $Frequency$FrequencyIdentity$$Type, owner: $UUID$$Type): $FrequencyManager<(FREQ)>
public "getFrequency"(identity: $Frequency$FrequencyIdentity$$Type, owner: $UUID$$Type): FREQ
public "codec"(): $Codec<(FREQ)>
public "getManagerWrapper"(): $FrequencyManagerWrapper<(FREQ)>
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (FREQ)>
public "getIdentitySerializer"(): $IdentitySerializer
public "getFrequencyManager"(freq: FREQ): $FrequencyManager<(FREQ)>
get "name"(): string
get "managerWrapper"(): $FrequencyManagerWrapper<(FREQ)>
get "identitySerializer"(): $IdentitySerializer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrequencyType$$Type<FREQ> = ($FrequencyType<(FREQ)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FrequencyType_<FREQ> = $FrequencyType$$Type<(FREQ)>;
}}
declare module "mekanism.common.item.block.machine.ItemBlockQIOComponent" {
import {$IColoredItem, $IColoredItem$$Type} from "mekanism.common.item.interfaces.IColoredItem"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$QIOFrequency, $QIOFrequency$$Type} from "mekanism.common.content.qio.QIOFrequency"
import {$FrequencyAware, $FrequencyAware$$Type} from "mekanism.common.attachments.FrequencyAware"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$IFrequencyItem, $IFrequencyItem$$Type} from "mekanism.common.lib.frequency.IFrequencyItem"
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"

export class $ItemBlockQIOComponent extends $ItemBlockTooltip<($BlockTile<(any), (any)>)> implements $IColoredItem, $IFrequencyItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockTile$$Type<(any), (any)>, properties: $Item$Properties$$Type)

public "inventoryTick"(stack: $ItemStack$$Type, level: $Level$$Type, entity: $Entity$$Type, slotId: integer, isSelected: boolean): void
public "getFrequencyComponent"(): $DataComponentType<($FrequencyAware<($QIOFrequency)>)>
public "getFrequencyType"(): $FrequencyType<(any)>
public "syncColorWithFrequency"<FREQ extends $Frequency>(stack: $ItemStack$$Type): void
get "frequencyComponent"(): $DataComponentType<($FrequencyAware<($QIOFrequency)>)>
get "frequencyType"(): $FrequencyType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockQIOComponent$$Type = ($ItemBlockQIOComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockQIOComponent_ = $ItemBlockQIOComponent$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.InputRecipeCache$EitherSideChemical" {
import {$ChemicalChemicalToChemicalRecipe, $ChemicalChemicalToChemicalRecipe$$Type} from "mekanism.api.recipes.ChemicalChemicalToChemicalRecipe"
import {$ChemicalInputCache, $ChemicalInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.ChemicalInputCache"
import {$ChemicalStackIngredient, $ChemicalStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ChemicalStackIngredient"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$EitherSideInputRecipeCache, $EitherSideInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.EitherSideInputRecipeCache"
import {$MekanismRecipeType, $MekanismRecipeType$$Type} from "mekanism.common.recipe.MekanismRecipeType"

export class $InputRecipeCache$EitherSideChemical<RECIPE extends $ChemicalChemicalToChemicalRecipe> extends $EitherSideInputRecipeCache<($ChemicalStack), ($ChemicalStackIngredient), (RECIPE), ($ChemicalInputCache<(RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$$Type<(any), (RECIPE), (any)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$EitherSideChemical$$Type<RECIPE> = ($InputRecipeCache$EitherSideChemical<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$EitherSideChemical_<RECIPE> = $InputRecipeCache$EitherSideChemical$$Type<(RECIPE)>;
}}
declare module "mekanism.common.item.gear.ItemFreeRunners" {
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$$Type} from "mekanism.common.registration.impl.CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$ArmorMaterial, $ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IModeItem$IAttachmentBasedModeItem, $IModeItem$IAttachmentBasedModeItem$$Type} from "mekanism.common.item.interfaces.IModeItem$IAttachmentBasedModeItem"
import {$ItemAttributeModifiers, $ItemAttributeModifiers$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$List, $List$$Type} from "java.util.List"
import {$IItemHUDProvider, $IItemHUDProvider$$Type} from "mekanism.common.item.interfaces.IItemHUDProvider"
import {$ItemAttributeModifierEvent, $ItemAttributeModifierEvent$$Type} from "net.neoforged.neoforge.event.ItemAttributeModifierEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior, $DispenseItemBehavior$$Type} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"
import {$IHasConditionalAttributes, $IHasConditionalAttributes$$Type} from "mekanism.common.item.interfaces.IHasConditionalAttributes"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$ItemSpecialArmor, $ItemSpecialArmor$$Type} from "mekanism.common.item.gear.ItemSpecialArmor"
import {$ItemFreeRunners$FreeRunnerMode, $ItemFreeRunners$FreeRunnerMode$$Type} from "mekanism.common.item.gear.ItemFreeRunners$FreeRunnerMode"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$Equipable, $Equipable$$Type} from "net.minecraft.world.item.Equipable"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $ItemFreeRunners extends $ItemSpecialArmor implements $IItemHUDProvider, $CreativeTabDeferredRegister$ICustomCreativeTabContents, $IModeItem$IAttachmentBasedModeItem<($ItemFreeRunners$FreeRunnerMode)>, $IHasConditionalAttributes {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
readonly "type": $ArmorItem$Type
readonly "material": $Holder<($ArmorMaterial)>
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)
constructor(material: $Holder$$Type<($ArmorMaterial)>, properties: $Item$Properties$$Type)

public "adjustAttributes"(event: $ItemAttributeModifierEvent$$Type): void
public "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public "getDefaultMode"(): $ItemFreeRunners$FreeRunnerMode
public "getModeDataType"(): $DataComponentType<($ItemFreeRunners$FreeRunnerMode)>
public "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
public "getBarWidth"(stack: $ItemStack$$Type): integer
public "getBarColor"(stack: $ItemStack$$Type): integer
public "isBarVisible"(stack: $ItemStack$$Type): boolean
public "canWalkOnPowderedSnow"(stack: $ItemStack$$Type, wearer: $LivingEntity$$Type): boolean
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
public "addItems"(tabOutput: $Consumer$$Type<($ItemStack)>): void
public "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void
public "addDefault"(): boolean
public "setMode"(stack: $ItemStack$$Type, player: $Player$$Type, mode: $ItemFreeRunners$FreeRunnerMode$$Type): void
public "getMode"(stack: $ItemStack$$Type): $ItemFreeRunners$FreeRunnerMode
public static "displayModeChange"(player: $Player$$Type): void
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
public "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
public static "get"(arg0: $ItemStack$$Type): $Equipable
get "defaultMode"(): $ItemFreeRunners$FreeRunnerMode
get "modeDataType"(): $DataComponentType<($ItemFreeRunners$FreeRunnerMode)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFreeRunners$$Type = ($ItemFreeRunners);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFreeRunners_ = $ItemFreeRunners$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.TripleInputRecipeCache" {
import {$AbstractInputRecipeCache, $AbstractInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.AbstractInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$InputIngredient, $InputIngredient$$Type} from "mekanism.api.recipes.ingredients.InputIngredient"
import {$IInputCache, $IInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.IInputCache"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TriPredicate, $TriPredicate$$Type} from "net.neoforged.neoforge.common.util.TriPredicate"

export class $TripleInputRecipeCache<INPUT_A, INGREDIENT_A extends $InputIngredient<(INPUT_A)>, INPUT_B, INGREDIENT_B extends $InputIngredient<(INPUT_B)>, INPUT_C, INGREDIENT_C extends $InputIngredient<(INPUT_C)>, RECIPE extends ($MekanismRecipe<(any)>) & ($TriPredicate<(INPUT_A), (INPUT_B), (INPUT_C)>), CACHE_A extends $IInputCache<(INPUT_A), (INGREDIENT_A), (RECIPE)>, CACHE_B extends $IInputCache<(INPUT_B), (INGREDIENT_B), (RECIPE)>, CACHE_C extends $IInputCache<(INPUT_C), (INGREDIENT_C), (RECIPE)>> extends $AbstractInputRecipeCache<(RECIPE)> {


public "clear"(): void
public "findFirstRecipe"(world: $Level$$Type, inputA: INPUT_A, inputB: INPUT_B, inputC: INPUT_C): RECIPE
public "containsInputCAB"(world: $Level$$Type, inputA: INPUT_A, inputB: INPUT_B, inputC: INPUT_C): boolean
public "containsInputABC"(world: $Level$$Type, inputA: INPUT_A, inputB: INPUT_B, inputC: INPUT_C): boolean
public "containsInputBAC"(world: $Level$$Type, inputA: INPUT_A, inputB: INPUT_B, inputC: INPUT_C): boolean
public "containsInputC"(world: $Level$$Type, input: INPUT_C): boolean
public "containsInputA"(world: $Level$$Type, input: INPUT_A): boolean
public "containsInputB"(world: $Level$$Type, input: INPUT_B): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TripleInputRecipeCache$$Type<INPUT_A, INGREDIENT_A, INPUT_B, INGREDIENT_B, INPUT_C, INGREDIENT_C, RECIPE, CACHE_A, CACHE_B, CACHE_C> = ($TripleInputRecipeCache<(INPUT_A), (INGREDIENT_A), (INPUT_B), (INGREDIENT_B), (INPUT_C), (INGREDIENT_C), (RECIPE), (CACHE_A), (CACHE_B), (CACHE_C)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TripleInputRecipeCache_<INPUT_A, INGREDIENT_A, INPUT_B, INGREDIENT_B, INPUT_C, INGREDIENT_C, RECIPE, CACHE_A, CACHE_B, CACHE_C> = $TripleInputRecipeCache$$Type<(INPUT_A), (INGREDIENT_A), (INPUT_B), (INGREDIENT_B), (INPUT_C), (INGREDIENT_C), (RECIPE), (CACHE_A), (CACHE_B), (CACHE_C)>;
}}
declare module "mekanism.common.tile.TileEntityChemicalTank$GasMode" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$IIncrementalEnum, $IIncrementalEnum$$Type} from "mekanism.api.IIncrementalEnum"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$IHasTextComponent$IHasEnumNameTextComponent, $IHasTextComponent$IHasEnumNameTextComponent$$Type} from "mekanism.api.text.IHasTextComponent$IHasEnumNameTextComponent"

export class $TileEntityChemicalTank$GasMode extends $Enum<($TileEntityChemicalTank$GasMode)> implements $IIncrementalEnum<($TileEntityChemicalTank$GasMode)>, $IHasTextComponent$IHasEnumNameTextComponent, $StringRepresentable {
static readonly "IDLE": $TileEntityChemicalTank$GasMode
static readonly "DUMPING_EXCESS": $TileEntityChemicalTank$GasMode
static readonly "DUMPING": $TileEntityChemicalTank$GasMode
static readonly "CODEC": $Codec<($TileEntityChemicalTank$GasMode)>
static readonly "BY_ID": $IntFunction<($TileEntityChemicalTank$GasMode)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($TileEntityChemicalTank$GasMode)>


public static "values"(): ($TileEntityChemicalTank$GasMode)[]
public static "valueOf"(name: string): $TileEntityChemicalTank$GasMode
public "byIndex"(index: integer): $TileEntityChemicalTank$GasMode
public "getSerializedName"(): string
public "getTextComponent"(): $Component
public "ordinal"(): integer
public "adjust"(arg0: integer): $TileEntityChemicalTank$GasMode
public "adjust"(arg0: integer, arg1: $Predicate$$Type<($TileEntityChemicalTank$GasMode)>): $TileEntityChemicalTank$GasMode
public "getNext"(arg0: $Predicate$$Type<($TileEntityChemicalTank$GasMode)>): $TileEntityChemicalTank$GasMode
public "getNext"(): $TileEntityChemicalTank$GasMode
public "getPrevious"(): $TileEntityChemicalTank$GasMode
public "getPrevious"(arg0: $Predicate$$Type<($TileEntityChemicalTank$GasMode)>): $TileEntityChemicalTank$GasMode
public "getTranslatedName"(): $Component
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "textComponent"(): $Component
get "next"(): $TileEntityChemicalTank$GasMode
get "previous"(): $TileEntityChemicalTank$GasMode
get "translatedName"(): $Component
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityChemicalTank$GasMode$$Type = (("idle") | ("dumping_excess") | ("dumping"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityChemicalTank$GasMode_ = $TileEntityChemicalTank$GasMode$$Type;
}}
declare module "mekanism.common.item.ItemNetworkReader" {
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$UseOnContext, $UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$ItemEnergized, $ItemEnergized$$Type} from "mekanism.common.item.ItemEnergized"

export class $ItemNetworkReader extends $ItemEnergized {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "useOn"(context: $UseOnContext$$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemNetworkReader$$Type = ($ItemNetworkReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemNetworkReader_ = $ItemNetworkReader$$Type;
}}
declare module "mekanism.common.resource.ore.BaseOreConfig" {
import {$OreAnchor, $OreAnchor$$Type} from "mekanism.common.resource.ore.OreAnchor"
import {$HeightShape, $HeightShape$$Type} from "mekanism.common.world.height.HeightShape"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $BaseOreConfig extends $Record {

constructor(name: string, perChunk: integer, discardChanceOnAirExposure: float, maxVeinSize: integer, shape: $HeightShape$$Type, min: $OreAnchor$$Type, max: $OreAnchor$$Type, plateau: integer)
constructor(name: string, perChunk: integer, discardChanceOnAirExposure: float, maxVeinSize: integer, shape: $HeightShape$$Type, min: $OreAnchor$$Type, max: $OreAnchor$$Type)

public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "min"(): $OreAnchor
public "max"(): $OreAnchor
public "shape"(): $HeightShape
public "maxVeinSize"(): integer
public "discardChanceOnAirExposure"(): float
public "plateau"(): integer
public "perChunk"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseOreConfig$$Type = ({"maxVeinSize"?: integer, "plateau"?: integer, "name"?: string, "perChunk"?: integer, "discardChanceOnAirExposure"?: float, "min"?: $OreAnchor$$Type, "shape"?: $HeightShape$$Type, "max"?: $OreAnchor$$Type}) | ([maxVeinSize?: integer, plateau?: integer, name?: string, perChunk?: integer, discardChanceOnAirExposure?: float, min?: $OreAnchor$$Type, shape?: $HeightShape$$Type, max?: $OreAnchor$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseOreConfig_ = $BaseOreConfig$$Type;
}}
declare module "mekanism.common.content.gear.IModuleItem" {
import {$ModuleData, $ModuleData$$Type} from "mekanism.api.gear.ModuleData"

export interface $IModuleItem {

 "getModuleData"(): $ModuleData<(any)>

(): $ModuleData$$Type<(any)>
get "moduleData"(): $ModuleData<(any)>
}

export namespace $IModuleItem {
const probejs$$marker: never
}
export class $IModuleItem$$Static implements $IModuleItem {


 "getModuleData"(): $ModuleData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModuleItem$$Type = (() => $ModuleData$$Type<(any)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModuleItem_ = $IModuleItem$$Type;
}}
declare module "mekanism.common.item.ItemConfigurationCard" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$UseOnContext, $UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"

export class $ItemConfigurationCard extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "use"(level: $Level$$Type, player: $Player$$Type, usedHand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$$Type): $InteractionResult
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "hasData"(stack: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemConfigurationCard$$Type = ($ItemConfigurationCard);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemConfigurationCard_ = $ItemConfigurationCard$$Type;
}}
declare module "mekanism.common.content.network.transmitter.Transmitter" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$ITileWrapper, $ITileWrapper$$Type} from "mekanism.common.tile.interfaces.ITileWrapper"
import {$CompatibleTransmitterValidator, $CompatibleTransmitterValidator$$Type} from "mekanism.common.lib.transmitter.CompatibleTransmitterValidator"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TransmissionType, $TransmissionType$$Type} from "mekanism.common.lib.transmitter.TransmissionType"
import {$DynamicNetwork, $DynamicNetwork$$Type} from "mekanism.common.lib.transmitter.DynamicNetwork"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$ConnectionType, $ConnectionType$$Type} from "mekanism.common.lib.transmitter.ConnectionType"
import {$TileEntityTransmitter, $TileEntityTransmitter$$Type} from "mekanism.common.tile.transmitter.TileEntityTransmitter"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AbstractAcceptorCache, $AbstractAcceptorCache$$Type} from "mekanism.common.lib.transmitter.acceptor.AbstractAcceptorCache"

export class $Transmitter<ACCEPTOR, NETWORK extends $DynamicNetwork<(ACCEPTOR), (NETWORK), (TRANSMITTER)>, TRANSMITTER extends $Transmitter<(ACCEPTOR), (NETWORK), (TRANSMITTER)>> implements $ITileWrapper {
 "currentTransmitterConnections": byte

constructor(transmitterTile: $TileEntityTransmitter$$Type, ...transmissionTypes: ($TransmissionType$$Type)[])

public "remove"(): void
public "write"(provider: $HolderLookup$Provider$$Type, nbtTags: $CompoundTag$$Type): $CompoundTag
public "read"(provider: $HolderLookup$Provider$$Type, nbtTags: $CompoundTag$$Type): void
public "isValid"(): boolean
public "getLevel"(): $Level
public "canConnect"(side: $Direction$$Type): boolean
public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
public "getConnectionType"(side: $Direction$$Type): $ConnectionType
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type, updateTag: $CompoundTag$$Type): $CompoundTag
public "onRightClick"(player: $Player$$Type, side: $Direction$$Type): $InteractionResult
public "isUpgrading"(): boolean
public "isRemote"(): boolean
public "setTransmitterNetwork"(network: NETWORK, requestNow: boolean): boolean
public "setTransmitterNetwork"(network: NETWORK): void
public "getAllCurrentConnections"(): byte
public "onNeighborBlockChange"(side: $Direction$$Type): void
public "validateAndTakeShare"(): void
public "getConnectionTypeRaw"(side: $Direction$$Type): $ConnectionType
public static "connectionMapContainsSide"(connections: byte, side: $Direction$$Type): boolean
public "setConnectionTypeRaw"(side: $Direction$$Type, type: $ConnectionType$$Type): void
public "createEmptyNetworkWithID"(networkID: $UUID$$Type): NETWORK
public "isValidTransmitterBasic"(transmitter: $TileEntityTransmitter$$Type, side: $Direction$$Type): boolean
public "getConnectionTypesRaw"(): ($ConnectionType)[]
public "setConnectionTypesRaw"(connectionTypes: ($ConnectionType$$Type)[]): void
public "getNewOrphanValidator"(): $CompatibleTransmitterValidator<(ACCEPTOR), (NETWORK), (TRANSMITTER)>
public "createNetworkByMerging"(toMerge: $Collection$$Type<(NETWORK)>): NETWORK
public "isRedstoneActivated"(): boolean
public "refreshAcceptorConnections"(side: $Direction$$Type): void
public "supportsTransmissionType"(transmitter: $Transmitter$$Type<(any), (any), (any)>): boolean
public "supportsTransmissionType"(transmitter: $TileEntityTransmitter$$Type): boolean
public "canConnectToAcceptor"(side: $Direction$$Type): boolean
public "takeShare"(): void
public "getPossibleAcceptorConnections"(): byte
public "getPossibleTransmitterConnections"(): byte
public "getSupportedTransmissionTypes"(): $Set<($TransmissionType)>
public "hasTransmitterNetwork"(): boolean
public "getTransmitterNetwork"(): NETWORK
public "getWorldPositionLong"(): long
public "getAcceptorCache"(): $AbstractAcceptorCache<(ACCEPTOR), (any)>
public "startUpgrading"(): void
public "refreshConnections"(side: $Direction$$Type): void
public "refreshConnections"(): void
public "notifyTileChange"(): void
public "onModeChange"(side: $Direction$$Type): void
public "getTransmitterTile"(): $TileEntityTransmitter
public "onConfigure"(player: $Player$$Type, side: $Direction$$Type): $InteractionResult
public "setOrphan"(nowOrphaned: boolean): void
public "isOrphan"(): boolean
public "getAcceptor"(side: $Direction$$Type): ACCEPTOR
public "isConnectionType"(side: $Direction$$Type, typeToCheck: $ConnectionType$$Type): boolean
public "canConnectMutual"(side: $Direction$$Type, cachedTile: $BlockEntity$$Type): boolean
public "canConnectMutual"(side: $Direction$$Type, cachedTransmitter: TRANSMITTER): boolean
public "requestsUpdate"(): void
public "handlesRedstone"(): boolean
public "markDirtyAcceptor"(side: $Direction$$Type): void
public "isValidTransmitter"(transmitter: $TileEntityTransmitter$$Type, side: $Direction$$Type): boolean
get "valid"(): boolean
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
get "upgrading"(): boolean
get "remote"(): boolean
set "transmitterNetwork"(value: NETWORK)
get "allCurrentConnections"(): byte
get "connectionTypesRaw"(): ($ConnectionType)[]
set "connectionTypesRaw"(value: ($ConnectionType$$Type)[])
get "newOrphanValidator"(): $CompatibleTransmitterValidator<(ACCEPTOR), (NETWORK), (TRANSMITTER)>
get "redstoneActivated"(): boolean
get "possibleAcceptorConnections"(): byte
get "possibleTransmitterConnections"(): byte
get "supportedTransmissionTypes"(): $Set<($TransmissionType)>
get "transmitterNetwork"(): NETWORK
get "worldPositionLong"(): long
get "acceptorCache"(): $AbstractAcceptorCache<(ACCEPTOR), (any)>
get "transmitterTile"(): $TileEntityTransmitter
set "orphan"(value: boolean)
get "orphan"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Transmitter$$Type<ACCEPTOR, NETWORK, TRANSMITTER> = ($Transmitter<(ACCEPTOR), (NETWORK), (TRANSMITTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Transmitter_<ACCEPTOR, NETWORK, TRANSMITTER> = $Transmitter$$Type<(ACCEPTOR), (NETWORK), (TRANSMITTER)>;
}}
declare module "mekanism.common.lib.frequency.FrequencyManagerWrapper$Type" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $FrequencyManagerWrapper$Type extends $Enum<($FrequencyManagerWrapper$Type)> {
static readonly "PUBLIC_ONLY": $FrequencyManagerWrapper$Type
static readonly "PRIVATE_ONLY": $FrequencyManagerWrapper$Type
static readonly "PUBLIC_PRIVATE_TRUSTED": $FrequencyManagerWrapper$Type


public static "values"(): ($FrequencyManagerWrapper$Type)[]
public static "valueOf"(name: string): $FrequencyManagerWrapper$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrequencyManagerWrapper$Type$$Type = (("public_only") | ("private_only") | ("public_private_trusted"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FrequencyManagerWrapper$Type_ = $FrequencyManagerWrapper$Type$$Type;
}}
declare module "mekanism.common.recipe.serializer.SawmillRecipeSerializer" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStackIngredient, $ItemStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ItemStackIngredient"
import {$BasicSawmillRecipe, $BasicSawmillRecipe$$Type} from "mekanism.api.recipes.basic.BasicSawmillRecipe"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Recipe, $Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"
import {$Function4, $Function4$$Type} from "com.mojang.datafixers.util.Function4"
import {$RecipeSerializer, $RecipeSerializer$$Type} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $SawmillRecipeSerializer implements $RecipeSerializer<($BasicSawmillRecipe)> {

constructor(factory: $Function4$$Type<($ItemStackIngredient$$Type), ($ItemStack$$Type), ($ItemStack$$Type), (double), ($BasicSawmillRecipe$$Type)>)

public "codec"(): $MapCodec<($BasicSawmillRecipe)>
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($BasicSawmillRecipe)>
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SawmillRecipeSerializer$$Type = ($SawmillRecipeSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SawmillRecipeSerializer_ = $SawmillRecipeSerializer$$Type;
}}
declare module "mekanism.common.resource.BlockResourceInfo" {
import {$MapColor, $MapColor$$Type} from "net.minecraft.world.level.material.MapColor"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$IResource, $IResource$$Type} from "mekanism.common.resource.IResource"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"

export class $BlockResourceInfo extends $Enum<($BlockResourceInfo)> implements $IResource {
static readonly "OSMIUM": $BlockResourceInfo
static readonly "RAW_OSMIUM": $BlockResourceInfo
static readonly "TIN": $BlockResourceInfo
static readonly "RAW_TIN": $BlockResourceInfo
static readonly "LEAD": $BlockResourceInfo
static readonly "RAW_LEAD": $BlockResourceInfo
static readonly "URANIUM": $BlockResourceInfo
static readonly "RAW_URANIUM": $BlockResourceInfo
static readonly "CHARCOAL": $BlockResourceInfo
static readonly "FLUORITE": $BlockResourceInfo
static readonly "BRONZE": $BlockResourceInfo
static readonly "STEEL": $BlockResourceInfo
static readonly "REFINED_OBSIDIAN": $BlockResourceInfo
static readonly "REFINED_GLOWSTONE": $BlockResourceInfo


public static "values"(): ($BlockResourceInfo)[]
public static "valueOf"(name: string): $BlockResourceInfo
public "isPortalFrame"(): boolean
public "getMapColor"(): $MapColor
public "getRegistrySuffix"(): string
public "burnsInFire"(): boolean
public "modifyProperties"(properties: $BlockBehaviour$Properties$$Type): $BlockBehaviour$Properties
get "portalFrame"(): boolean
get "mapColor"(): $MapColor
get "registrySuffix"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockResourceInfo$$Type = (("osmium") | ("raw_osmium") | ("tin") | ("raw_tin") | ("lead") | ("raw_lead") | ("uranium") | ("raw_uranium") | ("charcoal") | ("fluorite") | ("bronze") | ("steel") | ("refined_obsidian") | ("refined_glowstone"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockResourceInfo_ = $BlockResourceInfo$$Type;
}}
declare module "mekanism.common.tile.TileEntityBin" {
import {$IConfigurable, $IConfigurable$$Type} from "mekanism.api.IConfigurable"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$IUpgradeData, $IUpgradeData$$Type} from "mekanism.common.upgrade.IUpgradeData"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$BinInventorySlot, $BinInventorySlot$$Type} from "mekanism.common.inventory.slot.BinInventorySlot"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$BinUpgradeData, $BinUpgradeData$$Type} from "mekanism.common.upgrade.BinUpgradeData"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$BinTier, $BinTier$$Type} from "mekanism.common.tier.BinTier"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"

export class $TileEntityBin extends $TileEntityMekanism implements $IConfigurable {
 "addTicks": integer
 "removeTicks": integer
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getTier"(): $BinTier
public "setLocked"(isLocked: boolean): boolean
public "toggleLock"(): boolean
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "getBinSlot"(): $BinInventorySlot
public "onRightClick"(player: $Player$$Type): $InteractionResult
public "getUpgradeData"(provider: $HolderLookup$Provider$$Type): $BinUpgradeData
public "onContentsChanged"(): void
public "parseUpgradeData"(provider: $HolderLookup$Provider$$Type, upgradeData: $IUpgradeData$$Type): void
public "onSneakRightClick"(player: $Player$$Type): $InteractionResult
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "tier"(): $BinTier
set "locked"(value: boolean)
get "binSlot"(): $BinInventorySlot
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityBin$$Type = ($TileEntityBin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityBin_ = $TileEntityBin$$Type;
}}
declare module "mekanism.common.content.qio.IQIODriveItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"

export interface $IQIODriveItem {

 "getTypeCapacity"(stack: $ItemStack$$Type): integer
 "getCountCapacity"(stack: $ItemStack$$Type): long
}

export namespace $IQIODriveItem {
const probejs$$marker: never
}
export class $IQIODriveItem$$Static implements $IQIODriveItem {


 "getTypeCapacity"(stack: $ItemStack$$Type): integer
 "getCountCapacity"(stack: $ItemStack$$Type): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IQIODriveItem$$Type = ($IQIODriveItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IQIODriveItem_ = $IQIODriveItem$$Type;
}}
declare module "mekanism.common.block.states.IStateStorage" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IStateStorage {

}

export namespace $IStateStorage {
const probejs$$marker: never
}
export class $IStateStorage$$Static implements $IStateStorage {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IStateStorage$$Type = ($IStateStorage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IStateStorage_ = $IStateStorage$$Type;
}}
declare module "mekanism.common.item.block.ItemBlockCardboardBox" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BlockCardboardBox, $BlockCardboardBox$$Type} from "mekanism.common.block.BlockCardboardBox"
import {$ItemBlockMekanism, $ItemBlockMekanism$$Type} from "mekanism.common.item.block.ItemBlockMekanism"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$UseOnContext, $UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"

export class $ItemBlockCardboardBox extends $ItemBlockMekanism<($BlockCardboardBox)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockCardboardBox$$Type, properties: $Item$Properties$$Type)

public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "onItemUseFirst"(stack: $ItemStack$$Type, context: $UseOnContext$$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockCardboardBox$$Type = ($ItemBlockCardboardBox);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockCardboardBox_ = $ItemBlockCardboardBox$$Type;
}}
declare module "mekanism.common.tile.component.TileComponentEjector" {
import {$ISyncableData, $ISyncableData$$Type} from "mekanism.common.inventory.container.sync.ISyncableData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List, $List$$Type} from "java.util.List"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$TransmissionType, $TransmissionType$$Type} from "mekanism.common.lib.transmitter.TransmissionType"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$DataComponentMap$Builder, $DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$EnumColor, $EnumColor$$Type} from "mekanism.api.text.EnumColor"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IntSupplier, $IntSupplier$$Type} from "java.util.function.IntSupplier"
import {$LongSupplier, $LongSupplier$$Type} from "java.util.function.LongSupplier"
import {$ITileComponent, $ITileComponent$$Type} from "mekanism.common.tile.component.ITileComponent"
import {$BlockEntity$DataComponentInput, $BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$TileComponentConfig, $TileComponentConfig$$Type} from "mekanism.common.tile.component.TileComponentConfig"
import {$MekanismContainer$ISpecificContainerTracker, $MekanismContainer$ISpecificContainerTracker$$Type} from "mekanism.common.inventory.container.MekanismContainer$ISpecificContainerTracker"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$ConfigInfo, $ConfigInfo$$Type} from "mekanism.common.tile.component.config.ConfigInfo"
import {$RelativeSide, $RelativeSide$$Type} from "mekanism.api.RelativeSide"

export class $TileComponentEjector implements $ITileComponent, $MekanismContainer$ISpecificContainerTracker {

constructor(tile: $TileEntityMekanism$$Type, chemicalEjectRate: $LongSupplier$$Type, fluidEjectRate: $IntSupplier$$Type, energyEjectRate: $LongSupplier$$Type)
constructor(tile: $TileEntityMekanism$$Type, energyEjectRate: $LongSupplier$$Type, energyMarker: boolean)
constructor(tile: $TileEntityMekanism$$Type, chemicalEjectRate: $LongSupplier$$Type, fluidEjectRate: $IntSupplier$$Type)
constructor(tile: $TileEntityMekanism$$Type, chemicalEjectRate: $LongSupplier$$Type)
constructor(tile: $TileEntityMekanism$$Type)

public "deserialize"(ejectorNBT: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "serialize"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "applyImplicitComponents"(input: $BlockEntity$DataComponentInput$$Type): void
public "collectImplicitComponents"(builder: $DataComponentMap$Builder$$Type): void
public "tickServer"(): void
public "getSpecificSyncableData"(): $List<($ISyncableData)>
public "setOutputData"(config: $TileComponentConfig$$Type, ...types: ($TransmissionType$$Type)[]): $TileComponentEjector
public "setCanTankEject"(canTankEject: $Predicate$$Type<($IChemicalTank)>): $TileComponentEjector
public "setCanEject"(canEject: $Predicate$$Type<($TransmissionType)>): $TileComponentEjector
public "getComponentKey"(): string
public "isEjecting"(info: $ConfigInfo$$Type, type: $TransmissionType$$Type): boolean
public "isInputSideEnabled"(side: $RelativeSide$$Type): boolean
public "setStrictInput"(strict: boolean): void
public "hasStrictInput"(): boolean
public "getInputColor"(side: $RelativeSide$$Type): $EnumColor
public "getOutputColor"(): $EnumColor
public "setOutputColor"(color: $EnumColor$$Type): void
public "setInputColor"(side: $RelativeSide$$Type, color: $EnumColor$$Type): void
public "write"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "read"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "removed"(): void
public "invalidate"(): void
public "addToUpdateTag"(updateTag: $CompoundTag$$Type): void
public "readFromUpdateTag"(updateTag: $CompoundTag$$Type): void
public "trackForMainContainer"(container: $MekanismContainer$$Type): void
public "addRemapEntries"(remapEntries: $List$$Type<($DataComponentType$$Type<(any)>)>): void
get "specificSyncableData"(): $List<($ISyncableData)>
set "canTankEject"(value: $Predicate$$Type<($IChemicalTank)>)
set "canEject"(value: $Predicate$$Type<($TransmissionType)>)
get "componentKey"(): string
set "strictInput"(value: boolean)
get "outputColor"(): $EnumColor
set "outputColor"(value: $EnumColor$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileComponentEjector$$Type = ($TileComponentEjector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileComponentEjector_ = $TileComponentEjector$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.InputRecipeCache$SingleChemical" {
import {$ChemicalInputCache, $ChemicalInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.ChemicalInputCache"
import {$SingleInputRecipeCache, $SingleInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.SingleInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$ChemicalStackIngredient, $ChemicalStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ChemicalStackIngredient"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$MekanismRecipeType, $MekanismRecipeType$$Type} from "mekanism.common.recipe.MekanismRecipeType"

export class $InputRecipeCache$SingleChemical<RECIPE extends ($MekanismRecipe<(any)>) & ($Predicate<($ChemicalStack)>)> extends $SingleInputRecipeCache<($ChemicalStack), ($ChemicalStackIngredient), (RECIPE), ($ChemicalInputCache<(RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$$Type<(any), (RECIPE), (any)>, inputExtractor: $Function$$Type<(RECIPE), ($ChemicalStackIngredient$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$SingleChemical$$Type<RECIPE> = ($InputRecipeCache$SingleChemical<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$SingleChemical_<RECIPE> = $InputRecipeCache$SingleChemical$$Type<(RECIPE)>;
}}
declare module "mekanism.common.attachments.containers.creator.IContainerCreator" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IBasicContainerCreator, $IBasicContainerCreator$$Type} from "mekanism.common.attachments.containers.creator.IBasicContainerCreator"
import {$ContainerType, $ContainerType$$Type} from "mekanism.common.attachments.containers.ContainerType"
import {$INBTSerializable, $INBTSerializable$$Type} from "net.neoforged.neoforge.common.util.INBTSerializable"
import {$IAttachedContainers, $IAttachedContainers$$Type} from "mekanism.common.attachments.containers.IAttachedContainers"

export interface $IContainerCreator<CONTAINER extends $INBTSerializable<($CompoundTag)>, ATTACHED extends $IAttachedContainers<(any), (ATTACHED)>> extends $IBasicContainerCreator<(CONTAINER)> {

 "initStorage"(containers: integer): ATTACHED
 "totalContainers"(): integer
 "create"(containerType: $ContainerType$$Type<(CONTAINER), (any), (any)>, attachedTo: $ItemStack$$Type, containerIndex: integer): CONTAINER
}

export namespace $IContainerCreator {
const probejs$$marker: never
}
export class $IContainerCreator$$Static<CONTAINER extends $INBTSerializable<($CompoundTag)>, ATTACHED extends $IAttachedContainers<(any), (ATTACHED)>> implements $IContainerCreator {


 "initStorage"(containers: integer): ATTACHED
 "totalContainers"(): integer
 "create"(containerType: $ContainerType$$Type<(CONTAINER), (any), (any)>, attachedTo: $ItemStack$$Type, containerIndex: integer): CONTAINER
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IContainerCreator$$Type<CONTAINER, ATTACHED> = ($IContainerCreator<(CONTAINER), (ATTACHED)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IContainerCreator_<CONTAINER, ATTACHED> = $IContainerCreator$$Type<(CONTAINER), (ATTACHED)>;
}}
declare module "mekanism.common.item.gear.ItemScubaMask" {
import {$ArmorMaterial, $ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ItemAttributeModifiers, $ItemAttributeModifiers$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ItemSpecialArmor, $ItemSpecialArmor$$Type} from "mekanism.common.item.gear.ItemSpecialArmor"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Equipable, $Equipable$$Type} from "net.minecraft.world.item.Equipable"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior, $DispenseItemBehavior$$Type} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ItemScubaMask extends $ItemSpecialArmor {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
readonly "type": $ArmorItem$Type
readonly "material": $Holder<($ArmorMaterial)>
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public static "get"(arg0: $ItemStack$$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemScubaMask$$Type = ($ItemScubaMask);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemScubaMask_ = $ItemScubaMask$$Type;
}}
declare module "mekanism.common.lib.inventory.IAdvancedTransportEjector" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$$Type} from "mekanism.common.lib.inventory.TransitRequest$TransitResponse"
import {$TransitRequest, $TransitRequest$$Type} from "mekanism.common.lib.inventory.TransitRequest"
import {$SidedBlockPos, $SidedBlockPos$$Type} from "mekanism.common.lib.SidedBlockPos"
import {$TransporterPathfinder$Destination, $TransporterPathfinder$Destination$$Type} from "mekanism.common.content.transporter.TransporterPathfinder$Destination"

export interface $IAdvancedTransportEjector {

 "toggleRoundRobin"(): void
 "canSendHome"(stack: $ItemStack$$Type): boolean
 "getRoundRobin"(): boolean
 "sendHome"(request: $TransitRequest$$Type): $TransitRequest$TransitResponse
 "setRoundRobinTarget"(destination: $TransporterPathfinder$Destination$$Type): void
 "setRoundRobinTarget"(target: $SidedBlockPos$$Type): void
 "getRoundRobinTarget"(): $SidedBlockPos
get "roundRobin"(): boolean
set "roundRobinTarget"(value: $TransporterPathfinder$Destination$$Type)
set "roundRobinTarget"(value: $SidedBlockPos$$Type)
get "roundRobinTarget"(): $SidedBlockPos
}

export namespace $IAdvancedTransportEjector {
const probejs$$marker: never
}
export class $IAdvancedTransportEjector$$Static implements $IAdvancedTransportEjector {


 "toggleRoundRobin"(): void
 "canSendHome"(stack: $ItemStack$$Type): boolean
 "getRoundRobin"(): boolean
 "sendHome"(request: $TransitRequest$$Type): $TransitRequest$TransitResponse
 "setRoundRobinTarget"(destination: $TransporterPathfinder$Destination$$Type): void
 "setRoundRobinTarget"(target: $SidedBlockPos$$Type): void
 "getRoundRobinTarget"(): $SidedBlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAdvancedTransportEjector$$Type = ($IAdvancedTransportEjector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IAdvancedTransportEjector_ = $IAdvancedTransportEjector$$Type;
}}
declare module "mekanism.common.inventory.ISlotClickHandler" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ISlotClickHandler$IScrollableSlot, $ISlotClickHandler$IScrollableSlot$$Type} from "mekanism.common.inventory.ISlotClickHandler$IScrollableSlot"

export interface $ISlotClickHandler {

 "onClick"(slotProvider: $Supplier$$Type<($ISlotClickHandler$IScrollableSlot$$Type)>, button: integer, hasShiftDown: boolean, heldItem: $ItemStack$$Type): void

(slotProvider: $Supplier<($ISlotClickHandler$IScrollableSlot$$Type)>, button: integer, hasShiftDown: boolean, heldItem: $ItemStack): void
}

export namespace $ISlotClickHandler {
const probejs$$marker: never
}
export class $ISlotClickHandler$$Static implements $ISlotClickHandler {


 "onClick"(slotProvider: $Supplier$$Type<($ISlotClickHandler$IScrollableSlot$$Type)>, button: integer, hasShiftDown: boolean, heldItem: $ItemStack$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISlotClickHandler$$Type = ((slotProvider: $Supplier<($ISlotClickHandler$IScrollableSlot)>, button: integer, hasShiftDown: boolean, heldItem: $ItemStack) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISlotClickHandler_ = $ISlotClickHandler$$Type;
}}
declare module "mekanism.common.item.block.transmitter.ItemBlockLogisticalTransporter" {
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ItemBlockTransporter, $ItemBlockTransporter$$Type} from "mekanism.common.item.block.transmitter.ItemBlockTransporter"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$TileEntityLogisticalTransporter, $TileEntityLogisticalTransporter$$Type} from "mekanism.common.tile.transmitter.TileEntityLogisticalTransporter"
import {$BlockLargeTransmitter, $BlockLargeTransmitter$$Type} from "mekanism.common.block.transmitter.BlockLargeTransmitter"

export class $ItemBlockLogisticalTransporter extends $ItemBlockTransporter<($TileEntityLogisticalTransporter)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockLargeTransmitter$$Type<($TileEntityLogisticalTransporter$$Type)>, properties: $Item$Properties$$Type)

public "getTier"(): $ITier
get "tier"(): $ITier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockLogisticalTransporter$$Type = ($ItemBlockLogisticalTransporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockLogisticalTransporter_ = $ItemBlockLogisticalTransporter$$Type;
}}
declare module "mekanism.common.lib.transmitter.INetworkDataHandler" {
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $INetworkDataHandler {

 "getFlowInfo"(): $Component
 "getNeededInfo"(): $Component
 "getStoredInfo"(): $Component
 "getNetworkReaderCapacity"(): any
get "flowInfo"(): $Component
get "neededInfo"(): $Component
get "storedInfo"(): $Component
get "networkReaderCapacity"(): any
}

export namespace $INetworkDataHandler {
const probejs$$marker: never
}
export class $INetworkDataHandler$$Static implements $INetworkDataHandler {


 "getFlowInfo"(): $Component
 "getNeededInfo"(): $Component
 "getStoredInfo"(): $Component
 "getNetworkReaderCapacity"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $INetworkDataHandler$$Type = ($INetworkDataHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $INetworkDataHandler_ = $INetworkDataHandler$$Type;
}}
declare module "mekanism.common.block.prefab.BlockBasicMultiblock" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockBasicMultiblock<TILE extends $TileEntityMekanism> extends $BlockTile<(TILE), ($BlockTypeTile<(TILE)>)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(type: $BlockTypeTile$$Type<(TILE)>, propertiesModifier: $UnaryOperator$$Type<($BlockBehaviour$Properties)>)
constructor(type: $BlockTypeTile$$Type<(TILE)>, properties: $BlockBehaviour$Properties$$Type)

public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBasicMultiblock$$Type<TILE> = ($BlockBasicMultiblock<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBasicMultiblock_<TILE> = $BlockBasicMultiblock$$Type<(TILE)>;
}}
declare module "mekanism.common.inventory.container.SelectedWindowData$WindowType$ConfigSaveData" {
import {$IConfigTranslation, $IConfigTranslation$$Type} from "mekanism.common.config.IConfigTranslation"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$ModConfigSpec$Builder, $ModConfigSpec$Builder$$Type} from "net.neoforged.neoforge.common.ModConfigSpec$Builder"

export class $SelectedWindowData$WindowType$ConfigSaveData extends $Record implements $IConfigTranslation {

constructor(savePath: string, title: string, tooltip: string, button: string, getTranslationKey: string)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "savePath"(): string
public "title"(): string
public "button"(): string
public "tooltip"(): string
public "getTranslationKey"(): string
public "applyToBuilder"(builder: $ModConfigSpec$Builder$$Type): $ModConfigSpec$Builder
public static "getSectionTitle"(title: string, isSection: boolean): string
get "translationKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SelectedWindowData$WindowType$ConfigSaveData$$Type = ({"title"?: string, "tooltip"?: string, "savePath"?: string, "button"?: string, "getTranslationKey"?: string}) | ([title?: string, tooltip?: string, savePath?: string, button?: string, getTranslationKey?: string]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SelectedWindowData$WindowType$ConfigSaveData_ = $SelectedWindowData$WindowType$ConfigSaveData$$Type;
}}
declare module "mekanism.common.item.interfaces.IChemicalItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"

export interface $IChemicalItem {

 "useChemical"(stack: $ItemStack$$Type, amount: long): $ChemicalStack
 "hasChemical"(stack: $ItemStack$$Type): boolean
}

export namespace $IChemicalItem {
const probejs$$marker: never
}
export class $IChemicalItem$$Static implements $IChemicalItem {


 "useChemical"(stack: $ItemStack$$Type, amount: long): $ChemicalStack
 "hasChemical"(stack: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IChemicalItem$$Type = ($IChemicalItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IChemicalItem_ = $IChemicalItem$$Type;
}}
declare module "mekanism.common.config.value.CachedLongValue" {
import {$LongSupplier, $LongSupplier$$Type} from "java.util.function.LongSupplier"
import {$IMekanismConfig, $IMekanismConfig$$Type} from "mekanism.common.config.IMekanismConfig"
import {$ModConfigSpec$ConfigValue, $ModConfigSpec$ConfigValue$$Type} from "net.neoforged.neoforge.common.ModConfigSpec$ConfigValue"
import {$CachedValue, $CachedValue$$Type} from "mekanism.common.config.value.CachedValue"
import {$IConfigTranslation, $IConfigTranslation$$Type} from "mekanism.common.config.IConfigTranslation"
import {$ModConfigSpec$Builder, $ModConfigSpec$Builder$$Type} from "net.neoforged.neoforge.common.ModConfigSpec$Builder"

export class $CachedLongValue extends $CachedValue<(long)> implements $LongSupplier {


public "get"(): long
public static "wrap"(config: $IMekanismConfig$$Type, internal: $ModConfigSpec$ConfigValue$$Type<(long)>): $CachedLongValue
public "set"(value: long): void
public "getOrDefault"(): long
public "getAsLong"(): long
public static "define"(config: $IMekanismConfig$$Type, builder: $ModConfigSpec$Builder$$Type, comment: $IConfigTranslation$$Type, path: string, defaultValue: long, min: long, max: long): $CachedLongValue
public static "definedMin"(config: $IMekanismConfig$$Type, builder: $ModConfigSpec$Builder$$Type, comment: $IConfigTranslation$$Type, path: string, defaultValue: long, min: long): $CachedLongValue
public static "definePositive"(config: $IMekanismConfig$$Type, builder: $ModConfigSpec$Builder$$Type, comment: $IConfigTranslation$$Type, path: string, defaultValue: long): $CachedLongValue
get "orDefault"(): long
get "asLong"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedLongValue$$Type = ($CachedLongValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedLongValue_ = $CachedLongValue$$Type;
}}
declare module "mekanism.common.lib.chunkloading.IChunkLoader" {
import {$TileComponentChunkLoader, $TileComponentChunkLoader$$Type} from "mekanism.common.tile.component.TileComponentChunkLoader"
import {$Set, $Set$$Type} from "java.util.Set"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"

export interface $IChunkLoader {

 "getChunkSet"(): $Set<($ChunkPos)>
 "getChunkLoader"(): $TileComponentChunkLoader<(any)>
get "chunkSet"(): $Set<($ChunkPos)>
get "chunkLoader"(): $TileComponentChunkLoader<(any)>
}

export namespace $IChunkLoader {
const probejs$$marker: never
}
export class $IChunkLoader$$Static implements $IChunkLoader {


 "getChunkSet"(): $Set<($ChunkPos)>
 "getChunkLoader"(): $TileComponentChunkLoader<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IChunkLoader$$Type = ($IChunkLoader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IChunkLoader_ = $IChunkLoader$$Type;
}}
declare module "mekanism.common.inventory.slot.BasicInventorySlot" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$SlotOverlay, $SlotOverlay$$Type} from "mekanism.common.inventory.container.slot.SlotOverlay"
import {$ContainerSlotType, $ContainerSlotType$$Type} from "mekanism.common.inventory.container.slot.ContainerSlotType"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$ISupportsWarning, $ISupportsWarning$$Type} from "mekanism.common.inventory.warning.ISupportsWarning"

export class $BasicInventorySlot implements $IInventorySlot {
static readonly "alwaysTrue": $Predicate<($ItemStack)>
static readonly "alwaysFalse": $Predicate<($ItemStack)>
static readonly "alwaysTrueBi": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($ItemStack), ($AutomationType)>


public "isEmpty"(): boolean
public "getCount"(): integer
public static "at"(listener: $IContentsListener$$Type, x: integer, y: integer): $BasicInventorySlot
public static "at"(validator: $Predicate$$Type<($ItemStack)>, listener: $IContentsListener$$Type, x: integer, y: integer): $BasicInventorySlot
public static "at"(canExtract: $Predicate$$Type<($ItemStack)>, canInsert: $Predicate$$Type<($ItemStack)>, listener: $IContentsListener$$Type, x: integer, y: integer): $BasicInventorySlot
public static "at"(validator: $Predicate$$Type<($ItemStack)>, listener: $IContentsListener$$Type, x: integer, y: integer, limit: integer): $BasicInventorySlot
public static "at"(canExtract: $BiPredicate$$Type<($ItemStack), ($AutomationType)>, canInsert: $BiPredicate$$Type<($ItemStack), ($AutomationType)>, listener: $IContentsListener$$Type, x: integer, y: integer): $BasicInventorySlot
public static "at"(canExtract: $BiPredicate$$Type<($ItemStack), ($AutomationType)>, canInsert: $BiPredicate$$Type<($ItemStack), ($AutomationType)>, validator: $Predicate$$Type<($ItemStack)>, listener: $IContentsListener$$Type, x: integer, y: integer): $BasicInventorySlot
public "getStack"(): $ItemStack
public "getLimit"(stack: $ItemStack$$Type): integer
public "setStack"(stack: $ItemStack$$Type): void
public "extractItem"(amount: integer, action: $Action$$Type, automationType: $AutomationType$$Type): $ItemStack
public "isItemValid"(stack: $ItemStack$$Type): boolean
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $Tag$$Type): void
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $CompoundTag$$Type): void
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $Tag
public "setSlotType"(slotType: $ContainerSlotType$$Type): void
public "setStackSize"(amount: integer, action: $Action$$Type): integer
public "insertItem"(stack: $ItemStack$$Type, action: $Action$$Type, automationType: $AutomationType$$Type): $ItemStack
public "onContentsChanged"(): void
public "createContainerSlot"(): $Slot
public "tracksWarnings"(warningAdder: $Consumer$$Type<($ISupportsWarning<(any)>)>): void
public "setSlotOverlay"(slotOverlay: $SlotOverlay$$Type): void
public "setStackUnchecked"(stack: $ItemStack$$Type): void
public "growStack"(amount: integer, action: $Action$$Type): integer
public "isItemValidForInsertion"(stack: $ItemStack$$Type, automationType: $AutomationType$$Type): boolean
public "setEmpty"(): void
public "shrinkStack"(arg0: integer, arg1: $Action$$Type): integer
get "empty"(): boolean
get "count"(): integer
get "stack"(): $ItemStack
set "stack"(value: $ItemStack$$Type)
set "slotType"(value: $ContainerSlotType$$Type)
set "slotOverlay"(value: $SlotOverlay$$Type)
set "stackUnchecked"(value: $ItemStack$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicInventorySlot$$Type = ($BasicInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicInventorySlot_ = $BasicInventorySlot$$Type;
}}
declare module "mekanism.common.capabilities.fluid.item.FluidTankSpec" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$FluidTanksBuilder, $FluidTanksBuilder$$Type} from "mekanism.common.attachments.containers.fluid.FluidTanksBuilder"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IExtendedFluidTank, $IExtendedFluidTank$$Type} from "mekanism.api.fluid.IExtendedFluidTank"
import {$GenericTankSpec, $GenericTankSpec$$Type} from "mekanism.common.capabilities.GenericTankSpec"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$IntSupplier, $IntSupplier$$Type} from "java.util.function.IntSupplier"
import {$FluidTankSpec$ComponentTankFromSpecCreator, $FluidTankSpec$ComponentTankFromSpecCreator$$Type} from "mekanism.common.capabilities.fluid.item.FluidTankSpec$ComponentTankFromSpecCreator"
import {$FluidTankSpec$TankFromSpecCreator, $FluidTankSpec$TankFromSpecCreator$$Type} from "mekanism.common.capabilities.fluid.item.FluidTankSpec$TankFromSpecCreator"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$TriPredicate, $TriPredicate$$Type} from "net.neoforged.neoforge.common.util.TriPredicate"

export class $FluidTankSpec extends $GenericTankSpec<($FluidStack)> {
readonly "isValid": $Predicate<(TYPE)>
readonly "canExtract": $BiPredicate<(TYPE), ($AutomationType)>
readonly "canInsert": $TriPredicate<(TYPE), ($AutomationType), ($ItemStack)>

constructor(rate: $IntSupplier$$Type, capacity: $IntSupplier$$Type, canExtract: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, canInsert: $TriPredicate$$Type<($FluidStack), ($AutomationType), ($ItemStack)>, isValid: $Predicate$$Type<($FluidStack)>, supportsStack: $Predicate$$Type<($ItemStack)>)

public static "create"(rate: $IntSupplier$$Type, capacity: $IntSupplier$$Type): $FluidTankSpec
public "createTank"<TANK extends $IExtendedFluidTank>(tankCreator: $FluidTankSpec$TankFromSpecCreator$$Type<(TANK)>, stack: $ItemStack$$Type): TANK
public "addTank"(builder: $FluidTanksBuilder$$Type, tankCreator: $FluidTankSpec$ComponentTankFromSpecCreator$$Type): void
public static "createFillOnly"(rate: $IntSupplier$$Type, capacity: $IntSupplier$$Type, isValid: $Predicate$$Type<($FluidStack)>): $FluidTankSpec
public static "createFillOnly"(rate: $IntSupplier$$Type, capacity: $IntSupplier$$Type, isValid: $Predicate$$Type<($FluidStack)>, supportsStack: $Predicate$$Type<($ItemStack)>): $FluidTankSpec
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankSpec$$Type = ($FluidTankSpec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTankSpec_ = $FluidTankSpec$$Type;
}}
declare module "mekanism.common.inventory.GuiComponents$IToggleEnum" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $GuiComponents$IToggleEnum<TYPE extends ($Enum<(TYPE)>) & ($GuiComponents$IToggleEnum<(TYPE)>)> {

 "getIcon"(): $ResourceLocation
 "getTooltip"(): $Component
get "icon"(): $ResourceLocation
get "tooltip"(): $Component
}

export namespace $GuiComponents$IToggleEnum {
const probejs$$marker: never
}
export class $GuiComponents$IToggleEnum$$Static<TYPE extends ($Enum<(TYPE)>) & ($GuiComponents$IToggleEnum<(TYPE)>)> implements $GuiComponents$IToggleEnum {


 "getIcon"(): $ResourceLocation
 "getTooltip"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiComponents$IToggleEnum$$Type<TYPE> = ($GuiComponents$IToggleEnum<(TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiComponents$IToggleEnum_<TYPE> = $GuiComponents$IToggleEnum$$Type<(TYPE)>;
}}
declare module "mekanism.common.attachments.containers.heat.HeatCapacitorData" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $HeatCapacitorData extends $Record {
static readonly "CODEC": $Codec<($HeatCapacitorData)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($HeatCapacitorData)>

constructor(heat: double, capacity: double)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "capacity"(): double
public "withHeat"(heat: double): $HeatCapacitorData
public "heat"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeatCapacitorData$$Type = ({"heat"?: double, "capacity"?: double}) | ([heat?: double, capacity?: double]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeatCapacitorData_ = $HeatCapacitorData$$Type;
}}
declare module "mekanism.common.content.network.InventoryNetwork$AcceptorData" {
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$$Type} from "mekanism.common.lib.inventory.TransitRequest$TransitResponse"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Set, $Set$$Type} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $InventoryNetwork$AcceptorData {


public "getLocation"(): $BlockPos
public "getSides"(): $Set<($Direction)>
public "getResponse"(): $TransitRequest$TransitResponse
get "location"(): $BlockPos
get "sides"(): $Set<($Direction)>
get "response"(): $TransitRequest$TransitResponse
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryNetwork$AcceptorData$$Type = ($InventoryNetwork$AcceptorData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryNetwork$AcceptorData_ = $InventoryNetwork$AcceptorData$$Type;
}}
declare module "mekanism.common.inventory.warning.WarningTracker$WarningType" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $WarningTracker$WarningType extends $Enum<($WarningTracker$WarningType)> {
static readonly "INPUT_DOESNT_PRODUCE_OUTPUT": $WarningTracker$WarningType
static readonly "NO_MATCHING_RECIPE": $WarningTracker$WarningType
static readonly "NO_SPACE_IN_OUTPUT": $WarningTracker$WarningType
static readonly "NO_SPACE_IN_OUTPUT_OVERFLOW": $WarningTracker$WarningType
static readonly "NOT_ENOUGH_ENERGY": $WarningTracker$WarningType
static readonly "NOT_ENOUGH_ENERGY_REDUCED_RATE": $WarningTracker$WarningType
static readonly "INVALID_OREDICTIONIFICATOR_FILTER": $WarningTracker$WarningType
static readonly "FILTER_HAS_BLACKLISTED_ELEMENT": $WarningTracker$WarningType


public static "values"(): ($WarningTracker$WarningType)[]
public static "valueOf"(name: string): $WarningTracker$WarningType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WarningTracker$WarningType$$Type = (("input_doesnt_produce_output") | ("no_matching_recipe") | ("no_space_in_output") | ("no_space_in_output_overflow") | ("not_enough_energy") | ("not_enough_energy_reduced_rate") | ("invalid_oredictionificator_filter") | ("filter_has_blacklisted_element"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WarningTracker$WarningType_ = $WarningTracker$WarningType$$Type;
}}
declare module "mekanism.common.content.qio.QIOCraftingTransferHelper$SingularHashedItemSource" {
import {$UUID, $UUID$$Type} from "java.util.UUID"

export class $QIOCraftingTransferHelper$SingularHashedItemSource {

constructor(qioSource: $UUID$$Type, used: integer)
constructor(slot: byte, used: integer)

public "getSlot"(): byte
public "getUsed"(): integer
public "setUsed"(used: integer): void
public "getQioSource"(): $UUID
get "slot"(): byte
get "used"(): integer
set "used"(value: integer)
get "qioSource"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOCraftingTransferHelper$SingularHashedItemSource$$Type = ($QIOCraftingTransferHelper$SingularHashedItemSource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOCraftingTransferHelper$SingularHashedItemSource_ = $QIOCraftingTransferHelper$SingularHashedItemSource$$Type;
}}
declare module "mekanism.common.tile.transmitter.TileEntityTransmitter" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IConfigurable, $IConfigurable$$Type} from "mekanism.api.IConfigurable"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$AlloyTier, $AlloyTier$$Type} from "mekanism.api.tier.AlloyTier"
import {$IAlloyInteraction, $IAlloyInteraction$$Type} from "mekanism.api.IAlloyInteraction"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ConnectionType, $ConnectionType$$Type} from "mekanism.common.lib.transmitter.ConnectionType"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$ModelData, $ModelData$$Type} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$TransmitterModelData, $TransmitterModelData$$Type} from "mekanism.client.model.data.TransmitterModelData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ProxyConfigurable$ISidedConfigurable, $ProxyConfigurable$ISidedConfigurable$$Type} from "mekanism.common.capabilities.proxy.ProxyConfigurable$ISidedConfigurable"
import {$TransmitterType, $TransmitterType$$Type} from "mekanism.common.block.states.TransmitterType"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ModelProperty, $ModelProperty$$Type} from "net.neoforged.neoforge.client.model.data.ModelProperty"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$Transmitter, $Transmitter$$Type} from "mekanism.common.content.network.transmitter.Transmitter"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"

export class $TileEntityTransmitter extends $CapabilityTileEntity implements $ProxyConfigurable$ISidedConfigurable, $IAlloyInteraction {
static readonly "CONFIGURABLE_PROVIDER": $ICapabilityProvider<($TileEntityTransmitter), ($Direction), ($IConfigurable)>
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "isLoaded"(): boolean
public "setLevel"(level: $Level$$Type): void
public "saveAdditional"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "onChunkUnloaded"(): void
public "clearRemoved"(): void
public "loadAdditional"(nbt: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "sideChanged"(side: $Direction$$Type, old: $ConnectionType$$Type, type: $ConnectionType$$Type): void
public "setRemoved"(): void
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public static "tickServer"(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, transmitter: $TileEntityTransmitter$$Type): void
public "getModelData"(): $ModelData
public "onRightClick"(player: $Player$$Type, side: $Direction$$Type): $InteractionResult
public "onAdded"(): void
public "chunkAccessibilityChange"(loaded: boolean): void
public "onNeighborBlockChange"(side: $Direction$$Type): void
public "handleUpdatePacket"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getTransmitter"(): $Transmitter<(any), (any), (any)>
public "redstoneChanged"(powered: boolean): void
public "getTransmitterType"(): $TransmitterType
public "getSideLookingAt"(player: $Player$$Type, fallback: $Direction$$Type): $Direction
public "getSideLookingAt"(player: $Player$$Type): $Direction
public "getCollisionBoxes"(): $List<($VoxelShape)>
public "setForceUpdate"(): void
public "onSneakRightClick"(player: $Player$$Type, side: $Direction$$Type): $InteractionResult
public "onAlloyInteraction"(player: $Player$$Type, stack: $ItemStack$$Type, tier: $AlloyTier$$Type): void
public "onRightClick"(player: $Player$$Type): $InteractionResult
public "onSneakRightClick"(player: $Player$$Type): $InteractionResult
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
get "loaded"(): boolean
set "level"(value: $Level$$Type)
get "modelData"(): $ModelData
get "transmitter"(): $Transmitter<(any), (any), (any)>
get "transmitterType"(): $TransmitterType
get "collisionBoxes"(): $List<($VoxelShape)>
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityTransmitter$$Type = ($TileEntityTransmitter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityTransmitter_ = $TileEntityTransmitter$$Type;
}}
declare module "mekanism.common.lib.security.ISecurityTile" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$TileComponentSecurity, $TileComponentSecurity$$Type} from "mekanism.common.tile.component.TileComponentSecurity"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$ISecurityObject, $ISecurityObject$$Type} from "mekanism.api.security.ISecurityObject"
import {$SecurityMode, $SecurityMode$$Type} from "mekanism.api.security.SecurityMode"

export interface $ISecurityTile extends $ISecurityObject {

 "hasSecurity"(): boolean
 "setOwnerUUID"(owner: $UUID$$Type): void
 "getOwnerUUID"(): $UUID
 "getOwnerName"(): string
 "setSecurityMode"(mode: $SecurityMode$$Type): void
 "getSecurityMode"(): $SecurityMode
 "getSecurity"(): $TileComponentSecurity
 "onSecurityChanged"(arg0: $SecurityMode$$Type, arg1: $SecurityMode$$Type): void
 "ownerMatches"(arg0: $Player$$Type): boolean

(): $TileComponentSecurity$$Type
set "ownerUUID"(value: $UUID$$Type)
get "ownerUUID"(): $UUID
get "ownerName"(): string
set "securityMode"(value: $SecurityMode$$Type)
get "securityMode"(): $SecurityMode
get "security"(): $TileComponentSecurity
}

export namespace $ISecurityTile {
const probejs$$marker: never
}
export class $ISecurityTile$$Static implements $ISecurityTile {


 "hasSecurity"(): boolean
 "setOwnerUUID"(owner: $UUID$$Type): void
 "getOwnerUUID"(): $UUID
 "getOwnerName"(): string
 "setSecurityMode"(mode: $SecurityMode$$Type): void
 "getSecurityMode"(): $SecurityMode
 "getSecurity"(): $TileComponentSecurity
 "onSecurityChanged"(arg0: $SecurityMode$$Type, arg1: $SecurityMode$$Type): void
 "ownerMatches"(arg0: $Player$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISecurityTile$$Type = (() => $TileComponentSecurity$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISecurityTile_ = $ISecurityTile$$Type;
}}
declare module "mekanism.common.item.block.ItemBlockPersonalStorage" {
import {$PersonalStorageItemContainer, $PersonalStorageItemContainer$$Type} from "mekanism.common.inventory.container.item.PersonalStorageItemContainer"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ContainerTypeRegistryObject, $ContainerTypeRegistryObject$$Type} from "mekanism.common.registration.impl.ContainerTypeRegistryObject"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$IGuiItem, $IGuiItem$$Type} from "mekanism.common.item.interfaces.IGuiItem"
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BlockPersonalStorage, $BlockPersonalStorage$$Type} from "mekanism.common.block.BlockPersonalStorage"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$IDroppableContents, $IDroppableContents$$Type} from "mekanism.common.item.interfaces.IDroppableContents"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$UseOnContext, $UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"

export class $ItemBlockPersonalStorage<BLOCK extends $BlockPersonalStorage<(any), (any)>> extends $ItemBlockTooltip<(BLOCK)> implements $IDroppableContents, $IGuiItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: BLOCK, properties: $Item$Properties$$Type, openStat: $ResourceLocation$$Type)

public "use"(world: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "onDestroyed"(item: $ItemEntity$$Type, damageSource: $DamageSource$$Type): void
public "useOn"(context: $UseOnContext$$Type): $InteractionResult
public "getScalar"(stack: $ItemStack$$Type): integer
public "getDroppedSlots"(stack: $ItemStack$$Type): $List<($IInventorySlot)>
public "getContainerType"(): $ContainerTypeRegistryObject<($PersonalStorageItemContainer)>
public "canContentsDrop"(stack: $ItemStack$$Type): boolean
get "containerType"(): $ContainerTypeRegistryObject<($PersonalStorageItemContainer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockPersonalStorage$$Type<BLOCK> = ($ItemBlockPersonalStorage<(BLOCK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockPersonalStorage_<BLOCK> = $ItemBlockPersonalStorage$$Type<(BLOCK)>;
}}
declare module "mekanism.common.block.prefab.BlockFactoryMachine$BlockFactoryMachineModel" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$BlockFactoryMachine, $BlockFactoryMachine$$Type} from "mekanism.common.block.prefab.BlockFactoryMachine"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IStateFluidLoggable, $IStateFluidLoggable$$Type} from "mekanism.common.block.states.IStateFluidLoggable"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$Machine$FactoryMachine, $Machine$FactoryMachine$$Type} from "mekanism.common.content.blocktype.Machine$FactoryMachine"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IFluidLogType, $IFluidLogType$$Type} from "mekanism.common.block.states.IFluidLogType"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$EnumProperty, $EnumProperty$$Type} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor, $LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $BlockFactoryMachine$BlockFactoryMachineModel<TILE extends $TileEntityMekanism, MACHINE extends $Machine$FactoryMachine<(TILE)>> extends $BlockFactoryMachine<(TILE), (MACHINE)> implements $IStateFluidLoggable {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(machineType: MACHINE, propertiesModifier: $UnaryOperator$$Type<($BlockBehaviour$Properties)>)

public "setState"(state: $BlockState$$Type, fluid: $Fluid$$Type): $BlockState
public "isValidFluid"(fluid: $Fluid$$Type): boolean
public "canPlaceLiquid"(player: $Player$$Type, world: $BlockGetter$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluid: $Fluid$$Type): boolean
public "getPickupSound"(state: $BlockState$$Type): $Optional<($SoundEvent)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "pickupBlock"(player: $Player$$Type, world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type): $ItemStack
public "placeLiquid"(world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluidState: $FluidState$$Type): boolean
public "getFluid"(state: $BlockState$$Type): $FluidState
public "getFluidLightLevel"(state: $BlockState$$Type): integer
public "updateFluids"(state: $BlockState$$Type, world: $LevelAccessor$$Type, currentPos: $BlockPos$$Type): void
public "getFluidLoggedProperty"(): $EnumProperty<($IFluidLogType)>
public "asHolder"(): $Holder<(any)>
get "pickupSound"(): $Optional<($SoundEvent)>
get "fluidLoggedProperty"(): $EnumProperty<($IFluidLogType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockFactoryMachine$BlockFactoryMachineModel$$Type<TILE, MACHINE> = ($BlockFactoryMachine$BlockFactoryMachineModel<(TILE), (MACHINE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockFactoryMachine$BlockFactoryMachineModel_<TILE, MACHINE> = $BlockFactoryMachine$BlockFactoryMachineModel$$Type<(TILE), (MACHINE)>;
}}
declare module "mekanism.common.block.states.TransmitterType$Size" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $TransmitterType$Size extends $Enum<($TransmitterType$Size)> {
static readonly "SMALL": $TransmitterType$Size
static readonly "LARGE": $TransmitterType$Size
readonly "centerSize": integer


public static "values"(): ($TransmitterType$Size)[]
public static "valueOf"(name: string): $TransmitterType$Size
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransmitterType$Size$$Type = (("small") | ("large"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransmitterType$Size_ = $TransmitterType$Size$$Type;
}}
declare module "mekanism.common.lib.math.voxel.VoxelPlane" {
import {$Structure$Axis, $Structure$Axis$$Type} from "mekanism.common.lib.multiblock.Structure$Axis"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $VoxelPlane {

constructor(axis: $Structure$Axis$$Type, pos: $BlockPos$$Type, frame: boolean)

public "size"(): integer
public "equals"(obj: any): boolean
public "length"(): integer
public "toString"(): string
public "hashCode"(): integer
public "merge"(other: $VoxelPlane$$Type): void
public "isFull"(): boolean
public "height"(): integer
public "getAxis"(): $Structure$Axis
public "hasFrame"(): boolean
public "getMinCol"(): integer
public "getMaxCol"(): integer
public "getMaxRow"(): integer
public "getMinRow"(): integer
public "isOutside"(pos: $BlockPos$$Type): boolean
public "getMissing"(): integer
get "full"(): boolean
get "axis"(): $Structure$Axis
get "minCol"(): integer
get "maxCol"(): integer
get "maxRow"(): integer
get "minRow"(): integer
get "missing"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VoxelPlane$$Type = ($VoxelPlane);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VoxelPlane_ = $VoxelPlane$$Type;
}}
declare module "mekanism.common.lib.transmitter.acceptor.AcceptorCache$CacheBasedInfo" {
import {$AcceptorInfo, $AcceptorInfo$$Type} from "mekanism.common.lib.transmitter.acceptor.AcceptorInfo"
import {$BlockCapabilityCache, $BlockCapabilityCache$$Type} from "net.neoforged.neoforge.capabilities.BlockCapabilityCache"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $AcceptorCache$CacheBasedInfo<ACCEPTOR> extends $Record implements $AcceptorInfo<(ACCEPTOR)> {

constructor(cache: $BlockCapabilityCache$$Type<(ACCEPTOR), ($Direction$$Type)>)

public "cache"(): $BlockCapabilityCache<(ACCEPTOR), ($Direction)>
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "acceptor"(): ACCEPTOR
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AcceptorCache$CacheBasedInfo$$Type<ACCEPTOR> = ({"cache"?: $BlockCapabilityCache$$Type<(never), ($Direction$$Type)>}) | ([cache?: $BlockCapabilityCache$$Type<(never), ($Direction$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AcceptorCache$CacheBasedInfo_<ACCEPTOR> = $AcceptorCache$CacheBasedInfo$$Type<(ACCEPTOR)>;
}}
declare module "mekanism.common.item.interfaces.IHasConditionalAttributes" {
import {$ItemAttributeModifierEvent, $ItemAttributeModifierEvent$$Type} from "net.neoforged.neoforge.event.ItemAttributeModifierEvent"

export interface $IHasConditionalAttributes {

 "adjustAttributes"(event: $ItemAttributeModifierEvent$$Type): void

(event: $ItemAttributeModifierEvent): void
}

export namespace $IHasConditionalAttributes {
const probejs$$marker: never
}
export class $IHasConditionalAttributes$$Static implements $IHasConditionalAttributes {


 "adjustAttributes"(event: $ItemAttributeModifierEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHasConditionalAttributes$$Type = ((event: $ItemAttributeModifierEvent) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHasConditionalAttributes_ = $IHasConditionalAttributes$$Type;
}}
declare module "mekanism.common.lib.frequency.IColorableFrequency" {
import {$EnumColor, $EnumColor$$Type} from "mekanism.api.text.EnumColor"

export interface $IColorableFrequency {

 "setColor"(color: $EnumColor$$Type): void
 "getColor"(): $EnumColor
set "color"(value: $EnumColor$$Type)
get "color"(): $EnumColor
}

export namespace $IColorableFrequency {
const probejs$$marker: never
}
export class $IColorableFrequency$$Static implements $IColorableFrequency {


 "setColor"(color: $EnumColor$$Type): void
 "getColor"(): $EnumColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IColorableFrequency$$Type = ($IColorableFrequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IColorableFrequency_ = $IColorableFrequency$$Type;
}}
declare module "mekanism.common.block.prefab.BlockBase$BlockBaseModel" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BlockBase, $BlockBase$$Type} from "mekanism.common.block.prefab.BlockBase"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IStateFluidLoggable, $IStateFluidLoggable$$Type} from "mekanism.common.block.states.IStateFluidLoggable"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockType, $BlockType$$Type} from "mekanism.common.content.blocktype.BlockType"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IFluidLogType, $IFluidLogType$$Type} from "mekanism.common.block.states.IFluidLogType"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$EnumProperty, $EnumProperty$$Type} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor, $LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $BlockBase$BlockBaseModel<BLOCK extends $BlockType> extends $BlockBase<(BLOCK)> implements $IStateFluidLoggable {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(blockType: BLOCK, propertyModifier: $UnaryOperator$$Type<($BlockBehaviour$Properties)>)
constructor(blockType: BLOCK, properties: $BlockBehaviour$Properties$$Type)

public "setState"(state: $BlockState$$Type, fluid: $Fluid$$Type): $BlockState
public "isValidFluid"(fluid: $Fluid$$Type): boolean
public "canPlaceLiquid"(player: $Player$$Type, world: $BlockGetter$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluid: $Fluid$$Type): boolean
public "getPickupSound"(state: $BlockState$$Type): $Optional<($SoundEvent)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "pickupBlock"(player: $Player$$Type, world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type): $ItemStack
public "placeLiquid"(world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluidState: $FluidState$$Type): boolean
public "getFluid"(state: $BlockState$$Type): $FluidState
public "getFluidLightLevel"(state: $BlockState$$Type): integer
public "updateFluids"(state: $BlockState$$Type, world: $LevelAccessor$$Type, currentPos: $BlockPos$$Type): void
public "getFluidLoggedProperty"(): $EnumProperty<($IFluidLogType)>
public "asHolder"(): $Holder<(any)>
get "pickupSound"(): $Optional<($SoundEvent)>
get "fluidLoggedProperty"(): $EnumProperty<($IFluidLogType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBase$BlockBaseModel$$Type<BLOCK> = ($BlockBase$BlockBaseModel<(BLOCK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBase$BlockBaseModel_<BLOCK> = $BlockBase$BlockBaseModel$$Type<(BLOCK)>;
}}
declare module "mekanism.common.lib.inventory.TransitRequest$ItemData" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$HashedItem, $HashedItem$$Type} from "mekanism.common.lib.inventory.HashedItem"

export class $TransitRequest$ItemData {

constructor(itemType: $HashedItem$$Type)

public "equals"(o: any): boolean
public "hashCode"(): integer
public "use"(amount: integer): $ItemStack
public "getStack"(): $ItemStack
public "getTotalCount"(): integer
public "getItemType"(): $HashedItem
get "stack"(): $ItemStack
get "totalCount"(): integer
get "itemType"(): $HashedItem
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransitRequest$ItemData$$Type = ($TransitRequest$ItemData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransitRequest$ItemData_ = $TransitRequest$ItemData$$Type;
}}
declare module "mekanism.common.content.filter.BaseFilter" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$FilterType, $FilterType$$Type} from "mekanism.common.content.filter.FilterType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$IFilter, $IFilter$$Type} from "mekanism.common.content.filter.IFilter"

export class $BaseFilter<FILTER extends $BaseFilter<(FILTER)>> implements $IFilter<(FILTER)> {
static readonly "GENERIC_CODEC": $Codec<($IFilter<(any)>)>
static readonly "GENERIC_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IFilter<(any)>)>


public "equals"(o: any): boolean
public "hashCode"(): integer
public "clone"(): any
public "isEnabled"(): boolean
public static "fromType"(filterType: $FilterType$$Type): $IFilter<(any)>
public "setEnabled"(enabled: boolean): void
public "hasFilter"(): boolean
public "getFilterType"(): $FilterType
get "enabled"(): boolean
set "enabled"(value: boolean)
get "filterType"(): $FilterType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseFilter$$Type<FILTER> = ($BaseFilter<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseFilter_<FILTER> = $BaseFilter$$Type<(FILTER)>;
}}
declare module "mekanism.common.recipe.lookup.cache.EitherSideInputRecipeCache" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$AbstractInputRecipeCache, $AbstractInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.AbstractInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$InputIngredient, $InputIngredient$$Type} from "mekanism.api.recipes.ingredients.InputIngredient"
import {$IInputCache, $IInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.IInputCache"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"

export class $EitherSideInputRecipeCache<INPUT, INGREDIENT extends $InputIngredient<(INPUT)>, RECIPE extends ($MekanismRecipe<(any)>) & ($BiPredicate<(INPUT), (INPUT)>), CACHE extends $IInputCache<(INPUT), (INGREDIENT), (RECIPE)>> extends $AbstractInputRecipeCache<(RECIPE)> {


public "clear"(): void
public "containsInput"(world: $Level$$Type, input: INPUT): boolean
public "containsInput"(world: $Level$$Type, inputA: INPUT, inputB: INPUT): boolean
public "findFirstRecipe"(world: $Level$$Type, inputA: INPUT, inputB: INPUT): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EitherSideInputRecipeCache$$Type<INPUT, INGREDIENT, RECIPE, CACHE> = ($EitherSideInputRecipeCache<(INPUT), (INGREDIENT), (RECIPE), (CACHE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EitherSideInputRecipeCache_<INPUT, INGREDIENT, RECIPE, CACHE> = $EitherSideInputRecipeCache$$Type<(INPUT), (INGREDIENT), (RECIPE), (CACHE)>;
}}
declare module "mekanism.common.item.interfaces.IColoredItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$FrequencyAware, $FrequencyAware$$Type} from "mekanism.common.attachments.FrequencyAware"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"

export interface $IColoredItem {

 "getFrequencyComponent"(): $DataComponentType<($FrequencyAware<(any)>)>
 "syncColorWithFrequency"<FREQ extends $Frequency>(stack: $ItemStack$$Type): void
get "frequencyComponent"(): $DataComponentType<($FrequencyAware<(any)>)>
}

export namespace $IColoredItem {
const probejs$$marker: never
}
export class $IColoredItem$$Static implements $IColoredItem {


 "getFrequencyComponent"(): $DataComponentType<($FrequencyAware<(any)>)>
 "syncColorWithFrequency"<FREQ extends $Frequency>(stack: $ItemStack$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IColoredItem$$Type = ($IColoredItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IColoredItem_ = $IColoredItem$$Type;
}}
declare module "mekanism.common.item.ItemDictionary" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$UseOnContext, $UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $ItemDictionary extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "use"(world: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "useOn"(context: $UseOnContext$$Type): $InteractionResult
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "interactLivingEntity"(stack: $ItemStack$$Type, player: $Player$$Type, entity: $LivingEntity$$Type, hand: $InteractionHand$$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDictionary$$Type = ($ItemDictionary);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDictionary_ = $ItemDictionary$$Type;
}}
declare module "mekanism.common.item.ItemQIODrive" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$IQIODriveItem, $IQIODriveItem$$Type} from "mekanism.common.content.qio.IQIODriveItem"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$QIODriveTier, $QIODriveTier$$Type} from "mekanism.common.tier.QIODriveTier"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemQIODrive extends $Item implements $IQIODriveItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(tier: $QIODriveTier$$Type, properties: $Item$Properties$$Type)

public "getName"(stack: $ItemStack$$Type): $Component
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "getTypeCapacity"(stack: $ItemStack$$Type): integer
public "getCountCapacity"(stack: $ItemStack$$Type): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemQIODrive$$Type = ($ItemQIODrive);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemQIODrive_ = $ItemQIODrive$$Type;
}}
declare module "mekanism.common.config.value.CachedValue$IConfigValueInvalidationListener" {
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"

export interface $CachedValue$IConfigValueInvalidationListener extends $Runnable {

 "run"(): void

(): void
}

export namespace $CachedValue$IConfigValueInvalidationListener {
const probejs$$marker: never
}
export class $CachedValue$IConfigValueInvalidationListener$$Static implements $CachedValue$IConfigValueInvalidationListener {


 "run"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedValue$IConfigValueInvalidationListener$$Type = (() => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedValue$IConfigValueInvalidationListener_ = $CachedValue$IConfigValueInvalidationListener$$Type;
}}
declare module "mekanism.common.block.BlockBounding" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IStateFluidLoggable, $IStateFluidLoggable$$Type} from "mekanism.common.block.states.IStateFluidLoggable"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IHasTileEntity, $IHasTileEntity$$Type} from "mekanism.common.block.interfaces.IHasTileEntity"
import {$LevelReader, $LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Explosion, $Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$$Type} from "mekanism.common.registration.impl.TileEntityTypeRegistryObject"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener, $GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$TileEntityBoundingBlock, $TileEntityBoundingBlock$$Type} from "mekanism.common.tile.TileEntityBoundingBlock"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BlockEntityTicker, $BlockEntityTicker$$Type} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HitResult, $HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IFluidLogType, $IFluidLogType$$Type} from "mekanism.common.block.states.IFluidLogType"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$EnumProperty, $EnumProperty$$Type} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor, $LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $BlockBounding extends $Block implements $IHasTileEntity<($TileEntityBoundingBlock)>, $IStateFluidLoggable {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor()

public "getCloneItemStack"(state: $BlockState$$Type, target: $HitResult$$Type, world: $LevelReader$$Type, pos: $BlockPos$$Type, player: $Player$$Type): $ItemStack
public "playerWillDestroy"(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, player: $Player$$Type): $BlockState
public "playerDestroy"(world: $Level$$Type, player: $Player$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, te: $BlockEntity$$Type, stack: $ItemStack$$Type): void
public "getStateForPlacement"(context: $BlockPlaceContext$$Type): $BlockState
public "getExplosionResistance"(state: $BlockState$$Type, world: $BlockGetter$$Type, pos: $BlockPos$$Type, explosion: $Explosion$$Type): float
public "onDestroyedByPlayer"(state: $BlockState$$Type, world: $Level$$Type, pos: $BlockPos$$Type, player: $Player$$Type, willHarvest: boolean, fluidState: $FluidState$$Type): boolean
public "getTileType"(): $TileEntityTypeRegistryObject<($TileEntityBoundingBlock)>
public static "getMainBlockPos"(world: $BlockGetter$$Type, thisPos: $BlockPos$$Type): $BlockPos
public "getTicker"<T extends $BlockEntity>(level: $Level$$Type, state: $BlockState$$Type, blockEntityType: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(pos: $BlockPos$$Type, state: $BlockState$$Type): $TileEntityBoundingBlock
public "triggerBlockEntityEvent"(state: $BlockState$$Type, level: $Level$$Type, pos: $BlockPos$$Type, id: integer, param: integer): boolean
public "setState"(state: $BlockState$$Type, fluid: $Fluid$$Type): $BlockState
public "isValidFluid"(fluid: $Fluid$$Type): boolean
public "canPlaceLiquid"(player: $Player$$Type, world: $BlockGetter$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluid: $Fluid$$Type): boolean
public "getPickupSound"(state: $BlockState$$Type): $Optional<($SoundEvent)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "pickupBlock"(player: $Player$$Type, world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type): $ItemStack
public "placeLiquid"(world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluidState: $FluidState$$Type): boolean
public "getFluid"(state: $BlockState$$Type): $FluidState
public "getFluidLightLevel"(state: $BlockState$$Type): integer
public "updateFluids"(state: $BlockState$$Type, world: $LevelAccessor$$Type, currentPos: $BlockPos$$Type): void
public "getFluidLoggedProperty"(): $EnumProperty<($IFluidLogType)>
public "asHolder"(): $Holder<(any)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
get "tileType"(): $TileEntityTypeRegistryObject<($TileEntityBoundingBlock)>
get "pickupSound"(): $Optional<($SoundEvent)>
get "fluidLoggedProperty"(): $EnumProperty<($IFluidLogType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBounding$$Type = ($BlockBounding);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBounding_ = $BlockBounding$$Type;
}}
declare module "mekanism.common.inventory.slot.IFluidHandlerSlot" {
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$IFluidContainerManager$ContainerEditMode, $IFluidContainerManager$ContainerEditMode$$Type} from "mekanism.common.tile.interfaces.IFluidContainerManager$ContainerEditMode"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IExtendedFluidTank, $IExtendedFluidTank$$Type} from "mekanism.api.fluid.IExtendedFluidTank"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export interface $IFluidHandlerSlot extends $IInventorySlot {

 "setDraining"(draining: boolean): void
 "getFluidTank"(): $IExtendedFluidTank
 "isDraining"(): boolean
 "isFilling"(): boolean
 "setFilling"(filling: boolean): void
 "handleTank"(outputSlot: $IInventorySlot$$Type, editMode: $IFluidContainerManager$ContainerEditMode$$Type): void
 "fillTank"(outputSlot: $IInventorySlot$$Type): void
 "fillTank"(): boolean
 "drainTank"(outputSlot: $IInventorySlot$$Type): void
 "isEmpty"(): boolean
 "getCount"(): integer
 "getStack"(): $ItemStack
 "getLimit"(arg0: $ItemStack$$Type): integer
 "setStack"(arg0: $ItemStack$$Type): void
 "setEmpty"(): void
 "extractItem"(arg0: integer, arg1: $Action$$Type, arg2: $AutomationType$$Type): $ItemStack
 "isItemValid"(arg0: $ItemStack$$Type): boolean
 "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
 "setStackSize"(arg0: integer, arg1: $Action$$Type): integer
 "insertItem"(arg0: $ItemStack$$Type, arg1: $Action$$Type, arg2: $AutomationType$$Type): $ItemStack
 "shrinkStack"(arg0: integer, arg1: $Action$$Type): integer
 "createContainerSlot"(): $Slot
 "growStack"(arg0: integer, arg1: $Action$$Type): integer
 "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): void
 "onContentsChanged"(): void
set "draining"(value: boolean)
get "fluidTank"(): $IExtendedFluidTank
get "draining"(): boolean
get "filling"(): boolean
set "filling"(value: boolean)
get "empty"(): boolean
get "count"(): integer
get "stack"(): $ItemStack
set "stack"(value: $ItemStack$$Type)
}

export namespace $IFluidHandlerSlot {
const probejs$$marker: never
}
export class $IFluidHandlerSlot$$Static implements $IFluidHandlerSlot {


 "setDraining"(draining: boolean): void
 "getFluidTank"(): $IExtendedFluidTank
 "isDraining"(): boolean
 "isFilling"(): boolean
 "setFilling"(filling: boolean): void
 "handleTank"(outputSlot: $IInventorySlot$$Type, editMode: $IFluidContainerManager$ContainerEditMode$$Type): void
 "fillTank"(outputSlot: $IInventorySlot$$Type): void
 "fillTank"(): boolean
 "drainTank"(outputSlot: $IInventorySlot$$Type): void
 "isEmpty"(): boolean
 "getCount"(): integer
 "getStack"(): $ItemStack
 "getLimit"(arg0: $ItemStack$$Type): integer
 "setStack"(arg0: $ItemStack$$Type): void
 "setEmpty"(): void
 "extractItem"(arg0: integer, arg1: $Action$$Type, arg2: $AutomationType$$Type): $ItemStack
 "isItemValid"(arg0: $ItemStack$$Type): boolean
 "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
 "setStackSize"(arg0: integer, arg1: $Action$$Type): integer
 "insertItem"(arg0: $ItemStack$$Type, arg1: $Action$$Type, arg2: $AutomationType$$Type): $ItemStack
 "shrinkStack"(arg0: integer, arg1: $Action$$Type): integer
 "createContainerSlot"(): $Slot
 "growStack"(arg0: integer, arg1: $Action$$Type): integer
 "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): void
 "onContentsChanged"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFluidHandlerSlot$$Type = ($IFluidHandlerSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFluidHandlerSlot_ = $IFluidHandlerSlot$$Type;
}}
declare module "mekanism.common.item.ItemRobit" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent, $RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$UseOnContext, $UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ItemEnergized, $ItemEnergized$$Type} from "mekanism.common.item.ItemEnergized"
import {$ICapabilityAware, $ICapabilityAware$$Type} from "mekanism.common.capabilities.ICapabilityAware"

export class $ItemRobit extends $ItemEnergized implements $ICapabilityAware {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "onDestroyed"(item: $ItemEntity$$Type, damageSource: $DamageSource$$Type): void
public "useOn"(context: $UseOnContext$$Type): $InteractionResult
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "inventoryTick"(stack: $ItemStack$$Type, level: $Level$$Type, entity: $Entity$$Type, slot: integer, isSelected: boolean): void
public "attachCapabilities"(event: $RegisterCapabilitiesEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemRobit$$Type = ($ItemRobit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemRobit_ = $ItemRobit$$Type;
}}
declare module "mekanism.common.tile.TileEntityChargepad" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityChargepad extends $TileEntityMekanism {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(pos: $BlockPos$$Type, state: $BlockState$$Type)

public "setActive"(active: boolean): void
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
set "active"(value: boolean)
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityChargepad$$Type = ($TileEntityChargepad);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityChargepad_ = $TileEntityChargepad$$Type;
}}
declare module "mekanism.common.attachments.containers.creator.IBasicContainerCreator" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ContainerType, $ContainerType$$Type} from "mekanism.common.attachments.containers.ContainerType"
import {$INBTSerializable, $INBTSerializable$$Type} from "net.neoforged.neoforge.common.util.INBTSerializable"

export interface $IBasicContainerCreator<CONTAINER extends $INBTSerializable<($CompoundTag)>> {

 "create"(containerType: $ContainerType$$Type<(CONTAINER), (any), (any)>, attachedTo: $ItemStack$$Type, containerIndex: integer): CONTAINER

(containerType: $ContainerType<(CONTAINER), (any), (any)>, attachedTo: $ItemStack, containerIndex: integer): CONTAINER
}

export namespace $IBasicContainerCreator {
const probejs$$marker: never
}
export class $IBasicContainerCreator$$Static<CONTAINER extends $INBTSerializable<($CompoundTag)>> implements $IBasicContainerCreator {


 "create"(containerType: $ContainerType$$Type<(CONTAINER), (any), (any)>, attachedTo: $ItemStack$$Type, containerIndex: integer): CONTAINER
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IBasicContainerCreator$$Type<CONTAINER> = ((containerType: $ContainerType<(CONTAINER), (any), (any)>, attachedTo: $ItemStack, containerIndex: integer) => CONTAINER);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IBasicContainerCreator_<CONTAINER> = $IBasicContainerCreator$$Type<(CONTAINER)>;
}}
declare module "mekanism.common.tile.TileEntityCardboardBox" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TileEntityUpdateable, $TileEntityUpdateable$$Type} from "mekanism.common.tile.base.TileEntityUpdateable"
import {$List, $List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityCardboardBox extends $TileEntityUpdateable {
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(pos: $BlockPos$$Type, state: $BlockState$$Type)

public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "getRemapEntries"(): $List<($DataComponentType<(any)>)>
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
get "remapEntries"(): $List<($DataComponentType<(any)>)>
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityCardboardBox$$Type = ($TileEntityCardboardBox);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityCardboardBox_ = $TileEntityCardboardBox$$Type;
}}
declare module "mekanism.common.item.gear.ItemFreeRunners$FreeRunnerMode" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$IIncrementalEnum, $IIncrementalEnum$$Type} from "mekanism.api.IIncrementalEnum"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$IHasTextComponent$IHasEnumNameTextComponent, $IHasTextComponent$IHasEnumNameTextComponent$$Type} from "mekanism.api.text.IHasTextComponent$IHasEnumNameTextComponent"

export class $ItemFreeRunners$FreeRunnerMode extends $Enum<($ItemFreeRunners$FreeRunnerMode)> implements $IIncrementalEnum<($ItemFreeRunners$FreeRunnerMode)>, $IHasTextComponent$IHasEnumNameTextComponent, $StringRepresentable {
static readonly "NORMAL": $ItemFreeRunners$FreeRunnerMode
static readonly "SAFETY": $ItemFreeRunners$FreeRunnerMode
static readonly "DISABLED": $ItemFreeRunners$FreeRunnerMode
static readonly "CODEC": $Codec<($ItemFreeRunners$FreeRunnerMode)>
static readonly "BY_ID": $IntFunction<($ItemFreeRunners$FreeRunnerMode)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($ItemFreeRunners$FreeRunnerMode)>


public static "values"(): ($ItemFreeRunners$FreeRunnerMode)[]
public static "valueOf"(name: string): $ItemFreeRunners$FreeRunnerMode
public "byIndex"(index: integer): $ItemFreeRunners$FreeRunnerMode
public "getSerializedName"(): string
public "getTextComponent"(): $Component
public "preventsFallDamage"(): boolean
public "providesStepBoost"(): boolean
public "ordinal"(): integer
public "adjust"(arg0: integer): $ItemFreeRunners$FreeRunnerMode
public "adjust"(arg0: integer, arg1: $Predicate$$Type<($ItemFreeRunners$FreeRunnerMode)>): $ItemFreeRunners$FreeRunnerMode
public "getNext"(arg0: $Predicate$$Type<($ItemFreeRunners$FreeRunnerMode)>): $ItemFreeRunners$FreeRunnerMode
public "getNext"(): $ItemFreeRunners$FreeRunnerMode
public "getPrevious"(): $ItemFreeRunners$FreeRunnerMode
public "getPrevious"(arg0: $Predicate$$Type<($ItemFreeRunners$FreeRunnerMode)>): $ItemFreeRunners$FreeRunnerMode
public "getTranslatedName"(): $Component
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "textComponent"(): $Component
get "next"(): $ItemFreeRunners$FreeRunnerMode
get "previous"(): $ItemFreeRunners$FreeRunnerMode
get "translatedName"(): $Component
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFreeRunners$FreeRunnerMode$$Type = (("normal") | ("safety") | ("disabled"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFreeRunners$FreeRunnerMode_ = $ItemFreeRunners$FreeRunnerMode$$Type;
}}
declare module "mekanism.common.tier.ChemicalTankTier" {
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BaseTier, $BaseTier$$Type} from "mekanism.api.tier.BaseTier"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$CachedLongValue, $CachedLongValue$$Type} from "mekanism.common.config.value.CachedLongValue"

export class $ChemicalTankTier extends $Enum<($ChemicalTankTier)> implements $ITier, $StringRepresentable {
static readonly "BASIC": $ChemicalTankTier
static readonly "ADVANCED": $ChemicalTankTier
static readonly "ELITE": $ChemicalTankTier
static readonly "ULTIMATE": $ChemicalTankTier
static readonly "CREATIVE": $ChemicalTankTier


public static "values"(): ($ChemicalTankTier)[]
public static "valueOf"(name: string): $ChemicalTankTier
public "getOutput"(): long
public "getSerializedName"(): string
public "getStorage"(): long
public "getBaseStorage"(): long
public "getBaseOutput"(): long
public "getBaseTier"(): $BaseTier
public "setConfigReference"(storageReference: $CachedLongValue$$Type, outputReference: $CachedLongValue$$Type): void
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "output"(): long
get "serializedName"(): string
get "storage"(): long
get "baseStorage"(): long
get "baseOutput"(): long
get "baseTier"(): $BaseTier
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalTankTier$$Type = (("basic") | ("advanced") | ("elite") | ("ultimate") | ("creative"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalTankTier_ = $ChemicalTankTier$$Type;
}}
declare module "mekanism.common.capabilities.merged.MergedTank" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IExtendedFluidTank, $IExtendedFluidTank$$Type} from "mekanism.api.fluid.IExtendedFluidTank"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$MergedTank$CurrentType, $MergedTank$CurrentType$$Type} from "mekanism.common.capabilities.merged.MergedTank$CurrentType"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $MergedTank {


public static "create"(fluidTank: $IExtendedFluidTank$$Type, gasTank: $IChemicalTank$$Type): $MergedTank
public "getChemicalTank"(): $IChemicalTank
public "getFluidTank"(): $IExtendedFluidTank
public "addToUpdateTag"(provider: $HolderLookup$Provider$$Type, updateTag: $CompoundTag$$Type): void
public "readFromUpdateTag"(provider: $HolderLookup$Provider$$Type, tag: $CompoundTag$$Type): void
public "getCurrentType"(): $MergedTank$CurrentType
get "chemicalTank"(): $IChemicalTank
get "fluidTank"(): $IExtendedFluidTank
get "currentType"(): $MergedTank$CurrentType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MergedTank$$Type = ($MergedTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MergedTank_ = $MergedTank$$Type;
}}
declare module "mekanism.common.capabilities.GenericTankSpec" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$TriPredicate, $TriPredicate$$Type} from "net.neoforged.neoforge.common.util.TriPredicate"

export class $GenericTankSpec<TYPE> {
readonly "isValid": $Predicate<(TYPE)>
readonly "canExtract": $BiPredicate<(TYPE), ($AutomationType)>
readonly "canInsert": $TriPredicate<(TYPE), ($AutomationType), ($ItemStack)>


public "supportsStack"(stack: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenericTankSpec$$Type<TYPE> = ($GenericTankSpec<(TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenericTankSpec_<TYPE> = $GenericTankSpec$$Type<(TYPE)>;
}}
declare module "mekanism.common.content.gear.IModuleContainerItem" {
import {$IHasConditionalAttributes, $IHasConditionalAttributes$$Type} from "mekanism.common.item.interfaces.IHasConditionalAttributes"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$List, $List$$Type} from "java.util.List"
import {$IItemHUDProvider, $IItemHUDProvider$$Type} from "mekanism.common.item.interfaces.IItemHUDProvider"
import {$ItemAttributeModifierEvent, $ItemAttributeModifierEvent$$Type} from "net.neoforged.neoforge.event.ItemAttributeModifierEvent"
import {$IModeItem, $IModeItem$$Type} from "mekanism.common.item.interfaces.IModeItem"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$IModule, $IModule$$Type} from "mekanism.api.gear.IModule"
import {$IModuleDataProvider, $IModuleDataProvider$$Type} from "mekanism.api.providers.IModuleDataProvider"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IModuleContainer, $IModuleContainer$$Type} from "mekanism.api.gear.IModuleContainer"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ICustomModule, $ICustomModule$$Type} from "mekanism.api.gear.ICustomModule"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"

export interface $IModuleContainerItem extends $IModeItem, $IItemHUDProvider, $IHasConditionalAttributes {

 "getModules"(stack: $ItemStack$$Type): $Collection<($IModule<(any)>)>
 "adjustAttributes"(event: $ItemAttributeModifierEvent$$Type): void
 "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
 "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
 "hasModule"(stack: $ItemStack$$Type, type: $IModuleDataProvider$$Type<(any)>): boolean
 "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
 "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
 "isModuleEnabled"(stack: $ItemStack$$Type, type: $IModuleDataProvider$$Type<(any)>): boolean
 "addModuleDetails"(stack: $ItemStack$$Type, tooltip: $List$$Type<($Component$$Type)>): void
 "getEnabledModule"<MODULE extends $ICustomModule<(MODULE)>>(stack: $ItemStack$$Type, typeProvider: $IModuleDataProvider$$Type<(MODULE)>): $IModule<(MODULE)>
 "moduleContainer"(stack: $ItemStack$$Type): $IModuleContainer
 "hasInstalledModules"(stack: $ItemStack$$Type): boolean
 "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void
}

export namespace $IModuleContainerItem {
function displayModeChange(player: $Player$$Type): void
function isModeItem(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
function isModeItem(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
const probejs$$marker: never
}
export class $IModuleContainerItem$$Static implements $IModuleContainerItem {


 "getModules"(stack: $ItemStack$$Type): $Collection<($IModule<(any)>)>
 "adjustAttributes"(event: $ItemAttributeModifierEvent$$Type): void
 "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
 "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
 "hasModule"(stack: $ItemStack$$Type, type: $IModuleDataProvider$$Type<(any)>): boolean
 "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
 "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
 "isModuleEnabled"(stack: $ItemStack$$Type, type: $IModuleDataProvider$$Type<(any)>): boolean
 "addModuleDetails"(stack: $ItemStack$$Type, tooltip: $List$$Type<($Component$$Type)>): void
 "getEnabledModule"<MODULE extends $ICustomModule<(MODULE)>>(stack: $ItemStack$$Type, typeProvider: $IModuleDataProvider$$Type<(MODULE)>): $IModule<(MODULE)>
 "moduleContainer"(stack: $ItemStack$$Type): $IModuleContainer
 "hasInstalledModules"(stack: $ItemStack$$Type): boolean
static "displayModeChange"(player: $Player$$Type): void
static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
 "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModuleContainerItem$$Type = ($IModuleContainerItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModuleContainerItem_ = $IModuleContainerItem$$Type;
}}
declare module "mekanism.common.lib.frequency.IdentitySerializer" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$$Type} from "mekanism.common.lib.frequency.Frequency$FrequencyIdentity"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"

export interface $IdentitySerializer {

 "codec"(): $Codec<($Frequency$FrequencyIdentity)>
 "streamCodec"(): $StreamCodec<($ByteBuf), ($Frequency$FrequencyIdentity)>
}

export namespace $IdentitySerializer {
const NAME: $IdentitySerializer
const UUID: $IdentitySerializer
const probejs$$marker: never
}
export class $IdentitySerializer$$Static implements $IdentitySerializer {
static readonly "NAME": $IdentitySerializer
static readonly "UUID": $IdentitySerializer


 "codec"(): $Codec<($Frequency$FrequencyIdentity)>
 "streamCodec"(): $StreamCodec<($ByteBuf), ($Frequency$FrequencyIdentity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdentitySerializer$$Type = ($IdentitySerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdentitySerializer_ = $IdentitySerializer$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.type.FluidInputCache" {
import {$FluidStackIngredient, $FluidStackIngredient$$Type} from "mekanism.api.recipes.ingredients.FluidStackIngredient"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ComponentSensitiveInputCache, $ComponentSensitiveInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.ComponentSensitiveInputCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$InputIngredient, $InputIngredient$$Type} from "mekanism.api.recipes.ingredients.InputIngredient"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"

export class $FluidInputCache<RECIPE extends $MekanismRecipe<(any)>> extends $ComponentSensitiveInputCache<($Fluid), ($FluidStack), ($FluidStackIngredient), (RECIPE)> {

constructor()

public "isEmpty"(input: any): boolean
public "isEmpty"(input: $FluidStack$$Type): boolean
public "mapInputs"(recipe: RECIPE, inputIngredient: $FluidStackIngredient$$Type): boolean
public "mapInputs"(recipe: $MekanismRecipe$$Type<(any)>, inputIngredient: $InputIngredient$$Type<(any)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidInputCache$$Type<RECIPE> = ($FluidInputCache<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidInputCache_<RECIPE> = $FluidInputCache$$Type<(RECIPE)>;
}}
declare module "mekanism.common.item.block.transmitter.ItemBlockTransporter" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ILangEntry, $ILangEntry$$Type} from "mekanism.api.text.ILangEntry"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$TileEntityLogisticalTransporterBase, $TileEntityLogisticalTransporterBase$$Type} from "mekanism.common.tile.transmitter.TileEntityLogisticalTransporterBase"
import {$BlockLargeTransmitter, $BlockLargeTransmitter$$Type} from "mekanism.common.block.transmitter.BlockLargeTransmitter"

export class $ItemBlockTransporter<TILE extends $TileEntityLogisticalTransporterBase> extends $ItemBlockTooltip<($BlockLargeTransmitter<(TILE)>)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockLargeTransmitter$$Type<(TILE)>, properties: $Item$Properties$$Type)
constructor(block: $BlockLargeTransmitter$$Type<(TILE)>, properties: $Item$Properties$$Type, extraDetails: $ILangEntry$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockTransporter$$Type<TILE> = ($ItemBlockTransporter<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockTransporter_<TILE> = $ItemBlockTransporter$$Type<(TILE)>;
}}
declare module "mekanism.common.tile.TileEntityQuantumEntangloporter" {
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TransmissionType, $TransmissionType$$Type} from "mekanism.common.lib.transmitter.TransmissionType"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$ContainerType, $ContainerType$$Type} from "mekanism.common.attachments.containers.ContainerType"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$TileComponentConfig, $TileComponentConfig$$Type} from "mekanism.common.tile.component.TileComponentConfig"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IChemicalTankHolder, $IChemicalTankHolder$$Type} from "mekanism.common.capabilities.holder.chemical.IChemicalTankHolder"
import {$TileComponentEjector, $TileComponentEjector$$Type} from "mekanism.common.tile.component.TileComponentEjector"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$TileComponentChunkLoader, $TileComponentChunkLoader$$Type} from "mekanism.common.tile.component.TileComponentChunkLoader"
import {$InventoryFrequency, $InventoryFrequency$$Type} from "mekanism.common.content.entangloporter.InventoryFrequency"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$TileEntityConfigurableMachine, $TileEntityConfigurableMachine$$Type} from "mekanism.common.tile.prefab.TileEntityConfigurableMachine"
import {$IChunkLoader, $IChunkLoader$$Type} from "mekanism.common.lib.chunkloading.IChunkLoader"

export class $TileEntityQuantumEntangloporter extends $TileEntityConfigurableMachine implements $IChunkLoader {
 "ejectorComponent": $TileComponentEjector
readonly "configComponent": $TileComponentConfig
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(pos: $BlockPos$$Type, state: $BlockState$$Type)

public "hasFrequency"(): boolean
public "getAdjacent"(side: $Direction$$Type): $IHeatHandler
public "shouldDumpRadiation"(): boolean
public "getInitialChemicalTanks"(listener: $IContentsListener$$Type): $IChemicalTankHolder
public "addContainerTrackers"(container: $MekanismContainer$$Type): void
public "getChunkSet"(): $Set<($ChunkPos)>
public "persists"(type: $ContainerType$$Type<(any), (any), (any)>): boolean
public "getChunkLoader"(): $TileComponentChunkLoader<($TileEntityQuantumEntangloporter)>
public "getFreq"(): $InventoryFrequency
public "getLastEnvironmentLoss"(): double
public "getLastTransferLoss"(): double
public "getCachedCapability"<HANDLER>(side: $Direction$$Type, transmissionType: $TransmissionType$$Type): HANDLER
public "getDirection"(): $Direction
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "chunkSet"(): $Set<($ChunkPos)>
get "chunkLoader"(): $TileComponentChunkLoader<($TileEntityQuantumEntangloporter)>
get "freq"(): $InventoryFrequency
get "lastEnvironmentLoss"(): double
get "lastTransferLoss"(): double
get "direction"(): $Direction
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityQuantumEntangloporter$$Type = ($TileEntityQuantumEntangloporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityQuantumEntangloporter_ = $TileEntityQuantumEntangloporter$$Type;
}}
declare module "mekanism.common.tile.TileEntitySecurityDesk" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$SecurityFrequency, $SecurityFrequency$$Type} from "mekanism.common.lib.security.SecurityFrequency"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$SecurityMode, $SecurityMode$$Type} from "mekanism.api.security.SecurityMode"
import {$IBoundingBlock, $IBoundingBlock$$Type} from "mekanism.common.tile.interfaces.IBoundingBlock"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3i, $Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntitySecurityDesk extends $TileEntityMekanism implements $IBoundingBlock {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(pos: $BlockPos$$Type, state: $BlockState$$Type)

public "toggleOverride"(): void
public "removeTrusted"(index: integer): void
public "addTrusted"(name: string): void
public "getFreq"(): $SecurityFrequency
public "setSecurityDeskMode"(mode: $SecurityMode$$Type): void
public "getBoundingComparatorSignal"(offset: $Vec3i$$Type): integer
public "getOffsetCapabilityIfEnabled"<T>(capability: $BlockCapability$$Type<(T), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): T
public "isOffsetCapabilityDisabled"(capability: $BlockCapability$$Type<(any), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): boolean
public "triggerBoundingEvent"(offset: $Vec3i$$Type, id: integer, param: integer): boolean
public "onBoundingBlockPowerChange"(boundingPos: $BlockPos$$Type, oldLevel: integer, newLevel: integer): void
public "getOffsetCapability"<T>(capability: $BlockCapability$$Type<(T), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): T
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "freq"(): $SecurityFrequency
set "securityDeskMode"(value: $SecurityMode$$Type)
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntitySecurityDesk$$Type = ($TileEntitySecurityDesk);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntitySecurityDesk_ = $TileEntitySecurityDesk$$Type;
}}
declare module "mekanism.common.block.transmitter.BlockSmallTransmitter" {
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ConnectionType, $ConnectionType$$Type} from "mekanism.common.lib.transmitter.ConnectionType"
import {$TileEntityTransmitter, $TileEntityTransmitter$$Type} from "mekanism.common.tile.transmitter.TileEntityTransmitter"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockTransmitter, $BlockTransmitter$$Type} from "mekanism.common.block.transmitter.BlockTransmitter"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockSmallTransmitter<TILE extends $TileEntityTransmitter> extends $BlockTransmitter<(TILE)> {
static readonly "CENTER": $VoxelShape
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(type: $BlockTypeTile$$Type<(TILE)>)

public static "getSideForType"(type: $ConnectionType$$Type, side: $Direction$$Type): $VoxelShape
public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockSmallTransmitter$$Type<TILE> = ($BlockSmallTransmitter<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockSmallTransmitter_<TILE> = $BlockSmallTransmitter$$Type<(TILE)>;
}}
declare module "mekanism.common.lib.transmitter.acceptor.AcceptorCache" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$AcceptorCache$CacheBasedInfo, $AcceptorCache$CacheBasedInfo$$Type} from "mekanism.common.lib.transmitter.acceptor.AcceptorCache$CacheBasedInfo"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$TileEntityTransmitter, $TileEntityTransmitter$$Type} from "mekanism.common.tile.transmitter.TileEntityTransmitter"
import {$AbstractAcceptorCache, $AbstractAcceptorCache$$Type} from "mekanism.common.lib.transmitter.acceptor.AbstractAcceptorCache"

export class $AcceptorCache<ACCEPTOR> extends $AbstractAcceptorCache<(ACCEPTOR), ($AcceptorCache$CacheBasedInfo<(ACCEPTOR)>)> {
 "currentAcceptorConnections": byte

constructor(transmitterTile: $TileEntityTransmitter$$Type, capability: $BlockCapability$$Type<(ACCEPTOR), ($Direction$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AcceptorCache$$Type<ACCEPTOR> = ($AcceptorCache<(ACCEPTOR)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AcceptorCache_<ACCEPTOR> = $AcceptorCache$$Type<(ACCEPTOR)>;
}}
declare module "mekanism.common.content.qio.QIOCraftingTransferHelper" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Map, $Map$$Type} from "java.util.Map"
import {$HashedItem$UUIDAwareHashedItem, $HashedItem$UUIDAwareHashedItem$$Type} from "mekanism.common.lib.inventory.HashedItem$UUIDAwareHashedItem"
import {$List, $List$$Type} from "java.util.List"
import {$HashedItem, $HashedItem$$Type} from "mekanism.common.lib.inventory.HashedItem"
import {$QIOCraftingTransferHelper$HashedItemSource, $QIOCraftingTransferHelper$HashedItemSource$$Type} from "mekanism.common.content.qio.QIOCraftingTransferHelper$HashedItemSource"
import {$HotBarSlot, $HotBarSlot$$Type} from "mekanism.common.inventory.container.slot.HotBarSlot"
import {$MainInventorySlot, $MainInventorySlot$$Type} from "mekanism.common.inventory.container.slot.MainInventorySlot"
import {$QIOCraftingWindow, $QIOCraftingWindow$$Type} from "mekanism.common.content.qio.QIOCraftingWindow"
import {$Object2LongMap, $Object2LongMap$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongMap"

export class $QIOCraftingTransferHelper {
readonly "reverseLookup": $Map<($HashedItem), ($QIOCraftingTransferHelper$HashedItemSource)>

constructor(cachedInventory: $Object2LongMap$$Type<($HashedItem$UUIDAwareHashedItem$$Type)>, hotBarSlots: $List$$Type<($HotBarSlot$$Type)>, mainInventorySlots: $List$$Type<($MainInventorySlot$$Type)>, craftingWindow: $QIOCraftingWindow$$Type, player: $Player$$Type)

public "isInvalid"(): boolean
public "getSource"(item: $HashedItem$$Type): $QIOCraftingTransferHelper$HashedItemSource
public "getEmptyInventorySlots"(): byte
get "invalid"(): boolean
get "emptyInventorySlots"(): byte
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOCraftingTransferHelper$$Type = ($QIOCraftingTransferHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOCraftingTransferHelper_ = $QIOCraftingTransferHelper$$Type;
}}
declare module "mekanism.common.integration.computer.ComputerMethodFactory$ComputerFunctionCaller" {
import {$BaseComputerHelper, $BaseComputerHelper$$Type} from "mekanism.common.integration.computer.BaseComputerHelper"

export interface $ComputerMethodFactory$ComputerFunctionCaller<T> {

 "apply"(t: T, u: $BaseComputerHelper$$Type): any

(t: T, u: $BaseComputerHelper): any
}

export namespace $ComputerMethodFactory$ComputerFunctionCaller {
const probejs$$marker: never
}
export class $ComputerMethodFactory$ComputerFunctionCaller$$Static<T> implements $ComputerMethodFactory$ComputerFunctionCaller {


 "apply"(t: T, u: $BaseComputerHelper$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComputerMethodFactory$ComputerFunctionCaller$$Type<T> = ((t: T, u: $BaseComputerHelper) => any);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComputerMethodFactory$ComputerFunctionCaller_<T> = $ComputerMethodFactory$ComputerFunctionCaller$$Type<(T)>;
}}
declare module "mekanism.common.attachments.FrequencyAware" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$DriveMetadata, $DriveMetadata$$Type} from "mekanism.common.attachments.qio.DriveMetadata"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$$Type} from "mekanism.common.lib.frequency.Frequency$FrequencyIdentity"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $FrequencyAware<FREQ extends $Frequency> extends $Record {
static readonly "NONE": $FrequencyAware<(any)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($DriveMetadata)>

constructor(freq: FREQ)
constructor(identity: $Optional$$Type<($Frequency$FrequencyIdentity$$Type)>, frequency: $Optional$$Type<(FREQ)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "identity"(): $Optional<($Frequency$FrequencyIdentity)>
public static "create"<FREQ extends $Frequency>(frequencyType: $FrequencyType$$Type<(FREQ)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): $FrequencyAware<(FREQ)>
public "getOwner"(): $UUID
public "frequency"(): $Optional<(FREQ)>
public "getFrequency"(stack: $ItemStack$$Type, type: $DataComponentType$$Type<($FrequencyAware$$Type<(FREQ)>)>): FREQ
public static "none"<FREQ extends $Frequency>(): $FrequencyAware<(FREQ)>
public static "codec"<FREQ extends $Frequency>(frequencyType: $FrequencyType$$Type<(FREQ)>): $Codec<($FrequencyAware<(FREQ)>)>
public static "streamCodec"<FREQ extends $Frequency>(frequencyType: $FrequencyType$$Type<(FREQ)>): $StreamCodec<($ByteBuf), ($FrequencyAware<(FREQ)>)>
get "owner"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrequencyAware$$Type<FREQ> = ({"frequency"?: (never)?, "identity"?: ($Frequency$FrequencyIdentity$$Type)?}) | ([frequency?: (never)?, identity?: ($Frequency$FrequencyIdentity$$Type)?]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FrequencyAware_<FREQ> = $FrequencyAware$$Type<(FREQ)>;
}}
declare module "mekanism.common.item.ItemPortableTeleporter" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent, $RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ContainerTypeRegistryObject, $ContainerTypeRegistryObject$$Type} from "mekanism.common.registration.impl.ContainerTypeRegistryObject"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$IGuiItem, $IGuiItem$$Type} from "mekanism.common.item.interfaces.IGuiItem"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$IFrequencyItem, $IFrequencyItem$$Type} from "mekanism.common.lib.frequency.IFrequencyItem"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"
import {$ItemEnergized, $ItemEnergized$$Type} from "mekanism.common.item.ItemEnergized"
import {$ICapabilityAware, $ICapabilityAware$$Type} from "mekanism.common.capabilities.ICapabilityAware"

export class $ItemPortableTeleporter extends $ItemEnergized implements $IFrequencyItem, $IGuiItem, $ICapabilityAware {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "use"(world: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "attachCapabilities"(event: $RegisterCapabilitiesEvent$$Type): void
public "getFrequencyType"(): $FrequencyType<(any)>
public "getContainerType"(): $ContainerTypeRegistryObject<(any)>
get "frequencyType"(): $FrequencyType<(any)>
get "containerType"(): $ContainerTypeRegistryObject<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPortableTeleporter$$Type = ($ItemPortableTeleporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPortableTeleporter_ = $ItemPortableTeleporter$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.DoubleInputRecipeCache$DoubleSameInputRecipeCache" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$DoubleInputRecipeCache, $DoubleInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.DoubleInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$InputIngredient, $InputIngredient$$Type} from "mekanism.api.recipes.ingredients.InputIngredient"
import {$IInputCache, $IInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.IInputCache"

export class $DoubleInputRecipeCache$DoubleSameInputRecipeCache<INPUT, INGREDIENT extends $InputIngredient<(INPUT)>, RECIPE extends ($MekanismRecipe<(any)>) & ($BiPredicate<(INPUT), (INPUT)>), CACHE extends $IInputCache<(INPUT), (INGREDIENT), (RECIPE)>> extends $DoubleInputRecipeCache<(INPUT), (INGREDIENT), (INPUT), (INGREDIENT), (RECIPE), (CACHE), (CACHE)> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleInputRecipeCache$DoubleSameInputRecipeCache$$Type<INPUT, INGREDIENT, RECIPE, CACHE> = ($DoubleInputRecipeCache$DoubleSameInputRecipeCache<(INPUT), (INGREDIENT), (RECIPE), (CACHE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleInputRecipeCache$DoubleSameInputRecipeCache_<INPUT, INGREDIENT, RECIPE, CACHE> = $DoubleInputRecipeCache$DoubleSameInputRecipeCache$$Type<(INPUT), (INGREDIENT), (RECIPE), (CACHE)>;
}}
declare module "mekanism.common.attachments.IAttachmentAware" {
import {$IEventBus, $IEventBus$$Type} from "net.neoforged.bus.api.IEventBus"

export interface $IAttachmentAware {

 "attachAttachments"(eventBus: $IEventBus$$Type): void

(eventBus: $IEventBus): void
}

export namespace $IAttachmentAware {
const probejs$$marker: never
}
export class $IAttachmentAware$$Static implements $IAttachmentAware {


 "attachAttachments"(eventBus: $IEventBus$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAttachmentAware$$Type = ((eventBus: $IEventBus) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IAttachmentAware_ = $IAttachmentAware$$Type;
}}
declare module "mekanism.common.content.network.transmitter.LogisticalTransporterBase$PathCalculator" {
import {$TransporterStack, $TransporterStack$$Type} from "mekanism.common.content.transporter.TransporterStack"
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$$Type} from "mekanism.common.lib.inventory.TransitRequest$TransitResponse"
import {$LogisticalTransporterBase, $LogisticalTransporterBase$$Type} from "mekanism.common.content.network.transmitter.LogisticalTransporterBase"
import {$TransitRequest, $TransitRequest$$Type} from "mekanism.common.lib.inventory.TransitRequest"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export interface $LogisticalTransporterBase$PathCalculator<BE extends $BlockEntity> {

 "calculate"(stack: $TransporterStack$$Type, request: $TransitRequest$$Type, outputter: BE, transporter: $LogisticalTransporterBase$$Type, min: integer, doEmit: boolean): $TransitRequest$TransitResponse

(stack: $TransporterStack, request: $TransitRequest, outputter: BE, transporter: $LogisticalTransporterBase, min: integer, doEmit: boolean): $TransitRequest$TransitResponse$$Type
}

export namespace $LogisticalTransporterBase$PathCalculator {
const probejs$$marker: never
}
export class $LogisticalTransporterBase$PathCalculator$$Static<BE extends $BlockEntity> implements $LogisticalTransporterBase$PathCalculator {


 "calculate"(stack: $TransporterStack$$Type, request: $TransitRequest$$Type, outputter: BE, transporter: $LogisticalTransporterBase$$Type, min: integer, doEmit: boolean): $TransitRequest$TransitResponse
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogisticalTransporterBase$PathCalculator$$Type<BE> = ((stack: $TransporterStack, request: $TransitRequest, outputter: BE, transporter: $LogisticalTransporterBase, min: integer, doEmit: boolean) => $TransitRequest$TransitResponse$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LogisticalTransporterBase$PathCalculator_<BE> = $LogisticalTransporterBase$PathCalculator$$Type<(BE)>;
}}
declare module "mekanism.common.content.qio.QIODriveData" {
import {$QIODriveData$QIODriveKey, $QIODriveData$QIODriveKey$$Type} from "mekanism.common.content.qio.QIODriveData$QIODriveKey"
import {$HashedItem, $HashedItem$$Type} from "mekanism.common.lib.inventory.HashedItem"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$Object2LongMap, $Object2LongMap$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongMap"

export class $QIODriveData {

constructor(key: $QIODriveData$QIODriveKey$$Type)

public "remove"(type: $HashedItem$$Type, amount: long, action: $Action$$Type): long
public "add"(type: $HashedItem$$Type, amount: long, action: $Action$$Type): long
public "getKey"(): $QIODriveData$QIODriveKey
public "getTotalCount"(): long
public "getStored"(type: $HashedItem$$Type): long
public "getTypeCapacity"(): integer
public "getTotalTypes"(): integer
public "getCountCapacity"(): long
public "getItemMap"(): $Object2LongMap<($HashedItem)>
get "key"(): $QIODriveData$QIODriveKey
get "totalCount"(): long
get "typeCapacity"(): integer
get "totalTypes"(): integer
get "countCapacity"(): long
get "itemMap"(): $Object2LongMap<($HashedItem)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIODriveData$$Type = ($QIODriveData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIODriveData_ = $QIODriveData$$Type;
}}
declare module "mekanism.common.tier.QIODriveTier" {
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$BaseTier, $BaseTier$$Type} from "mekanism.api.tier.BaseTier"

export class $QIODriveTier extends $Enum<($QIODriveTier)> implements $ITier {
static readonly "BASE": $QIODriveTier
static readonly "HYPER_DENSE": $QIODriveTier
static readonly "TIME_DILATING": $QIODriveTier
static readonly "SUPERMASSIVE": $QIODriveTier


public static "values"(): ($QIODriveTier)[]
public static "valueOf"(name: string): $QIODriveTier
public "getMaxCount"(): long
public "getBaseTier"(): $BaseTier
public "getMaxTypes"(): integer
get "maxCount"(): long
get "baseTier"(): $BaseTier
get "maxTypes"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIODriveTier$$Type = (("base") | ("hyper_dense") | ("time_dilating") | ("supermassive"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIODriveTier_ = $QIODriveTier$$Type;
}}
declare module "mekanism.common.capabilities.chemical.item.ChemicalTankSpec$TankFromSpecCreator" {
import {$LongSupplier, $LongSupplier$$Type} from "java.util.function.LongSupplier"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ChemicalAttributeValidator, $ChemicalAttributeValidator$$Type} from "mekanism.api.chemical.attribute.ChemicalAttributeValidator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Chemical, $Chemical$$Type} from "mekanism.api.chemical.Chemical"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"

export interface $ChemicalTankSpec$TankFromSpecCreator {

 "create"(rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, isValid: $Predicate$$Type<($Chemical)>, validator: $ChemicalAttributeValidator$$Type, listener: $IContentsListener$$Type): $IChemicalTank
 "create"(rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, isValid: $Predicate$$Type<($Chemical)>, listener: $IContentsListener$$Type): $IChemicalTank
 "create"(rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, isValid: $Predicate$$Type<($Chemical)>): $IChemicalTank

(rate: $LongSupplier, capacity: $LongSupplier, canExtract: $BiPredicate<($Chemical), ($AutomationType)>, canInsert: $BiPredicate<($Chemical), ($AutomationType)>, isValid: $Predicate<($Chemical)>, validator: $ChemicalAttributeValidator, listener: $IContentsListener): $IChemicalTank$$Type
}

export namespace $ChemicalTankSpec$TankFromSpecCreator {
const probejs$$marker: never
}
export class $ChemicalTankSpec$TankFromSpecCreator$$Static implements $ChemicalTankSpec$TankFromSpecCreator {


 "create"(rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, isValid: $Predicate$$Type<($Chemical)>, validator: $ChemicalAttributeValidator$$Type, listener: $IContentsListener$$Type): $IChemicalTank
 "create"(rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, isValid: $Predicate$$Type<($Chemical)>, listener: $IContentsListener$$Type): $IChemicalTank
 "create"(rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, isValid: $Predicate$$Type<($Chemical)>): $IChemicalTank
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalTankSpec$TankFromSpecCreator$$Type = ((rate: $LongSupplier, capacity: $LongSupplier, canExtract: $BiPredicate<($Chemical), ($AutomationType)>, canInsert: $BiPredicate<($Chemical), ($AutomationType)>, isValid: $Predicate<($Chemical)>, validator: $ChemicalAttributeValidator, listener: $IContentsListener) => $IChemicalTank$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalTankSpec$TankFromSpecCreator_ = $ChemicalTankSpec$TankFromSpecCreator$$Type;
}}
declare module "mekanism.common.item.gear.ItemAtomicDisassembler$DisassemblerMode" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$EnumColor, $EnumColor$$Type} from "mekanism.api.text.EnumColor"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$IRadialMode, $IRadialMode$$Type} from "mekanism.api.radial.mode.IRadialMode"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$IHasTextComponent$IHasEnumNameTextComponent, $IHasTextComponent$IHasEnumNameTextComponent$$Type} from "mekanism.api.text.IHasTextComponent$IHasEnumNameTextComponent"
import {$IDisableableEnum, $IDisableableEnum$$Type} from "mekanism.api.IDisableableEnum"

export class $ItemAtomicDisassembler$DisassemblerMode extends $Enum<($ItemAtomicDisassembler$DisassemblerMode)> implements $IDisableableEnum<($ItemAtomicDisassembler$DisassemblerMode)>, $IHasTextComponent$IHasEnumNameTextComponent, $IRadialMode, $StringRepresentable {
static readonly "NORMAL": $ItemAtomicDisassembler$DisassemblerMode
static readonly "SLOW": $ItemAtomicDisassembler$DisassemblerMode
static readonly "FAST": $ItemAtomicDisassembler$DisassemblerMode
static readonly "VEIN": $ItemAtomicDisassembler$DisassemblerMode
static readonly "OFF": $ItemAtomicDisassembler$DisassemblerMode
static readonly "CODEC": $Codec<($ItemAtomicDisassembler$DisassemblerMode)>
static readonly "BY_ID": $IntFunction<($ItemAtomicDisassembler$DisassemblerMode)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($ItemAtomicDisassembler$DisassemblerMode)>


public static "values"(): ($ItemAtomicDisassembler$DisassemblerMode)[]
public static "valueOf"(name: string): $ItemAtomicDisassembler$DisassemblerMode
public "isEnabled"(): boolean
public "color"(): $EnumColor
public "icon"(): $ResourceLocation
public "byIndex"(index: integer): $Enum<(any)>
public "getEfficiency"(): integer
public "sliceName"(): $Component
public "getSerializedName"(): string
public "getTextComponent"(): $Component
public "adjust"(arg0: integer): $ItemAtomicDisassembler$DisassemblerMode
public "getNext"(arg0: $Predicate$$Type<($ItemAtomicDisassembler$DisassemblerMode)>): $ItemAtomicDisassembler$DisassemblerMode
public "getNext"(): $ItemAtomicDisassembler$DisassemblerMode
public "getPrevious"(arg0: $Predicate$$Type<($ItemAtomicDisassembler$DisassemblerMode)>): $ItemAtomicDisassembler$DisassemblerMode
public "getPrevious"(): $ItemAtomicDisassembler$DisassemblerMode
public "getTranslatedName"(): $Component
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public "adjust"(arg0: integer, arg1: $Predicate$$Type<($ItemAtomicDisassembler$DisassemblerMode)>): $ItemAtomicDisassembler$DisassemblerMode
get "enabled"(): boolean
get "efficiency"(): integer
get "serializedName"(): string
get "textComponent"(): $Component
get "next"(): $ItemAtomicDisassembler$DisassemblerMode
get "previous"(): $ItemAtomicDisassembler$DisassemblerMode
get "translatedName"(): $Component
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemAtomicDisassembler$DisassemblerMode$$Type = (("normal") | ("slow") | ("fast") | ("vein") | ("off"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemAtomicDisassembler$DisassemblerMode_ = $ItemAtomicDisassembler$DisassemblerMode$$Type;
}}
declare module "mekanism.common.config.IMekanismConfig" {
import {$ModConfig$Type, $ModConfig$Type$$Type} from "net.neoforged.fml.config.ModConfig$Type"
import {$CachedValue, $CachedValue$$Type} from "mekanism.common.config.value.CachedValue"
import {$ModConfigSpec, $ModConfigSpec$$Type} from "net.neoforged.neoforge.common.ModConfigSpec"

export interface $IMekanismConfig {

 "save"(): void
 "getFileName"(): string
 "isLoaded"(): boolean
 "clearCache"(unloading: boolean): void
 "addCachedValue"(configValue: $CachedValue$$Type<(any)>): void
 "getConfigSpec"(): $ModConfigSpec
 "getConfigType"(): $ModConfig$Type
 "getTranslation"(): string
get "fileName"(): string
get "loaded"(): boolean
get "configSpec"(): $ModConfigSpec
get "configType"(): $ModConfig$Type
get "translation"(): string
}

export namespace $IMekanismConfig {
const probejs$$marker: never
}
export class $IMekanismConfig$$Static implements $IMekanismConfig {


 "save"(): void
 "getFileName"(): string
 "isLoaded"(): boolean
 "clearCache"(unloading: boolean): void
 "addCachedValue"(configValue: $CachedValue$$Type<(any)>): void
 "getConfigSpec"(): $ModConfigSpec
 "getConfigType"(): $ModConfig$Type
 "getTranslation"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMekanismConfig$$Type = ($IMekanismConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMekanismConfig_ = $IMekanismConfig$$Type;
}}
declare module "mekanism.common.integration.computer.TableType$Builder" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$TableType, $TableType$$Type} from "mekanism.common.integration.computer.TableType"

export class $TableType$Builder {


public "build"(destination: $Map$$Type<($Class$$Type<(any)>), ($TableType$$Type)>): $TableType
public "extendedFrom"(c: $Class$$Type<(any)>): $TableType$Builder
public "addField"(name: string, javaType: $Class$$Type<(any)>, description: string, ...javaExtra: ($Class$$Type<(any)>)[]): $TableType$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TableType$Builder$$Type = ($TableType$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TableType$Builder_ = $TableType$Builder$$Type;
}}
declare module "mekanism.common.content.filter.IFilter" {
import {$FilterType, $FilterType$$Type} from "mekanism.common.content.filter.FilterType"

export interface $IFilter<FILTER extends $IFilter<(FILTER)>> {

 "clone"(): FILTER
 "isEnabled"(): boolean
 "hasFilter"(): boolean
 "setEnabled"(enabled: boolean): void
 "getFilterType"(): $FilterType
get "enabled"(): boolean
set "enabled"(value: boolean)
get "filterType"(): $FilterType
}

export namespace $IFilter {
const probejs$$marker: never
}
export class $IFilter$$Static<FILTER extends $IFilter<(FILTER)>> implements $IFilter {


 "clone"(): FILTER
 "isEnabled"(): boolean
 "hasFilter"(): boolean
 "setEnabled"(enabled: boolean): void
 "getFilterType"(): $FilterType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFilter$$Type<FILTER> = ($IFilter<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFilter_<FILTER> = $IFilter$$Type<(FILTER)>;
}}
declare module "mekanism.common.tile.TileEntityIndustrialAlarm" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityIndustrialAlarm extends $TileEntityMekanism {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(pos: $BlockPos$$Type, state: $BlockState$$Type)

public "onPowerChange"(): void
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityIndustrialAlarm$$Type = ($TileEntityIndustrialAlarm);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityIndustrialAlarm_ = $TileEntityIndustrialAlarm$$Type;
}}
declare module "mekanism.common.inventory.container.sync.ISyncableData$DirtyType" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $ISyncableData$DirtyType extends $Enum<($ISyncableData$DirtyType)> {
static readonly "CLEAN": $ISyncableData$DirtyType
static readonly "SIZE": $ISyncableData$DirtyType
static readonly "DIRTY": $ISyncableData$DirtyType


public static "get"(dirty: boolean): $ISyncableData$DirtyType
public static "values"(): ($ISyncableData$DirtyType)[]
public static "valueOf"(name: string): $ISyncableData$DirtyType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISyncableData$DirtyType$$Type = (("clean") | ("size") | ("dirty"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISyncableData$DirtyType_ = $ISyncableData$DirtyType$$Type;
}}
declare module "mekanism.common.tile.prefab.TileEntityConfigurableMachine" {
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ISideConfiguration, $ISideConfiguration$$Type} from "mekanism.common.tile.interfaces.ISideConfiguration"
import {$TileComponentConfig, $TileComponentConfig$$Type} from "mekanism.common.tile.component.TileComponentConfig"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TileComponentEjector, $TileComponentEjector$$Type} from "mekanism.common.tile.component.TileComponentEjector"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$DataType, $DataType$$Type} from "mekanism.common.tile.component.config.DataType"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"

export class $TileEntityConfigurableMachine extends $TileEntityMekanism implements $ISideConfiguration {
 "ejectorComponent": $TileComponentEjector
readonly "configComponent": $TileComponentConfig
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "getConfig"(): $TileComponentConfig
public "getConfigurationData"(provider: $HolderLookup$Provider$$Type, player: $Player$$Type): $CompoundTag
public "setConfigurationData"(provider: $HolderLookup$Provider$$Type, player: $Player$$Type, data: $CompoundTag$$Type): void
public "getEjector"(): $TileComponentEjector
public "getDirection"(): $Direction
public "getActiveDataType"(container: any): $DataType
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "config"(): $TileComponentConfig
get "ejector"(): $TileComponentEjector
get "direction"(): $Direction
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityConfigurableMachine$$Type = ($TileEntityConfigurableMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityConfigurableMachine_ = $TileEntityConfigurableMachine$$Type;
}}
declare module "mekanism.common.tile.transmitter.TileEntityThermodynamicConductor" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$TransmitterModelData, $TransmitterModelData$$Type} from "mekanism.client.model.data.TransmitterModelData"
import {$IConfigurable, $IConfigurable$$Type} from "mekanism.api.IConfigurable"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TransmitterType, $TransmitterType$$Type} from "mekanism.common.block.states.TransmitterType"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ModelProperty, $ModelProperty$$Type} from "net.neoforged.neoforge.client.model.data.ModelProperty"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$ConnectionType, $ConnectionType$$Type} from "mekanism.common.lib.transmitter.ConnectionType"
import {$Transmitter, $Transmitter$$Type} from "mekanism.common.content.network.transmitter.Transmitter"
import {$TileEntityTransmitter, $TileEntityTransmitter$$Type} from "mekanism.common.tile.transmitter.TileEntityTransmitter"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityThermodynamicConductor extends $TileEntityTransmitter {
static readonly "CONFIGURABLE_PROVIDER": $ICapabilityProvider<($TileEntityTransmitter), ($Direction), ($IConfigurable)>
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "sideChanged"(side: $Direction$$Type, old: $ConnectionType$$Type, type: $ConnectionType$$Type): void
public "getTransmitter"(): $Transmitter<(any), (any), (any)>
public "redstoneChanged"(powered: boolean): void
public "getTransmitterType"(): $TransmitterType
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
get "transmitter"(): $Transmitter<(any), (any), (any)>
get "transmitterType"(): $TransmitterType
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityThermodynamicConductor$$Type = ($TileEntityThermodynamicConductor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityThermodynamicConductor_ = $TileEntityThermodynamicConductor$$Type;
}}
declare module "mekanism.common.content.gear.IRadialModuleContainerItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$List, $List$$Type} from "java.util.List"
import {$ItemAttributeModifierEvent, $ItemAttributeModifierEvent$$Type} from "net.neoforged.neoforge.event.ItemAttributeModifierEvent"
import {$IGenericRadialModeItem, $IGenericRadialModeItem$$Type} from "mekanism.common.lib.radial.IGenericRadialModeItem"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$IModule, $IModule$$Type} from "mekanism.api.gear.IModule"
import {$RadialData, $RadialData$$Type} from "mekanism.api.radial.RadialData"
import {$IModuleDataProvider, $IModuleDataProvider$$Type} from "mekanism.api.providers.IModuleDataProvider"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IModuleContainer, $IModuleContainer$$Type} from "mekanism.api.gear.IModuleContainer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$IRadialMode, $IRadialMode$$Type} from "mekanism.api.radial.mode.IRadialMode"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ICustomModule, $ICustomModule$$Type} from "mekanism.api.gear.ICustomModule"
import {$IModuleContainerItem, $IModuleContainerItem$$Type} from "mekanism.common.content.gear.IModuleContainerItem"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"

export interface $IRadialModuleContainerItem extends $IModuleContainerItem, $IGenericRadialModeItem {

 "setMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, player: $Player$$Type, radialData: $RadialData$$Type<(M)>, mode: M): void
 "getMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, radialData: $RadialData$$Type<(M)>): M
 "getRadialData"(stack: $ItemStack$$Type): $RadialData<(any)>
 "getRadialIdentifier"(): $ResourceLocation
 "getModules"(stack: $ItemStack$$Type): $Collection<($IModule<(any)>)>
 "adjustAttributes"(event: $ItemAttributeModifierEvent$$Type): void
 "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
 "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
 "hasModule"(stack: $ItemStack$$Type, type: $IModuleDataProvider$$Type<(any)>): boolean
 "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
 "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
 "isModuleEnabled"(stack: $ItemStack$$Type, type: $IModuleDataProvider$$Type<(any)>): boolean
 "addModuleDetails"(stack: $ItemStack$$Type, tooltip: $List$$Type<($Component$$Type)>): void
 "getEnabledModule"<MODULE extends $ICustomModule<(MODULE)>>(stack: $ItemStack$$Type, typeProvider: $IModuleDataProvider$$Type<(MODULE)>): $IModule<(MODULE)>
 "moduleContainer"(stack: $ItemStack$$Type): $IModuleContainer
 "hasInstalledModules"(stack: $ItemStack$$Type): boolean
 "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void

(): $ResourceLocation$$Type
get "radialIdentifier"(): $ResourceLocation
}

export namespace $IRadialModuleContainerItem {
function displayModeChange(player: $Player$$Type): void
function isModeItem(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
function isModeItem(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
const probejs$$marker: never
}
export class $IRadialModuleContainerItem$$Static implements $IRadialModuleContainerItem {


 "setMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, player: $Player$$Type, radialData: $RadialData$$Type<(M)>, mode: M): void
 "getMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, radialData: $RadialData$$Type<(M)>): M
 "getRadialData"(stack: $ItemStack$$Type): $RadialData<(any)>
 "getRadialIdentifier"(): $ResourceLocation
 "getModules"(stack: $ItemStack$$Type): $Collection<($IModule<(any)>)>
 "adjustAttributes"(event: $ItemAttributeModifierEvent$$Type): void
 "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
 "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
 "hasModule"(stack: $ItemStack$$Type, type: $IModuleDataProvider$$Type<(any)>): boolean
 "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
 "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
 "isModuleEnabled"(stack: $ItemStack$$Type, type: $IModuleDataProvider$$Type<(any)>): boolean
 "addModuleDetails"(stack: $ItemStack$$Type, tooltip: $List$$Type<($Component$$Type)>): void
 "getEnabledModule"<MODULE extends $ICustomModule<(MODULE)>>(stack: $ItemStack$$Type, typeProvider: $IModuleDataProvider$$Type<(MODULE)>): $IModule<(MODULE)>
 "moduleContainer"(stack: $ItemStack$$Type): $IModuleContainer
 "hasInstalledModules"(stack: $ItemStack$$Type): boolean
static "displayModeChange"(player: $Player$$Type): void
static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
 "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRadialModuleContainerItem$$Type = (() => $ResourceLocation$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRadialModuleContainerItem_ = $IRadialModuleContainerItem$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.AbstractInputRecipeCache" {
import {$IInputRecipeCache, $IInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.IInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"

export class $AbstractInputRecipeCache<RECIPE extends $MekanismRecipe<(any)>> implements $IInputRecipeCache {


public "clear"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractInputRecipeCache$$Type<RECIPE> = ($AbstractInputRecipeCache<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractInputRecipeCache_<RECIPE> = $AbstractInputRecipeCache$$Type<(RECIPE)>;
}}
declare module "mekanism.common.item.interfaces.IModeItem$IAttachmentBasedModeItem" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$IModeItem, $IModeItem$$Type} from "mekanism.common.item.interfaces.IModeItem"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"

export interface $IModeItem$IAttachmentBasedModeItem<MODE> extends $IModeItem {

 "setMode"(stack: $ItemStack$$Type, player: $Player$$Type, mode: MODE): void
 "getMode"(stack: $ItemStack$$Type): MODE
 "getDefaultMode"(): MODE
 "getModeDataType"(): $DataComponentType<(MODE)>
 "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
 "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
 "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
get "defaultMode"(): MODE
get "modeDataType"(): $DataComponentType<(MODE)>
}

export namespace $IModeItem$IAttachmentBasedModeItem {
function displayModeChange(player: $Player$$Type): void
function isModeItem(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
function isModeItem(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
const probejs$$marker: never
}
export class $IModeItem$IAttachmentBasedModeItem$$Static<MODE> implements $IModeItem$IAttachmentBasedModeItem {


 "setMode"(stack: $ItemStack$$Type, player: $Player$$Type, mode: MODE): void
 "getMode"(stack: $ItemStack$$Type): MODE
 "getDefaultMode"(): MODE
 "getModeDataType"(): $DataComponentType<(MODE)>
 "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
static "displayModeChange"(player: $Player$$Type): void
 "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
 "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModeItem$IAttachmentBasedModeItem$$Type<MODE> = ($IModeItem$IAttachmentBasedModeItem<(MODE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModeItem$IAttachmentBasedModeItem_<MODE> = $IModeItem$IAttachmentBasedModeItem$$Type<(MODE)>;
}}
declare module "mekanism.common.tile.TileEntityEnergyCube" {
import {$TileEntityEnergyCube$CubeSideState, $TileEntityEnergyCube$CubeSideState$$Type} from "mekanism.common.tile.TileEntityEnergyCube$CubeSideState"
import {$EnergyCubeTier, $EnergyCubeTier$$Type} from "mekanism.common.tier.EnergyCubeTier"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$IUpgradeData, $IUpgradeData$$Type} from "mekanism.common.upgrade.IUpgradeData"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$TileComponentConfig, $TileComponentConfig$$Type} from "mekanism.common.tile.component.TileComponentConfig"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$ModelData, $ModelData$$Type} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TileComponentEjector, $TileComponentEjector$$Type} from "mekanism.common.tile.component.TileComponentEjector"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$EnergyCubeEnergyContainer, $EnergyCubeEnergyContainer$$Type} from "mekanism.common.capabilities.energy.EnergyCubeEnergyContainer"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ModelProperty, $ModelProperty$$Type} from "net.neoforged.neoforge.client.model.data.ModelProperty"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$TileEntityConfigurableMachine, $TileEntityConfigurableMachine$$Type} from "mekanism.common.tile.prefab.TileEntityConfigurableMachine"

export class $TileEntityEnergyCube extends $TileEntityConfigurableMachine {
static readonly "SIDE_STATE_PROPERTY": $ModelProperty<(($TileEntityEnergyCube$CubeSideState)[])>
 "ejectorComponent": $TileComponentEjector
readonly "configComponent": $TileComponentConfig
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getTier"(): $EnergyCubeTier
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "getModelData"(): $ModelData
public "getUpgradeData"(provider: $HolderLookup$Provider$$Type): $IUpgradeData
public "getEnergyContainer"(): $EnergyCubeEnergyContainer
public "getEnergyScale"(): float
public "parseUpgradeData"(provider: $HolderLookup$Provider$$Type, upgradeData: $IUpgradeData$$Type): void
public "getRedstoneLevel"(): integer
public "getDirection"(): $Direction
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "tier"(): $EnergyCubeTier
get "modelData"(): $ModelData
get "energyContainer"(): $EnergyCubeEnergyContainer
get "energyScale"(): float
get "redstoneLevel"(): integer
get "direction"(): $Direction
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityEnergyCube$$Type = ($TileEntityEnergyCube);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityEnergyCube_ = $TileEntityEnergyCube$$Type;
}}
declare module "mekanism.common.item.block.ItemBlockMekanism" {
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockItem, $BlockItem$$Type} from "net.minecraft.world.item.BlockItem"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ItemBlockMekanism<BLOCK extends $Block> extends $BlockItem implements $IBlockProvider {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: BLOCK, properties: $Item$Properties$$Type)

public "getName"(stack: $ItemStack$$Type): $Component
public "getBlock"(): BLOCK
public "getTier"(): $ITier
public "getTranslationKey"(): string
public "defaultState"(): $BlockState
public "getRegistryName"(): $ResourceLocation
public "getItemStack"(): $ItemStack
public "getItemStack"(arg0: integer): $ItemStack
public "getName"(): string
public "getTextComponent"(): $Component
get "block"(): BLOCK
get "tier"(): $ITier
get "translationKey"(): string
get "registryName"(): $ResourceLocation
get "itemStack"(): $ItemStack
get "name"(): string
get "textComponent"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockMekanism$$Type<BLOCK> = ($ItemBlockMekanism<(BLOCK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockMekanism_<BLOCK> = $ItemBlockMekanism$$Type<(BLOCK)>;
}}
declare module "mekanism.common.content.transporter.SorterFilter" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$BaseFilter, $BaseFilter$$Type} from "mekanism.common.content.filter.BaseFilter"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Finder, $Finder$$Type} from "mekanism.common.lib.inventory.Finder"
import {$IFilter, $IFilter$$Type} from "mekanism.common.content.filter.IFilter"
import {$TransitRequest, $TransitRequest$$Type} from "mekanism.common.lib.inventory.TransitRequest"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$EnumColor, $EnumColor$$Type} from "mekanism.api.text.EnumColor"

export class $SorterFilter<FILTER extends $SorterFilter<(FILTER)>> extends $BaseFilter<(FILTER)> {
static readonly "MAX_LENGTH": integer
 "color": $EnumColor
 "allowDefault": boolean
 "sizeMode": boolean
 "min": integer
 "max": integer
static readonly "GENERIC_CODEC": $Codec<($IFilter<(any)>)>
static readonly "GENERIC_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IFilter<(any)>)>


public "equals"(o: any): boolean
public "hashCode"(): integer
public "clone"(): FILTER
public "mapInventory"(itemHandler: $IItemHandler$$Type, singleItem: boolean): $TransitRequest
public "getFinder"(): $Finder
get "finder"(): $Finder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SorterFilter$$Type<FILTER> = ($SorterFilter<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SorterFilter_<FILTER> = $SorterFilter$$Type<(FILTER)>;
}}
declare module "mekanism.common.lib.transmitter.DynamicNetwork" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$CompatibleTransmitterValidator, $CompatibleTransmitterValidator$$Type} from "mekanism.common.lib.transmitter.CompatibleTransmitterValidator"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$INetworkDataHandler, $INetworkDataHandler$$Type} from "mekanism.common.lib.transmitter.INetworkDataHandler"
import {$IHasTextComponent, $IHasTextComponent$$Type} from "mekanism.api.text.IHasTextComponent"
import {$Transmitter, $Transmitter$$Type} from "mekanism.common.content.network.transmitter.Transmitter"
import {$Set, $Set$$Type} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $DynamicNetwork<ACCEPTOR, NETWORK extends $DynamicNetwork<(ACCEPTOR), (NETWORK), (TRANSMITTER)>, TRANSMITTER extends $Transmitter<(ACCEPTOR), (NETWORK), (TRANSMITTER)>> implements $INetworkDataHandler, $IHasTextComponent {


public "equals"(o: any): boolean
public "hashCode"(): integer
public "commit"(): void
public "isEmpty"(): boolean
public "register"(): void
public "invalidate"(triggerTransmitter: TRANSMITTER): void
public "getUUID"(): $UUID
public "deregister"(): void
public "getWorld"(): $Level
public "isRemote"(): boolean
public "getAcceptorDirections"(pos: long): $Set<($Direction)>
public "adoptTransmittersAndAcceptorsFrom"(net: NETWORK): $List<(TRANSMITTER)>
public "getAcceptorCount"(): integer
public "transmittersSize"(): integer
public "getTransmitter"(pos: long): TRANSMITTER
public "getTransmitter"(pos: $BlockPos$$Type): TRANSMITTER
public "hasAcceptor"(acceptorPos: $BlockPos$$Type): boolean
public "getTransmitters"(): $Collection<(TRANSMITTER)>
public "addNewTransmitters"(newTransmitters: $Collection$$Type<(TRANSMITTER)>, transmitterValidator: $CompatibleTransmitterValidator$$Type<(ACCEPTOR), (NETWORK), (TRANSMITTER)>): void
public "onUpdate"(): void
public "addTransmitter"(transmitter: TRANSMITTER): void
public "removeTransmitter"(transmitter: TRANSMITTER): void
public "getCachedAcceptor"(acceptorPos: long, side: $Direction$$Type): ACCEPTOR
public "acceptorChanged"(transmitter: TRANSMITTER, side: $Direction$$Type): void
public "getTransmitterValidator"(): $CompatibleTransmitterValidator<(ACCEPTOR), (NETWORK), (TRANSMITTER)>
public "getFlowInfo"(): $Component
public "getNeededInfo"(): $Component
public "getStoredInfo"(): $Component
public "getNetworkReaderCapacity"(): any
public "getTextComponent"(): $Component
get "empty"(): boolean
get "uUID"(): $UUID
get "world"(): $Level
get "remote"(): boolean
get "acceptorCount"(): integer
get "transmitters"(): $Collection<(TRANSMITTER)>
get "transmitterValidator"(): $CompatibleTransmitterValidator<(ACCEPTOR), (NETWORK), (TRANSMITTER)>
get "flowInfo"(): $Component
get "neededInfo"(): $Component
get "storedInfo"(): $Component
get "networkReaderCapacity"(): any
get "textComponent"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicNetwork$$Type<ACCEPTOR, NETWORK, TRANSMITTER> = ($DynamicNetwork<(ACCEPTOR), (NETWORK), (TRANSMITTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DynamicNetwork_<ACCEPTOR, NETWORK, TRANSMITTER> = $DynamicNetwork$$Type<(ACCEPTOR), (NETWORK), (TRANSMITTER)>;
}}
declare module "mekanism.common.item.block.transmitter.ItemBlockThermodynamicConductor" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$TileEntityThermodynamicConductor, $TileEntityThermodynamicConductor$$Type} from "mekanism.common.tile.transmitter.TileEntityThermodynamicConductor"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockSmallTransmitter, $BlockSmallTransmitter$$Type} from "mekanism.common.block.transmitter.BlockSmallTransmitter"

export class $ItemBlockThermodynamicConductor extends $ItemBlockTooltip<($BlockSmallTransmitter<($TileEntityThermodynamicConductor)>)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockSmallTransmitter$$Type<($TileEntityThermodynamicConductor$$Type)>, properties: $Item$Properties$$Type)

public "getTier"(): $ITier
get "tier"(): $ITier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockThermodynamicConductor$$Type = ($ItemBlockThermodynamicConductor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockThermodynamicConductor_ = $ItemBlockThermodynamicConductor$$Type;
}}
declare module "mekanism.common.advancements.triggers.ChangeRobitSkinTrigger$TriggerInstance" {
import {$Criterion, $Criterion$$Type} from "net.minecraft.advancements.Criterion"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$ContextAwarePredicate, $ContextAwarePredicate$$Type} from "net.minecraft.advancements.critereon.ContextAwarePredicate"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$CriterionValidator, $CriterionValidator$$Type} from "net.minecraft.advancements.critereon.CriterionValidator"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$SimpleCriterionTrigger$SimpleInstance, $SimpleCriterionTrigger$SimpleInstance$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger$SimpleInstance"
import {$RobitSkin, $RobitSkin$$Type} from "mekanism.api.robit.RobitSkin"

export class $ChangeRobitSkinTrigger$TriggerInstance extends $Record implements $SimpleCriterionTrigger$SimpleInstance {
static readonly "CODEC": $Codec<($ChangeRobitSkinTrigger$TriggerInstance)>

constructor(player: $Optional$$Type<($ContextAwarePredicate$$Type)>, skin: $Optional$$Type<($ResourceKey$$Type<($RobitSkin$$Type)>)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "player"(): $Optional<($ContextAwarePredicate)>
public "skin"(): $Optional<($ResourceKey<($RobitSkin)>)>
public static "toAny"(): $Criterion<($ChangeRobitSkinTrigger$TriggerInstance)>
public static "toSkin"(skin: $ResourceKey$$Type<($RobitSkin)>): $Criterion<($ChangeRobitSkinTrigger$TriggerInstance)>
public "validate"(arg0: $CriterionValidator$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChangeRobitSkinTrigger$TriggerInstance$$Type = ({"skin"?: ($ResourceKey$$Type<($RobitSkin$$Type)>)?, "player"?: ($ContextAwarePredicate$$Type)?}) | ([skin?: ($ResourceKey$$Type<($RobitSkin$$Type)>)?, player?: ($ContextAwarePredicate$$Type)?]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChangeRobitSkinTrigger$TriggerInstance_ = $ChangeRobitSkinTrigger$TriggerInstance$$Type;
}}
declare module "mekanism.common.lib.transmitter.acceptor.AcceptorInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $AcceptorInfo<ACCEPTOR> {

 "acceptor"(): ACCEPTOR

(): ACCEPTOR
}

export namespace $AcceptorInfo {
const probejs$$marker: never
}
export class $AcceptorInfo$$Static<ACCEPTOR> implements $AcceptorInfo {


 "acceptor"(): ACCEPTOR
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AcceptorInfo$$Type<ACCEPTOR> = (() => ACCEPTOR);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AcceptorInfo_<ACCEPTOR> = $AcceptorInfo$$Type<(ACCEPTOR)>;
}}
declare module "mekanism.common.tile.component.TileComponentSecurity" {
import {$SecurityFrequency, $SecurityFrequency$$Type} from "mekanism.common.lib.security.SecurityFrequency"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$SecurityMode, $SecurityMode$$Type} from "mekanism.api.security.SecurityMode"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$DataComponentMap$Builder, $DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ITileComponent, $ITileComponent$$Type} from "mekanism.common.tile.component.ITileComponent"
import {$BlockEntity$DataComponentInput, $BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"

export class $TileComponentSecurity implements $ITileComponent {
readonly "tile": $TileEntityMekanism

constructor(tile: $TileEntityMekanism$$Type)

public "deserialize"(securityNBT: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getFrequency"(): $SecurityFrequency
public "serialize"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "setMode"(mode: $SecurityMode$$Type): void
public "getMode"(): $SecurityMode
public "applyImplicitComponents"(input: $BlockEntity$DataComponentInput$$Type): void
public "collectImplicitComponents"(builder: $DataComponentMap$Builder$$Type): void
public "setOwnerUUID"(uuid: $UUID$$Type): void
public "addToUpdateTag"(updateTag: $CompoundTag$$Type): void
public "readFromUpdateTag"(updateTag: $CompoundTag$$Type): void
public "trackForMainContainer"(container: $MekanismContainer$$Type): void
public "getOwnerUUID"(): $UUID
public "getOwnerName"(): string
public "getComponentKey"(): string
public "addRemapEntries"(remapEntries: $List$$Type<($DataComponentType$$Type<(any)>)>): void
public "write"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "read"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "removed"(): void
public "invalidate"(): void
get "frequency"(): $SecurityFrequency
set "mode"(value: $SecurityMode$$Type)
get "mode"(): $SecurityMode
set "ownerUUID"(value: $UUID$$Type)
get "ownerUUID"(): $UUID
get "ownerName"(): string
get "componentKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileComponentSecurity$$Type = ($TileComponentSecurity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileComponentSecurity_ = $TileComponentSecurity$$Type;
}}
declare module "mekanism.common.config.value.CachedIntValue" {
import {$LongSupplier, $LongSupplier$$Type} from "java.util.function.LongSupplier"
import {$IMekanismConfig, $IMekanismConfig$$Type} from "mekanism.common.config.IMekanismConfig"
import {$ModConfigSpec$ConfigValue, $ModConfigSpec$ConfigValue$$Type} from "net.neoforged.neoforge.common.ModConfigSpec$ConfigValue"
import {$CachedValue, $CachedValue$$Type} from "mekanism.common.config.value.CachedValue"
import {$IntSupplier, $IntSupplier$$Type} from "java.util.function.IntSupplier"

export class $CachedIntValue extends $CachedValue<(integer)> implements $IntSupplier, $LongSupplier {


public "get"(): integer
public static "wrap"(config: $IMekanismConfig$$Type, internal: $ModConfigSpec$ConfigValue$$Type<(integer)>): $CachedIntValue
public "set"(value: integer): void
public "getOrDefault"(): integer
public "getAsInt"(): integer
public "getAsLong"(): long
get "orDefault"(): integer
get "asInt"(): integer
get "asLong"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedIntValue$$Type = ($CachedIntValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedIntValue_ = $CachedIntValue$$Type;
}}
declare module "mekanism.common.capabilities.energy.BasicEnergyContainer" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IEnergyContainer, $IEnergyContainer$$Type} from "mekanism.api.energy.IEnergyContainer"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $BasicEnergyContainer implements $IEnergyContainer {
static readonly "alwaysTrue": $Predicate<($AutomationType)>
static readonly "alwaysFalse": $Predicate<($AutomationType)>
static readonly "internalOnly": $Predicate<($AutomationType)>
static readonly "manualOnly": $Predicate<($AutomationType)>
static readonly "notExternal": $Predicate<($AutomationType)>


public "extract"(amount: long, action: $Action$$Type, automationType: $AutomationType$$Type): long
public "insert"(amount: long, action: $Action$$Type, automationType: $AutomationType$$Type): long
public "isEmpty"(): boolean
public static "create"(maxEnergy: long, listener: $IContentsListener$$Type): $BasicEnergyContainer
public static "create"(maxEnergy: long, canExtract: $Predicate$$Type<($AutomationType)>, canInsert: $Predicate$$Type<($AutomationType)>, listener: $IContentsListener$$Type): $BasicEnergyContainer
public static "input"(maxEnergy: long, listener: $IContentsListener$$Type): $BasicEnergyContainer
public static "output"(maxEnergy: long, listener: $IContentsListener$$Type): $BasicEnergyContainer
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $Tag$$Type): void
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $CompoundTag$$Type): void
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "getMaxEnergy"(): long
public "onContentsChanged"(): void
public "getEnergy"(): long
public "setEnergy"(energy: long): void
public "setEmpty"(): void
public "getNeeded"(): long
get "empty"(): boolean
get "maxEnergy"(): long
get "energy"(): long
set "energy"(value: long)
get "needed"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicEnergyContainer$$Type = ($BasicEnergyContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicEnergyContainer_ = $BasicEnergyContainer$$Type;
}}
declare module "mekanism.common.lib.inventory.Finder" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export interface $Finder extends $Predicate<($ItemStack)> {

 "test"(arg0: $ItemStack$$Type): boolean
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>

(arg0: $ItemStack): boolean
}

export namespace $Finder {
const ANY: $Finder
const NONE: $Finder
function strict(itemType: $ItemStack$$Type): $Finder
function tag(tagName: string): $Finder
function item(itemType: $Item$$Type): $Finder
function item(itemType: $ItemStack$$Type): $Finder
function modID(modID: string): $Finder
function not<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
function isEqual<T>(arg0: any): $Predicate<($ItemStack)>
const probejs$$marker: never
}
export class $Finder$$Static implements $Finder {
static readonly "ANY": $Finder
static readonly "NONE": $Finder


static "strict"(itemType: $ItemStack$$Type): $Finder
static "tag"(tagName: string): $Finder
static "item"(itemType: $Item$$Type): $Finder
static "item"(itemType: $ItemStack$$Type): $Finder
static "modID"(modID: string): $Finder
 "test"(arg0: $ItemStack$$Type): boolean
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "not"<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "isEqual"<T>(arg0: any): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Finder$$Type = ((arg0: $ItemStack) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Finder_ = $Finder$$Type;
}}
declare module "mekanism.common.tile.TileEntityBoundingBlock" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$TileComponentUpgrade, $TileComponentUpgrade$$Type} from "mekanism.common.tile.component.TileComponentUpgrade"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RegisterCapabilitiesEvent, $RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$IUpgradeTile, $IUpgradeTile$$Type} from "mekanism.common.tile.interfaces.IUpgradeTile"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Nameable, $Nameable$$Type} from "net.minecraft.world.Nameable"
import {$TileEntityUpdateable, $TileEntityUpdateable$$Type} from "mekanism.common.tile.base.TileEntityUpdateable"
import {$Upgrade, $Upgrade$$Type} from "mekanism.api.Upgrade"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityBoundingBlock extends $TileEntityUpdateable implements $IUpgradeTile, $Nameable {
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(pos: $BlockPos$$Type, state: $BlockState$$Type)

public "getName"(): $Component
public "getDisplayName"(): $Component
public "getComponent"(): $TileComponentUpgrade
public "saveAdditional"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "loadAdditional"(nbt: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "hasCustomName"(): boolean
public "getCustomName"(): $Component
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "recalculateUpgrades"(upgradeType: $Upgrade$$Type): void
public "onNeighborChange"(block: $Block$$Type, neighborPos: $BlockPos$$Type): void
public "triggerEvent"(id: integer, param: integer): boolean
public "getComparatorSignal"(): integer
public "getMainTile"(): $BlockEntity
public "supportsUpgrades"(): boolean
public static "proxyCapability"<CAP>(event: $RegisterCapabilitiesEvent$$Type, capability: $BlockCapability$$Type<(CAP), ($Direction$$Type)>): void
public static "alwaysProxyCapability"<CAP, CONTEXT>(event: $RegisterCapabilitiesEvent$$Type, capability: $BlockCapability$$Type<(CAP), (CONTEXT)>): void
public "getMainPos"(): $BlockPos
public "setMainLocation"(pos: $BlockPos$$Type): void
public "hasReceivedCoords"(): boolean
public "supportsUpgrade"(upgradeType: $Upgrade$$Type): boolean
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
get "name"(): $Component
get "displayName"(): $Component
get "component"(): $TileComponentUpgrade
get "customName"(): $Component
get "comparatorSignal"(): integer
get "mainTile"(): $BlockEntity
get "mainPos"(): $BlockPos
set "mainLocation"(value: $BlockPos$$Type)
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityBoundingBlock$$Type = ($TileEntityBoundingBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityBoundingBlock_ = $TileEntityBoundingBlock$$Type;
}}
declare module "mekanism.common.block.prefab.BlockBase" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$Mob, $Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$ITypeBlock, $ITypeBlock$$Type} from "mekanism.common.block.interfaces.ITypeBlock"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockType, $BlockType$$Type} from "mekanism.common.content.blocktype.BlockType"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockMekanism, $BlockMekanism$$Type} from "mekanism.common.block.BlockMekanism"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IHasDescription, $IHasDescription$$Type} from "mekanism.common.block.interfaces.IHasDescription"
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$ILangEntry, $ILangEntry$$Type} from "mekanism.api.text.ILangEntry"
import {$Explosion, $Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$PathType, $PathType$$Type} from "net.minecraft.world.level.pathfinder.PathType"
import {$MutableComponent, $MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockBase<TYPE extends $BlockType> extends $BlockMekanism implements $IHasDescription, $ITypeBlock {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(type: TYPE, propertyModifier: $UnaryOperator$$Type<($BlockBehaviour$Properties)>)
constructor(type: TYPE, properties: $BlockBehaviour$Properties$$Type)

public "getName"(): $MutableComponent
public "getType"(): $BlockType
public "getDescription"(): $ILangEntry
public "getBlockPathType"(state: $BlockState$$Type, level: $BlockGetter$$Type, pos: $BlockPos$$Type, mob: $Mob$$Type): $PathType
public "getExplosionResistance"(state: $BlockState$$Type, world: $BlockGetter$$Type, pos: $BlockPos$$Type, explosion: $Explosion$$Type): float
public "asHolder"(): $Holder<(any)>
get "name"(): $MutableComponent
get "type"(): $BlockType
get "description"(): $ILangEntry
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBase$$Type<TYPE> = ($BlockBase<(TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBase_<TYPE> = $BlockBase$$Type<(TYPE)>;
}}
declare module "mekanism.common.inventory.container.slot.MainInventorySlot" {
import {$InsertableSlot, $InsertableSlot$$Type} from "mekanism.common.inventory.container.slot.InsertableSlot"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"

export class $MainInventorySlot extends $InsertableSlot {
readonly "slot": integer
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer
 "animationProgress": float

constructor(inventory: $Container$$Type, index: integer, x: integer, y: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MainInventorySlot$$Type = ($MainInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MainInventorySlot_ = $MainInventorySlot$$Type;
}}
declare module "mekanism.common.advancements.triggers.MekanismDamageTrigger$TriggerInstance" {
import {$Criterion, $Criterion$$Type} from "net.minecraft.advancements.Criterion"
import {$MekanismDamageTypes$MekanismDamageType, $MekanismDamageTypes$MekanismDamageType$$Type} from "mekanism.common.registries.MekanismDamageTypes$MekanismDamageType"
import {$ContextAwarePredicate, $ContextAwarePredicate$$Type} from "net.minecraft.advancements.critereon.ContextAwarePredicate"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$CriterionValidator, $CriterionValidator$$Type} from "net.minecraft.advancements.critereon.CriterionValidator"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$SimpleCriterionTrigger$SimpleInstance, $SimpleCriterionTrigger$SimpleInstance$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger$SimpleInstance"

export class $MekanismDamageTrigger$TriggerInstance extends $Record implements $SimpleCriterionTrigger$SimpleInstance {
static readonly "CODEC": $Codec<($MekanismDamageTrigger$TriggerInstance)>

constructor(player: $Optional$$Type<($ContextAwarePredicate$$Type)>, damageType: $MekanismDamageTypes$MekanismDamageType$$Type, killed: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "player"(): $Optional<($ContextAwarePredicate)>
public static "killed"(damageType: $MekanismDamageTypes$MekanismDamageType$$Type): $Criterion<($MekanismDamageTrigger$TriggerInstance)>
public "killed"(): boolean
public "damageType"(): $MekanismDamageTypes$MekanismDamageType
public static "damaged"(damageType: $MekanismDamageTypes$MekanismDamageType$$Type): $Criterion<($MekanismDamageTrigger$TriggerInstance)>
public "validate"(arg0: $CriterionValidator$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismDamageTrigger$TriggerInstance$$Type = ({"damageType"?: $MekanismDamageTypes$MekanismDamageType$$Type, "killed"?: boolean, "player"?: ($ContextAwarePredicate$$Type)?}) | ([damageType?: $MekanismDamageTypes$MekanismDamageType$$Type, killed?: boolean, player?: ($ContextAwarePredicate$$Type)?]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismDamageTrigger$TriggerInstance_ = $MekanismDamageTrigger$TriggerInstance$$Type;
}}
declare module "mekanism.common.block.basic.BlockChargepad" {
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$TileEntityChargepad, $TileEntityChargepad$$Type} from "mekanism.common.tile.TileEntityChargepad"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$$Type} from "mekanism.common.block.prefab.BlockTile$BlockTileModel"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockChargepad extends $BlockTile$BlockTileModel<($TileEntityChargepad), ($BlockTypeTile<($TileEntityChargepad)>)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor()

public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockChargepad$$Type = ($BlockChargepad);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockChargepad_ = $BlockChargepad$$Type;
}}
declare module "mekanism.common.item.ItemGaugeDropper" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$MergedTankCreator, $MergedTankCreator$$Type} from "mekanism.common.attachments.containers.chemical.merged.MergedTankCreator"

export class $ItemGaugeDropper extends $Item {
static readonly "MERGED_TANK_CREATOR": $MergedTankCreator
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "use"(world: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "getBarWidth"(stack: $ItemStack$$Type): integer
public "getBarColor"(stack: $ItemStack$$Type): integer
public "isBarVisible"(stack: $ItemStack$$Type): boolean
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemGaugeDropper$$Type = ($ItemGaugeDropper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemGaugeDropper_ = $ItemGaugeDropper$$Type;
}}
declare module "mekanism.common.block.interfaces.ITypeBlock" {
import {$BlockType, $BlockType$$Type} from "mekanism.common.content.blocktype.BlockType"

export interface $ITypeBlock {

 "getType"(): $BlockType

(): $BlockType$$Type
get "type"(): $BlockType
}

export namespace $ITypeBlock {
const probejs$$marker: never
}
export class $ITypeBlock$$Static implements $ITypeBlock {


 "getType"(): $BlockType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITypeBlock$$Type = (() => $BlockType$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITypeBlock_ = $ITypeBlock$$Type;
}}
declare module "mekanism.common.attachments.containers.fluid.ComponentBackedFluidHandler" {
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler$FluidAction"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$IExtendedFluidTank, $IExtendedFluidTank$$Type} from "mekanism.api.fluid.IExtendedFluidTank"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$IMekanismFluidHandler, $IMekanismFluidHandler$$Type} from "mekanism.api.fluid.IMekanismFluidHandler"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$AttachedFluids, $AttachedFluids$$Type} from "mekanism.common.attachments.containers.fluid.AttachedFluids"
import {$ComponentBackedHandler, $ComponentBackedHandler$$Type} from "mekanism.common.attachments.containers.ComponentBackedHandler"
import {$IFluidHandlerItem, $IFluidHandlerItem$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandlerItem"

export class $ComponentBackedFluidHandler extends $ComponentBackedHandler<($FluidStack), ($IExtendedFluidTank), ($AttachedFluids)> implements $IMekanismFluidHandler, $IFluidHandlerItem {

constructor(attachedTo: $ItemStack$$Type, totalTanks: integer)

public "getContainer"(): $ItemStack
public "getFluidTank"(tank: integer, side: $Direction$$Type): $IExtendedFluidTank
public "getTanks"(side: $Direction$$Type): integer
public "getFluidInTank"(tank: integer, side: $Direction$$Type): $FluidStack
public "getFluidTanks"(side: $Direction$$Type): $List<($IExtendedFluidTank)>
public "extractFluid"(stack: $FluidStack$$Type, side: $Direction$$Type, action: $Action$$Type): $FluidStack
public "extractFluid"(amount: integer, side: $Direction$$Type, action: $Action$$Type): $FluidStack
public "insertFluid"(stack: $FluidStack$$Type, side: $Direction$$Type, action: $Action$$Type): $FluidStack
public "getTankCapacity"(arg0: integer, arg1: $Direction$$Type): integer
public "isFluidValid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type): void
public "canHandleFluid"(): boolean
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Direction$$Type, arg3: $Action$$Type): $FluidStack
public "insertFluid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $FluidStack
public "getTanks"(): integer
public "getTankCapacity"(arg0: integer): integer
public "getFluidInTank"(arg0: integer): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$$Type): void
public "getFluidSideFor"(): $Direction
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Action$$Type): $FluidStack
public "insertFluid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Action$$Type): $FluidStack
public "fill"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): integer
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
public "drain"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
public "spliterator"(): $Spliterator<(T)>
public "extractFluid"(arg0: integer, arg1: $Action$$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$$Type, arg1: $Action$$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$$Type, arg1: $Action$$Type): $FluidStack
public "remove"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$$Type<(E)>): $List<(E)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$$Type<(E)>): boolean
public "removeAll"(arg0: $Collection$$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$$Type<(any)>): boolean
public "reversed"(): $SequencedCollection<(any)>
public "containsAll"(arg0: $Collection$$Type<(any)>): boolean
get "container"(): $ItemStack
get "tanks"(): integer
get "fluidSideFor"(): $Direction
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBackedFluidHandler$$Type = ($ComponentBackedFluidHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBackedFluidHandler_ = $ComponentBackedFluidHandler$$Type;
}}
declare module "mekanism.common.tile.TileEntityPersonalStorage" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"

export class $TileEntityPersonalStorage extends $TileEntityMekanism {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string


public "close"(player: $Player$$Type): void
public "open"(player: $Player$$Type): void
public "recheckOpen"(): void
public "openGui"(player: $Player$$Type): $InteractionResult
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityPersonalStorage$$Type = ($TileEntityPersonalStorage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityPersonalStorage_ = $TileEntityPersonalStorage$$Type;
}}
declare module "mekanism.common.content.oredictionificator.OredictionificatorFilter" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$BaseFilter, $BaseFilter$$Type} from "mekanism.common.content.filter.BaseFilter"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$IFilter, $IFilter$$Type} from "mekanism.common.content.filter.IFilter"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $OredictionificatorFilter<TYPE, STACK, FILTER extends $OredictionificatorFilter<(TYPE), (STACK), (FILTER)>> extends $BaseFilter<(FILTER)> {
static readonly "GENERIC_CODEC": $Codec<($IFilter<(any)>)>
static readonly "GENERIC_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IFilter<(any)>)>


public "equals"(o: any): boolean
public "hashCode"(): integer
public "clone"(): FILTER
public "next"(): void
public "previous"(): void
public "setFilter"(location: $ResourceLocation$$Type): void
public "getResult"(): STACK
public "checkValidity"(): void
public "hasFilter"(): boolean
public "getFilterText"(): string
public "filterMatches"(location: $ResourceLocation$$Type): boolean
public "flushCachedTag"(): void
public "setSelectedOutput"(output: $Holder$$Type<(TYPE)>): void
public "getResultElement"(): TYPE
public "computerSetFilter"(tag: $ResourceLocation$$Type): void
set "filter"(value: $ResourceLocation$$Type)
get "result"(): STACK
get "filterText"(): string
set "selectedOutput"(value: $Holder$$Type<(TYPE)>)
get "resultElement"(): TYPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OredictionificatorFilter$$Type<TYPE, STACK, FILTER> = ($OredictionificatorFilter<(TYPE), (STACK), (FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OredictionificatorFilter_<TYPE, STACK, FILTER> = $OredictionificatorFilter$$Type<(TYPE), (STACK), (FILTER)>;
}}
declare module "mekanism.common.inventory.container.MekanismContainer$ISpecificContainerTracker" {
import {$ISyncableData, $ISyncableData$$Type} from "mekanism.common.inventory.container.sync.ISyncableData"
import {$List, $List$$Type} from "java.util.List"

export interface $MekanismContainer$ISpecificContainerTracker {

 "getSpecificSyncableData"(): $List<($ISyncableData)>

(): $List$$Type<($ISyncableData$$Type)>
get "specificSyncableData"(): $List<($ISyncableData)>
}

export namespace $MekanismContainer$ISpecificContainerTracker {
const probejs$$marker: never
}
export class $MekanismContainer$ISpecificContainerTracker$$Static implements $MekanismContainer$ISpecificContainerTracker {


 "getSpecificSyncableData"(): $List<($ISyncableData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismContainer$ISpecificContainerTracker$$Type = (() => $List$$Type<($ISyncableData$$Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismContainer$ISpecificContainerTracker_ = $MekanismContainer$ISpecificContainerTracker$$Type;
}}
declare module "mekanism.common.inventory.container.slot.VirtualInventoryContainerSlot" {
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$SlotOverlay, $SlotOverlay$$Type} from "mekanism.common.inventory.container.slot.SlotOverlay"
import {$IVirtualSlot, $IVirtualSlot$$Type} from "mekanism.common.inventory.container.slot.IVirtualSlot"
import {$SelectedWindowData, $SelectedWindowData$$Type} from "mekanism.common.inventory.container.SelectedWindowData"
import {$InventoryContainerSlot, $InventoryContainerSlot$$Type} from "mekanism.common.inventory.container.slot.InventoryContainerSlot"
import {$IGUIWindow, $IGUIWindow$$Type} from "mekanism.common.inventory.container.IGUIWindow"
import {$BasicInventorySlot, $BasicInventorySlot$$Type} from "mekanism.common.inventory.slot.BasicInventorySlot"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$IntSupplier, $IntSupplier$$Type} from "java.util.function.IntSupplier"

export class $VirtualInventoryContainerSlot extends $InventoryContainerSlot implements $IVirtualSlot {
readonly "slot": integer
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer
 "animationProgress": float

constructor(slot: $BasicInventorySlot$$Type, windowData: $SelectedWindowData$$Type, slotOverlay: $SlotOverlay$$Type, uncheckedSetter: $Consumer$$Type<($ItemStack)>)

public "getSlot"(): $Slot
public "exists"(windowData: $SelectedWindowData$$Type): boolean
public "updateRenderInfo"(stackToRender: $ItemStack$$Type, shouldDrawOverlay: boolean, tooltipOverride: string): void
public "getStackToRender"(): $ItemStack
public "getTooltipOverride"(): string
public "getLinkedWindow"(): $IGUIWindow
public "shouldDrawOverlay"(): boolean
public "updatePosition"(window: $IGUIWindow$$Type, xPositionSupplier: $IntSupplier$$Type, yPositionSupplier: $IntSupplier$$Type): void
public "getActualX"(): integer
public "getActualY"(): integer
get "slot"(): $Slot
get "stackToRender"(): $ItemStack
get "tooltipOverride"(): string
get "linkedWindow"(): $IGUIWindow
get "actualX"(): integer
get "actualY"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualInventoryContainerSlot$$Type = ($VirtualInventoryContainerSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VirtualInventoryContainerSlot_ = $VirtualInventoryContainerSlot$$Type;
}}
declare module "mekanism.common.content.blocktype.Factory" {
import {$Machine$FactoryMachine, $Machine$FactoryMachine$$Type} from "mekanism.common.content.blocktype.Machine$FactoryMachine"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$$Type} from "mekanism.common.registration.impl.TileEntityTypeRegistryObject"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ContainerTypeRegistryObject, $ContainerTypeRegistryObject$$Type} from "mekanism.common.registration.impl.ContainerTypeRegistryObject"
import {$TileEntityFactory, $TileEntityFactory$$Type} from "mekanism.common.tile.factory.TileEntityFactory"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$FactoryTier, $FactoryTier$$Type} from "mekanism.common.tier.FactoryTier"

export class $Factory<TILE extends $TileEntityFactory<(any)>> extends $Machine$FactoryMachine<(TILE)> {

constructor(tileEntityRegistrar: $Supplier$$Type<($TileEntityTypeRegistryObject$$Type<(TILE)>)>, containerRegistrar: $Supplier$$Type<($ContainerTypeRegistryObject$$Type<($MekanismContainer$$Type)>)>, origMachine: $Machine$FactoryMachine$$Type<(any)>, tier: $FactoryTier$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Factory$$Type<TILE> = ($Factory<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Factory_<TILE> = $Factory$$Type<(TILE)>;
}}
declare module "mekanism.common.block.BlockCardboardBox" {
import {$BlockEntityTicker, $BlockEntityTicker$$Type} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockMekanism, $BlockMekanism$$Type} from "mekanism.common.block.BlockMekanism"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$TileEntityCardboardBox, $TileEntityCardboardBox$$Type} from "mekanism.common.tile.TileEntityCardboardBox"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IHasTileEntity, $IHasTileEntity$$Type} from "mekanism.common.block.interfaces.IHasTileEntity"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$$Type} from "mekanism.common.registration.impl.TileEntityTypeRegistryObject"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IStateStorage, $IStateStorage$$Type} from "mekanism.common.block.states.IStateStorage"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$GameEventListener, $GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockCardboardBox extends $BlockMekanism implements $IStateStorage, $IHasTileEntity<($TileEntityCardboardBox)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor()

public "getStateForPlacement"(context: $BlockPlaceContext$$Type): $BlockState
public "getTileType"(): $TileEntityTypeRegistryObject<($TileEntityCardboardBox)>
public "getTicker"<T extends $BlockEntity>(level: $Level$$Type, state: $BlockState$$Type, blockEntityType: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(pos: $BlockPos$$Type, state: $BlockState$$Type): $TileEntityCardboardBox
public "triggerBlockEntityEvent"(state: $BlockState$$Type, level: $Level$$Type, pos: $BlockPos$$Type, id: integer, param: integer): boolean
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "asHolder"(): $Holder<(any)>
get "tileType"(): $TileEntityTypeRegistryObject<($TileEntityCardboardBox)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockCardboardBox$$Type = ($BlockCardboardBox);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockCardboardBox_ = $BlockCardboardBox$$Type;
}}
declare module "mekanism.common.content.transporter.TransporterStack" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$LongList, $LongList$$Type} from "it.unimi.dsi.fastutil.longs.LongList"
import {$LogisticalTransporterBase, $LogisticalTransporterBase$$Type} from "mekanism.common.content.network.transmitter.LogisticalTransporterBase"
import {$TransitRequest, $TransitRequest$$Type} from "mekanism.common.lib.inventory.TransitRequest"
import {$TransporterStack$Path, $TransporterStack$Path$$Type} from "mekanism.common.content.transporter.TransporterStack$Path"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$EnumColor, $EnumColor$$Type} from "mekanism.api.text.EnumColor"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$$Type} from "mekanism.common.lib.inventory.TransitRequest$TransitResponse"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Set, $Set$$Type} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$IAdvancedTransportEjector, $IAdvancedTransportEjector$$Type} from "mekanism.common.lib.inventory.IAdvancedTransportEjector"

export class $TransporterStack {
static "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($TransporterStack)>
 "itemStack": $ItemStack
 "progress": integer
 "color": $EnumColor
 "initiatedPath": boolean
 "idleDir": $Direction
 "originalLocation": $BlockPos
 "homeLocation": $BlockPos

constructor()

public "isFinal"(transporter: $LogisticalTransporterBase$$Type): boolean
public "write"(provider: $HolderLookup$Provider$$Type, nbtTags: $CompoundTag$$Type): void
public "read"(provider: $HolderLookup$Provider$$Type, nbtTags: $CompoundTag$$Type): void
public "getPath"(): $LongList
public "getNext"(transporter: $LogisticalTransporterBase$$Type): long
public "getSide"(transporter: $LogisticalTransporterBase$$Type): $Direction
public "getSide"(pos: $BlockPos$$Type, target: long): $Direction
public "hasPath"(): boolean
public "readFromUpdateTag"(provider: $HolderLookup$Provider$$Type, updateTag: $CompoundTag$$Type): void
public "getPathType"(): $TransporterStack$Path
public static "readFromNBT"(provider: $HolderLookup$Provider$$Type, nbtTags: $CompoundTag$$Type): $TransporterStack
public "getPrev"(transporter: $LogisticalTransporterBase$$Type): long
public "canInsertToTransporter"(transmitter: $LogisticalTransporterBase$$Type, from: $Direction$$Type, transporterFrom: $LogisticalTransporterBase$$Type): boolean
public "canInsertToTransporterNN"(transporter: $LogisticalTransporterBase$$Type, from: $Direction$$Type, tileFrom: $BlockEntity$$Type): boolean
public "canInsertToTransporterNN"(transporter: $LogisticalTransporterBase$$Type, from: $Direction$$Type, transporterFrom: $LogisticalTransporterBase$$Type): boolean
public "getDest"(): long
public "writeToUpdateTag"(provider: $HolderLookup$Provider$$Type, transporter: $LogisticalTransporterBase$$Type, updateTag: $CompoundTag$$Type): void
public static "readFromUpdate"(provider: $HolderLookup$Provider$$Type, nbtTags: $CompoundTag$$Type): $TransporterStack
public "recalculatePath"(request: $TransitRequest$$Type, transporter: $LogisticalTransporterBase$$Type, min: integer): $TransitRequest$TransitResponse
public "recalculatePath"(request: $TransitRequest$$Type, transporter: $LogisticalTransporterBase$$Type, min: integer, updateFlowing: boolean): $TransitRequest$TransitResponse
public "recalculatePath"(request: $TransitRequest$$Type, ignored: $BlockEntity$$Type, transporter: $LogisticalTransporterBase$$Type, min: integer, updateFlowing: boolean): $TransitRequest$TransitResponse
public "recalculatePath"(request: $TransitRequest$$Type, transporter: $LogisticalTransporterBase$$Type, min: integer, additionalFlowingStacks: $Map$$Type<($GlobalPos$$Type), ($Set$$Type<($TransporterStack$$Type)>)>): $TransitRequest$TransitResponse
public "recalculateRRPath"<BE extends ($BlockEntity) & ($IAdvancedTransportEjector)>(request: $TransitRequest$$Type, outputter: BE, transporter: $LogisticalTransporterBase$$Type, min: integer, updateFlowing: boolean): $TransitRequest$TransitResponse
public "recalculateRRPath"<BE extends ($BlockEntity) & ($IAdvancedTransportEjector)>(request: $TransitRequest$$Type, outputter: BE, transporter: $LogisticalTransporterBase$$Type, min: integer): $TransitRequest$TransitResponse
public "calculateIdle"(transporter: $LogisticalTransporterBase$$Type): boolean
public "getSideOfDest"(): $Direction
public "updateForPos"(pos: $BlockPos$$Type): $TransporterStack
get "path"(): $LongList
get "pathType"(): $TransporterStack$Path
get "dest"(): long
get "sideOfDest"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransporterStack$$Type = ($TransporterStack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransporterStack_ = $TransporterStack$$Type;
}}
declare module "mekanism.common.network.to_client.container.property.PropertyType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ISyncableData, $ISyncableData$$Type} from "mekanism.common.inventory.container.sync.ISyncableData"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$PropertyData, $PropertyData$$Type} from "mekanism.common.network.to_client.container.property.PropertyData"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $PropertyType extends $Enum<($PropertyType)> {
static readonly "BOOLEAN": $PropertyType
static readonly "BYTE": $PropertyType
static readonly "DOUBLE": $PropertyType
static readonly "FLOAT": $PropertyType
static readonly "INT": $PropertyType
static readonly "LONG": $PropertyType
static readonly "SHORT": $PropertyType
static readonly "BYTE_ARRAY": $PropertyType
static readonly "ITEM_STACK": $PropertyType
static readonly "FLUID_STACK": $PropertyType
static readonly "CHEMICAL_STACK": $PropertyType
static readonly "BLOCK_POS": $PropertyType
static readonly "BY_ID": $IntFunction<($PropertyType)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($PropertyType)>


public static "values"(): ($PropertyType)[]
public static "valueOf"(name: string): $PropertyType
public "getDefault"<T>(): T
public "create"(supplier: $Supplier$$Type<(any)>, consumer: $Consumer$$Type<(any)>): $ISyncableData
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($PropertyData)>
public static "getFromType"(type: $Class$$Type<(any)>): $PropertyType
get "default"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyType$$Type = (("boolean") | ("byte") | ("double") | ("float") | ("int") | ("long") | ("short") | ("byte_array") | ("item_stack") | ("fluid_stack") | ("chemical_stack") | ("block_pos"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyType_ = $PropertyType$$Type;
}}
declare module "mekanism.common.registration.MekanismDeferredRegister" {
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$MekanismDeferredHolder, $MekanismDeferredHolder$$Type} from "mekanism.common.registration.MekanismDeferredHolder"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$DeferredRegister, $DeferredRegister$$Type} from "net.neoforged.neoforge.registries.DeferredRegister"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$DeferredHolder, $DeferredHolder$$Type} from "net.neoforged.neoforge.registries.DeferredHolder"

export class $MekanismDeferredRegister<T> extends $DeferredRegister<(T)> {

constructor(registryKey: $ResourceKey$$Type<($Registry<(T)>)>, namespace: string)
constructor(registryKey: $ResourceKey$$Type<($Registry<(T)>)>, namespace: string, holderCreator: $Function$$Type<($ResourceKey<(T)>), ($MekanismDeferredHolder$$Type<(T), (T)>)>)

public "register"(name: string, sup: $Supplier$$Type<(any)>): $DeferredHolder<(any), (any)>
public "register"(name: string, func: $Function$$Type<(any), (any)>): $DeferredHolder<(any), (any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismDeferredRegister$$Type<T> = ($MekanismDeferredRegister<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismDeferredRegister_<T> = $MekanismDeferredRegister$$Type<(T)>;
}}
declare module "mekanism.common.item.block.transmitter.ItemBlockPressurizedTube" {
import {$TileEntityPressurizedTube, $TileEntityPressurizedTube$$Type} from "mekanism.common.tile.transmitter.TileEntityPressurizedTube"
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockSmallTransmitter, $BlockSmallTransmitter$$Type} from "mekanism.common.block.transmitter.BlockSmallTransmitter"

export class $ItemBlockPressurizedTube extends $ItemBlockTooltip<($BlockSmallTransmitter<($TileEntityPressurizedTube)>)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockSmallTransmitter$$Type<($TileEntityPressurizedTube$$Type)>, properties: $Item$Properties$$Type)

public "getTier"(): $ITier
get "tier"(): $ITier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockPressurizedTube$$Type = ($ItemBlockPressurizedTube);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockPressurizedTube_ = $ItemBlockPressurizedTube$$Type;
}}
declare module "mekanism.common.advancements.triggers.UseGaugeDropperTrigger$UseDropperAction" {
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"

export class $UseGaugeDropperTrigger$UseDropperAction extends $Enum<($UseGaugeDropperTrigger$UseDropperAction)> implements $StringRepresentable {
static readonly "ANY": $UseGaugeDropperTrigger$UseDropperAction
static readonly "FILL": $UseGaugeDropperTrigger$UseDropperAction
static readonly "DRAIN": $UseGaugeDropperTrigger$UseDropperAction
static readonly "DUMP": $UseGaugeDropperTrigger$UseDropperAction
static readonly "CODEC": $Codec<($UseGaugeDropperTrigger$UseDropperAction)>


public static "values"(): ($UseGaugeDropperTrigger$UseDropperAction)[]
public static "valueOf"(name: string): $UseGaugeDropperTrigger$UseDropperAction
public "getSerializedName"(): string
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UseGaugeDropperTrigger$UseDropperAction$$Type = (("any") | ("fill") | ("drain") | ("dump"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UseGaugeDropperTrigger$UseDropperAction_ = $UseGaugeDropperTrigger$UseDropperAction$$Type;
}}
declare module "mekanism.common.inventory.container.slot.ContainerSlotType" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $ContainerSlotType extends $Enum<($ContainerSlotType)> {
static readonly "IGNORED": $ContainerSlotType
static readonly "NORMAL": $ContainerSlotType
static readonly "POWER": $ContainerSlotType
static readonly "INPUT": $ContainerSlotType
static readonly "EXTRA": $ContainerSlotType
static readonly "OUTPUT": $ContainerSlotType
static readonly "VALIDITY": $ContainerSlotType


public static "values"(): ($ContainerSlotType)[]
public static "valueOf"(name: string): $ContainerSlotType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerSlotType$$Type = (("ignored") | ("normal") | ("power") | ("input") | ("extra") | ("output") | ("validity"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContainerSlotType_ = $ContainerSlotType$$Type;
}}
declare module "mekanism.common.item.block.machine.ItemBlockLaserTractorBeam" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemBlockLaserTractorBeam extends $ItemBlockTooltip<($BlockTile<(any), (any)>)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockTile$$Type<(any), (any)>, properties: $Item$Properties$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockLaserTractorBeam$$Type = ($ItemBlockLaserTractorBeam);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockLaserTractorBeam_ = $ItemBlockLaserTractorBeam$$Type;
}}
declare module "mekanism.common.item.gear.ItemHDPEElytra" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Equipable, $Equipable$$Type} from "net.minecraft.world.item.Equipable"
import {$ElytraItem, $ElytraItem$$Type} from "net.minecraft.world.item.ElytraItem"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemHDPEElytra extends $ElytraItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "getEquipmentSlot"(stack: $ItemStack$$Type): $EquipmentSlot
public "isValidRepairItem"(toRepair: $ItemStack$$Type, repair: $ItemStack$$Type): boolean
public static "get"(arg0: $ItemStack$$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemHDPEElytra$$Type = ($ItemHDPEElytra);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemHDPEElytra_ = $ItemHDPEElytra$$Type;
}}
declare module "mekanism.common.item.block.ItemBlockSecurityDesk" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$TileEntitySecurityDesk, $TileEntitySecurityDesk$$Type} from "mekanism.common.tile.TileEntitySecurityDesk"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$$Type} from "mekanism.common.block.prefab.BlockTile$BlockTileModel"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"

export class $ItemBlockSecurityDesk extends $ItemBlockTooltip<($BlockTile$BlockTileModel<($TileEntitySecurityDesk), ($BlockTypeTile<($TileEntitySecurityDesk)>)>)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockTile$BlockTileModel$$Type<($TileEntitySecurityDesk$$Type), ($BlockTypeTile$$Type<($TileEntitySecurityDesk$$Type)>)>, properties: $Item$Properties$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockSecurityDesk$$Type = ($ItemBlockSecurityDesk);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockSecurityDesk_ = $ItemBlockSecurityDesk$$Type;
}}
declare module "mekanism.common.integration.computer.BaseComputerHelper" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$IFilter, $IFilter$$Type} from "mekanism.common.content.filter.IFilter"
import {$MinerFilter, $MinerFilter$$Type} from "mekanism.common.content.miner.MinerFilter"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$Vec3i, $Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$SorterFilter, $SorterFilter$$Type} from "mekanism.common.content.transporter.SorterFilter"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$MethodHelpData, $MethodHelpData$$Type} from "mekanism.common.integration.computer.MethodHelpData"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$Lazy, $Lazy$$Type} from "net.neoforged.neoforge.common.util.Lazy"
import {$OredictionificatorFilter, $OredictionificatorFilter$$Type} from "mekanism.common.content.oredictionificator.OredictionificatorFilter"
import {$Convertable, $Convertable$$Type} from "mekanism.common.integration.computer.Convertable"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$QIOFilter, $QIOFilter$$Type} from "mekanism.common.content.qio.filter.QIOFilter"
import {$TableType, $TableType$$Type} from "mekanism.common.integration.computer.TableType"

export class $BaseComputerHelper {
static readonly "BUILTIN_TABLES": $Lazy<($Map<($Class<(any)>), ($TableType)>)>

constructor()

public "getBoolean"(param: integer): boolean
public "getByte"(param: integer): byte
public "getShort"(param: integer): short
public "getChar"(param: integer): character
public "getInt"(param: integer): integer
public "getLong"(param: integer): long
public "getFloat"(param: integer): float
public "getDouble"(param: integer): double
public "convert"(globalPos: $GlobalPos$$Type): any
public "convert"(pos: $Vec3i$$Type): any
public "convert"(state: $BlockState$$Type): any
public "convert"(frequency: $Frequency$$Type): any
public "convert"(res: $Enum$$Type<(any)>): any
public "convert"(uuid: $UUID$$Type): any
public "convert"(stack: $ChemicalStack$$Type): any
public "convert"(stack: $FluidStack$$Type): any
public "convert"(stack: $ItemStack$$Type): any
public "convert"<KEY, VALUE>(res: $Map$$Type<(KEY), (VALUE)>, keyConverter: $Function$$Type<(KEY), (any)>, valueConverter: $Function$$Type<(VALUE), (any)>): any
public "convert"(item: $Item$$Type): any
public "convert"(convertable: $Convertable$$Type<(any)>): any
public "convert"(methodHelpData: $MethodHelpData$$Type): any
public "convert"(minerFilter: $MinerFilter$$Type<(any)>): any
public "convert"(sorterFilter: $SorterFilter$$Type<(any)>): any
public "convert"(qioFilter: $QIOFilter$$Type<(any)>): any
public "convert"(filter: $OredictionificatorFilter$$Type<(any), (any), (any)>): any
public "convert"(d: double): any
public "convert"(i: long): any
public "convert"(i: integer): any
public "convert"(rl: $ResourceLocation$$Type): any
public "convert"<T>(list: $Collection$$Type<(T)>, converter: $Function$$Type<(T), (any)>): any
public "convert"(b: boolean): any
public "convert"(s: string): any
public "getMap"(param: integer): $Map<(any), (any)>
public static "convertType"(clazz: $Class$$Type<(any)>): $Class<(any)>
public "getFilter"<FILTER extends $IFilter<(FILTER)>>(param: integer, expectedType: $Class$$Type<(FILTER)>): FILTER
public "getString"(param: integer): string
public "getItem"(param: integer): $Item
public "getEnum"<T extends $Enum<(T)>>(param: integer, enumClazz: $Class$$Type<(T)>): T
public "getResourceLocation"(param: integer): $ResourceLocation
public "getItemStack"(param: integer): $ItemStack
public "voidResult"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseComputerHelper$$Type = ($BaseComputerHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseComputerHelper_ = $BaseComputerHelper$$Type;
}}
declare module "mekanism.common.item.ItemAlloy" {
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$UseOnContext, $UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$AlloyTier, $AlloyTier$$Type} from "mekanism.api.tier.AlloyTier"

export class $ItemAlloy extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(tier: $AlloyTier$$Type, properties: $Item$Properties$$Type)

public "getTier"(): $AlloyTier
public "useOn"(context: $UseOnContext$$Type): $InteractionResult
get "tier"(): $AlloyTier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemAlloy$$Type = ($ItemAlloy);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemAlloy_ = $ItemAlloy$$Type;
}}
declare module "mekanism.common.tile.laser.TileEntityLaserReceptor" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$TileEntityBasicLaser, $TileEntityBasicLaser$$Type} from "mekanism.common.tile.laser.TileEntityBasicLaser"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ILaserReceptor, $ILaserReceptor$$Type} from "mekanism.api.lasers.ILaserReceptor"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityLaserReceptor extends $TileEntityBasicLaser implements $ILaserReceptor {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "canLasersDig"(): boolean
public "receiveLaserEnergy"(energy: long): void
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityLaserReceptor$$Type = ($TileEntityLaserReceptor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityLaserReceptor_ = $TileEntityLaserReceptor$$Type;
}}
declare module "mekanism.common.attachments.containers.fluid.ComponentBackedFluidTank" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler$FluidAction"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IExtendedFluidTank, $IExtendedFluidTank$$Type} from "mekanism.api.fluid.IExtendedFluidTank"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IntSupplier, $IntSupplier$$Type} from "java.util.function.IntSupplier"
import {$AttachedFluids, $AttachedFluids$$Type} from "mekanism.common.attachments.containers.fluid.AttachedFluids"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ComponentBackedContainer, $ComponentBackedContainer$$Type} from "mekanism.common.attachments.containers.ComponentBackedContainer"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"

export class $ComponentBackedFluidTank extends $ComponentBackedContainer<($FluidStack), ($AttachedFluids)> implements $IExtendedFluidTank {

constructor(attachedTo: $ItemStack$$Type, tankIndex: integer, canExtract: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, canInsert: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, validator: $Predicate$$Type<($FluidStack)>, rate: $IntSupplier$$Type, capacity: $IntSupplier$$Type)

public "extract"(amount: integer, action: $Action$$Type, automationType: $AutomationType$$Type): $FluidStack
public "insert"(stack: $FluidStack$$Type, action: $Action$$Type, automationType: $AutomationType$$Type): $FluidStack
public "setStack"(stack: $FluidStack$$Type): void
public "getCapacity"(): integer
/**
 * 
 * @deprecated
 */
public "drain"(stack: $FluidStack$$Type, action: $IFluidHandler$FluidAction$$Type): $FluidStack
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "setStackSize"(amount: integer, action: $Action$$Type): integer
public "getFluid"(): $FluidStack
public "isFluidValid"(stack: $FluidStack$$Type): boolean
public "setStackUnchecked"(stack: $FluidStack$$Type): void
public "growStack"(amount: integer, action: $Action$$Type): integer
public "isEmpty"(): boolean
/**
 * 
 * @deprecated
 */
public "fill"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): integer
public "setEmpty"(): void
/**
 * 
 * @deprecated
 */
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
public "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): void
public "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $Tag$$Type): void
public "getNeeded"(): integer
public "getFluidAmount"(): integer
public "shrinkStack"(arg0: integer, arg1: $Action$$Type): integer
public "isFluidEqual"(arg0: $FluidStack$$Type): boolean
set "stack"(value: $FluidStack$$Type)
get "capacity"(): integer
get "fluid"(): $FluidStack
set "stackUnchecked"(value: $FluidStack$$Type)
get "empty"(): boolean
get "needed"(): integer
get "fluidAmount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBackedFluidTank$$Type = ($ComponentBackedFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBackedFluidTank_ = $ComponentBackedFluidTank$$Type;
}}
declare module "mekanism.common.lib.SidedBlockPos" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$TransporterPathfinder$Destination, $TransporterPathfinder$Destination$$Type} from "mekanism.common.content.transporter.TransporterPathfinder$Destination"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $SidedBlockPos extends $Record {

constructor(pos: long, side: $Direction$$Type)

public static "get"(destination: $TransporterPathfinder$Destination$$Type): $SidedBlockPos
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "pos"(): long
public static "deserialize"(tag: $CompoundTag$$Type): $SidedBlockPos
public "serialize"(): $CompoundTag
public "side"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SidedBlockPos$$Type = ({"side"?: $Direction$$Type, "pos"?: long}) | ([side?: $Direction$$Type, pos?: long]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SidedBlockPos_ = $SidedBlockPos$$Type;
}}
declare module "mekanism.common.item.block.machine.ItemBlockTeleporter" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"
import {$IFrequencyItem, $IFrequencyItem$$Type} from "mekanism.common.lib.frequency.IFrequencyItem"

export class $ItemBlockTeleporter extends $ItemBlockTooltip<($BlockTile<(any), (any)>)> implements $IFrequencyItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockTile$$Type<(any), (any)>, properties: $Item$Properties$$Type)

public "getFrequencyType"(): $FrequencyType<(any)>
get "frequencyType"(): $FrequencyType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockTeleporter$$Type = ($ItemBlockTeleporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockTeleporter_ = $ItemBlockTeleporter$$Type;
}}
declare module "mekanism.common.inventory.container.sync.ISyncableData" {
import {$ISyncableData$DirtyType, $ISyncableData$DirtyType$$Type} from "mekanism.common.inventory.container.sync.ISyncableData$DirtyType"
import {$PropertyData, $PropertyData$$Type} from "mekanism.common.network.to_client.container.property.PropertyData"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export interface $ISyncableData {

 "isDirty"(): $ISyncableData$DirtyType
 "getPropertyData"(registryAccess: $RegistryAccess$$Type, property: short, dirtyType: $ISyncableData$DirtyType$$Type): $PropertyData
get "dirty"(): boolean
}

export namespace $ISyncableData {
const probejs$$marker: never
}
export class $ISyncableData$$Static implements $ISyncableData {


 "isDirty"(): $ISyncableData$DirtyType
 "getPropertyData"(registryAccess: $RegistryAccess$$Type, property: short, dirtyType: $ISyncableData$DirtyType$$Type): $PropertyData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISyncableData$$Type = ($ISyncableData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISyncableData_ = $ISyncableData$$Type;
}}
declare module "mekanism.common.tile.interfaces.ITileDirectional" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"

export interface $ITileDirectional {

 "isDirectional"(): boolean
 "getDirection"(): $Direction
 "getOppositeDirection"(): $Direction
 "setFacing"(direction: $Direction$$Type): void
 "getLeftSide"(): $Direction
 "getRightSide"(): $Direction
get "directional"(): boolean
get "direction"(): $Direction
get "oppositeDirection"(): $Direction
set "facing"(value: $Direction$$Type)
get "leftSide"(): $Direction
get "rightSide"(): $Direction
}

export namespace $ITileDirectional {
const probejs$$marker: never
}
export class $ITileDirectional$$Static implements $ITileDirectional {


 "isDirectional"(): boolean
 "getDirection"(): $Direction
 "getOppositeDirection"(): $Direction
 "setFacing"(direction: $Direction$$Type): void
 "getLeftSide"(): $Direction
 "getRightSide"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileDirectional$$Type = ($ITileDirectional);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileDirectional_ = $ITileDirectional$$Type;
}}
declare module "mekanism.common.item.ItemUpgrade" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$IUpgradeItem, $IUpgradeItem$$Type} from "mekanism.common.item.interfaces.IUpgradeItem"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Upgrade, $Upgrade$$Type} from "mekanism.api.Upgrade"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$UseOnContext, $UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"

export class $ItemUpgrade extends $Item implements $IUpgradeItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(type: $Upgrade$$Type, properties: $Item$Properties$$Type)

public "getUpgradeType"(stack: $ItemStack$$Type): $Upgrade
public "useOn"(context: $UseOnContext$$Type): $InteractionResult
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemUpgrade$$Type = ($ItemUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemUpgrade_ = $ItemUpgrade$$Type;
}}
declare module "mekanism.common.content.gear.IBlastingItem" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $IBlastingItem {

 "getBlastedBlocks"(world: $Level$$Type, player: $Player$$Type, stack: $ItemStack$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type): $Map<($BlockPos), ($BlockState)>

(world: $Level, player: $Player, stack: $ItemStack, pos: $BlockPos, state: $BlockState): $Map$$Type<($BlockPos$$Type), ($BlockState$$Type)>
}

export namespace $IBlastingItem {
function canBlastBlock(world: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type): boolean
function findPositions(world: $Level$$Type, targetPos: $BlockPos$$Type, player: $Player$$Type, radius: integer): $Map<($BlockPos), ($BlockState)>
const probejs$$marker: never
}
export class $IBlastingItem$$Static implements $IBlastingItem {


 "getBlastedBlocks"(world: $Level$$Type, player: $Player$$Type, stack: $ItemStack$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type): $Map<($BlockPos), ($BlockState)>
static "canBlastBlock"(world: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type): boolean
static "findPositions"(world: $Level$$Type, targetPos: $BlockPos$$Type, player: $Player$$Type, radius: integer): $Map<($BlockPos), ($BlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IBlastingItem$$Type = ((world: $Level, player: $Player, stack: $ItemStack, pos: $BlockPos, state: $BlockState) => $Map$$Type<($BlockPos$$Type), ($BlockState$$Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IBlastingItem_ = $IBlastingItem$$Type;
}}
declare module "mekanism.common.tile.interfaces.ITileRedstone" {
import {$IRedstoneControl, $IRedstoneControl$$Type} from "mekanism.common.tile.interfaces.IRedstoneControl"
import {$IRedstoneControl$RedstoneControl, $IRedstoneControl$RedstoneControl$$Type} from "mekanism.common.tile.interfaces.IRedstoneControl$RedstoneControl"

export interface $ITileRedstone extends $IRedstoneControl {

 "supportsRedstone"(): boolean
 "supportsMode"(mode: $IRedstoneControl$RedstoneControl$$Type): boolean
 "onPowerChange"(): void
 "wasPowered"(): boolean
 "isPowered"(): boolean
 "setControlType"(type: $IRedstoneControl$RedstoneControl$$Type): void
 "getControlType"(): $IRedstoneControl$RedstoneControl
get "powered"(): boolean
set "controlType"(value: $IRedstoneControl$RedstoneControl$$Type)
get "controlType"(): $IRedstoneControl$RedstoneControl
}

export namespace $ITileRedstone {
const probejs$$marker: never
}
export class $ITileRedstone$$Static implements $ITileRedstone {


 "supportsRedstone"(): boolean
 "supportsMode"(mode: $IRedstoneControl$RedstoneControl$$Type): boolean
 "onPowerChange"(): void
 "wasPowered"(): boolean
 "isPowered"(): boolean
 "setControlType"(type: $IRedstoneControl$RedstoneControl$$Type): void
 "getControlType"(): $IRedstoneControl$RedstoneControl
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileRedstone$$Type = ($ITileRedstone);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileRedstone_ = $ITileRedstone$$Type;
}}
declare module "mekanism.common.recipe.WrappedShapedRecipe" {
import {$CraftingInput, $CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ShapedRecipePattern, $ShapedRecipePattern$$Type} from "net.minecraft.world.item.crafting.ShapedRecipePattern"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$ShapedRecipe, $ShapedRecipe$$Type} from "net.minecraft.world.item.crafting.ShapedRecipe"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $WrappedShapedRecipe extends $ShapedRecipe {
readonly "pattern": $ShapedRecipePattern
readonly "result": $ItemStack
readonly "group": string


public "matches"(input: $RecipeInput$$Type, world: $Level$$Type): boolean
public "matches"(input: $CraftingInput$$Type, world: $Level$$Type): boolean
public "getWidth"(): integer
public "canCraftInDimensions"(width: integer, height: integer): boolean
public "getHeight"(): integer
public "getInternal"(): $ShapedRecipe
public "getRemainingItems"(input: $RecipeInput$$Type): $NonNullList<(any)>
public "getRemainingItems"(input: $CraftingInput$$Type): $NonNullList<($ItemStack)>
public "isSpecial"(): boolean
public "assemble"(input: $RecipeInput$$Type, provider: $HolderLookup$Provider$$Type): $ItemStack
public "assemble"(input: $CraftingInput$$Type, provider: $HolderLookup$Provider$$Type): $ItemStack
public "getResultItem"(provider: $HolderLookup$Provider$$Type): $ItemStack
public "isIncomplete"(): boolean
public "getIngredients"(): $NonNullList<($Ingredient)>
public "getToastSymbol"(): $ItemStack
get "width"(): integer
get "height"(): integer
get "internal"(): $ShapedRecipe
get "special"(): boolean
get "incomplete"(): boolean
get "ingredients"(): $NonNullList<($Ingredient)>
get "toastSymbol"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedShapedRecipe$$Type = ($WrappedShapedRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedShapedRecipe_ = $WrappedShapedRecipe$$Type;
}}
declare module "mekanism.common.tile.multiblock.TileEntityInductionCell" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$MachineEnergyContainer, $MachineEnergyContainer$$Type} from "mekanism.common.capabilities.energy.MachineEnergyContainer"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$TileEntityInternalMultiblock, $TileEntityInternalMultiblock$$Type} from "mekanism.common.tile.prefab.TileEntityInternalMultiblock"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$InductionCellTier, $InductionCellTier$$Type} from "mekanism.common.tier.InductionCellTier"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityInductionCell extends $TileEntityInternalMultiblock {
 "tier": $InductionCellTier
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "getEnergyContainer"(): $MachineEnergyContainer<($TileEntityInductionCell)>
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "energyContainer"(): $MachineEnergyContainer<($TileEntityInductionCell)>
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityInductionCell$$Type = ($TileEntityInductionCell);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityInductionCell_ = $TileEntityInductionCell$$Type;
}}
declare module "mekanism.common.inventory.container.IGUIWindow" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IGUIWindow {

}

export namespace $IGUIWindow {
const probejs$$marker: never
}
export class $IGUIWindow$$Static implements $IGUIWindow {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGUIWindow$$Type = ($IGUIWindow);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGUIWindow_ = $IGUIWindow$$Type;
}}
declare module "mekanism.common.recipe.lookup.monitor.RecipeCacheLookupMonitor" {
import {$IEnergyContainer, $IEnergyContainer$$Type} from "mekanism.api.energy.IEnergyContainer"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$IRecipeLookupHandler, $IRecipeLookupHandler$$Type} from "mekanism.common.recipe.lookup.IRecipeLookupHandler"
import {$CachedRecipe, $CachedRecipe$$Type} from "mekanism.api.recipes.cache.CachedRecipe"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$ICachedRecipeHolder, $ICachedRecipeHolder$$Type} from "mekanism.api.recipes.cache.ICachedRecipeHolder"

export class $RecipeCacheLookupMonitor<RECIPE extends $MekanismRecipe<(any)>> implements $ICachedRecipeHolder<(RECIPE)>, $IContentsListener {

constructor(handler: $IRecipeLookupHandler$$Type<(RECIPE)>)
constructor(handler: $IRecipeLookupHandler$$Type<(RECIPE)>, cacheIndex: integer)

public "onChange"(): void
public "hasNoRecipe"(cacheIndex: integer): boolean
public "setHasNoRecipe"(cacheIndex: integer): void
public "loadSavedData"(cached: $CachedRecipe$$Type<(RECIPE)>, cacheIndex: integer): void
public "getRecipe"(cacheIndex: integer): RECIPE
public "invalidateCache"(): boolean
public "onContentsChanged"(): void
public "updateAndProcess"(energyContainer: $IEnergyContainer$$Type): long
public "updateAndProcess"(): boolean
public "getCachedRecipe"(cacheIndex: integer): $CachedRecipe<(RECIPE)>
public "getSavedOperatingTicks"(cacheIndex: integer): integer
public "createNewCachedRecipe"(recipe: RECIPE, cacheIndex: integer): $CachedRecipe<(RECIPE)>
public "unpause"(): void
public "getUpdatedCache"(arg0: integer): $CachedRecipe<(RECIPE)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeCacheLookupMonitor$$Type<RECIPE> = ($RecipeCacheLookupMonitor<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeCacheLookupMonitor_<RECIPE> = $RecipeCacheLookupMonitor$$Type<(RECIPE)>;
}}
declare module "mekanism.common.lib.frequency.FrequencyManager" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$$Type} from "mekanism.common.lib.frequency.Frequency$FrequencyIdentity"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"
import {$SecurityMode, $SecurityMode$$Type} from "mekanism.api.security.SecurityMode"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $FrequencyManager<FREQ extends $Frequency> {
static readonly "MAX_FREQ_LENGTH": integer

constructor(frequencyType: $FrequencyType$$Type<(FREQ)>)
constructor(frequencyType: $FrequencyType$$Type<(FREQ)>, uuid: $UUID$$Type, securityMode: $SecurityMode$$Type)

public "getName"(): string
public "remove"(key: any, ownerUUID: $UUID$$Type): boolean
public static "reset"(): void
public static "load"(): void
public "getType"(): $FrequencyType<(FREQ)>
public static "tick"(tickingNormally: boolean): void
public "getFrequency"(key: any): FREQ
public "deactivate"(freq: $Frequency$$Type, tile: $BlockEntity$$Type): void
public "getFrequencies"(): $Collection<(FREQ)>
public "createOrLoad"(): void
public "validateAndUpdate"(tile: $BlockEntity$$Type, freq: FREQ): FREQ
public "addFrequency"(freq: FREQ): void
public "getOrCreateFrequency"(identity: $Frequency$FrequencyIdentity$$Type, ownerUUID: $UUID$$Type): FREQ
get "name"(): string
get "type"(): $FrequencyType<(FREQ)>
get "frequencies"(): $Collection<(FREQ)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrequencyManager$$Type<FREQ> = ($FrequencyManager<(FREQ)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FrequencyManager_<FREQ> = $FrequencyManager$$Type<(FREQ)>;
}}
declare module "mekanism.common.content.qio.IQIOFrequencyHolder" {
import {$ITileWrapper, $ITileWrapper$$Type} from "mekanism.common.tile.interfaces.ITileWrapper"
import {$IQIOComponent, $IQIOComponent$$Type} from "mekanism.api.inventory.qio.IQIOComponent"
import {$QIOFrequency, $QIOFrequency$$Type} from "mekanism.common.content.qio.QIOFrequency"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$IQIOFrequency, $IQIOFrequency$$Type} from "mekanism.api.inventory.qio.IQIOFrequency"
import {$IFrequencyHandler, $IFrequencyHandler$$Type} from "mekanism.common.lib.frequency.IFrequencyHandler"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$$Type} from "mekanism.common.lib.frequency.Frequency$FrequencyIdentity"
import {$TileComponentFrequency, $TileComponentFrequency$$Type} from "mekanism.common.lib.frequency.TileComponentFrequency"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"

export interface $IQIOFrequencyHolder extends $IFrequencyHandler, $ITileWrapper, $IQIOComponent {

 "getQIOFrequency"(): $IQIOFrequency
 "getPublicFrequencies"(): $List<($QIOFrequency)>
 "getPrivateFrequencies"(): $List<($QIOFrequency)>
 "getFrequency"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): FREQ
 "getPublicCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "removeFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
 "getTrustedCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "getPrivateCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "setFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
 "getFrequencyComponent"(): $TileComponentFrequency
 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
get "qIOFrequency"(): $IQIOFrequency
get "publicFrequencies"(): $List<($QIOFrequency)>
get "privateFrequencies"(): $List<($QIOFrequency)>
get "frequencyComponent"(): $TileComponentFrequency
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}

export namespace $IQIOFrequencyHolder {
const probejs$$marker: never
}
export class $IQIOFrequencyHolder$$Static implements $IQIOFrequencyHolder {


 "getQIOFrequency"(): $IQIOFrequency
 "getPublicFrequencies"(): $List<($QIOFrequency)>
 "getPrivateFrequencies"(): $List<($QIOFrequency)>
 "getFrequency"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): FREQ
 "getPublicCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "removeFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
 "getTrustedCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "getPrivateCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "setFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
 "getFrequencyComponent"(): $TileComponentFrequency
 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IQIOFrequencyHolder$$Type = ($IQIOFrequencyHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IQIOFrequencyHolder_ = $IQIOFrequencyHolder$$Type;
}}
declare module "mekanism.common.item.interfaces.IModeItem$DisplayChange" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export class $IModeItem$DisplayChange extends $Enum<($IModeItem$DisplayChange)> {
static readonly "NONE": $IModeItem$DisplayChange
static readonly "MAIN_HAND": $IModeItem$DisplayChange
static readonly "OTHER": $IModeItem$DisplayChange


public static "values"(): ($IModeItem$DisplayChange)[]
public static "valueOf"(name: string): $IModeItem$DisplayChange
public "sendMessage"<DATA>(player: $Player$$Type, data: DATA, message: $Function$$Type<(DATA), ($Component$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModeItem$DisplayChange$$Type = (("none") | ("main_hand") | ("other"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModeItem$DisplayChange_ = $IModeItem$DisplayChange$$Type;
}}
declare module "mekanism.common.attachments.containers.ComponentBackedHandler" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$AbstractList, $AbstractList$$Type} from "java.util.AbstractList"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$INBTSerializable, $INBTSerializable$$Type} from "net.neoforged.neoforge.common.util.INBTSerializable"
import {$IAttachedContainers, $IAttachedContainers$$Type} from "mekanism.common.attachments.containers.IAttachedContainers"

export class $ComponentBackedHandler<TYPE, CONTAINER extends $INBTSerializable<($CompoundTag)>, ATTACHED extends $IAttachedContainers<(TYPE), (ATTACHED)>> extends $AbstractList<(CONTAINER)> implements $IContentsListener, $Iterable<(CONTAINER)> {


public "size"(): integer
public "get"(index: integer): CONTAINER
public "iterator"(): $Iterator<(CONTAINER)>
public "onContentsChanged"(): void
public "getContainers"(): $List<(CONTAINER)>
public "spliterator"(): $Spliterator<(CONTAINER)>
public "remove"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$$Type<(E)>): $List<(E)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$$Type<(E)>): boolean
public "removeAll"(arg0: $Collection$$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$$Type<(any)>): boolean
public "reversed"(): $SequencedCollection<(any)>
public "containsAll"(arg0: $Collection$$Type<(any)>): boolean
get "containers"(): $List<(CONTAINER)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBackedHandler$$Type<TYPE, CONTAINER, ATTACHED> = ($ComponentBackedHandler<(TYPE), (CONTAINER), (ATTACHED)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBackedHandler_<TYPE, CONTAINER, ATTACHED> = $ComponentBackedHandler$$Type<(TYPE), (CONTAINER), (ATTACHED)>;
}}
declare module "mekanism.common.advancements.triggers.BlockLaserTrigger" {
import {$BlockLaserTrigger$TriggerInstance, $BlockLaserTrigger$TriggerInstance$$Type} from "mekanism.common.advancements.triggers.BlockLaserTrigger$TriggerInstance"
import {$SimpleCriterionTrigger, $SimpleCriterionTrigger$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"

export class $BlockLaserTrigger extends $SimpleCriterionTrigger<($BlockLaserTrigger$TriggerInstance)> {

constructor()

public "trigger"(player: $ServerPlayer$$Type): void
public "codec"(): $Codec<($BlockLaserTrigger$TriggerInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockLaserTrigger$$Type = ($BlockLaserTrigger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockLaserTrigger_ = $BlockLaserTrigger$$Type;
}}
declare module "mekanism.common.tier.InductionProviderTier" {
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$BaseTier, $BaseTier$$Type} from "mekanism.api.tier.BaseTier"
import {$CachedLongValue, $CachedLongValue$$Type} from "mekanism.common.config.value.CachedLongValue"

export class $InductionProviderTier extends $Enum<($InductionProviderTier)> implements $ITier {
static readonly "BASIC": $InductionProviderTier
static readonly "ADVANCED": $InductionProviderTier
static readonly "ELITE": $InductionProviderTier
static readonly "ULTIMATE": $InductionProviderTier


public static "values"(): ($InductionProviderTier)[]
public static "valueOf"(name: string): $InductionProviderTier
public "getOutput"(): long
public "getBaseOutput"(): long
public "getBaseTier"(): $BaseTier
public "setConfigReference"(outputReference: $CachedLongValue$$Type): void
get "output"(): long
get "baseOutput"(): long
get "baseTier"(): $BaseTier
set "configReference"(value: $CachedLongValue$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InductionProviderTier$$Type = (("basic") | ("advanced") | ("elite") | ("ultimate"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InductionProviderTier_ = $InductionProviderTier$$Type;
}}
declare module "mekanism.common.attachments.containers.chemical.ComponentBackedChemicalTank" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ChemicalAttributeValidator, $ChemicalAttributeValidator$$Type} from "mekanism.api.chemical.attribute.ChemicalAttributeValidator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Chemical, $Chemical$$Type} from "mekanism.api.chemical.Chemical"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$AttachedChemicals, $AttachedChemicals$$Type} from "mekanism.common.attachments.containers.chemical.AttachedChemicals"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$LongSupplier, $LongSupplier$$Type} from "java.util.function.LongSupplier"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ComponentBackedContainer, $ComponentBackedContainer$$Type} from "mekanism.common.attachments.containers.ComponentBackedContainer"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"

export class $ComponentBackedChemicalTank extends $ComponentBackedContainer<($ChemicalStack), ($AttachedChemicals)> implements $IChemicalTank {

constructor(attachedTo: $ItemStack$$Type, tankIndex: integer, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, validator: $Predicate$$Type<($Chemical)>, rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, attributeValidator: $ChemicalAttributeValidator$$Type)

public "extract"(amount: long, action: $Action$$Type, automationType: $AutomationType$$Type): $ChemicalStack
public "insert"(stack: $ChemicalStack$$Type, action: $Action$$Type, automationType: $AutomationType$$Type): $ChemicalStack
public "getStack"(): $ChemicalStack
public "isValid"(stack: $ChemicalStack$$Type): boolean
public "setStack"(stack: $ChemicalStack$$Type): void
public "getCapacity"(): long
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "setStackSize"(amount: long, action: $Action$$Type): long
public "setStackUnchecked"(stack: $ChemicalStack$$Type): void
public "growStack"(amount: long, action: $Action$$Type): long
public "getAttributeValidator"(): $ChemicalAttributeValidator
public "isEmpty"(): boolean
public "getType"(): $Chemical
public "isTypeEqual"(arg0: $ChemicalStack$$Type): boolean
public "isTypeEqual"(arg0: $Chemical$$Type): boolean
public "setEmpty"(): void
public "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): void
public "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $Tag$$Type): void
public "getNeeded"(): long
public "getStored"(): long
public "shrinkStack"(arg0: long, arg1: $Action$$Type): long
get "stack"(): $ChemicalStack
set "stack"(value: $ChemicalStack$$Type)
get "capacity"(): long
set "stackUnchecked"(value: $ChemicalStack$$Type)
get "attributeValidator"(): $ChemicalAttributeValidator
get "empty"(): boolean
get "type"(): $Chemical
get "needed"(): long
get "stored"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBackedChemicalTank$$Type = ($ComponentBackedChemicalTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBackedChemicalTank_ = $ComponentBackedChemicalTank$$Type;
}}
declare module "mekanism.common.item.block.ItemBlockLaserAmplifier" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$TileEntityLaserAmplifier, $TileEntityLaserAmplifier$$Type} from "mekanism.common.tile.laser.TileEntityLaserAmplifier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$$Type} from "mekanism.common.block.prefab.BlockTile$BlockTileModel"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"

export class $ItemBlockLaserAmplifier extends $ItemBlockTooltip<($BlockTile$BlockTileModel<($TileEntityLaserAmplifier), ($BlockTypeTile<($TileEntityLaserAmplifier)>)>)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockTile$BlockTileModel$$Type<($TileEntityLaserAmplifier$$Type), ($BlockTypeTile$$Type<($TileEntityLaserAmplifier$$Type)>)>, properties: $Item$Properties$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockLaserAmplifier$$Type = ($ItemBlockLaserAmplifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockLaserAmplifier_ = $ItemBlockLaserAmplifier$$Type;
}}
declare module "mekanism.common.attachments.containers.heat.ComponentBackedHeatHandler" {
import {$IMekanismHeatHandler, $IMekanismHeatHandler$$Type} from "mekanism.api.heat.IMekanismHeatHandler"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$ComponentBackedHandler, $ComponentBackedHandler$$Type} from "mekanism.common.attachments.containers.ComponentBackedHandler"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$IHeatCapacitor, $IHeatCapacitor$$Type} from "mekanism.api.heat.IHeatCapacitor"
import {$HeatCapacitorData, $HeatCapacitorData$$Type} from "mekanism.common.attachments.containers.heat.HeatCapacitorData"
import {$AttachedHeat, $AttachedHeat$$Type} from "mekanism.common.attachments.containers.heat.AttachedHeat"

export class $ComponentBackedHeatHandler extends $ComponentBackedHandler<($HeatCapacitorData), ($IHeatCapacitor), ($AttachedHeat)> implements $IMekanismHeatHandler {

constructor(attachedTo: $ItemStack$$Type, totalCapacitors: integer)

public "getHeatCapacitor"(capacitor: integer, side: $Direction$$Type): $IHeatCapacitor
public "getHeatCapacitorCount"(side: $Direction$$Type): integer
public "getHeatCapacitors"(side: $Direction$$Type): $List<($IHeatCapacitor)>
public "getTemperature"(arg0: integer, arg1: $Direction$$Type): double
public "getHeatCapacity"(arg0: integer, arg1: $Direction$$Type): double
public "canHandleHeat"(): boolean
public "getTotalInverseInsulation"(arg0: $Direction$$Type): double
public "getTotalTemperature"(arg0: $Direction$$Type): double
public "getTotalHeatCapacity"(arg0: $Direction$$Type): double
public "getInverseConduction"(arg0: integer, arg1: $Direction$$Type): double
public "getInverseInsulation"(arg0: integer, arg1: $Direction$$Type): double
public "getTotalInverseConductionCoefficient"(arg0: $Direction$$Type): double
public "handleHeat"(arg0: double, arg1: $Direction$$Type): void
public "handleHeat"(arg0: integer, arg1: double, arg2: $Direction$$Type): void
public "getTemperature"(arg0: integer): double
public "getHeatCapacity"(arg0: integer): double
public "getHeatSideFor"(): $Direction
public "getTotalTemperature"(): double
public "getTotalHeatCapacity"(): double
public "getInverseConduction"(arg0: integer): double
public "getHeatCapacitorCount"(): integer
public "getTotalInverseConduction"(): double
public "handleHeat"(arg0: double): void
public "handleHeat"(arg0: integer, arg1: double): void
public "spliterator"(): $Spliterator<(T)>
public "remove"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$$Type<(E)>): $List<(E)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$$Type<(E)>): boolean
public "removeAll"(arg0: $Collection$$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$$Type<(any)>): boolean
public "reversed"(): $SequencedCollection<(any)>
public "containsAll"(arg0: $Collection$$Type<(any)>): boolean
get "heatSideFor"(): $Direction
get "totalTemperature"(): double
get "totalHeatCapacity"(): double
get "heatCapacitorCount"(): integer
get "totalInverseConduction"(): double
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBackedHeatHandler$$Type = ($ComponentBackedHeatHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBackedHeatHandler_ = $ComponentBackedHeatHandler$$Type;
}}
declare module "mekanism.common.resource.ore.OreType" {
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$IResource, $IResource$$Type} from "mekanism.common.resource.IResource"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$List, $List$$Type} from "java.util.List"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$BaseOreConfig, $BaseOreConfig$$Type} from "mekanism.common.resource.ore.BaseOreConfig"

export class $OreType extends $Enum<($OreType)> implements $StringRepresentable {
static readonly "TIN": $OreType
static readonly "OSMIUM": $OreType
static readonly "URANIUM": $OreType
static readonly "FLUORITE": $OreType
static readonly "LEAD": $OreType
static "CODEC": $Codec<($OreType)>


public static "get"(resource: $IResource$$Type): $OreType
public static "values"(): ($OreType)[]
public static "valueOf"(name: string): $OreType
public "getResource"(): $IResource
public "getSerializedName"(): string
public "getMinExp"(): integer
public "getMaxExp"(): integer
public "getBaseConfigs"(): $List<($BaseOreConfig)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "resource"(): $IResource
get "serializedName"(): string
get "minExp"(): integer
get "maxExp"(): integer
get "baseConfigs"(): $List<($BaseOreConfig)>
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreType$$Type = (("tin") | ("osmium") | ("uranium") | ("fluorite") | ("lead"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OreType_ = $OreType$$Type;
}}
declare module "mekanism.common.item.gear.ItemJetpack" {
import {$ArmorMaterial, $ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IJetpackItem$JetpackMode, $IJetpackItem$JetpackMode$$Type} from "mekanism.common.item.interfaces.IJetpackItem$JetpackMode"
import {$IModeItem$IAttachmentBasedModeItem, $IModeItem$IAttachmentBasedModeItem$$Type} from "mekanism.common.item.interfaces.IModeItem$IAttachmentBasedModeItem"
import {$ItemAttributeModifiers, $ItemAttributeModifiers$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$List, $List$$Type} from "java.util.List"
import {$IItemHUDProvider, $IItemHUDProvider$$Type} from "mekanism.common.item.interfaces.IItemHUDProvider"
import {$ItemChemicalArmor, $ItemChemicalArmor$$Type} from "mekanism.common.item.gear.ItemChemicalArmor"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior, $DispenseItemBehavior$$Type} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Equipable, $Equipable$$Type} from "net.minecraft.world.item.Equipable"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$IJetpackItem, $IJetpackItem$$Type} from "mekanism.common.item.interfaces.IJetpackItem"

export class $ItemJetpack extends $ItemChemicalArmor implements $IItemHUDProvider, $IJetpackItem, $IModeItem$IAttachmentBasedModeItem<($IJetpackItem$JetpackMode)> {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
readonly "type": $ArmorItem$Type
readonly "material": $Holder<($ArmorMaterial)>
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)
constructor(material: $Holder$$Type<($ArmorMaterial)>, properties: $Item$Properties$$Type)

public "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public "getDefaultMode"(): any
public "getModeDataType"(): $DataComponentType<($IJetpackItem$JetpackMode)>
public "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
public "useJetpackFuel"(stack: $ItemStack$$Type): void
public "getJetpackThrust"(stack: $ItemStack$$Type): double
public "canUseJetpack"(stack: $ItemStack$$Type): boolean
public "getJetpackMode"(stack: $ItemStack$$Type): $IJetpackItem$JetpackMode
public "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void
public static "getActiveJetpack"(entity: $LivingEntity$$Type): $ItemStack
public static "getPrimaryJetpack"(entity: $LivingEntity$$Type): $ItemStack
public static "getPlayerJetpackMode"<PLAYER extends $Player>(player: PLAYER, mode: $IJetpackItem$JetpackMode$$Type, ascendingCheck: $Predicate$$Type<(PLAYER)>): $IJetpackItem$JetpackMode
public static "handleJetpackMotion"<PLAYER extends $Player>(player: PLAYER, mode: $IJetpackItem$JetpackMode$$Type, thrust: double, ascendingCheck: $Predicate$$Type<(PLAYER)>): boolean
public "setMode"(stack: $ItemStack$$Type, player: $Player$$Type, mode: $IJetpackItem$JetpackMode$$Type): void
public "getMode"(stack: $ItemStack$$Type): $IJetpackItem$JetpackMode
public static "displayModeChange"(player: $Player$$Type): void
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
public "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
public static "get"(arg0: $ItemStack$$Type): $Equipable
get "defaultMode"(): any
get "modeDataType"(): $DataComponentType<($IJetpackItem$JetpackMode)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemJetpack$$Type = ($ItemJetpack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemJetpack_ = $ItemJetpack$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.InputRecipeCache$FluidChemical" {
import {$ChemicalInputCache, $ChemicalInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.ChemicalInputCache"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$FluidStackIngredient, $FluidStackIngredient$$Type} from "mekanism.api.recipes.ingredients.FluidStackIngredient"
import {$DoubleInputRecipeCache, $DoubleInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.DoubleInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$ChemicalStackIngredient, $ChemicalStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ChemicalStackIngredient"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$MekanismRecipeType, $MekanismRecipeType$$Type} from "mekanism.common.recipe.MekanismRecipeType"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidInputCache, $FluidInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.FluidInputCache"

export class $InputRecipeCache$FluidChemical<RECIPE extends ($MekanismRecipe<(any)>) & ($BiPredicate<($FluidStack), ($ChemicalStack)>)> extends $DoubleInputRecipeCache<($FluidStack), ($FluidStackIngredient), ($ChemicalStack), ($ChemicalStackIngredient), (RECIPE), ($FluidInputCache<(RECIPE)>), ($ChemicalInputCache<(RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$$Type<(any), (RECIPE), (any)>, inputAExtractor: $Function$$Type<(RECIPE), ($FluidStackIngredient$$Type)>, inputBExtractor: $Function$$Type<(RECIPE), ($ChemicalStackIngredient$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$FluidChemical$$Type<RECIPE> = ($InputRecipeCache$FluidChemical<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$FluidChemical_<RECIPE> = $InputRecipeCache$FluidChemical$$Type<(RECIPE)>;
}}
declare module "mekanism.common.tile.TileEntityFluidTank" {
import {$IConfigurable, $IConfigurable$$Type} from "mekanism.api.IConfigurable"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$IUpgradeData, $IUpgradeData$$Type} from "mekanism.common.upgrade.IUpgradeData"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$FluidTankUpgradeData, $FluidTankUpgradeData$$Type} from "mekanism.common.upgrade.FluidTankUpgradeData"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IFluidContainerManager$ContainerEditMode, $IFluidContainerManager$ContainerEditMode$$Type} from "mekanism.common.tile.interfaces.IFluidContainerManager$ContainerEditMode"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$FluidTankTier, $FluidTankTier$$Type} from "mekanism.common.tier.FluidTankTier"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$FluidTankFluidTank, $FluidTankFluidTank$$Type} from "mekanism.common.capabilities.fluid.FluidTankFluidTank"
import {$IFluidContainerManager, $IFluidContainerManager$$Type} from "mekanism.common.tile.interfaces.IFluidContainerManager"

export class $TileEntityFluidTank extends $TileEntityMekanism implements $IConfigurable, $IFluidContainerManager {
 "fluidTank": $FluidTankFluidTank
 "tier": $FluidTankTier
 "valveFluid": $FluidStack
 "prevScale": float
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "saveAdditional"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "loadAdditional"(nbt: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "readSustainedData"(provider: $HolderLookup$Provider$$Type, data: $CompoundTag$$Type): void
public "writeSustainedData"(provider: $HolderLookup$Provider$$Type, data: $CompoundTag$$Type): void
public "nextMode"(): void
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "addContainerTrackers"(container: $MekanismContainer$$Type): void
public "onRightClick"(player: $Player$$Type): $InteractionResult
public "getUpgradeData"(provider: $HolderLookup$Provider$$Type): $FluidTankUpgradeData
public "getContainerEditMode"(): $IFluidContainerManager$ContainerEditMode
public "insertFluid"(tank: integer, stack: $FluidStack$$Type, side: $Direction$$Type, action: $Action$$Type): $FluidStack
public "insertFluid"(stack: $FluidStack$$Type, side: $Direction$$Type, action: $Action$$Type): $FluidStack
public "previousMode"(): void
public "parseUpgradeData"(provider: $HolderLookup$Provider$$Type, upgradeData: $IUpgradeData$$Type): void
public "getRedstoneLevel"(): integer
public "onSneakRightClick"(player: $Player$$Type): $InteractionResult
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "containerEditMode"(): $IFluidContainerManager$ContainerEditMode
get "redstoneLevel"(): integer
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityFluidTank$$Type = ($TileEntityFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityFluidTank_ = $TileEntityFluidTank$$Type;
}}
declare module "mekanism.common.tile.prefab.TileEntityStructuralMultiblock" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IStructuralMultiblock, $IStructuralMultiblock$$Type} from "mekanism.common.lib.multiblock.IStructuralMultiblock"
import {$IConfigurable, $IConfigurable$$Type} from "mekanism.api.IConfigurable"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Structure, $Structure$$Type} from "mekanism.common.lib.multiblock.Structure"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$MultiblockData, $MultiblockData$$Type} from "mekanism.common.lib.multiblock.MultiblockData"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$MultiblockManager, $MultiblockManager$$Type} from "mekanism.common.lib.multiblock.MultiblockManager"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"

export class $TileEntityStructuralMultiblock extends $TileEntityMekanism implements $IStructuralMultiblock, $IConfigurable {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(provider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
public "setRemoved"(): void
public "multiblockFormed"(multiblock: $MultiblockData$$Type): void
public "multiblockUnformed"(structure: $Structure$$Type): void
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "shouldDumpRadiation"(): boolean
public "onNeighborChange"(block: $Block$$Type, neighborPos: $BlockPos$$Type): void
public "onRightClick"(player: $Player$$Type): $InteractionResult
public "onAdded"(): void
public "getStructureMap"(): $Map<($MultiblockManager<(any)>), ($Structure)>
public "hasStructure"(structure: $Structure$$Type): boolean
public "getDefaultData"(): $MultiblockData
public "setStructure"(manager: $MultiblockManager$$Type<(any)>, structure: $Structure$$Type): void
public "onSneakRightClick"(player: $Player$$Type): $InteractionResult
public "hasFormedMultiblock"(): boolean
public "structuralGuiAccessAllowed"(): boolean
public "onActivate"(player: $Player$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type): $ItemInteractionResult
public "canInterface"(manager: $MultiblockManager$$Type<(any)>): boolean
public "getMultiblockData"(manager: $MultiblockManager$$Type<(any)>): $MultiblockData
public "resetStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
public "setMultiblockData"(manager: $MultiblockManager$$Type<(any)>, multiblockData: $MultiblockData$$Type): void
public "resetForFormed"(): void
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "structureMap"(): $Map<($MultiblockManager<(any)>), ($Structure)>
get "defaultData"(): $MultiblockData
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityStructuralMultiblock$$Type = ($TileEntityStructuralMultiblock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityStructuralMultiblock_ = $TileEntityStructuralMultiblock$$Type;
}}
declare module "mekanism.common.block.basic.BlockFluidTank" {
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$$Type} from "mekanism.common.block.prefab.BlockTile$BlockTileModel"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$TileEntityFluidTank, $TileEntityFluidTank$$Type} from "mekanism.common.tile.TileEntityFluidTank"
import {$Machine, $Machine$$Type} from "mekanism.common.content.blocktype.Machine"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockFluidTank extends $BlockTile$BlockTileModel<($TileEntityFluidTank), ($Machine<($TileEntityFluidTank)>)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(type: $Machine$$Type<($TileEntityFluidTank$$Type)>)

public "getLightEmission"(state: $BlockState$$Type, world: $BlockGetter$$Type, pos: $BlockPos$$Type): integer
public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockFluidTank$$Type = ($BlockFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockFluidTank_ = $BlockFluidTank$$Type;
}}
declare module "mekanism.common.inventory.container.slot.InsertableSlot" {
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$SelectedWindowData, $SelectedWindowData$$Type} from "mekanism.common.inventory.container.SelectedWindowData"
import {$IInsertableSlot, $IInsertableSlot$$Type} from "mekanism.common.inventory.container.slot.IInsertableSlot"
import {$Action, $Action$$Type} from "mekanism.api.Action"

export class $InsertableSlot extends $Slot implements $IInsertableSlot {
readonly "slot": integer
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer
 "animationProgress": float

constructor(inventory: $Container$$Type, index: integer, x: integer, y: integer)

public "insertItem"(stack: $ItemStack$$Type, action: $Action$$Type): $ItemStack
public "exists"(windowData: $SelectedWindowData$$Type): boolean
public "canMergeWith"(stack: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InsertableSlot$$Type = ($InsertableSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InsertableSlot_ = $InsertableSlot$$Type;
}}
declare module "mekanism.common.capabilities.fluid.FluidTankFluidTank" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$BasicFluidTank, $BasicFluidTank$$Type} from "mekanism.common.capabilities.fluid.BasicFluidTank"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$TileEntityFluidTank, $TileEntityFluidTank$$Type} from "mekanism.common.tile.TileEntityFluidTank"

export class $FluidTankFluidTank extends $BasicFluidTank {
static readonly "alwaysTrue": $Predicate<($FluidStack)>
static readonly "alwaysFalse": $Predicate<($FluidStack)>
static readonly "alwaysTrueBi": $BiPredicate<($FluidStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($FluidStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($FluidStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($FluidStack), ($AutomationType)>


public "extract"(amount: integer, action: $Action$$Type, automationType: $AutomationType$$Type): $FluidStack
public "insert"(stack: $FluidStack$$Type, action: $Action$$Type, automationType: $AutomationType$$Type): $FluidStack
public static "create"(tile: $TileEntityFluidTank$$Type, listener: $IContentsListener$$Type): $FluidTankFluidTank
public "setStackSize"(amount: integer, action: $Action$$Type): integer
public "growStack"(amount: integer, action: $Action$$Type): integer
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $Tag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankFluidTank$$Type = ($FluidTankFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTankFluidTank_ = $FluidTankFluidTank$$Type;
}}
declare module "mekanism.common.item.interfaces.IItemHUDProvider" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $IItemHUDProvider {

 "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
 "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void

(list: $List<($Component)>, player: $Player, stack: $ItemStack, slotType: $EquipmentSlot): void
}

export namespace $IItemHUDProvider {
const probejs$$marker: never
}
export class $IItemHUDProvider$$Static implements $IItemHUDProvider {


 "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
 "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IItemHUDProvider$$Type = ((list: $List<($Component)>, player: $Player, stack: $ItemStack, slotType: $EquipmentSlot) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IItemHUDProvider_ = $IItemHUDProvider$$Type;
}}
declare module "mekanism.common.item.gear.ItemElectricBow" {
import {$BowItem, $BowItem$$Type} from "net.minecraft.world.item.BowItem"
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$$Type} from "mekanism.common.registration.impl.CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IModeItem$IAttachmentBasedModeItem, $IModeItem$IAttachmentBasedModeItem$$Type} from "mekanism.common.item.interfaces.IModeItem$IAttachmentBasedModeItem"
import {$List, $List$$Type} from "java.util.List"
import {$IItemHUDProvider, $IItemHUDProvider$$Type} from "mekanism.common.item.interfaces.IItemHUDProvider"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemEnchantments, $ItemEnchantments$$Type} from "net.minecraft.world.item.enchantment.ItemEnchantments"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$SoundInstance, $SoundInstance$$Type} from "net.minecraft.client.resources.sounds.SoundInstance"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$HolderLookup$RegistryLookup, $HolderLookup$RegistryLookup$$Type} from "net.minecraft.core.HolderLookup$RegistryLookup"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$Enchantment, $Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $ItemElectricBow extends $BowItem implements $IItemHUDProvider, $CreativeTabDeferredRegister$ICustomCreativeTabContents, $IModeItem$IAttachmentBasedModeItem<(boolean)> {
static readonly "MAX_DRAW_DURATION": integer
static readonly "DEFAULT_RANGE": integer
 "currentBowPullSound": $SoundInstance
static readonly "ARROW_ONLY": $Predicate<($ItemStack)>
static readonly "ARROW_OR_FIREWORK": $Predicate<($ItemStack)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "getDefaultMode"(): boolean
public "getModeDataType"(): $DataComponentType<(boolean)>
public "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
public "isPrimaryItemFor"(stack: $ItemStack$$Type, enchantment: $Holder$$Type<($Enchantment)>): boolean
public "getAllEnchantments"(stack: $ItemStack$$Type, lookup: $HolderLookup$RegistryLookup$$Type<($Enchantment$$Type)>): $ItemEnchantments
public "getBarWidth"(stack: $ItemStack$$Type): integer
public "getBarColor"(stack: $ItemStack$$Type): integer
public "isBarVisible"(stack: $ItemStack$$Type): boolean
public "releaseUsing"(bow: $ItemStack$$Type, world: $Level$$Type, entity: $LivingEntity$$Type, timeLeft: integer): void
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$$Type, newStack: $ItemStack$$Type, slotChanged: boolean): boolean
public "shouldCauseBlockBreakReset"(oldStack: $ItemStack$$Type, newStack: $ItemStack$$Type): boolean
public "getEnchantmentLevel"(stack: $ItemStack$$Type, enchantment: $Holder$$Type<($Enchantment)>): integer
public "addItems"(tabOutput: $Consumer$$Type<($ItemStack)>): void
public "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
public "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void
public "addDefault"(): boolean
public "setMode"(stack: $ItemStack$$Type, player: $Player$$Type, mode: boolean): void
public "getMode"(stack: $ItemStack$$Type): boolean
public "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "displayModeChange"(player: $Player$$Type): void
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
get "defaultMode"(): boolean
get "modeDataType"(): $DataComponentType<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemElectricBow$$Type = ($ItemElectricBow);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemElectricBow_ = $ItemElectricBow$$Type;
}}
declare module "mekanism.common.tile.TileEntityPersonalChest" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TileEntityPersonalStorage, $TileEntityPersonalStorage$$Type} from "mekanism.common.tile.TileEntityPersonalStorage"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$LidBlockEntity, $LidBlockEntity$$Type} from "net.minecraft.world.level.block.entity.LidBlockEntity"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityPersonalChest extends $TileEntityPersonalStorage implements $LidBlockEntity {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(pos: $BlockPos$$Type, state: $BlockState$$Type)

public "getOpenNess"(partialTicks: float): float
public "openGui"(player: $Player$$Type): $InteractionResult
public "triggerEvent"(id: integer, type: integer): boolean
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityPersonalChest$$Type = ($TileEntityPersonalChest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityPersonalChest_ = $TileEntityPersonalChest$$Type;
}}
declare module "mekanism.common.tile.interfaces.ITierUpgradable" {
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IUpgradeData, $IUpgradeData$$Type} from "mekanism.common.upgrade.IUpgradeData"

export interface $ITierUpgradable {

 "canBeUpgraded"(): boolean
 "getUpgradeData"(provider: $HolderLookup$Provider$$Type): $IUpgradeData

(): boolean
}

export namespace $ITierUpgradable {
const probejs$$marker: never
}
export class $ITierUpgradable$$Static implements $ITierUpgradable {


 "canBeUpgraded"(): boolean
 "getUpgradeData"(provider: $HolderLookup$Provider$$Type): $IUpgradeData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITierUpgradable$$Type = (() => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITierUpgradable_ = $ITierUpgradable$$Type;
}}
declare module "mekanism.common.resource.ore.OreAnchor" {
import {$AnchorType, $AnchorType$$Type} from "mekanism.common.world.height.AnchorType"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $OreAnchor extends $Record {

constructor(type: $AnchorType$$Type, value: integer)

public "type"(): $AnchorType
public "value"(): integer
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "absolute"(value: integer): $OreAnchor
public static "belowTop"(value: integer): $OreAnchor
public static "aboveBottom"(value: integer): $OreAnchor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreAnchor$$Type = ({"value"?: integer, "type"?: $AnchorType$$Type}) | ([value?: integer, type?: $AnchorType$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OreAnchor_ = $OreAnchor$$Type;
}}
declare module "mekanism.common.tier.TransporterTier" {
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$BaseTier, $BaseTier$$Type} from "mekanism.api.tier.BaseTier"
import {$CachedIntValue, $CachedIntValue$$Type} from "mekanism.common.config.value.CachedIntValue"

export class $TransporterTier extends $Enum<($TransporterTier)> implements $ITier {
static readonly "BASIC": $TransporterTier
static readonly "ADVANCED": $TransporterTier
static readonly "ELITE": $TransporterTier
static readonly "ULTIMATE": $TransporterTier


public static "get"(tier: $BaseTier$$Type): $TransporterTier
public static "values"(): ($TransporterTier)[]
public static "valueOf"(name: string): $TransporterTier
public "getSpeed"(): integer
public "getBasePull"(): integer
public "getBaseSpeed"(): integer
public "getBaseTier"(): $BaseTier
public "setConfigReference"(pullReference: $CachedIntValue$$Type, speedReference: $CachedIntValue$$Type): void
public "getPullAmount"(): integer
get "speed"(): integer
get "basePull"(): integer
get "baseSpeed"(): integer
get "baseTier"(): $BaseTier
get "pullAmount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransporterTier$$Type = (("basic") | ("advanced") | ("elite") | ("ultimate"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransporterTier_ = $TransporterTier$$Type;
}}
declare module "mekanism.common.tile.interfaces.ITileSound" {
import {$ITileWrapper, $ITileWrapper$$Type} from "mekanism.common.tile.interfaces.ITileWrapper"
import {$SoundSource, $SoundSource$$Type} from "net.minecraft.sounds.SoundSource"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"

export interface $ITileSound extends $ITileWrapper {

 "getVolume"(): float
 "hasSound"(): boolean
 "getSoundPos"(): $BlockPos
 "getSoundCategory"(): $SoundSource
 "getInitialVolume"(): float
 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
get "volume"(): float
get "soundPos"(): $BlockPos
get "soundCategory"(): $SoundSource
get "initialVolume"(): float
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}

export namespace $ITileSound {
const probejs$$marker: never
}
export class $ITileSound$$Static implements $ITileSound {


 "getVolume"(): float
 "hasSound"(): boolean
 "getSoundPos"(): $BlockPos
 "getSoundCategory"(): $SoundSource
 "getInitialVolume"(): float
 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileSound$$Type = ($ITileSound);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileSound_ = $ITileSound$$Type;
}}
declare module "mekanism.common.block.prefab.BlockFactoryMachine$BlockFactory" {
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$TileEntityFactory, $TileEntityFactory$$Type} from "mekanism.common.tile.factory.TileEntityFactory"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockFactoryMachine$BlockFactoryMachineModel, $BlockFactoryMachine$BlockFactoryMachineModel$$Type} from "mekanism.common.block.prefab.BlockFactoryMachine$BlockFactoryMachineModel"
import {$Factory, $Factory$$Type} from "mekanism.common.content.blocktype.Factory"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockFactoryMachine$BlockFactory<TILE extends $TileEntityFactory<(any)>> extends $BlockFactoryMachine$BlockFactoryMachineModel<(TILE), ($Factory<(TILE)>)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(factoryType: $Factory$$Type<(TILE)>)

public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockFactoryMachine$BlockFactory$$Type<TILE> = ($BlockFactoryMachine$BlockFactory<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockFactoryMachine$BlockFactory_<TILE> = $BlockFactoryMachine$BlockFactory$$Type<(TILE)>;
}}
declare module "mekanism.common.item.gear.ItemScubaTank" {
import {$ArmorMaterial, $ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IModeItem$IAttachmentBasedModeItem, $IModeItem$IAttachmentBasedModeItem$$Type} from "mekanism.common.item.interfaces.IModeItem$IAttachmentBasedModeItem"
import {$ItemAttributeModifiers, $ItemAttributeModifiers$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$List, $List$$Type} from "java.util.List"
import {$IItemHUDProvider, $IItemHUDProvider$$Type} from "mekanism.common.item.interfaces.IItemHUDProvider"
import {$ItemChemicalArmor, $ItemChemicalArmor$$Type} from "mekanism.common.item.gear.ItemChemicalArmor"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior, $DispenseItemBehavior$$Type} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Equipable, $Equipable$$Type} from "net.minecraft.world.item.Equipable"

export class $ItemScubaTank extends $ItemChemicalArmor implements $IItemHUDProvider, $IModeItem$IAttachmentBasedModeItem<(boolean)> {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
readonly "type": $ArmorItem$Type
readonly "material": $Holder<($ArmorMaterial)>
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public "getDefaultMode"(): any
public "getModeDataType"(): $DataComponentType<(boolean)>
public "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
public "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void
public "setMode"(stack: $ItemStack$$Type, player: $Player$$Type, mode: boolean): void
public "getMode"(stack: $ItemStack$$Type): boolean
public static "displayModeChange"(player: $Player$$Type): void
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
public "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
public static "get"(arg0: $ItemStack$$Type): $Equipable
get "defaultMode"(): any
get "modeDataType"(): $DataComponentType<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemScubaTank$$Type = ($ItemScubaTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemScubaTank_ = $ItemScubaTank$$Type;
}}
declare module "mekanism.common.block.BlockMekanism" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$HitResult, $HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader, $LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Explosion, $Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$Rotation, $Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor, $LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$PushReaction, $PushReaction$$Type} from "net.minecraft.world.level.material.PushReaction"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockMekanism extends $Block {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>


public "rotate"(state: $BlockState$$Type, world: $LevelAccessor$$Type, pos: $BlockPos$$Type, rotation: $Rotation$$Type): $BlockState
public "animateTick"(state: $BlockState$$Type, world: $Level$$Type, pos: $BlockPos$$Type, random: $RandomSource$$Type): void
public "getCloneItemStack"(state: $BlockState$$Type, target: $HitResult$$Type, world: $LevelReader$$Type, pos: $BlockPos$$Type, player: $Player$$Type): $ItemStack
public "onBlockExploded"(state: $BlockState$$Type, world: $Level$$Type, pos: $BlockPos$$Type, explosion: $Explosion$$Type): void
public "setPlacedBy"(world: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, placer: $LivingEntity$$Type, stack: $ItemStack$$Type): void
public "getPistonPushReaction"(state: $BlockState$$Type): $PushReaction
public "getStateForPlacement"(context: $BlockPlaceContext$$Type): $BlockState
public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockMekanism$$Type = ($BlockMekanism);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockMekanism_ = $BlockMekanism$$Type;
}}
declare module "mekanism.common.attachments.containers.fluid.AttachedFluids" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$IAttachedContainers, $IAttachedContainers$$Type} from "mekanism.common.attachments.containers.IAttachedContainers"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $AttachedFluids extends $Record implements $IAttachedContainers<($FluidStack), ($AttachedFluids)> {
static readonly "EMPTY": $AttachedFluids
static readonly "CODEC": $Codec<($AttachedFluids)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($AttachedFluids)>

constructor(containers: $List$$Type<(any)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "create"(containers: $List$$Type<(any)>): $IAttachedContainers<(any), (any)>
public static "create"(containers: integer): $AttachedFluids
public "containers"(): $List<($FluidStack)>
public "getEmptyStack"(): any
public "size"(): integer
public "get"(index: integer): $FluidStack
public "isEmpty"(): boolean
public "iterator"(): $Iterator<($FluidStack)>
public "spliterator"(): $Spliterator<($FluidStack)>
public "forEach"(action: $Consumer$$Type<($FluidStack)>): void
public "getOrDefault"(index: integer): $FluidStack
public "with"(index: integer, data: $FluidStack$$Type): $AttachedFluids
[Symbol.iterator](): IterableIterator<$FluidStack>;
get "emptyStack"(): any
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedFluids$$Type = ({"containers"?: $List$$Type<($FluidStack$$Type)>}) | ([containers?: $List$$Type<($FluidStack$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttachedFluids_ = $AttachedFluids$$Type;
}}
declare module "mekanism.common.tile.base.WrenchResult" {
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $WrenchResult extends $Enum<($WrenchResult)> {
static readonly "DISMANTLED": $WrenchResult
static readonly "SUCCESS": $WrenchResult
static readonly "PASS": $WrenchResult
static readonly "NO_SECURITY": $WrenchResult
static readonly "RADIOACTIVE": $WrenchResult


public static "values"(): ($WrenchResult)[]
public static "valueOf"(name: string): $WrenchResult
public "getInteractionResult"(): $ItemInteractionResult
get "interactionResult"(): $ItemInteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrenchResult$$Type = (("dismantled") | ("success") | ("pass") | ("no_security") | ("radioactive"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrenchResult_ = $WrenchResult$$Type;
}}
declare module "mekanism.common.content.qio.QIOCraftingWindow" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$SelectedWindowData, $SelectedWindowData$$Type} from "mekanism.common.inventory.container.SelectedWindowData"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$HotBarSlot, $HotBarSlot$$Type} from "mekanism.common.inventory.container.slot.HotBarSlot"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$IQIOCraftingWindowHolder, $IQIOCraftingWindowHolder$$Type} from "mekanism.common.content.qio.IQIOCraftingWindowHolder"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$MainInventorySlot, $MainInventorySlot$$Type} from "mekanism.common.inventory.container.slot.MainInventorySlot"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"

export class $QIOCraftingWindow implements $IContentsListener {

constructor(holder: $IQIOCraftingWindowHolder$$Type, windowIndex: byte)
constructor(holder: $IQIOCraftingWindowHolder$$Type, windowIndex: byte, inputSaveListener: $IntFunction$$Type<($IContentsListener$$Type)>)

public "isOutput"(stack: $ItemStack$$Type): boolean
public "invalidateRecipe"(): void
public "emptyTo"(toPlayerInv: boolean, hotBarSlots: $List$$Type<($HotBarSlot$$Type)>, mainInventorySlots: $List$$Type<($MainInventorySlot$$Type)>): void
public "getOutputSlot"(): $IInventorySlot
public "onContentsChanged"(): void
public "performCraft"(player: $Player$$Type, result: $ItemStack$$Type, amountCrafted: integer): $ItemStack
public "performCraft"(player: $Player$$Type, hotBarSlots: $List$$Type<($HotBarSlot$$Type)>, mainInventorySlots: $List$$Type<($MainInventorySlot$$Type)>): void
public "getInputSlot"(slot: integer): $IInventorySlot
public "getWindowData"(): $SelectedWindowData
public "getWindowIndex"(): byte
public "canViewRecipe"(player: $ServerPlayer$$Type): boolean
get "outputSlot"(): $IInventorySlot
get "windowData"(): $SelectedWindowData
get "windowIndex"(): byte
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOCraftingWindow$$Type = ($QIOCraftingWindow);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOCraftingWindow_ = $QIOCraftingWindow$$Type;
}}
declare module "mekanism.common.recipe.IMekanismRecipeTypeProvider" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$IInputRecipeCache, $IInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.IInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$RecipeHolder, $RecipeHolder$$Type} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$List, $List$$Type} from "java.util.List"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$RecipeManager, $RecipeManager$$Type} from "net.minecraft.world.item.crafting.RecipeManager"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MekanismRecipeType, $MekanismRecipeType$$Type} from "mekanism.common.recipe.MekanismRecipeType"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"

export interface $IMekanismRecipeTypeProvider<VANILLA_INPUT extends $RecipeInput, RECIPE extends $MekanismRecipe<(VANILLA_INPUT)>, INPUT_CACHE extends $IInputRecipeCache> {

 "stream"(world: $Level$$Type): $Stream<($RecipeHolder<(RECIPE)>)>
 "contains"(world: $Level$$Type, matchCriteria: $Predicate$$Type<(RECIPE)>): boolean
 "findFirst"(world: $Level$$Type, matchCriteria: $Predicate$$Type<(RECIPE)>): RECIPE
 "getRecipes"(recipeManager: $RecipeManager$$Type, world: $Level$$Type): $List<($RecipeHolder<(RECIPE)>)>
 "getRecipes"(world: $Level$$Type): $List<($RecipeHolder<(RECIPE)>)>
 "getRecipeType"(): $MekanismRecipeType<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>
 "getRegistryName"(): $ResourceLocation
 "getInputCache"(): INPUT_CACHE

(): $MekanismRecipeType$$Type<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>
get "recipeType"(): $MekanismRecipeType<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>
get "registryName"(): $ResourceLocation
get "inputCache"(): INPUT_CACHE
}

export namespace $IMekanismRecipeTypeProvider {
const probejs$$marker: never
}
export class $IMekanismRecipeTypeProvider$$Static<VANILLA_INPUT extends $RecipeInput, RECIPE extends $MekanismRecipe<(VANILLA_INPUT)>, INPUT_CACHE extends $IInputRecipeCache> implements $IMekanismRecipeTypeProvider {


 "stream"(world: $Level$$Type): $Stream<($RecipeHolder<(RECIPE)>)>
 "contains"(world: $Level$$Type, matchCriteria: $Predicate$$Type<(RECIPE)>): boolean
 "findFirst"(world: $Level$$Type, matchCriteria: $Predicate$$Type<(RECIPE)>): RECIPE
 "getRecipes"(recipeManager: $RecipeManager$$Type, world: $Level$$Type): $List<($RecipeHolder<(RECIPE)>)>
 "getRecipes"(world: $Level$$Type): $List<($RecipeHolder<(RECIPE)>)>
 "getRecipeType"(): $MekanismRecipeType<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>
 "getRegistryName"(): $ResourceLocation
 "getInputCache"(): INPUT_CACHE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMekanismRecipeTypeProvider$$Type<VANILLA_INPUT, RECIPE, INPUT_CACHE> = (() => $MekanismRecipeType$$Type<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMekanismRecipeTypeProvider_<VANILLA_INPUT, RECIPE, INPUT_CACHE> = $IMekanismRecipeTypeProvider$$Type<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>;
}}
declare module "mekanism.common.tile.interfaces.ITileFilterHolder" {
import {$IFilter, $IFilter$$Type} from "mekanism.common.content.filter.IFilter"
import {$FilterManager, $FilterManager$$Type} from "mekanism.common.content.filter.FilterManager"

export interface $ITileFilterHolder<FILTER extends $IFilter<(any)>> {

 "getFilterManager"(): $FilterManager<(FILTER)>

(): $FilterManager$$Type<(FILTER)>
get "filterManager"(): $FilterManager<(FILTER)>
}

export namespace $ITileFilterHolder {
const probejs$$marker: never
}
export class $ITileFilterHolder$$Static<FILTER extends $IFilter<(any)>> implements $ITileFilterHolder {


 "getFilterManager"(): $FilterManager<(FILTER)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileFilterHolder$$Type<FILTER> = (() => $FilterManager$$Type<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileFilterHolder_<FILTER> = $ITileFilterHolder$$Type<(FILTER)>;
}}
declare module "mekanism.common.inventory.container.SelectedWindowData" {
import {$SelectedWindowData$WindowType, $SelectedWindowData$WindowType$$Type} from "mekanism.common.inventory.container.SelectedWindowData$WindowType"
import {$SelectedWindowData$WindowPosition, $SelectedWindowData$WindowPosition$$Type} from "mekanism.common.inventory.container.SelectedWindowData$WindowPosition"

export class $SelectedWindowData {
static readonly "UNSPECIFIED": $SelectedWindowData
readonly "type": $SelectedWindowData$WindowType
readonly "extraData": byte

constructor(type: $SelectedWindowData$WindowType$$Type)
constructor(type: $SelectedWindowData$WindowType$$Type, extraData: byte)

public "equals"(o: any): boolean
public "hashCode"(): integer
public "wasPinned"(): boolean
public "getLastPosition"(): $SelectedWindowData$WindowPosition
public "updateLastPosition"(x: integer, y: integer, pinned: boolean): void
get "lastPosition"(): $SelectedWindowData$WindowPosition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SelectedWindowData$$Type = ($SelectedWindowData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SelectedWindowData_ = $SelectedWindowData$$Type;
}}
declare module "mekanism.common.lib.transmitter.acceptor.AbstractAcceptorCache" {
import {$AcceptorInfo, $AcceptorInfo$$Type} from "mekanism.common.lib.transmitter.acceptor.AcceptorInfo"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Set, $Set$$Type} from "java.util.Set"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"

export class $AbstractAcceptorCache<ACCEPTOR, INFO extends $AcceptorInfo<(ACCEPTOR)>> {
 "currentAcceptorConnections": byte


public "getConnectedAcceptor"(side: $Direction$$Type): ACCEPTOR
public "initializeCache"(level: $ServerLevel$$Type): void
public "getCachedAcceptor"(side: $Direction$$Type): ACCEPTOR
public "getConnectedAcceptors"(sides: $Set$$Type<($Direction$$Type)>): $List<(ACCEPTOR)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractAcceptorCache$$Type<ACCEPTOR, INFO> = ($AbstractAcceptorCache<(ACCEPTOR), (INFO)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractAcceptorCache_<ACCEPTOR, INFO> = $AbstractAcceptorCache$$Type<(ACCEPTOR), (INFO)>;
}}
declare module "mekanism.common.resource.IResource" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IResource {

 "getRegistrySuffix"(): string

(): string
get "registrySuffix"(): string
}

export namespace $IResource {
const probejs$$marker: never
}
export class $IResource$$Static implements $IResource {


 "getRegistrySuffix"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IResource$$Type = (() => string);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IResource_ = $IResource$$Type;
}}
declare module "mekanism.common.lib.frequency.Frequency$FrequencyIdentity" {
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$SecurityMode, $SecurityMode$$Type} from "mekanism.api.security.SecurityMode"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $Frequency$FrequencyIdentity extends $Record {

constructor(key: any, securityMode: $SecurityMode$$Type, ownerUUID: $UUID$$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "key"(): any
public "ownerUUID"(): $UUID
public "securityMode"(): $SecurityMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Frequency$FrequencyIdentity$$Type = ({"ownerUUID"?: $UUID$$Type, "key"?: any, "securityMode"?: $SecurityMode$$Type}) | ([ownerUUID?: $UUID$$Type, key?: any, securityMode?: $SecurityMode$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Frequency$FrequencyIdentity_ = $Frequency$FrequencyIdentity$$Type;
}}
declare module "mekanism.common.inventory.container.slot.HotBarSlot" {
import {$InsertableSlot, $InsertableSlot$$Type} from "mekanism.common.inventory.container.slot.InsertableSlot"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"

export class $HotBarSlot extends $InsertableSlot {
readonly "slot": integer
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer
 "animationProgress": float

constructor(inventory: $Container$$Type, index: integer, x: integer, y: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HotBarSlot$$Type = ($HotBarSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HotBarSlot_ = $HotBarSlot$$Type;
}}
declare module "mekanism.common.content.qio.QIODriveData$QIODriveKey" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$QIODriveData, $QIODriveData$$Type} from "mekanism.common.content.qio.QIODriveData"
import {$IQIODriveHolder, $IQIODriveHolder$$Type} from "mekanism.common.content.qio.IQIODriveHolder"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $QIODriveData$QIODriveKey extends $Record {

constructor(holder: $IQIODriveHolder$$Type, driveSlot: integer)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "holder"(): $IQIODriveHolder
public "save"(data: $QIODriveData$$Type): void
public "dataUpdate"(): void
public "getDriveStack"(): $ItemStack
public "updateMetadata"(data: $QIODriveData$$Type): void
public "driveSlot"(): integer
get "driveStack"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIODriveData$QIODriveKey$$Type = ({"holder"?: $IQIODriveHolder$$Type, "driveSlot"?: integer}) | ([holder?: $IQIODriveHolder$$Type, driveSlot?: integer]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIODriveData$QIODriveKey_ = $QIODriveData$QIODriveKey$$Type;
}}
declare module "mekanism.common.block.BlockQIOComponent" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$$Type} from "mekanism.common.block.prefab.BlockTile$BlockTileModel"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$TileEntityQIOComponent, $TileEntityQIOComponent$$Type} from "mekanism.common.tile.qio.TileEntityQIOComponent"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockQIOComponent<TILE extends $TileEntityQIOComponent, BLOCK extends $BlockTypeTile<(TILE)>> extends $BlockTile$BlockTileModel<(TILE), (BLOCK)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(type: BLOCK, propertiesModifier: $UnaryOperator$$Type<($BlockBehaviour$Properties)>)

public "getStateForPlacement"(context: $BlockPlaceContext$$Type): $BlockState
public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockQIOComponent$$Type<TILE, BLOCK> = ($BlockQIOComponent<(TILE), (BLOCK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockQIOComponent_<TILE, BLOCK> = $BlockQIOComponent$$Type<(TILE), (BLOCK)>;
}}
declare module "mekanism.common.upgrade.IUpgradeData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IUpgradeData {

}

export namespace $IUpgradeData {
const probejs$$marker: never
}
export class $IUpgradeData$$Static implements $IUpgradeData {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IUpgradeData$$Type = ($IUpgradeData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IUpgradeData_ = $IUpgradeData$$Type;
}}
declare module "mekanism.common.lib.inventory.TransitRequest$SimpleTransitRequest" {
import {$CollectionTransitRequest, $CollectionTransitRequest$$Type} from "mekanism.common.lib.inventory.CollectionTransitRequest"
import {$List, $List$$Type} from "java.util.List"
import {$TransitRequest$ItemData, $TransitRequest$ItemData$$Type} from "mekanism.common.lib.inventory.TransitRequest$ItemData"

export class $TransitRequest$SimpleTransitRequest extends $CollectionTransitRequest {


public "getItemData"(): $List<($TransitRequest$ItemData)>
get "itemData"(): $List<($TransitRequest$ItemData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransitRequest$SimpleTransitRequest$$Type = ($TransitRequest$SimpleTransitRequest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransitRequest$SimpleTransitRequest_ = $TransitRequest$SimpleTransitRequest$$Type;
}}
declare module "mekanism.common.content.filter.FilterManager" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$HashList, $HashList$$Type} from "mekanism.common.lib.collection.HashList"
import {$List, $List$$Type} from "java.util.List"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$IFilter, $IFilter$$Type} from "mekanism.common.content.filter.IFilter"
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $FilterManager<FILTER extends $IFilter<(any)>> {

constructor(filterClass: $Class$$Type<(FILTER)>, markForSave: $Runnable$$Type)

public "count"(): integer
public "getFilters"(): $HashList<(FILTER)>
public "removeFilter"(filter: FILTER): boolean
public "addFilter"(filter: FILTER): boolean
public "addContainerTrackers"(container: $MekanismContainer$$Type): void
public "toggleState"(index: integer): void
public "writeToNBT"(provider: $HolderLookup$Provider$$Type, nbt: $CompoundTag$$Type): void
public "readFromNBT"(provider: $HolderLookup$Provider$$Type, nbt: $CompoundTag$$Type): void
public "getEnabledFilters"(): $List<(FILTER)>
public "anyEnabledMatch"(validator: $Predicate$$Type<(FILTER)>): boolean
public "anyEnabledMatch"<DATA>(extra: DATA, validator: $BiPredicate$$Type<(FILTER), (DATA)>): boolean
public "hasEnabledFilters"(): boolean
public "tryAddFilter"(toAdd: $IFilter$$Type<(any)>, save: boolean): void
public "tryEditFilter"<F extends $IFilter<(F)>>(currentFilter: F, newFilter: F): void
public "trySetFilters"(filters: $Collection$$Type<($IFilter$$Type<(any)>)>): void
get "filters"(): $HashList<(FILTER)>
get "enabledFilters"(): $List<(FILTER)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterManager$$Type<FILTER> = ($FilterManager<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterManager_<FILTER> = $FilterManager$$Type<(FILTER)>;
}}
declare module "mekanism.common.attachments.containers.ComponentBackedContainer" {
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$IAttachedContainers, $IAttachedContainers$$Type} from "mekanism.common.attachments.containers.IAttachedContainers"

export class $ComponentBackedContainer<TYPE, ATTACHED extends $IAttachedContainers<(TYPE), (ATTACHED)>> implements $IContentsListener {


public "onContentsChanged"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBackedContainer$$Type<TYPE, ATTACHED> = ($ComponentBackedContainer<(TYPE), (ATTACHED)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBackedContainer_<TYPE, ATTACHED> = $ComponentBackedContainer$$Type<(TYPE), (ATTACHED)>;
}}
declare module "mekanism.common.tile.TileEntityEnergyCube$CubeSideState" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $TileEntityEnergyCube$CubeSideState extends $Enum<($TileEntityEnergyCube$CubeSideState)> {
static readonly "ACTIVE_LIT": $TileEntityEnergyCube$CubeSideState
static readonly "ACTIVE_UNLIT": $TileEntityEnergyCube$CubeSideState
static readonly "INACTIVE": $TileEntityEnergyCube$CubeSideState


public static "values"(): ($TileEntityEnergyCube$CubeSideState)[]
public static "valueOf"(name: string): $TileEntityEnergyCube$CubeSideState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityEnergyCube$CubeSideState$$Type = (("active_lit") | ("active_unlit") | ("inactive"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityEnergyCube$CubeSideState_ = $TileEntityEnergyCube$CubeSideState$$Type;
}}
declare module "mekanism.common.item.interfaces.IModeItem" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"

export interface $IModeItem {

 "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
 "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
 "getScrollTextComponent"(stack: $ItemStack$$Type): $Component

(player: $Player, stack: $ItemStack, shift: integer, displayChange: $IModeItem$DisplayChange): void
}

export namespace $IModeItem {
function displayModeChange(player: $Player$$Type): void
function isModeItem(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
function isModeItem(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
function isModeItem(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
const probejs$$marker: never
}
export class $IModeItem$$Static implements $IModeItem {


 "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
static "displayModeChange"(player: $Player$$Type): void
 "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
 "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IModeItem$$Type = ((player: $Player, stack: $ItemStack, shift: integer, displayChange: $IModeItem$DisplayChange) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IModeItem_ = $IModeItem$$Type;
}}
declare module "mekanism.common.capabilities.proxy.ProxyConfigurable$ISidedConfigurable" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$IConfigurable, $IConfigurable$$Type} from "mekanism.api.IConfigurable"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"

export interface $ProxyConfigurable$ISidedConfigurable extends $IConfigurable {

 "onRightClick"(player: $Player$$Type): $InteractionResult
 "onRightClick"(player: $Player$$Type, side: $Direction$$Type): $InteractionResult
 "onSneakRightClick"(player: $Player$$Type): $InteractionResult
 "onSneakRightClick"(player: $Player$$Type, side: $Direction$$Type): $InteractionResult
}

export namespace $ProxyConfigurable$ISidedConfigurable {
const probejs$$marker: never
}
export class $ProxyConfigurable$ISidedConfigurable$$Static implements $ProxyConfigurable$ISidedConfigurable {


 "onRightClick"(player: $Player$$Type): $InteractionResult
 "onRightClick"(player: $Player$$Type, side: $Direction$$Type): $InteractionResult
 "onSneakRightClick"(player: $Player$$Type): $InteractionResult
 "onSneakRightClick"(player: $Player$$Type, side: $Direction$$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProxyConfigurable$ISidedConfigurable$$Type = ($ProxyConfigurable$ISidedConfigurable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProxyConfigurable$ISidedConfigurable_ = $ProxyConfigurable$ISidedConfigurable$$Type;
}}
declare module "mekanism.common.item.interfaces.IUpgradeItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Upgrade, $Upgrade$$Type} from "mekanism.api.Upgrade"

export interface $IUpgradeItem {

 "getUpgradeType"(stack: $ItemStack$$Type): $Upgrade

(stack: $ItemStack): $Upgrade$$Type
}

export namespace $IUpgradeItem {
const probejs$$marker: never
}
export class $IUpgradeItem$$Static implements $IUpgradeItem {


 "getUpgradeType"(stack: $ItemStack$$Type): $Upgrade
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IUpgradeItem$$Type = ((stack: $ItemStack) => $Upgrade$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IUpgradeItem_ = $IUpgradeItem$$Type;
}}
declare module "mekanism.common.upgrade.ChemicalTankUpgradeData" {
import {$ITileComponent, $ITileComponent$$Type} from "mekanism.common.tile.component.ITileComponent"
import {$ChemicalInventorySlot, $ChemicalInventorySlot$$Type} from "mekanism.common.inventory.slot.chemical.ChemicalInventorySlot"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TileEntityChemicalTank$GasMode, $TileEntityChemicalTank$GasMode$$Type} from "mekanism.common.tile.TileEntityChemicalTank$GasMode"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$List, $List$$Type} from "java.util.List"
import {$IRedstoneControl$RedstoneControl, $IRedstoneControl$RedstoneControl$$Type} from "mekanism.common.tile.interfaces.IRedstoneControl$RedstoneControl"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IUpgradeData, $IUpgradeData$$Type} from "mekanism.common.upgrade.IUpgradeData"

export class $ChemicalTankUpgradeData implements $IUpgradeData {
readonly "redstone": boolean
readonly "controlType": $IRedstoneControl$RedstoneControl
readonly "drainSlot": $ChemicalInventorySlot
readonly "fillSlot": $ChemicalInventorySlot
readonly "dumping": $TileEntityChemicalTank$GasMode
readonly "storedChemical": $ChemicalStack
readonly "components": $CompoundTag

constructor(provider: $HolderLookup$Provider$$Type, redstone: boolean, controlType: $IRedstoneControl$RedstoneControl$$Type, drainSlot: $ChemicalInventorySlot$$Type, fillSlot: $ChemicalInventorySlot$$Type, dumping: $TileEntityChemicalTank$GasMode$$Type, storedChemical: $ChemicalStack$$Type, components: $List$$Type<($ITileComponent$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalTankUpgradeData$$Type = ($ChemicalTankUpgradeData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalTankUpgradeData_ = $ChemicalTankUpgradeData$$Type;
}}
declare module "mekanism.common.block.prefab.BlockFactoryMachine" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$Machine$FactoryMachine, $Machine$FactoryMachine$$Type} from "mekanism.common.content.blocktype.Machine$FactoryMachine"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockFactoryMachine<TILE extends $TileEntityMekanism, MACHINE extends $Machine$FactoryMachine<(TILE)>> extends $BlockTile<(TILE), (MACHINE)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(machineType: MACHINE, propertiesModifier: $UnaryOperator$$Type<($BlockBehaviour$Properties)>)

public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockFactoryMachine$$Type<TILE, MACHINE> = ($BlockFactoryMachine<(TILE), (MACHINE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockFactoryMachine_<TILE, MACHINE> = $BlockFactoryMachine$$Type<(TILE), (MACHINE)>;
}}
declare module "mekanism.common.content.qio.QIOFrequency" {
import {$QIODriveData$QIODriveKey, $QIODriveData$QIODriveKey$$Type} from "mekanism.common.content.qio.QIODriveData$QIODriveKey"
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IColorableFrequency, $IColorableFrequency$$Type} from "mekanism.common.lib.frequency.IColorableFrequency"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$IQIOFrequency, $IQIOFrequency$$Type} from "mekanism.api.inventory.qio.IQIOFrequency"
import {$IHashedItem, $IHashedItem$$Type} from "mekanism.api.inventory.IHashedItem"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$EnumColor, $EnumColor$$Type} from "mekanism.api.text.EnumColor"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Set, $Set$$Type} from "java.util.Set"
import {$ObjLongConsumer, $ObjLongConsumer$$Type} from "java.util.function.ObjLongConsumer"
import {$Object2LongMap, $Object2LongMap$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongMap"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$HashedItem, $HashedItem$$Type} from "mekanism.common.lib.inventory.HashedItem"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$SecurityMode, $SecurityMode$$Type} from "mekanism.api.security.SecurityMode"
import {$QIOFrequency$QIOItemTypeData, $QIOFrequency$QIOItemTypeData$$Type} from "mekanism.common.content.qio.QIOFrequency$QIOItemTypeData"
import {$QIODriveData, $QIODriveData$$Type} from "mekanism.common.content.qio.QIODriveData"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $QIOFrequency extends $Frequency implements $IColorableFrequency, $IQIOFrequency {
static readonly "CODEC": $Codec<($QIOFrequency)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($QIOFrequency)>

constructor(n: string, uuid: $UUID$$Type, securityMode: $SecurityMode$$Type)

public "update"(tile: $BlockEntity$$Type): boolean
public "tick"(tickingNormally: boolean): boolean
public "setColor"(color: $EnumColor$$Type): void
public "removeItem"(amount: integer): $ItemStack
public "removeItem"(stack: $ItemStack$$Type, amount: integer): $ItemStack
public "addItem"(stack: $ItemStack$$Type): $ItemStack
public "onRemove"(): void
public "getColor"(): $EnumColor
public "getTotalItemCount"(): long
public "getTotalItemTypes"(remote: boolean): integer
public "getDriveData"(key: $QIODriveData$QIODriveKey$$Type): $QIODriveData
public "saveAll"(): void
public "getStored"(type: $ItemStack$$Type): long
public "getTotalItemCountCapacity"(): long
public "getTotalItemTypeCapacity"(): integer
public "massExtract"(stack: $ItemStack$$Type, amount: long, action: $Action$$Type): long
public "forAllHashedStored"(consumer: $ObjLongConsumer$$Type<($IHashedItem)>): void
public "getStoredByHash"(itemType: $HashedItem$$Type): long
public "getTypesForItem"(item: $Item$$Type): $Set<($HashedItem)>
public "forAllStored"(consumer: $ObjLongConsumer$$Type<($ItemStack)>): void
public "getStacksByItem"(item: $Item$$Type): $Object2LongMap<($HashedItem)>
public "getItemDataMap"(): $Map<($HashedItem), ($QIOFrequency$QIOItemTypeData)>
public "openItemViewer"(player: $ServerPlayer$$Type): void
public "closeItemViewer"(player: $ServerPlayer$$Type): void
public "getSyncHash"(): integer
public "onDeactivate"(tile: $BlockEntity$$Type): boolean
public "getStacksByTag"(tag: string): $Object2LongMap<($HashedItem)>
public "removeDrive"(key: $QIODriveData$QIODriveKey$$Type, updateItemMap: boolean): void
public "getStacksByModID"(modID: string): $Object2LongMap<($HashedItem)>
public "removeByType"(itemType: $HashedItem$$Type, amount: integer): $ItemStack
public "getAllDrives"(): $Collection<($QIODriveData)>
public "getStacksByModIDWildcard"(wildcard: string): $Object2LongMap<($HashedItem)>
public "getStacksByTagWildcard"(wildcard: string): $Object2LongMap<($HashedItem)>
public "addDrive"(key: $QIODriveData$QIODriveKey$$Type): void
public "isStoring"(itemType: $HashedItem$$Type): boolean
public "massInsert"(stack: $ItemStack$$Type, amount: long, action: $Action$$Type): long
set "color"(value: $EnumColor$$Type)
get "color"(): $EnumColor
get "totalItemCount"(): long
get "totalItemCountCapacity"(): long
get "totalItemTypeCapacity"(): integer
get "itemDataMap"(): $Map<($HashedItem), ($QIOFrequency$QIOItemTypeData)>
get "syncHash"(): integer
get "allDrives"(): $Collection<($QIODriveData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOFrequency$$Type = ($QIOFrequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOFrequency_ = $QIOFrequency$$Type;
}}
declare module "mekanism.common.inventory.slot.QIODriveSlot" {
import {$QIODriveData$QIODriveKey, $QIODriveData$QIODriveKey$$Type} from "mekanism.common.content.qio.QIODriveData$QIODriveKey"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$BasicInventorySlot, $BasicInventorySlot$$Type} from "mekanism.common.inventory.slot.BasicInventorySlot"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$IQIODriveHolder, $IQIODriveHolder$$Type} from "mekanism.common.content.qio.IQIODriveHolder"

export class $QIODriveSlot extends $BasicInventorySlot {
static readonly "IS_QIO_ITEM": $Predicate<($ItemStack)>
static readonly "alwaysTrue": $Predicate<($ItemStack)>
static readonly "alwaysFalse": $Predicate<($ItemStack)>
static readonly "alwaysTrueBi": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($ItemStack), ($AutomationType)>

constructor(driveHolder: $IQIODriveHolder$$Type, slot: integer, levelSupplier: $Supplier$$Type<($Level$$Type)>, listener: $IContentsListener$$Type, x: integer, y: integer)

public "getKey"(): $QIODriveData$QIODriveKey
public "setStack"(stack: $ItemStack$$Type): void
public "extractItem"(amount: integer, action: $Action$$Type, automationType: $AutomationType$$Type): $ItemStack
public "insertItem"(stack: $ItemStack$$Type, action: $Action$$Type, automationType: $AutomationType$$Type): $ItemStack
public "setStackUnchecked"(stack: $ItemStack$$Type): void
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $Tag
public "createContainerSlot"(): $Slot
get "key"(): $QIODriveData$QIODriveKey
set "stack"(value: $ItemStack$$Type)
set "stackUnchecked"(value: $ItemStack$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIODriveSlot$$Type = ($QIODriveSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIODriveSlot_ = $QIODriveSlot$$Type;
}}
declare module "mekanism.common.block.transmitter.BlockLargeTransmitter" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ConnectionType, $ConnectionType$$Type} from "mekanism.common.lib.transmitter.ConnectionType"
import {$TileEntityTransmitter, $TileEntityTransmitter$$Type} from "mekanism.common.tile.transmitter.TileEntityTransmitter"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockTransmitter, $BlockTransmitter$$Type} from "mekanism.common.block.transmitter.BlockTransmitter"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockLargeTransmitter<TILE extends $TileEntityTransmitter> extends $BlockTransmitter<(TILE)> {
static readonly "CENTER": $VoxelShape
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(type: $BlockTypeTile$$Type<(TILE)>, propertiesModifier: $UnaryOperator$$Type<($BlockBehaviour$Properties)>)
constructor(type: $BlockTypeTile$$Type<(TILE)>)

public static "getSideForType"(type: $ConnectionType$$Type, side: $Direction$$Type): $VoxelShape
public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockLargeTransmitter$$Type<TILE> = ($BlockLargeTransmitter<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockLargeTransmitter_<TILE> = $BlockLargeTransmitter$$Type<(TILE)>;
}}
declare module "mekanism.common.item.interfaces.IJetpackItem$JetpackMode" {
import {$IHasModeIcon, $IHasModeIcon$$Type} from "mekanism.api.gear.config.IHasModeIcon"
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$IIncrementalEnum, $IIncrementalEnum$$Type} from "mekanism.api.IIncrementalEnum"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$IHasTextComponent$IHasEnumNameTextComponent, $IHasTextComponent$IHasEnumNameTextComponent$$Type} from "mekanism.api.text.IHasTextComponent$IHasEnumNameTextComponent"

export class $IJetpackItem$JetpackMode extends $Enum<($IJetpackItem$JetpackMode)> implements $IIncrementalEnum<($IJetpackItem$JetpackMode)>, $IHasModeIcon, $StringRepresentable, $IHasTextComponent$IHasEnumNameTextComponent {
static readonly "NORMAL": $IJetpackItem$JetpackMode
static readonly "HOVER": $IJetpackItem$JetpackMode
static readonly "VECTOR": $IJetpackItem$JetpackMode
static readonly "DISABLED": $IJetpackItem$JetpackMode
static readonly "CODEC": $Codec<($IJetpackItem$JetpackMode)>
static readonly "BY_ID": $IntFunction<($IJetpackItem$JetpackMode)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($IJetpackItem$JetpackMode)>


public static "values"(): ($IJetpackItem$JetpackMode)[]
public static "valueOf"(name: string): $IJetpackItem$JetpackMode
public "byIndex"(index: integer): $Enum<(any)>
public "getHUDIcon"(): $ResourceLocation
public "getSerializedName"(): string
public "getTextComponent"(): $Component
public "getModeIcon"(): $ResourceLocation
public "ordinal"(): integer
public "adjust"(arg0: integer): $IJetpackItem$JetpackMode
public "adjust"(arg0: integer, arg1: $Predicate$$Type<($IJetpackItem$JetpackMode)>): $IJetpackItem$JetpackMode
public "getNext"(arg0: $Predicate$$Type<($IJetpackItem$JetpackMode)>): $IJetpackItem$JetpackMode
public "getNext"(): $IJetpackItem$JetpackMode
public "getPrevious"(): $IJetpackItem$JetpackMode
public "getPrevious"(arg0: $Predicate$$Type<($IJetpackItem$JetpackMode)>): $IJetpackItem$JetpackMode
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public "getTranslatedName"(): $Component
get "hUDIcon"(): $ResourceLocation
get "serializedName"(): string
get "textComponent"(): $Component
get "modeIcon"(): $ResourceLocation
get "next"(): $IJetpackItem$JetpackMode
get "previous"(): $IJetpackItem$JetpackMode
get "remappedEnumConstantName"(): string
get "translatedName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IJetpackItem$JetpackMode$$Type = (("normal") | ("hover") | ("vector") | ("disabled"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IJetpackItem$JetpackMode_ = $IJetpackItem$JetpackMode$$Type;
}}
declare module "mekanism.common.block.states.IStateFluidLoggable" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$LiquidBlockContainer, $LiquidBlockContainer$$Type} from "net.minecraft.world.level.block.LiquidBlockContainer"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IFluidLogType, $IFluidLogType$$Type} from "mekanism.common.block.states.IFluidLogType"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BucketPickup, $BucketPickup$$Type} from "net.minecraft.world.level.block.BucketPickup"
import {$EnumProperty, $EnumProperty$$Type} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor, $LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $IStateFluidLoggable extends $BucketPickup, $LiquidBlockContainer {

 "setState"(state: $BlockState$$Type, fluid: $Fluid$$Type): $BlockState
 "isValidFluid"(fluid: $Fluid$$Type): boolean
 "canPlaceLiquid"(player: $Player$$Type, world: $BlockGetter$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluid: $Fluid$$Type): boolean
 "getPickupSound"(state: $BlockState$$Type): $Optional<($SoundEvent)>
 "getPickupSound"(): $Optional<($SoundEvent)>
 "pickupBlock"(player: $Player$$Type, world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type): $ItemStack
 "placeLiquid"(world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluidState: $FluidState$$Type): boolean
 "getFluid"(state: $BlockState$$Type): $FluidState
 "getFluidLightLevel"(state: $BlockState$$Type): integer
 "updateFluids"(state: $BlockState$$Type, world: $LevelAccessor$$Type, currentPos: $BlockPos$$Type): void
 "getFluidLoggedProperty"(): $EnumProperty<($IFluidLogType)>
get "pickupSound"(): $Optional<($SoundEvent)>
get "fluidLoggedProperty"(): $EnumProperty<($IFluidLogType)>
}

export namespace $IStateFluidLoggable {
const probejs$$marker: never
}
export class $IStateFluidLoggable$$Static implements $IStateFluidLoggable {


 "setState"(state: $BlockState$$Type, fluid: $Fluid$$Type): $BlockState
 "isValidFluid"(fluid: $Fluid$$Type): boolean
 "canPlaceLiquid"(player: $Player$$Type, world: $BlockGetter$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluid: $Fluid$$Type): boolean
 "getPickupSound"(state: $BlockState$$Type): $Optional<($SoundEvent)>
 "getPickupSound"(): $Optional<($SoundEvent)>
 "pickupBlock"(player: $Player$$Type, world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type): $ItemStack
 "placeLiquid"(world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluidState: $FluidState$$Type): boolean
 "getFluid"(state: $BlockState$$Type): $FluidState
 "getFluidLightLevel"(state: $BlockState$$Type): integer
 "updateFluids"(state: $BlockState$$Type, world: $LevelAccessor$$Type, currentPos: $BlockPos$$Type): void
 "getFluidLoggedProperty"(): $EnumProperty<($IFluidLogType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IStateFluidLoggable$$Type = ($IStateFluidLoggable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IStateFluidLoggable_ = $IStateFluidLoggable$$Type;
}}
declare module "mekanism.common.capabilities.resolver.ICapabilityResolver" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$List, $List$$Type} from "java.util.List"

export interface $ICapabilityResolver<CONTEXT> {

 "resolve"<T>(capability: $BlockCapability$$Type<(T), (CONTEXT)>, side: CONTEXT): T
 "invalidate"(capability: $BlockCapability$$Type<(any), (CONTEXT)>, context: CONTEXT): void
 "invalidateAll"(): void
 "getSupportedCapabilities"(): $List<($BlockCapability<(any), (CONTEXT)>)>
get "supportedCapabilities"(): $List<($BlockCapability<(any), (CONTEXT)>)>
}

export namespace $ICapabilityResolver {
const probejs$$marker: never
}
export class $ICapabilityResolver$$Static<CONTEXT> implements $ICapabilityResolver {


 "resolve"<T>(capability: $BlockCapability$$Type<(T), (CONTEXT)>, side: CONTEXT): T
 "invalidate"(capability: $BlockCapability$$Type<(any), (CONTEXT)>, context: CONTEXT): void
 "invalidateAll"(): void
 "getSupportedCapabilities"(): $List<($BlockCapability<(any), (CONTEXT)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICapabilityResolver$$Type<CONTEXT> = ($ICapabilityResolver<(CONTEXT)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICapabilityResolver_<CONTEXT> = $ICapabilityResolver$$Type<(CONTEXT)>;
}}
declare module "mekanism.common.item.ItemModule" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$IModuleItem, $IModuleItem$$Type} from "mekanism.common.content.gear.IModuleItem"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$IModuleDataProvider, $IModuleDataProvider$$Type} from "mekanism.api.providers.IModuleDataProvider"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ModuleData, $ModuleData$$Type} from "mekanism.api.gear.ModuleData"

export class $ItemModule extends $Item implements $IModuleItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(moduleData: $IModuleDataProvider$$Type<(any)>, properties: $Item$Properties$$Type)

public "getDescriptionId"(): string
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "getModuleData"(): $ModuleData<(any)>
get "descriptionId"(): string
get "moduleData"(): $ModuleData<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModule$$Type = ($ItemModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemModule_ = $ItemModule$$Type;
}}
declare module "mekanism.common.registration.impl.FluidDeferredRegister$MekanismFluidType" {
import {$FluidType$Properties, $FluidType$Properties$$Type} from "net.neoforged.neoforge.fluids.FluidType$Properties"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$FluidDeferredRegister$FluidTypeRenderProperties, $FluidDeferredRegister$FluidTypeRenderProperties$$Type} from "mekanism.common.registration.impl.FluidDeferredRegister$FluidTypeRenderProperties"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Lazy, $Lazy$$Type} from "net.neoforged.neoforge.common.util.Lazy"
import {$FluidType, $FluidType$$Type} from "net.neoforged.neoforge.fluids.FluidType"

export class $FluidDeferredRegister$MekanismFluidType extends $FluidType {
readonly "stillTexture": $ResourceLocation
readonly "flowingTexture": $ResourceLocation
readonly "overlayTexture": $ResourceLocation
readonly "renderOverlayTexture": $ResourceLocation
readonly "color": integer
static readonly "BUCKET_VOLUME": integer
static readonly "SIZE": $Lazy<(integer)>

constructor(properties: $FluidType$Properties$$Type, renderProperties: $FluidDeferredRegister$FluidTypeRenderProperties$$Type)

public "isVaporizedOnPlacement"(level: $Level$$Type, pos: $BlockPos$$Type, stack: $FluidStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidDeferredRegister$MekanismFluidType$$Type = ($FluidDeferredRegister$MekanismFluidType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidDeferredRegister$MekanismFluidType_ = $FluidDeferredRegister$MekanismFluidType$$Type;
}}
declare module "mekanism.common.capabilities.energy.EnergyCubeEnergyContainer" {
import {$EnergyCubeTier, $EnergyCubeTier$$Type} from "mekanism.common.tier.EnergyCubeTier"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$BasicEnergyContainer, $BasicEnergyContainer$$Type} from "mekanism.common.capabilities.energy.BasicEnergyContainer"

export class $EnergyCubeEnergyContainer extends $BasicEnergyContainer {
static readonly "alwaysTrue": $Predicate<($AutomationType)>
static readonly "alwaysFalse": $Predicate<($AutomationType)>
static readonly "internalOnly": $Predicate<($AutomationType)>
static readonly "manualOnly": $Predicate<($AutomationType)>
static readonly "notExternal": $Predicate<($AutomationType)>


public "extract"(amount: long, action: $Action$$Type, automationType: $AutomationType$$Type): long
public "insert"(amount: long, action: $Action$$Type, automationType: $AutomationType$$Type): long
public static "create"(tier: $EnergyCubeTier$$Type, listener: $IContentsListener$$Type): $EnergyCubeEnergyContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyCubeEnergyContainer$$Type = ($EnergyCubeEnergyContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyCubeEnergyContainer_ = $EnergyCubeEnergyContainer$$Type;
}}
declare module "mekanism.common.lib.multiblock.Structure" {
import {$Int2ObjectSortedMap, $Int2ObjectSortedMap$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectSortedMap"
import {$IMultiblock, $IMultiblock$$Type} from "mekanism.common.lib.multiblock.IMultiblock"
import {$VoxelPlane, $VoxelPlane$$Type} from "mekanism.common.lib.math.voxel.VoxelPlane"
import {$Structure$Axis, $Structure$Axis$$Type} from "mekanism.common.lib.multiblock.Structure$Axis"
import {$MultiblockManager, $MultiblockManager$$Type} from "mekanism.common.lib.multiblock.MultiblockManager"
import {$FormationProtocol$FormationResult, $FormationProtocol$FormationResult$$Type} from "mekanism.common.lib.multiblock.FormationProtocol$FormationResult"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IMultiblockBase, $IMultiblockBase$$Type} from "mekanism.common.lib.multiblock.IMultiblockBase"
import {$MultiblockData, $MultiblockData$$Type} from "mekanism.common.lib.multiblock.MultiblockData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $Structure {
static readonly "INVALID": $Structure

constructor(node: $IMultiblockBase$$Type)

public "size"(): integer
public "add"(s: $Structure$$Type): void
public "contains"(pos: $BlockPos$$Type): boolean
public "tick"<TILE extends ($BlockEntity) & ($IMultiblockBase)>(tile: TILE, tryValidate: boolean): void
public "isValid"(): boolean
public "getManager"(): $MultiblockManager<(any)>
public "markForUpdate"(world: $Level$$Type, invalidate: boolean): void
public "getController"(): $IMultiblock<(any)>
public "invalidate"(world: $Level$$Type): void
public "getMultiblockData"(): $MultiblockData
public "doImmediateUpdate"<TILE extends ($BlockEntity) & ($IMultiblockBase)>(tile: TILE, tryValidate: boolean): void
public "setMultiblockData"(multiblockData: $MultiblockData$$Type): void
public "getTile"(pos: $BlockPos$$Type): $IMultiblockBase
public "runUpdate"<TILE extends ($BlockEntity) & ($IMultiblockBase)>(tile: TILE): $FormationProtocol$FormationResult
public "removeMultiblock"(world: $Level$$Type): void
public "getMinorAxisMap"(axis: $Structure$Axis$$Type): $Int2ObjectSortedMap<($VoxelPlane)>
public "getMajorAxisMap"(axis: $Structure$Axis$$Type): $Int2ObjectSortedMap<($VoxelPlane)>
get "valid"(): boolean
get "manager"(): $MultiblockManager<(any)>
get "controller"(): $IMultiblock<(any)>
get "multiblockData"(): $MultiblockData
set "multiblockData"(value: $MultiblockData$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Structure$$Type = ($Structure);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Structure_ = $Structure$$Type;
}}
declare module "mekanism.common.item.gear.ItemAtomicDisassembler" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$IItemHUDProvider, $IItemHUDProvider$$Type} from "mekanism.common.item.interfaces.IItemHUDProvider"
import {$ItemAttributeModifierEvent, $ItemAttributeModifierEvent$$Type} from "net.neoforged.neoforge.event.ItemAttributeModifierEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$ItemAbility, $ItemAbility$$Type} from "net.neoforged.neoforge.common.ItemAbility"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IRadialMode, $IRadialMode$$Type} from "mekanism.api.radial.mode.IRadialMode"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Set, $Set$$Type} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ItemEnergized, $ItemEnergized$$Type} from "mekanism.common.item.ItemEnergized"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IRadialModeItem, $IRadialModeItem$$Type} from "mekanism.common.lib.radial.IRadialModeItem"
import {$IHasConditionalAttributes, $IHasConditionalAttributes$$Type} from "mekanism.common.item.interfaces.IHasConditionalAttributes"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ItemAtomicDisassembler$DisassemblerMode, $ItemAtomicDisassembler$DisassemblerMode$$Type} from "mekanism.common.item.gear.ItemAtomicDisassembler$DisassemblerMode"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$RadialData, $RadialData$$Type} from "mekanism.api.radial.RadialData"
import {$Enchantment, $Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $ItemAtomicDisassembler extends $ItemEnergized implements $IItemHUDProvider, $IRadialModeItem<($ItemAtomicDisassembler$DisassemblerMode)>, $IHasConditionalAttributes {
static readonly "ALWAYS_SUPPORTED_ACTIONS": $Set<($ItemAbility)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "adjustAttributes"(event: $ItemAttributeModifierEvent$$Type): void
public "getDefaultMode"(): $ItemAtomicDisassembler$DisassemblerMode
public "getRadialData"(stack: $ItemStack$$Type): $RadialData<($ItemAtomicDisassembler$DisassemblerMode)>
public "getModeDataType"(): $DataComponentType<($ItemAtomicDisassembler$DisassemblerMode)>
public "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
public "isPrimaryItemFor"(stack: $ItemStack$$Type, enchantment: $Holder$$Type<($Enchantment)>): boolean
public "isBookEnchantable"(stack: $ItemStack$$Type, book: $ItemStack$$Type): boolean
public "isEnchantable"(stack: $ItemStack$$Type): boolean
public "getDestroySpeed"(stack: $ItemStack$$Type, state: $BlockState$$Type): float
public "canPerformAction"(stack: $ItemStack$$Type, action: $ItemAbility$$Type): boolean
public "mineBlock"(stack: $ItemStack$$Type, world: $Level$$Type, state: $BlockState$$Type, pos: $BlockPos$$Type, entity: $LivingEntity$$Type): boolean
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
public "hurtEnemy"(stack: $ItemStack$$Type, target: $LivingEntity$$Type, attacker: $LivingEntity$$Type): boolean
public "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
public static "fullyChargedStack"(): $ItemStack
public "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void
public "setMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, player: $Player$$Type, radialData: $RadialData$$Type<(M)>, mode: M): void
public "getMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, radialData: $RadialData$$Type<(M)>): M
public "setMode"(stack: $ItemStack$$Type, player: $Player$$Type, mode: $ItemAtomicDisassembler$DisassemblerMode$$Type): void
public "getMode"(stack: $ItemStack$$Type): $ItemAtomicDisassembler$DisassemblerMode
public "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "displayModeChange"(player: $Player$$Type): void
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
get "defaultMode"(): $ItemAtomicDisassembler$DisassemblerMode
get "modeDataType"(): $DataComponentType<($ItemAtomicDisassembler$DisassemblerMode)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemAtomicDisassembler$$Type = ($ItemAtomicDisassembler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemAtomicDisassembler_ = $ItemAtomicDisassembler$$Type;
}}
declare module "mekanism.common.tier.EnergyCubeTier" {
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BaseTier, $BaseTier$$Type} from "mekanism.api.tier.BaseTier"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$CachedLongValue, $CachedLongValue$$Type} from "mekanism.common.config.value.CachedLongValue"

export class $EnergyCubeTier extends $Enum<($EnergyCubeTier)> implements $ITier, $StringRepresentable {
static readonly "BASIC": $EnergyCubeTier
static readonly "ADVANCED": $EnergyCubeTier
static readonly "ELITE": $EnergyCubeTier
static readonly "ULTIMATE": $EnergyCubeTier
static readonly "CREATIVE": $EnergyCubeTier


public static "values"(): ($EnergyCubeTier)[]
public static "valueOf"(name: string): $EnergyCubeTier
public "getOutput"(): long
public "getSerializedName"(): string
public "getMaxEnergy"(): long
public "getBaseMaxEnergy"(): long
public "getBaseOutput"(): long
public "getBaseTier"(): $BaseTier
public "setConfigReference"(storageReference: $CachedLongValue$$Type, outputReference: $CachedLongValue$$Type): void
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "output"(): long
get "serializedName"(): string
get "maxEnergy"(): long
get "baseMaxEnergy"(): long
get "baseOutput"(): long
get "baseTier"(): $BaseTier
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyCubeTier$$Type = (("basic") | ("advanced") | ("elite") | ("ultimate") | ("creative"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyCubeTier_ = $EnergyCubeTier$$Type;
}}
declare module "mekanism.common.config.IConfigTranslation" {
import {$IHasTranslationKey, $IHasTranslationKey$$Type} from "mekanism.api.text.IHasTranslationKey"
import {$ModConfigSpec$Builder, $ModConfigSpec$Builder$$Type} from "net.neoforged.neoforge.common.ModConfigSpec$Builder"

export interface $IConfigTranslation extends $IHasTranslationKey {

 "title"(): string
 "button"(): string
 "tooltip"(): string
 "applyToBuilder"(builder: $ModConfigSpec$Builder$$Type): $ModConfigSpec$Builder
 "getTranslationKey"(): string
get "translationKey"(): string
}

export namespace $IConfigTranslation {
function getSectionTitle(title: string, isSection: boolean): string
const probejs$$marker: never
}
export class $IConfigTranslation$$Static implements $IConfigTranslation {


 "title"(): string
 "button"(): string
 "tooltip"(): string
 "applyToBuilder"(builder: $ModConfigSpec$Builder$$Type): $ModConfigSpec$Builder
static "getSectionTitle"(title: string, isSection: boolean): string
 "getTranslationKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IConfigTranslation$$Type = ($IConfigTranslation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IConfigTranslation_ = $IConfigTranslation$$Type;
}}
declare module "mekanism.common.lib.multiblock.IValveHandler$ValveData" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $IValveHandler$ValveData {
readonly "location": $BlockPos
readonly "side": $Direction
 "prevActive": boolean
 "activeTicks": integer

constructor(location: $BlockPos$$Type, side: $Direction$$Type)

public "equals"(obj: any): boolean
public "hashCode"(): integer
public "onTransfer"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IValveHandler$ValveData$$Type = ($IValveHandler$ValveData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IValveHandler$ValveData_ = $IValveHandler$ValveData$$Type;
}}
declare module "mekanism.common.attachments.containers.energy.ComponentBackedEnergyHandler" {
import {$IEnergyContainer, $IEnergyContainer$$Type} from "mekanism.api.energy.IEnergyContainer"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$ComponentBackedHandler, $ComponentBackedHandler$$Type} from "mekanism.common.attachments.containers.ComponentBackedHandler"
import {$List, $List$$Type} from "java.util.List"
import {$AttachedEnergy, $AttachedEnergy$$Type} from "mekanism.common.attachments.containers.energy.AttachedEnergy"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$IMekanismStrictEnergyHandler, $IMekanismStrictEnergyHandler$$Type} from "mekanism.api.energy.IMekanismStrictEnergyHandler"

export class $ComponentBackedEnergyHandler extends $ComponentBackedHandler<(long), ($IEnergyContainer), ($AttachedEnergy)> implements $IMekanismStrictEnergyHandler {

constructor(attachedTo: $ItemStack$$Type, totalContainers: integer)

public "getEnergyContainerCount"(side: $Direction$$Type): integer
public "getEnergyContainers"(side: $Direction$$Type): $List<($IEnergyContainer)>
public "extractEnergy"(amount: long, side: $Direction$$Type, action: $Action$$Type): long
public "getEnergy"(container: integer, side: $Direction$$Type): long
public "getEnergyContainer"(container: integer, side: $Direction$$Type): $IEnergyContainer
public "insertEnergy"(amount: long, side: $Direction$$Type, action: $Action$$Type): long
public "getMaxEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "extractEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type, arg3: $Action$$Type): long
public "getNeededEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "setEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type): void
public "canHandleEnergy"(): boolean
public "insertEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type, arg3: $Action$$Type): long
public "getEnergyContainerCount"(): integer
public "getMaxEnergy"(arg0: integer): long
public "extractEnergy"(arg0: integer, arg1: long, arg2: $Action$$Type): long
public "getNeededEnergy"(arg0: integer): long
public "getEnergy"(arg0: integer): long
public "setEnergy"(arg0: integer, arg1: long): void
public "insertEnergy"(arg0: integer, arg1: long, arg2: $Action$$Type): long
public "getEnergySideFor"(): $Direction
public "spliterator"(): $Spliterator<(T)>
public "extractEnergy"(arg0: long, arg1: $Action$$Type): long
public "insertEnergy"(arg0: long, arg1: $Action$$Type): long
public "remove"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$$Type<(E)>): $List<(E)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$$Type<(E)>): boolean
public "removeAll"(arg0: $Collection$$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$$Type<(any)>): boolean
public "reversed"(): $SequencedCollection<(any)>
public "containsAll"(arg0: $Collection$$Type<(any)>): boolean
get "energyContainerCount"(): integer
get "energySideFor"(): $Direction
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBackedEnergyHandler$$Type = ($ComponentBackedEnergyHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBackedEnergyHandler_ = $ComponentBackedEnergyHandler$$Type;
}}
declare module "mekanism.common.item.ItemConfigurator" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$IItemHUDProvider, $IItemHUDProvider$$Type} from "mekanism.common.item.interfaces.IItemHUDProvider"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$ItemAbility, $ItemAbility$$Type} from "net.neoforged.neoforge.common.ItemAbility"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader, $LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IRadialMode, $IRadialMode$$Type} from "mekanism.api.radial.mode.IRadialMode"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$UseOnContext, $UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"
import {$IRadialModeItem, $IRadialModeItem$$Type} from "mekanism.common.lib.radial.IRadialModeItem"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ItemConfigurator$ConfiguratorMode, $ItemConfigurator$ConfiguratorMode$$Type} from "mekanism.common.item.ItemConfigurator$ConfiguratorMode"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$RadialData, $RadialData$$Type} from "mekanism.api.radial.RadialData"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"

export class $ItemConfigurator extends $Item implements $IRadialModeItem<($ItemConfigurator$ConfiguratorMode)>, $IItemHUDProvider {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "getName"(stack: $ItemStack$$Type): $Component
public "getDefaultMode"(): any
public "getRadialData"(stack: $ItemStack$$Type): $RadialData<($ItemConfigurator$ConfiguratorMode)>
public "getModeDataType"(): $DataComponentType<($ItemConfigurator$ConfiguratorMode)>
public "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
public "doesSneakBypassUse"(stack: $ItemStack$$Type, world: $LevelReader$$Type, pos: $BlockPos$$Type, player: $Player$$Type): boolean
public "canPerformAction"(stack: $ItemStack$$Type, action: $ItemAbility$$Type): boolean
public "useOn"(context: $UseOnContext$$Type): $InteractionResult
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
public "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
public "setMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, player: $Player$$Type, radialData: $RadialData$$Type<(M)>, mode: M): void
public "getMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, radialData: $RadialData$$Type<(M)>): M
public "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void
public "setMode"(stack: $ItemStack$$Type, player: $Player$$Type, mode: $ItemConfigurator$ConfiguratorMode$$Type): void
public "getMode"(stack: $ItemStack$$Type): $ItemConfigurator$ConfiguratorMode
public "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "displayModeChange"(player: $Player$$Type): void
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
get "defaultMode"(): any
get "modeDataType"(): $DataComponentType<($ItemConfigurator$ConfiguratorMode)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemConfigurator$$Type = ($ItemConfigurator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemConfigurator_ = $ItemConfigurator$$Type;
}}
declare module "mekanism.common.advancements.triggers.UseGaugeDropperTrigger" {
import {$SimpleCriterionTrigger, $SimpleCriterionTrigger$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$UseGaugeDropperTrigger$TriggerInstance, $UseGaugeDropperTrigger$TriggerInstance$$Type} from "mekanism.common.advancements.triggers.UseGaugeDropperTrigger$TriggerInstance"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$UseGaugeDropperTrigger$UseDropperAction, $UseGaugeDropperTrigger$UseDropperAction$$Type} from "mekanism.common.advancements.triggers.UseGaugeDropperTrigger$UseDropperAction"

export class $UseGaugeDropperTrigger extends $SimpleCriterionTrigger<($UseGaugeDropperTrigger$TriggerInstance)> {

constructor()

public "trigger"(player: $ServerPlayer$$Type, action: $UseGaugeDropperTrigger$UseDropperAction$$Type): void
public "codec"(): $Codec<($UseGaugeDropperTrigger$TriggerInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UseGaugeDropperTrigger$$Type = ($UseGaugeDropperTrigger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UseGaugeDropperTrigger_ = $UseGaugeDropperTrigger$$Type;
}}
declare module "mekanism.common.advancements.triggers.AlloyUpgradeTrigger" {
import {$AlloyUpgradeTrigger$TriggerInstance, $AlloyUpgradeTrigger$TriggerInstance$$Type} from "mekanism.common.advancements.triggers.AlloyUpgradeTrigger$TriggerInstance"
import {$SimpleCriterionTrigger, $SimpleCriterionTrigger$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"

export class $AlloyUpgradeTrigger extends $SimpleCriterionTrigger<($AlloyUpgradeTrigger$TriggerInstance)> {

constructor()

public "trigger"(player: $ServerPlayer$$Type): void
public "codec"(): $Codec<($AlloyUpgradeTrigger$TriggerInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlloyUpgradeTrigger$$Type = ($AlloyUpgradeTrigger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlloyUpgradeTrigger_ = $AlloyUpgradeTrigger$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.InputRecipeCache$ItemFluidChemical" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$TripleInputRecipeCache, $TripleInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.TripleInputRecipeCache"
import {$ChemicalStackIngredient, $ChemicalStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ChemicalStackIngredient"
import {$MekanismRecipeType, $MekanismRecipeType$$Type} from "mekanism.common.recipe.MekanismRecipeType"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidInputCache, $FluidInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.FluidInputCache"
import {$ChemicalInputCache, $ChemicalInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.ChemicalInputCache"
import {$ItemStackIngredient, $ItemStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ItemStackIngredient"
import {$FluidStackIngredient, $FluidStackIngredient$$Type} from "mekanism.api.recipes.ingredients.FluidStackIngredient"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$ItemInputCache, $ItemInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.ItemInputCache"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$TriPredicate, $TriPredicate$$Type} from "net.neoforged.neoforge.common.util.TriPredicate"

export class $InputRecipeCache$ItemFluidChemical<RECIPE extends ($MekanismRecipe<(any)>) & ($TriPredicate<($ItemStack), ($FluidStack), ($ChemicalStack)>)> extends $TripleInputRecipeCache<($ItemStack), ($ItemStackIngredient), ($FluidStack), ($FluidStackIngredient), ($ChemicalStack), ($ChemicalStackIngredient), (RECIPE), ($ItemInputCache<(RECIPE)>), ($FluidInputCache<(RECIPE)>), ($ChemicalInputCache<(RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$$Type<(any), (RECIPE), (any)>, inputAExtractor: $Function$$Type<(RECIPE), ($ItemStackIngredient$$Type)>, inputBExtractor: $Function$$Type<(RECIPE), ($FluidStackIngredient$$Type)>, inputCExtractor: $Function$$Type<(RECIPE), ($ChemicalStackIngredient$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$ItemFluidChemical$$Type<RECIPE> = ($InputRecipeCache$ItemFluidChemical<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$ItemFluidChemical_<RECIPE> = $InputRecipeCache$ItemFluidChemical$$Type<(RECIPE)>;
}}
declare module "mekanism.common.inventory.container.QIOItemViewerContainer" {
import {$ContainerListener, $ContainerListener$$Type} from "net.minecraft.world.inventory.ContainerListener"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$HashedItem$UUIDAwareHashedItem, $HashedItem$UUIDAwareHashedItem$$Type} from "mekanism.common.lib.inventory.HashedItem$UUIDAwareHashedItem"
import {$QIOFrequency, $QIOFrequency$$Type} from "mekanism.common.content.qio.QIOFrequency"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$QIOItemViewerContainer$ListSortType, $QIOItemViewerContainer$ListSortType$$Type} from "mekanism.common.inventory.container.QIOItemViewerContainer$ListSortType"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ContainerSynchronizer, $ContainerSynchronizer$$Type} from "net.minecraft.world.inventory.ContainerSynchronizer"
import {$QIOCraftingTransferHelper, $QIOCraftingTransferHelper$$Type} from "mekanism.common.content.qio.QIOCraftingTransferHelper"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$QIOCraftingWindow, $QIOCraftingWindow$$Type} from "mekanism.common.content.qio.QIOCraftingWindow"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ISlotClickHandler$IScrollableSlot, $ISlotClickHandler$IScrollableSlot$$Type} from "mekanism.common.inventory.ISlotClickHandler$IScrollableSlot"
import {$QIOItemViewerContainer$SortDirection, $QIOItemViewerContainer$SortDirection$$Type} from "mekanism.common.inventory.container.QIOItemViewerContainer$SortDirection"
import {$MenuType, $MenuType$$Type} from "net.minecraft.world.inventory.MenuType"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$VirtualInventoryContainerSlot, $VirtualInventoryContainerSlot$$Type} from "mekanism.common.inventory.container.slot.VirtualInventoryContainerSlot"
import {$ISlotClickHandler, $ISlotClickHandler$$Type} from "mekanism.common.inventory.ISlotClickHandler"
import {$Object2LongMap, $Object2LongMap$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongMap"

export class $QIOItemViewerContainer extends $MekanismContainer implements $ISlotClickHandler {
static readonly "SLOTS_X_MIN": integer
static readonly "SLOTS_X_MAX": integer
static readonly "SLOTS_Y_MIN": integer
static readonly "SLOTS_Y_MAX": integer
static readonly "SLOTS_START_Y": integer
static readonly "BASE_Y_OFFSET": integer
static readonly "TRANSPORTER_CONFIG_WINDOW": integer
static readonly "SIDE_CONFIG_WINDOW": integer
static readonly "UPGRADE_WINDOW": integer
static readonly "SKIN_SELECT_WINDOW": integer
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
 "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
readonly "remoteSlots": $NonNullList<($ItemStack)>
 "remoteCarried": $ItemStack
 "stateId": integer
 "menuType": $MenuType<(any)>
 "containerId": integer
 "quickcraftType": integer
 "quickcraftStatus": integer
readonly "quickcraftSlots": $Set<($Slot)>
readonly "containerListeners": $List<($ContainerListener)>
 "synchronizer": $ContainerSynchronizer


public "getFrequency"(): $QIOFrequency
public "onClick"(slotProvider: $Supplier$$Type<($ISlotClickHandler$IScrollableSlot$$Type)>, button: integer, hasShiftDown: boolean, heldItem: $ItemStack$$Type): void
public "getCraftingWindow"(selectedCraftingGrid: integer): $QIOCraftingWindow
public "broadcastChanges"(): void
public "quickMoveStack"(player: $Player$$Type, slotID: integer): $ItemStack
public "handleUpdate"(itemMap: $Object2LongMap$$Type<($HashedItem$UUIDAwareHashedItem$$Type)>, countCapacity: long, typeCapacity: integer): void
public "getTransferHelper"(player: $Player$$Type, craftingWindow: $QIOCraftingWindow$$Type): $QIOCraftingTransferHelper
public "getCraftingWindowSlot"(tableIndex: byte, slotIndex: integer): $VirtualInventoryContainerSlot
public "getSelectedCraftingGrid"(): byte
public "getSelectedCraftingGrid"(player: $UUID$$Type): byte
public "shiftClickIntoFrequency"(): boolean
public "toggleTargetDirection"(): void
public "insertIntoPlayerInventory"(player: $UUID$$Type, stack: $ItemStack$$Type): $ItemStack
public static "getSlotsYMax"(): integer
public "updateSearch"(level: $Level$$Type, queryText: string): void
public "getSortDirection"(): $QIOItemViewerContainer$SortDirection
public "handleBatchUpdate"(itemMap: $Object2LongMap$$Type<($HashedItem$UUIDAwareHashedItem$$Type)>, countCapacity: long, typeCapacity: integer): void
public "setSortType"(sortType: $QIOItemViewerContainer$ListSortType$$Type): void
public "setSortDirection"(sortDirection: $QIOItemViewerContainer$SortDirection$$Type): void
public "getQIOItemList"(): $List<($ISlotClickHandler$IScrollableSlot)>
public "getSortType"(): $QIOItemViewerContainer$ListSortType
public "getTypeCapacity"(): integer
public "getTotalItems"(): long
public "getTotalTypes"(): integer
public "getCountCapacity"(): long
public "recreate"(): $QIOItemViewerContainer
public "handleKill"(): void
public "simulateInsertIntoPlayerInventory"(player: $UUID$$Type, stack: $ItemStack$$Type): $ItemStack
get "frequency"(): $QIOFrequency
get "selectedCraftingGrid"(): byte
get "sortDirection"(): $QIOItemViewerContainer$SortDirection
set "sortType"(value: $QIOItemViewerContainer$ListSortType$$Type)
set "sortDirection"(value: $QIOItemViewerContainer$SortDirection$$Type)
get "qIOItemList"(): $List<($ISlotClickHandler$IScrollableSlot)>
get "sortType"(): $QIOItemViewerContainer$ListSortType
get "typeCapacity"(): integer
get "totalItems"(): long
get "totalTypes"(): integer
get "countCapacity"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOItemViewerContainer$$Type = ($QIOItemViewerContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOItemViewerContainer_ = $QIOItemViewerContainer$$Type;
}}
declare module "mekanism.common.tile.transmitter.TileEntityUniversalCable" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$TransmitterModelData, $TransmitterModelData$$Type} from "mekanism.client.model.data.TransmitterModelData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IConfigurable, $IConfigurable$$Type} from "mekanism.api.IConfigurable"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TransmitterType, $TransmitterType$$Type} from "mekanism.common.block.states.TransmitterType"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ModelProperty, $ModelProperty$$Type} from "net.neoforged.neoforge.client.model.data.ModelProperty"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$ConnectionType, $ConnectionType$$Type} from "mekanism.common.lib.transmitter.ConnectionType"
import {$Transmitter, $Transmitter$$Type} from "mekanism.common.content.network.transmitter.Transmitter"
import {$TileEntityTransmitter, $TileEntityTransmitter$$Type} from "mekanism.common.tile.transmitter.TileEntityTransmitter"
import {$BoundMethodHolder, $BoundMethodHolder$$Type} from "mekanism.common.integration.computer.BoundMethodHolder"
import {$IComputerTile, $IComputerTile$$Type} from "mekanism.common.integration.computer.IComputerTile"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityUniversalCable extends $TileEntityTransmitter implements $IComputerTile {
static readonly "CONFIGURABLE_PROVIDER": $ICapabilityProvider<($TileEntityTransmitter), ($Direction), ($IConfigurable)>
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "getUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "sideChanged"(side: $Direction$$Type, old: $ConnectionType$$Type, type: $ConnectionType$$Type): void
public "getComputerName"(): string
public "getTransmitter"(): $Transmitter<(any), (any), (any)>
public "redstoneChanged"(powered: boolean): void
public "getTransmitterType"(): $TransmitterType
public "isComputerCapabilityPersistent"(): boolean
public "hasComputerSupport"(): boolean
public "getComputerMethods"(holder: $BoundMethodHolder$$Type): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
get "computerName"(): string
get "transmitter"(): $Transmitter<(any), (any), (any)>
get "transmitterType"(): $TransmitterType
get "computerCapabilityPersistent"(): boolean
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityUniversalCable$$Type = ($TileEntityUniversalCable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityUniversalCable_ = $TileEntityUniversalCable$$Type;
}}
declare module "mekanism.common.upgrade.FluidTankUpgradeData" {
import {$ITileComponent, $ITileComponent$$Type} from "mekanism.common.tile.component.ITileComponent"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IFluidContainerManager$ContainerEditMode, $IFluidContainerManager$ContainerEditMode$$Type} from "mekanism.common.tile.interfaces.IFluidContainerManager$ContainerEditMode"
import {$FluidInventorySlot, $FluidInventorySlot$$Type} from "mekanism.common.inventory.slot.FluidInventorySlot"
import {$List, $List$$Type} from "java.util.List"
import {$OutputInventorySlot, $OutputInventorySlot$$Type} from "mekanism.common.inventory.slot.OutputInventorySlot"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IUpgradeData, $IUpgradeData$$Type} from "mekanism.common.upgrade.IUpgradeData"

export class $FluidTankUpgradeData implements $IUpgradeData {
readonly "redstone": boolean
readonly "inputSlot": $FluidInventorySlot
readonly "outputSlot": $OutputInventorySlot
readonly "editMode": $IFluidContainerManager$ContainerEditMode
readonly "stored": $FluidStack
readonly "components": $CompoundTag

constructor(provider: $HolderLookup$Provider$$Type, redstone: boolean, inputSlot: $FluidInventorySlot$$Type, outputSlot: $OutputInventorySlot$$Type, editMode: $IFluidContainerManager$ContainerEditMode$$Type, stored: $FluidStack$$Type, components: $List$$Type<($ITileComponent$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankUpgradeData$$Type = ($FluidTankUpgradeData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTankUpgradeData_ = $FluidTankUpgradeData$$Type;
}}
declare module "mekanism.common.tier.BinTier" {
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$BaseTier, $BaseTier$$Type} from "mekanism.api.tier.BaseTier"
import {$CachedIntValue, $CachedIntValue$$Type} from "mekanism.common.config.value.CachedIntValue"

export class $BinTier extends $Enum<($BinTier)> implements $ITier {
static readonly "BASIC": $BinTier
static readonly "ADVANCED": $BinTier
static readonly "ELITE": $BinTier
static readonly "ULTIMATE": $BinTier
static readonly "CREATIVE": $BinTier


public static "values"(): ($BinTier)[]
public static "valueOf"(name: string): $BinTier
public "getStorage"(): integer
public "getBaseStorage"(): integer
public "getBaseTier"(): $BaseTier
public "setConfigReference"(storageReference: $CachedIntValue$$Type): void
get "storage"(): integer
get "baseStorage"(): integer
get "baseTier"(): $BaseTier
set "configReference"(value: $CachedIntValue$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinTier$$Type = (("basic") | ("advanced") | ("elite") | ("ultimate") | ("creative"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinTier_ = $BinTier$$Type;
}}
declare module "mekanism.common.lib.frequency.FrequencyManagerWrapper" {
import {$FrequencyManagerWrapper$Type, $FrequencyManagerWrapper$Type$$Type} from "mekanism.common.lib.frequency.FrequencyManagerWrapper$Type"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"
import {$FrequencyManager, $FrequencyManager$$Type} from "mekanism.common.lib.frequency.FrequencyManager"

export class $FrequencyManagerWrapper<FREQ extends $Frequency> {


public "clear"(): void
public static "create"<FREQ extends $Frequency>(frequencyType: $FrequencyType$$Type<(FREQ)>, type: $FrequencyManagerWrapper$Type$$Type): $FrequencyManagerWrapper<(FREQ)>
public "getPublicManager"(): $FrequencyManager<(FREQ)>
public "getPrivateManager"(ownerUUID: $UUID$$Type): $FrequencyManager<(FREQ)>
public "getTrustedManager"(ownerUUID: $UUID$$Type): $FrequencyManager<(FREQ)>
public "getTrustedManagers"(): $Collection<($FrequencyManager<(FREQ)>)>
get "publicManager"(): $FrequencyManager<(FREQ)>
get "trustedManagers"(): $Collection<($FrequencyManager<(FREQ)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrequencyManagerWrapper$$Type<FREQ> = ($FrequencyManagerWrapper<(FREQ)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FrequencyManagerWrapper_<FREQ> = $FrequencyManagerWrapper$$Type<(FREQ)>;
}}
declare module "mekanism.common.tile.laser.TileEntityLaserAmplifier$RedstoneOutput" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IHasTranslationKey$IHasEnumNameTranslationKey, $IHasTranslationKey$IHasEnumNameTranslationKey$$Type} from "mekanism.api.text.IHasTranslationKey$IHasEnumNameTranslationKey"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$IIncrementalEnum, $IIncrementalEnum$$Type} from "mekanism.api.IIncrementalEnum"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"

export class $TileEntityLaserAmplifier$RedstoneOutput extends $Enum<($TileEntityLaserAmplifier$RedstoneOutput)> implements $IIncrementalEnum<($TileEntityLaserAmplifier$RedstoneOutput)>, $IHasTranslationKey$IHasEnumNameTranslationKey, $StringRepresentable {
static readonly "OFF": $TileEntityLaserAmplifier$RedstoneOutput
static readonly "ENTITY_DETECTION": $TileEntityLaserAmplifier$RedstoneOutput
static readonly "ENERGY_CONTENTS": $TileEntityLaserAmplifier$RedstoneOutput
static readonly "CODEC": $Codec<($TileEntityLaserAmplifier$RedstoneOutput)>
static readonly "BY_ID": $IntFunction<($TileEntityLaserAmplifier$RedstoneOutput)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($TileEntityLaserAmplifier$RedstoneOutput)>


public static "values"(): ($TileEntityLaserAmplifier$RedstoneOutput)[]
public static "valueOf"(name: string): $TileEntityLaserAmplifier$RedstoneOutput
public "byIndex"(index: integer): $TileEntityLaserAmplifier$RedstoneOutput
public "getSerializedName"(): string
public "getTranslationKey"(): string
public "ordinal"(): integer
public "adjust"(arg0: integer): $TileEntityLaserAmplifier$RedstoneOutput
public "adjust"(arg0: integer, arg1: $Predicate$$Type<($TileEntityLaserAmplifier$RedstoneOutput)>): $TileEntityLaserAmplifier$RedstoneOutput
public "getNext"(arg0: $Predicate$$Type<($TileEntityLaserAmplifier$RedstoneOutput)>): $TileEntityLaserAmplifier$RedstoneOutput
public "getNext"(): $TileEntityLaserAmplifier$RedstoneOutput
public "getPrevious"(): $TileEntityLaserAmplifier$RedstoneOutput
public "getPrevious"(arg0: $Predicate$$Type<($TileEntityLaserAmplifier$RedstoneOutput)>): $TileEntityLaserAmplifier$RedstoneOutput
public "getTranslatedName"(): $Component
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "translationKey"(): string
get "next"(): $TileEntityLaserAmplifier$RedstoneOutput
get "previous"(): $TileEntityLaserAmplifier$RedstoneOutput
get "translatedName"(): $Component
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityLaserAmplifier$RedstoneOutput$$Type = (("off") | ("entity_detection") | ("energy_contents"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityLaserAmplifier$RedstoneOutput_ = $TileEntityLaserAmplifier$RedstoneOutput$$Type;
}}
declare module "mekanism.common.integration.computer.MethodRestriction" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"

export class $MethodRestriction extends $Enum<($MethodRestriction)> implements $Predicate<(any)> {
static readonly "NONE": $MethodRestriction
static readonly "DIRECTIONAL": $MethodRestriction
static readonly "ENERGY": $MethodRestriction
static readonly "MULTIBLOCK": $MethodRestriction
static readonly "REDSTONE_CONTROL": $MethodRestriction
static readonly "COMPARATOR": $MethodRestriction


public static "values"(): ($MethodRestriction)[]
public "test"(handler: any): boolean
public static "valueOf"(name: string): $MethodRestriction
public "or"(arg0: $Predicate$$Type<(any)>): $Predicate<(any)>
public "negate"(): $Predicate<(any)>
public "and"(arg0: $Predicate$$Type<(any)>): $Predicate<(any)>
public static "not"<T>(arg0: $Predicate$$Type<(any)>): $Predicate<(any)>
public static "isEqual"<T>(arg0: any): $Predicate<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodRestriction$$Type = (("none") | ("directional") | ("energy") | ("multiblock") | ("redstone_control") | ("comparator"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodRestriction_ = $MethodRestriction$$Type;
}}
declare module "mekanism.common.lib.inventory.HashedItem" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$IHashedItem, $IHashedItem$$Type} from "mekanism.api.inventory.IHashedItem"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $HashedItem implements $IHashedItem {
static readonly "CODEC": $Codec<($HashedItem)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($HashedItem)>


public "equals"(obj: any): boolean
public "hashCode"(): integer
public static "create"(stack: $ItemStack$$Type): $HashedItem
public static "raw"(stack: $ItemStack$$Type): $HashedItem
public "createStack"(size: integer): $ItemStack
public "internalToNBT"(provider: $HolderLookup$Provider$$Type): $Tag
public "getInternalStack"(): $ItemStack
public "recreate"(): $HashedItem
public "getItem"(): $Item
public "getMaxStackSize"(): integer
get "internalStack"(): $ItemStack
get "item"(): $Item
get "maxStackSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HashedItem$$Type = ($HashedItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HashedItem_ = $HashedItem$$Type;
}}
declare module "mekanism.common.attachments.component.AttachedSideConfig$LightConfigInfo" {
import {$IPersistentConfigInfo, $IPersistentConfigInfo$$Type} from "mekanism.common.tile.component.config.IPersistentConfigInfo"
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$DataType, $DataType$$Type} from "mekanism.common.tile.component.config.DataType"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$RelativeSide, $RelativeSide$$Type} from "mekanism.api.RelativeSide"

export class $AttachedSideConfig$LightConfigInfo extends $Record implements $IPersistentConfigInfo {
static readonly "CODEC": $Codec<($AttachedSideConfig$LightConfigInfo)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($AttachedSideConfig$LightConfigInfo)>
static readonly "MACHINE": $AttachedSideConfig$LightConfigInfo
static readonly "EXTRA_MACHINE": $AttachedSideConfig$LightConfigInfo
static readonly "INPUT_ONLY": $AttachedSideConfig$LightConfigInfo
static readonly "OUT_NO_EJECT": $AttachedSideConfig$LightConfigInfo
static readonly "OUT_EJECT": $AttachedSideConfig$LightConfigInfo
static readonly "OUT_EJECT_LEFT": $AttachedSideConfig$LightConfigInfo
static readonly "FRONT_OUT_NO_EJECT": $AttachedSideConfig$LightConfigInfo
static readonly "FRONT_OUT_EJECT": $AttachedSideConfig$LightConfigInfo
static readonly "RIGHT_OUTPUT": $AttachedSideConfig$LightConfigInfo
static readonly "FRONT_OUT_EJECT_NO_TOP": $AttachedSideConfig$LightConfigInfo
static readonly "INPUT_ONLY_NO_TOP": $AttachedSideConfig$LightConfigInfo
static readonly "INPUT_OUT_ALL": $AttachedSideConfig$LightConfigInfo
static readonly "TWO_OUTPUT": $AttachedSideConfig$LightConfigInfo
static readonly "TWO_OUTPUT_ITEM": $AttachedSideConfig$LightConfigInfo
static readonly "TWO_INPUT_AND_OUT": $AttachedSideConfig$LightConfigInfo
static readonly "TWO_INPUT_ITEM": $AttachedSideConfig$LightConfigInfo

constructor(sideConfig: $Map$$Type<(any), (any)>, isEjecting: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getDataType"(side: $RelativeSide$$Type): $DataType
public "sideConfig"(): $Map<($RelativeSide), ($DataType)>
public "isEjecting"(): boolean
get "ejecting"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedSideConfig$LightConfigInfo$$Type = ({"isEjecting"?: boolean, "sideConfig"?: $Map$$Type<($RelativeSide$$Type), ($DataType$$Type)>}) | ([isEjecting?: boolean, sideConfig?: $Map$$Type<($RelativeSide$$Type), ($DataType$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttachedSideConfig$LightConfigInfo_ = $AttachedSideConfig$LightConfigInfo$$Type;
}}
declare module "mekanism.common.inventory.slot.chemical.ChemicalInventorySlot" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$BooleanSupplier, $BooleanSupplier$$Type} from "java.util.function.BooleanSupplier"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$BasicInventorySlot, $BasicInventorySlot$$Type} from "mekanism.common.inventory.slot.BasicInventorySlot"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"

export class $ChemicalInventorySlot extends $BasicInventorySlot {
static readonly "alwaysTrue": $Predicate<($ItemStack)>
static readonly "alwaysFalse": $Predicate<($ItemStack)>
static readonly "alwaysTrueBi": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($ItemStack), ($AutomationType)>


public static "fill"(chemicalTank: $IChemicalTank$$Type, listener: $IContentsListener$$Type, x: integer, y: integer): $ChemicalInventorySlot
public static "fillInsertCheck"(chemicalTank: $IChemicalTank$$Type, stack: $ItemStack$$Type): boolean
public static "drain"(chemicalTank: $IChemicalTank$$Type, listener: $IContentsListener$$Type, x: integer, y: integer): $ChemicalInventorySlot
public static "getDrainInsertPredicate"(chemicalTank: $IChemicalTank$$Type): $Predicate<($ItemStack)>
public static "getFillExtractPredicate"(chemicalTank: $IChemicalTank$$Type): $Predicate<($ItemStack)>
public static "getPotentialConversion"(world: $Level$$Type, itemStack: $ItemStack$$Type): $ChemicalStack
public static "drainChemicalTank"(slot: $IInventorySlot$$Type, chemicalTank: $IChemicalTank$$Type, handler: $IChemicalHandler$$Type): void
public static "fillChemicalTank"(slot: $IInventorySlot$$Type, chemicalTank: $IChemicalTank$$Type, handler: $IChemicalHandler$$Type): void
public static "fillOrConvert"(gasTank: $IChemicalTank$$Type, worldSupplier: $Supplier$$Type<($Level$$Type)>, listener: $IContentsListener$$Type, x: integer, y: integer): $ChemicalInventorySlot
public "fillTankOrConvert"(): void
public static "rotaryDrain"(chemicalTank: $IChemicalTank$$Type, modeSupplier: $BooleanSupplier$$Type, listener: $IContentsListener$$Type, x: integer, y: integer): $ChemicalInventorySlot
public "fillTank"(): void
public "drainTank"(): void
public static "rotaryFill"(chemicalTank: $IChemicalTank$$Type, modeSupplier: $BooleanSupplier$$Type, listener: $IContentsListener$$Type, x: integer, y: integer): $ChemicalInventorySlot
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $Tag
public "createContainerSlot"(): $Slot
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalInventorySlot$$Type = ($ChemicalInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalInventorySlot_ = $ChemicalInventorySlot$$Type;
}}
declare module "mekanism.common.item.gear.ItemHazmatSuitArmor" {
import {$ArmorMaterial, $ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent, $RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ItemAttributeModifiers, $ItemAttributeModifiers$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Enchantment, $Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Equipable, $Equipable$$Type} from "net.minecraft.world.item.Equipable"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ArmorItem, $ArmorItem$$Type} from "net.minecraft.world.item.ArmorItem"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior, $DispenseItemBehavior$$Type} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$ICapabilityAware, $ICapabilityAware$$Type} from "mekanism.common.capabilities.ICapabilityAware"

export class $ItemHazmatSuitArmor extends $ArmorItem implements $ICapabilityAware {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
readonly "type": $ArmorItem$Type
readonly "material": $Holder<($ArmorMaterial)>
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(armorType: $ArmorItem$Type$$Type, properties: $Item$Properties$$Type)

public "isPrimaryItemFor"(stack: $ItemStack$$Type, enchantment: $Holder$$Type<($Enchantment)>): boolean
public "isBookEnchantable"(stack: $ItemStack$$Type, book: $ItemStack$$Type): boolean
public "isEnchantable"(stack: $ItemStack$$Type): boolean
public "attachCapabilities"(event: $RegisterCapabilitiesEvent$$Type): void
public static "getShieldingByArmor"(type: $ArmorItem$Type$$Type): double
public static "get"(arg0: $ItemStack$$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemHazmatSuitArmor$$Type = ($ItemHazmatSuitArmor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemHazmatSuitArmor_ = $ItemHazmatSuitArmor$$Type;
}}
declare module "mekanism.common.content.entangloporter.InventoryFrequency" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$IExtendedFluidTank, $IExtendedFluidTank$$Type} from "mekanism.api.fluid.IExtendedFluidTank"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IMekanismFluidHandler, $IMekanismFluidHandler$$Type} from "mekanism.api.fluid.IMekanismFluidHandler"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$IEnergyContainer, $IEnergyContainer$$Type} from "mekanism.api.energy.IEnergyContainer"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$IHeatCapacitor, $IHeatCapacitor$$Type} from "mekanism.api.heat.IHeatCapacitor"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler$FluidAction"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$SecurityMode, $SecurityMode$$Type} from "mekanism.api.security.SecurityMode"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IMekanismStrictEnergyHandler, $IMekanismStrictEnergyHandler$$Type} from "mekanism.api.energy.IMekanismStrictEnergyHandler"
import {$IMekanismInventory, $IMekanismInventory$$Type} from "mekanism.api.inventory.IMekanismInventory"
import {$IChemicalTracker, $IChemicalTracker$$Type} from "mekanism.common.capabilities.chemical.IChemicalTracker"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$HeatAPI$HeatTransfer, $HeatAPI$HeatTransfer$$Type} from "mekanism.api.heat.HeatAPI$HeatTransfer"
import {$ITileHeatHandler, $ITileHeatHandler$$Type} from "mekanism.common.capabilities.heat.ITileHeatHandler"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $InventoryFrequency extends $Frequency implements $IMekanismInventory, $IMekanismFluidHandler, $IMekanismStrictEnergyHandler, $ITileHeatHandler, $IChemicalTracker {
static readonly "CODEC": $Codec<($InventoryFrequency)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($InventoryFrequency)>
 "storedEnergy": $IEnergyContainer

constructor(n: string, uuid: $UUID$$Type, securityMode: $SecurityMode$$Type)

public "update"(tile: $BlockEntity$$Type): boolean
public "getEnergyContainers"(side: $Direction$$Type): $List<($IEnergyContainer)>
public "getChemicalTanks"(side: $Direction$$Type): $List<($IChemicalTank)>
public "getInventorySlots"(side: $Direction$$Type): $List<($IInventorySlot)>
public "onContentsChanged"(): void
public "getFluidTanks"(side: $Direction$$Type): $List<($IExtendedFluidTank)>
public "getHeatCapacitors"(side: $Direction$$Type): $List<($IHeatCapacitor)>
public "handleEject"(gameTime: long): void
public "onDeactivate"(tile: $BlockEntity$$Type): boolean
public "getSlots"(arg0: $Direction$$Type): integer
public "getStackInSlot"(arg0: integer, arg1: $Direction$$Type): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: $Direction$$Type, arg3: $Action$$Type): $ItemStack
public "getSlotLimit"(arg0: integer, arg1: $Direction$$Type): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $ItemStack
public "getInventorySlot"(arg0: integer, arg1: $Direction$$Type): $IInventorySlot
public "hasInventory"(): boolean
public "isInventoryEmpty"(arg0: $Direction$$Type): boolean
public "isInventoryEmpty"(): boolean
public "getFluidTank"(arg0: integer, arg1: $Direction$$Type): $IExtendedFluidTank
public "getTanks"(arg0: $Direction$$Type): integer
public "getTankCapacity"(arg0: integer, arg1: $Direction$$Type): integer
public "getFluidInTank"(arg0: integer, arg1: $Direction$$Type): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type): void
public "canHandleFluid"(): boolean
public "extractFluid"(arg0: integer, arg1: $Direction$$Type, arg2: $Action$$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Direction$$Type, arg3: $Action$$Type): $FluidStack
public "insertFluid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $FluidStack
public "getEnergyContainerCount"(arg0: $Direction$$Type): integer
public "getMaxEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "extractEnergy"(arg0: long, arg1: $Direction$$Type, arg2: $Action$$Type): long
public "extractEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type, arg3: $Action$$Type): long
public "getNeededEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "getEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "setEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type): void
public "canHandleEnergy"(): boolean
public "getEnergyContainer"(arg0: integer, arg1: $Direction$$Type): $IEnergyContainer
public "insertEnergy"(arg0: long, arg1: $Direction$$Type, arg2: $Action$$Type): long
public "insertEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type, arg3: $Action$$Type): long
public "simulateAdjacent"(): double
public "getAdjacent"(side: $Direction$$Type): $IHeatHandler
public "simulate"(): $HeatAPI$HeatTransfer
public "getAmbientTemperature"(side: $Direction$$Type): double
public "incrementAdjacentTransfer"(currentAdjacentTransfer: double, tempToTransfer: double, side: $Direction$$Type): double
public "simulateEnvironment"(): double
public "updateHeatCapacitors"(side: $Direction$$Type): void
public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "getInventorySideFor"(): $Direction
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "getTanks"(): integer
public "getTankCapacity"(arg0: integer): integer
public "getFluidInTank"(arg0: integer): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$$Type): void
public "getFluidSideFor"(): $Direction
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Action$$Type): $FluidStack
public "insertFluid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Action$$Type): $FluidStack
public "getEnergyContainerCount"(): integer
public "getMaxEnergy"(arg0: integer): long
public "extractEnergy"(arg0: integer, arg1: long, arg2: $Action$$Type): long
public "getNeededEnergy"(arg0: integer): long
public "getEnergy"(arg0: integer): long
public "setEnergy"(arg0: integer, arg1: long): void
public "insertEnergy"(arg0: integer, arg1: long, arg2: $Action$$Type): long
public "getEnergySideFor"(): $Direction
public "getTemperature"(arg0: integer, arg1: $Direction$$Type): double
public "getHeatCapacitor"(arg0: integer, arg1: $Direction$$Type): $IHeatCapacitor
public "getHeatCapacity"(arg0: integer, arg1: $Direction$$Type): double
public "canHandleHeat"(): boolean
public "getTotalInverseInsulation"(arg0: $Direction$$Type): double
public "getTotalTemperature"(arg0: $Direction$$Type): double
public "getTotalHeatCapacity"(arg0: $Direction$$Type): double
public "getInverseConduction"(arg0: integer, arg1: $Direction$$Type): double
public "getHeatCapacitorCount"(arg0: $Direction$$Type): integer
public "getInverseInsulation"(arg0: integer, arg1: $Direction$$Type): double
public "getTotalInverseConductionCoefficient"(arg0: $Direction$$Type): double
public "handleHeat"(arg0: double, arg1: $Direction$$Type): void
public "handleHeat"(arg0: integer, arg1: double, arg2: $Direction$$Type): void
/**
 * 
 * @deprecated
 */
public "fill"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): integer
/**
 * 
 * @deprecated
 */
public "drain"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Action$$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$$Type, arg1: $Action$$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$$Type, arg1: $Action$$Type): $FluidStack
public "extractEnergy"(arg0: long, arg1: $Action$$Type): long
public "insertEnergy"(arg0: long, arg1: $Action$$Type): long
public "getTemperature"(arg0: integer): double
public "getHeatCapacity"(arg0: integer): double
public "getHeatSideFor"(): $Direction
public "getTotalTemperature"(): double
public "getTotalHeatCapacity"(): double
public "getInverseConduction"(arg0: integer): double
public "getHeatCapacitorCount"(): integer
public "getTotalInverseConduction"(): double
public "handleHeat"(arg0: double): void
public "handleHeat"(arg0: integer, arg1: double): void
public "kjs$self"(): $IItemHandler
public "getStackInSlot"(arg0: integer): $ItemStack
public "getSlots"(): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isMutable"(): boolean
public "getBlock"(arg0: $Level$$Type): $BlockContainerJS
public "asContainer"(): $Container
public "getHeight"(): integer
public "setChanged"(): void
public "insertItem"(arg0: $ItemStack$$Type, arg1: boolean): $ItemStack
public "getAllItems"(): $List<($ItemStack)>
public "countNonEmpty"(): integer
public "countNonEmpty"(arg0: $ItemPredicate$$Type): integer
public "getWidth"(): integer
public "isEmpty"(): boolean
public "find"(): integer
public "find"(arg0: $ItemPredicate$$Type): integer
public "clear"(arg0: $ItemPredicate$$Type): void
public "clear"(): void
public "count"(arg0: $ItemPredicate$$Type): integer
public "count"(): integer
get "inventoryEmpty"(): boolean
get "slots"(): integer
get "inventorySideFor"(): $Direction
get "tanks"(): integer
get "fluidSideFor"(): $Direction
get "energyContainerCount"(): integer
get "energySideFor"(): $Direction
get "heatSideFor"(): $Direction
get "totalTemperature"(): double
get "totalHeatCapacity"(): double
get "heatCapacitorCount"(): integer
get "totalInverseConduction"(): double
get "slots"(): integer
get "mutable"(): boolean
get "height"(): integer
get "allItems"(): $List<($ItemStack)>
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryFrequency$$Type = ($InventoryFrequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryFrequency_ = $InventoryFrequency$$Type;
}}
declare module "mekanism.common.block.BlockRadioactiveWasteBarrel" {
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$TileEntityRadioactiveWasteBarrel, $TileEntityRadioactiveWasteBarrel$$Type} from "mekanism.common.tile.TileEntityRadioactiveWasteBarrel"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$$Type} from "mekanism.common.block.prefab.BlockTile$BlockTileModel"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockRadioactiveWasteBarrel extends $BlockTile$BlockTileModel<($TileEntityRadioactiveWasteBarrel), ($BlockTypeTile<($TileEntityRadioactiveWasteBarrel)>)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor()

public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRadioactiveWasteBarrel$$Type = ($BlockRadioactiveWasteBarrel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockRadioactiveWasteBarrel_ = $BlockRadioactiveWasteBarrel$$Type;
}}
declare module "mekanism.common.registration.INamedEntry" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"

export interface $INamedEntry {

 "getName"(): string
 "getId"(): $ResourceLocation

(): $ResourceLocation$$Type
get "name"(): string
get "id"(): $ResourceLocation
}

export namespace $INamedEntry {
const probejs$$marker: never
}
export class $INamedEntry$$Static implements $INamedEntry {


 "getName"(): string
 "getId"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $INamedEntry$$Type = (() => $ResourceLocation$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $INamedEntry_ = $INamedEntry$$Type;
}}
declare module "mekanism.common.block.interfaces.IHasDescription" {
import {$ILangEntry, $ILangEntry$$Type} from "mekanism.api.text.ILangEntry"

export interface $IHasDescription {

 "getDescription"(): $ILangEntry

(): $ILangEntry$$Type
get "description"(): $ILangEntry
}

export namespace $IHasDescription {
const probejs$$marker: never
}
export class $IHasDescription$$Static implements $IHasDescription {


 "getDescription"(): $ILangEntry
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHasDescription$$Type = (() => $ILangEntry$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHasDescription_ = $IHasDescription$$Type;
}}
declare module "mekanism.common.content.transporter.PathfinderCache$CachedPath" {
import {$LongList, $LongList$$Type} from "it.unimi.dsi.fastutil.longs.LongList"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $PathfinderCache$CachedPath extends $Record {

constructor(path: $LongList$$Type, cost: double)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "path"(): $LongList
public "cost"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathfinderCache$CachedPath$$Type = ({"path"?: $LongList$$Type, "cost"?: double}) | ([path?: $LongList$$Type, cost?: double]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PathfinderCache$CachedPath_ = $PathfinderCache$CachedPath$$Type;
}}
declare module "mekanism.common.inventory.slot.FluidInventorySlot" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$IFluidContainerManager$ContainerEditMode, $IFluidContainerManager$ContainerEditMode$$Type} from "mekanism.common.tile.interfaces.IFluidContainerManager$ContainerEditMode"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IExtendedFluidTank, $IExtendedFluidTank$$Type} from "mekanism.api.fluid.IExtendedFluidTank"
import {$IFluidHandlerSlot, $IFluidHandlerSlot$$Type} from "mekanism.common.inventory.slot.IFluidHandlerSlot"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$BooleanSupplier, $BooleanSupplier$$Type} from "java.util.function.BooleanSupplier"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$IFluidHandlerItem, $IFluidHandlerItem$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandlerItem"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$BasicInventorySlot, $BasicInventorySlot$$Type} from "mekanism.common.inventory.slot.BasicInventorySlot"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"

export class $FluidInventorySlot extends $BasicInventorySlot implements $IFluidHandlerSlot {
static readonly "alwaysTrue": $Predicate<($ItemStack)>
static readonly "alwaysFalse": $Predicate<($ItemStack)>
static readonly "alwaysTrueBi": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($ItemStack), ($AutomationType)>


public static "fill"(fluidTank: $IExtendedFluidTank$$Type, listener: $IContentsListener$$Type, x: integer, y: integer): $FluidInventorySlot
public static "input"(fluidTank: $IExtendedFluidTank$$Type, listener: $IContentsListener$$Type, x: integer, y: integer): $FluidInventorySlot
public "setDraining"(draining: boolean): void
public static "getFillPredicate"(fluidTank: $IExtendedFluidTank$$Type): $Predicate<($ItemStack)>
public "setStack"(stack: $ItemStack$$Type): void
public "getFluidTank"(): $IExtendedFluidTank
public "isDraining"(): boolean
public "isFilling"(): boolean
public "setFilling"(filling: boolean): void
public static "drain"(fluidTank: $IExtendedFluidTank$$Type, listener: $IContentsListener$$Type, x: integer, y: integer): $FluidInventorySlot
public static "isNonFullFluidContainer"(fluidHandler: $IFluidHandlerItem$$Type): boolean
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $Tag$$Type): void
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $CompoundTag$$Type): void
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $Tag
public static "tryGetFluidHandlerUnstacked"(stack: $ItemStack$$Type): $IFluidHandlerItem
public static "rotary"(fluidTank: $IExtendedFluidTank$$Type, modeSupplier: $BooleanSupplier$$Type, listener: $IContentsListener$$Type, x: integer, y: integer): $FluidInventorySlot
public "handleTank"(outputSlot: $IInventorySlot$$Type, editMode: $IFluidContainerManager$ContainerEditMode$$Type): void
public "fillTank"(outputSlot: $IInventorySlot$$Type): void
public "fillTank"(): boolean
public "drainTank"(outputSlot: $IInventorySlot$$Type): void
public "createContainerSlot"(): $Slot
set "draining"(value: boolean)
set "stack"(value: $ItemStack$$Type)
get "fluidTank"(): $IExtendedFluidTank
get "draining"(): boolean
get "filling"(): boolean
set "filling"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidInventorySlot$$Type = ($FluidInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidInventorySlot_ = $FluidInventorySlot$$Type;
}}
declare module "mekanism.common.inventory.warning.ISupportsWarning" {
import {$WarningTracker$WarningType, $WarningTracker$WarningType$$Type} from "mekanism.common.inventory.warning.WarningTracker$WarningType"
import {$BooleanSupplier, $BooleanSupplier$$Type} from "java.util.function.BooleanSupplier"

export interface $ISupportsWarning<TYPE extends $ISupportsWarning<(TYPE)>> {

 "warning"(type: $WarningTracker$WarningType$$Type, warningSupplier: $BooleanSupplier$$Type): TYPE

(type: $WarningTracker$WarningType, warningSupplier: $BooleanSupplier): TYPE
}

export namespace $ISupportsWarning {
function compound(existing: $BooleanSupplier$$Type, newSupplier: $BooleanSupplier$$Type): $BooleanSupplier
const probejs$$marker: never
}
export class $ISupportsWarning$$Static<TYPE extends $ISupportsWarning<(TYPE)>> implements $ISupportsWarning {


 "warning"(type: $WarningTracker$WarningType$$Type, warningSupplier: $BooleanSupplier$$Type): TYPE
static "compound"(existing: $BooleanSupplier$$Type, newSupplier: $BooleanSupplier$$Type): $BooleanSupplier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISupportsWarning$$Type<TYPE> = ((type: $WarningTracker$WarningType, warningSupplier: $BooleanSupplier) => TYPE);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISupportsWarning_<TYPE> = $ISupportsWarning$$Type<(TYPE)>;
}}
declare module "mekanism.common.content.transporter.TransporterPathfinder$Destination" {
import {$PathfinderCache$CachedPath, $PathfinderCache$CachedPath$$Type} from "mekanism.common.content.transporter.PathfinderCache$CachedPath"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$$Type} from "mekanism.common.lib.inventory.TransitRequest$TransitResponse"
import {$LongList, $LongList$$Type} from "it.unimi.dsi.fastutil.longs.LongList"
import {$TransporterStack$Path, $TransporterStack$Path$$Type} from "mekanism.common.content.transporter.TransporterStack$Path"

export class $TransporterPathfinder$Destination implements $Comparable<($TransporterPathfinder$Destination)> {

constructor(path: $PathfinderCache$CachedPath$$Type, ret: $TransitRequest$TransitResponse$$Type)
constructor(path: $LongList$$Type, ret: $TransitRequest$TransitResponse$$Type, gScore: double)

public "equals"(o: any): boolean
public "hashCode"(): integer
public "compareTo"(dest: any): integer
public "compareTo"(dest: $TransporterPathfinder$Destination$$Type): integer
public "getPath"(): $LongList
public "setPathType"(type: $TransporterStack$Path$$Type): $TransporterPathfinder$Destination
public "getPathType"(): $TransporterStack$Path
public "getResponse"(): $TransitRequest$TransitResponse
get "path"(): $LongList
set "pathType"(value: $TransporterStack$Path$$Type)
get "pathType"(): $TransporterStack$Path
get "response"(): $TransitRequest$TransitResponse
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransporterPathfinder$Destination$$Type = ($TransporterPathfinder$Destination);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransporterPathfinder$Destination_ = $TransporterPathfinder$Destination$$Type;
}}
declare module "mekanism.common.block.BlockIndustrialAlarm" {
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$TileEntityIndustrialAlarm, $TileEntityIndustrialAlarm$$Type} from "mekanism.common.tile.TileEntityIndustrialAlarm"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$$Type} from "mekanism.common.block.prefab.BlockTile$BlockTileModel"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockIndustrialAlarm extends $BlockTile$BlockTileModel<($TileEntityIndustrialAlarm), ($BlockTypeTile<($TileEntityIndustrialAlarm)>)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor()

public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIndustrialAlarm$$Type = ($BlockIndustrialAlarm);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockIndustrialAlarm_ = $BlockIndustrialAlarm$$Type;
}}
declare module "mekanism.common.block.transmitter.BlockTransmitter" {
import {$BlockEntityTicker, $BlockEntityTicker$$Type} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBase$BlockBaseModel, $BlockBase$BlockBaseModel$$Type} from "mekanism.common.block.prefab.BlockBase$BlockBaseModel"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IHasTileEntity, $IHasTileEntity$$Type} from "mekanism.common.block.interfaces.IHasTileEntity"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$$Type} from "mekanism.common.registration.impl.TileEntityTypeRegistryObject"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$TileEntityTransmitter, $TileEntityTransmitter$$Type} from "mekanism.common.tile.transmitter.TileEntityTransmitter"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$GameEventListener, $GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockTransmitter<TILE extends $TileEntityTransmitter> extends $BlockBase$BlockBaseModel<($BlockTypeTile<(TILE)>)> implements $IHasTileEntity<(TILE)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>


public "getTileType"(): $TileEntityTypeRegistryObject<(TILE)>
public "getTicker"<T extends $BlockEntity>(level: $Level$$Type, state: $BlockState$$Type, blockEntityType: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(pos: $BlockPos$$Type, state: $BlockState$$Type): TILE
public "triggerBlockEntityEvent"(state: $BlockState$$Type, level: $Level$$Type, pos: $BlockPos$$Type, id: integer, param: integer): boolean
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "asHolder"(): $Holder<(any)>
get "tileType"(): $TileEntityTypeRegistryObject<(TILE)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTransmitter$$Type<TILE> = ($BlockTransmitter<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTransmitter_<TILE> = $BlockTransmitter$$Type<(TILE)>;
}}
declare module "mekanism.common.tile.laser.TileEntityLaserAmplifier" {
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$TileEntityLaserAmplifier$RedstoneOutput, $TileEntityLaserAmplifier$RedstoneOutput$$Type} from "mekanism.common.tile.laser.TileEntityLaserAmplifier$RedstoneOutput"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IRedstoneControl$RedstoneControl, $IRedstoneControl$RedstoneControl$$Type} from "mekanism.common.tile.interfaces.IRedstoneControl$RedstoneControl"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$TileEntityLaserReceptor, $TileEntityLaserReceptor$$Type} from "mekanism.common.tile.laser.TileEntityLaserReceptor"
import {$IHasMode, $IHasMode$$Type} from "mekanism.common.tile.interfaces.IHasMode"

export class $TileEntityLaserAmplifier extends $TileEntityLaserReceptor implements $IHasMode {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(pos: $BlockPos$$Type, state: $BlockState$$Type)

public "setDelay"(delay: integer): void
public "getDelay"(): integer
public "readSustainedData"(provider: $HolderLookup$Provider$$Type, data: $CompoundTag$$Type): void
public "writeSustainedData"(provider: $HolderLookup$Provider$$Type, data: $CompoundTag$$Type): void
public "supportsMode"(mode: $IRedstoneControl$RedstoneControl$$Type): boolean
public "nextMode"(): void
public "addContainerTrackers"(container: $MekanismContainer$$Type): void
public "getMaxThreshold"(): long
public "getOutputMode"(): $TileEntityLaserAmplifier$RedstoneOutput
public "getMinThreshold"(): long
public "previousMode"(): void
public "getRedstoneLevel"(): integer
public "setMinThresholdFromPacket"(target: long): void
public "setMaxThresholdFromPacket"(target: long): void
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
set "delay"(value: integer)
get "delay"(): integer
get "maxThreshold"(): long
get "outputMode"(): $TileEntityLaserAmplifier$RedstoneOutput
get "minThreshold"(): long
get "redstoneLevel"(): integer
set "minThresholdFromPacket"(value: long)
set "maxThresholdFromPacket"(value: long)
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityLaserAmplifier$$Type = ($TileEntityLaserAmplifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityLaserAmplifier_ = $TileEntityLaserAmplifier$$Type;
}}
declare module "mekanism.common.world.ResizableOreFeature" {
import {$GeodeConfiguration, $GeodeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration, $VegetationPatchConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature, $SeagrassFeature$$Type} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration, $SpringConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration, $ReplaceSphereConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig, $TwistingVinesConfig$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration, $BlockStateConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration, $BlockPileConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$EndGatewayConfiguration, $EndGatewayConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$UnderwaterMagmaConfiguration, $UnderwaterMagmaConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$LakeFeature$Configuration, $LakeFeature$Configuration$$Type} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$RootSystemConfiguration, $RootSystemConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature, $BonusChestFeature$$Type} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration, $OreConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig, $NetherForestVegetationConfig$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration, $RandomBooleanFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration, $CountConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration, $RandomPatchConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration, $RandomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration, $HugeMushroomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration, $SimpleBlockConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$DeltaFeatureConfiguration, $DeltaFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$MultifaceGrowthConfiguration, $MultifaceGrowthConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$LayerConfiguration, $LayerConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ReplaceBlockConfiguration, $ReplaceBlockConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$ProbabilityFeatureConfiguration, $ProbabilityFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$Feature, $Feature$$Type} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration, $BlockColumnConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration, $FossilFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration, $LargeDripstoneConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration, $ColumnFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext, $FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration, $SpikeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration, $HugeFungusConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration, $TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$PointedDripstoneConfiguration, $PointedDripstoneConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$DiskConfiguration, $DiskConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$SimpleRandomFeatureConfiguration, $SimpleRandomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$SculkPatchConfiguration, $SculkPatchConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$ResizableOreFeatureConfig, $ResizableOreFeatureConfig$$Type} from "mekanism.common.world.ResizableOreFeatureConfig"
import {$DripstoneClusterConfiguration, $DripstoneClusterConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $ResizableOreFeature extends $Feature<($ResizableOreFeatureConfig)> {
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>

constructor()

public "place"(context: $FeaturePlaceContext$$Type<($ResizableOreFeatureConfig$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResizableOreFeature$$Type = ($ResizableOreFeature);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResizableOreFeature_ = $ResizableOreFeature$$Type;
}}
declare module "mekanism.common.world.ResizableDiskReplaceFeature" {
import {$GeodeConfiguration, $GeodeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration, $VegetationPatchConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature, $SeagrassFeature$$Type} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration, $SpringConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration, $ReplaceSphereConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig, $TwistingVinesConfig$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration, $BlockStateConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration, $BlockPileConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$EndGatewayConfiguration, $EndGatewayConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$UnderwaterMagmaConfiguration, $UnderwaterMagmaConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$LakeFeature$Configuration, $LakeFeature$Configuration$$Type} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration, $RootSystemConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature, $BonusChestFeature$$Type} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration, $OreConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig, $NetherForestVegetationConfig$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration, $RandomBooleanFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration, $CountConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration, $RandomPatchConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration, $RandomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration, $HugeMushroomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration, $SimpleBlockConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$DeltaFeatureConfiguration, $DeltaFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$MultifaceGrowthConfiguration, $MultifaceGrowthConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$ResizableDiskConfig, $ResizableDiskConfig$$Type} from "mekanism.common.world.ResizableDiskConfig"
import {$LayerConfiguration, $LayerConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ReplaceBlockConfiguration, $ReplaceBlockConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$ProbabilityFeatureConfiguration, $ProbabilityFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$Feature, $Feature$$Type} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration, $BlockColumnConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration, $FossilFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration, $LargeDripstoneConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration, $ColumnFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext, $FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration, $SpikeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration, $HugeFungusConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration, $TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$PointedDripstoneConfiguration, $PointedDripstoneConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$DiskConfiguration, $DiskConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$SimpleRandomFeatureConfiguration, $SimpleRandomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$SculkPatchConfiguration, $SculkPatchConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$DripstoneClusterConfiguration, $DripstoneClusterConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $ResizableDiskReplaceFeature extends $Feature<($ResizableDiskConfig)> {
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>

constructor(codec: $Codec$$Type<($ResizableDiskConfig$$Type)>)

public "place"(context: $FeaturePlaceContext$$Type<($ResizableDiskConfig$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResizableDiskReplaceFeature$$Type = ($ResizableDiskReplaceFeature);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResizableDiskReplaceFeature_ = $ResizableDiskReplaceFeature$$Type;
}}
declare module "mekanism.common.recipe.lookup.IRecipeLookupHandler" {
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$IMekanismRecipeTypeProvider, $IMekanismRecipeTypeProvider$$Type} from "mekanism.common.recipe.IMekanismRecipeTypeProvider"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$CachedRecipe, $CachedRecipe$$Type} from "mekanism.api.recipes.cache.CachedRecipe"
import {$IRecipeViewerRecipeType, $IRecipeViewerRecipeType$$Type} from "mekanism.client.recipe_viewer.type.IRecipeViewerRecipeType"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"

export interface $IRecipeLookupHandler<RECIPE extends $MekanismRecipe<(any)>> extends $IContentsListener {

 "getLevel"(): $Level
 "getRecipe"(cacheIndex: integer): RECIPE
 "getRecipeType"(): $IMekanismRecipeTypeProvider<(any), (RECIPE), (any)>
 "clearRecipeErrors"(cacheIndex: integer): void
 "recipeViewerType"(): $IRecipeViewerRecipeType<(RECIPE)>
 "onCachedRecipeChanged"(cachedRecipe: $CachedRecipe$$Type<(RECIPE)>, cacheIndex: integer): void
 "getSavedOperatingTicks"(cacheIndex: integer): integer
 "createNewCachedRecipe"(recipe: RECIPE, cacheIndex: integer): $CachedRecipe<(RECIPE)>
 "onContentsChanged"(): void
get "level"(): $Level
get "recipeType"(): $IMekanismRecipeTypeProvider<(any), (RECIPE), (any)>
}

export namespace $IRecipeLookupHandler {
const probejs$$marker: never
}
export class $IRecipeLookupHandler$$Static<RECIPE extends $MekanismRecipe<(any)>> implements $IRecipeLookupHandler {


 "getLevel"(): $Level
 "getRecipe"(cacheIndex: integer): RECIPE
 "getRecipeType"(): $IMekanismRecipeTypeProvider<(any), (RECIPE), (any)>
 "clearRecipeErrors"(cacheIndex: integer): void
 "recipeViewerType"(): $IRecipeViewerRecipeType<(RECIPE)>
 "onCachedRecipeChanged"(cachedRecipe: $CachedRecipe$$Type<(RECIPE)>, cacheIndex: integer): void
 "getSavedOperatingTicks"(cacheIndex: integer): integer
 "createNewCachedRecipe"(recipe: RECIPE, cacheIndex: integer): $CachedRecipe<(RECIPE)>
 "onContentsChanged"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRecipeLookupHandler$$Type<RECIPE> = ($IRecipeLookupHandler<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRecipeLookupHandler_<RECIPE> = $IRecipeLookupHandler$$Type<(RECIPE)>;
}}
declare module "mekanism.common.attachments.containers.ContainerType" {
import {$IMekanismConfig, $IMekanismConfig$$Type} from "mekanism.common.config.IMekanismConfig"
import {$ComponentBackedHeatHandler, $ComponentBackedHeatHandler$$Type} from "mekanism.common.attachments.containers.heat.ComponentBackedHeatHandler"
import {$ComponentBackedEnergyHandler, $ComponentBackedEnergyHandler$$Type} from "mekanism.common.attachments.containers.energy.ComponentBackedEnergyHandler"
import {$ComponentBackedFluidHandler, $ComponentBackedFluidHandler$$Type} from "mekanism.common.attachments.containers.fluid.ComponentBackedFluidHandler"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent, $RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List, $List$$Type} from "java.util.List"
import {$ComponentBackedChemicalHandler, $ComponentBackedChemicalHandler$$Type} from "mekanism.common.attachments.containers.chemical.ComponentBackedChemicalHandler"
import {$IExtendedFluidTank, $IExtendedFluidTank$$Type} from "mekanism.api.fluid.IExtendedFluidTank"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$DataComponentMap$Builder, $DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$INBTSerializable, $INBTSerializable$$Type} from "net.neoforged.neoforge.common.util.INBTSerializable"
import {$AttachedChemicals, $AttachedChemicals$$Type} from "mekanism.common.attachments.containers.chemical.AttachedChemicals"
import {$ComponentBackedItemHandler, $ComponentBackedItemHandler$$Type} from "mekanism.common.attachments.containers.item.ComponentBackedItemHandler"
import {$DeferredHolder, $DeferredHolder$$Type} from "net.neoforged.neoforge.registries.DeferredHolder"
import {$AttachedItems, $AttachedItems$$Type} from "mekanism.common.attachments.containers.item.AttachedItems"
import {$AttachedFluids, $AttachedFluids$$Type} from "mekanism.common.attachments.containers.fluid.AttachedFluids"
import {$IEventBus, $IEventBus$$Type} from "net.neoforged.bus.api.IEventBus"
import {$IEnergyContainer, $IEnergyContainer$$Type} from "mekanism.api.energy.IEnergyContainer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ComponentBackedHandler, $ComponentBackedHandler$$Type} from "mekanism.common.attachments.containers.ComponentBackedHandler"
import {$AttachedEnergy, $AttachedEnergy$$Type} from "mekanism.common.attachments.containers.energy.AttachedEnergy"
import {$IHeatCapacitor, $IHeatCapacitor$$Type} from "mekanism.api.heat.IHeatCapacitor"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IAttachedContainers, $IAttachedContainers$$Type} from "mekanism.common.attachments.containers.IAttachedContainers"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockEntity$DataComponentInput, $BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$ItemLike, $ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$IContainerCreator, $IContainerCreator$$Type} from "mekanism.common.attachments.containers.creator.IContainerCreator"
import {$DataComponentPatch$Builder, $DataComponentPatch$Builder$$Type} from "net.minecraft.core.component.DataComponentPatch$Builder"
import {$AttachedHeat, $AttachedHeat$$Type} from "mekanism.common.attachments.containers.heat.AttachedHeat"

export class $ContainerType<CONTAINER extends $INBTSerializable<($CompoundTag)>, ATTACHED extends $IAttachedContainers<(any), (ATTACHED)>, HANDLER extends $ComponentBackedHandler<(any), (CONTAINER), (ATTACHED)>> {
static readonly "TYPES": $List<($ContainerType<(any), (any), (any)>)>
static readonly "ENERGY": $ContainerType<($IEnergyContainer), ($AttachedEnergy), ($ComponentBackedEnergyHandler)>
static readonly "ITEM": $ContainerType<($IInventorySlot), ($AttachedItems), ($ComponentBackedItemHandler)>
static readonly "FLUID": $ContainerType<($IExtendedFluidTank), ($AttachedFluids), ($ComponentBackedFluidHandler)>
static readonly "CHEMICAL": $ContainerType<($IChemicalTank), ($AttachedChemicals), ($ComponentBackedChemicalHandler)>
static readonly "HEAT": $ContainerType<($IHeatCapacitor), ($AttachedHeat), ($ComponentBackedHeatHandler)>
static readonly "CODEC": $Codec<($ContainerType<(any), (any), (any)>)>


public "getComponentType"(): $DeferredHolder<($DataComponentType<(any)>), ($DataComponentType<(ATTACHED)>)>
public "readFrom"(provider: $HolderLookup$Provider$$Type, tag: $CompoundTag$$Type, tile: $TileEntityMekanism$$Type): void
public "readFrom"(provider: $HolderLookup$Provider$$Type, tag: $CompoundTag$$Type, containers: $List$$Type<(CONTAINER)>): void
public "getTag"(): string
public "supports"(stack: $ItemStack$$Type): boolean
public "addDefault"(item: $ItemLike$$Type, builder: $DataComponentPatch$Builder$$Type): void
public "createHandlerIfData"(stack: $ItemStack$$Type): HANDLER
public "createContainer"(attachedTo: $ItemStack$$Type, containerIndex: integer): CONTAINER
public "saveTo"(provider: $HolderLookup$Provider$$Type, tag: $CompoundTag$$Type, tile: $TileEntityMekanism$$Type): void
public "saveTo"(provider: $HolderLookup$Provider$$Type, tag: $CompoundTag$$Type, containers: $List$$Type<(CONTAINER)>): void
public "canHandle"(tile: $TileEntityMekanism$$Type): boolean
public static "anySupports"(itemLike: $ItemLike$$Type): boolean
public "addDefaultCreators"(eventBus: $IEventBus$$Type, item: $Item$$Type, defaultCreator: $Supplier$$Type<($IContainerCreator$$Type<(CONTAINER), (ATTACHED)>)>, ...requiredConfigs: ($IMekanismConfig$$Type)[]): void
public "getComponentName"(): $ResourceLocation
public "copyFromStack"(provider: $HolderLookup$Provider$$Type, stack: $ItemStack$$Type, containers: $List$$Type<(CONTAINER)>): void
public "copyToStack"(provider: $HolderLookup$Provider$$Type, containers: $List$$Type<(CONTAINER)>, stack: $ItemStack$$Type): void
public "getContainerCount"(stack: $ItemStack$$Type): integer
public "createHandler"(stack: $ItemStack$$Type): HANDLER
public "copyToTile"(tile: $TileEntityMekanism$$Type, input: $BlockEntity$DataComponentInput$$Type): void
public "createNewAttachment"(stack: $ItemStack$$Type): ATTACHED
public "registerItemCapabilities"(event: $RegisterCapabilitiesEvent$$Type, item: $Item$$Type, exposeWhenStacked: boolean, ...requiredConfigs: ($IMekanismConfig$$Type)[]): void
public "getAttachmentContainersIfPresent"(stack: $ItemStack$$Type): $List<(CONTAINER)>
public "copyFromTile"(tile: $TileEntityMekanism$$Type, builder: $DataComponentMap$Builder$$Type): void
public "getContainers"(tile: $TileEntityMekanism$$Type): $List<(CONTAINER)>
public "getOrEmpty"(stack: $ItemStack$$Type): ATTACHED
get "componentType"(): $DeferredHolder<($DataComponentType<(any)>), ($DataComponentType<(ATTACHED)>)>
get "tag"(): string
get "componentName"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerType$$Type<CONTAINER, ATTACHED, HANDLER> = ($ContainerType<(CONTAINER), (ATTACHED), (HANDLER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContainerType_<CONTAINER, ATTACHED, HANDLER> = $ContainerType$$Type<(CONTAINER), (ATTACHED), (HANDLER)>;
}}
declare module "mekanism.common.lib.multiblock.IStructureValidator" {
import {$Structure, $Structure$$Type} from "mekanism.common.lib.multiblock.Structure"
import {$FormationProtocol, $FormationProtocol$$Type} from "mekanism.common.lib.multiblock.FormationProtocol"
import {$MultiblockManager, $MultiblockManager$$Type} from "mekanism.common.lib.multiblock.MultiblockManager"
import {$FormationProtocol$FormationResult, $FormationProtocol$FormationResult$$Type} from "mekanism.common.lib.multiblock.FormationProtocol$FormationResult"
import {$Long2ObjectMap, $Long2ObjectMap$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectMap"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ChunkAccess, $ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$IShape, $IShape$$Type} from "mekanism.common.lib.math.voxel.IShape"
import {$MultiblockData, $MultiblockData$$Type} from "mekanism.common.lib.multiblock.MultiblockData"

export interface $IStructureValidator<T extends $MultiblockData> {

 "validate"(ctx: $FormationProtocol$$Type<(T)>, chunkMap: $Long2ObjectMap$$Type<($ChunkAccess$$Type)>): $FormationProtocol$FormationResult
 "init"(world: $Level$$Type, manager: $MultiblockManager$$Type<(T)>, structure: $Structure$$Type): void
 "getShape"(): $IShape
 "postcheck"(structure: T, chunkMap: $Long2ObjectMap$$Type<($ChunkAccess$$Type)>): $FormationProtocol$FormationResult
 "precheck"(): boolean
get "shape"(): $IShape
}

export namespace $IStructureValidator {
const probejs$$marker: never
}
export class $IStructureValidator$$Static<T extends $MultiblockData> implements $IStructureValidator {


 "validate"(ctx: $FormationProtocol$$Type<(T)>, chunkMap: $Long2ObjectMap$$Type<($ChunkAccess$$Type)>): $FormationProtocol$FormationResult
 "init"(world: $Level$$Type, manager: $MultiblockManager$$Type<(T)>, structure: $Structure$$Type): void
 "getShape"(): $IShape
 "postcheck"(structure: T, chunkMap: $Long2ObjectMap$$Type<($ChunkAccess$$Type)>): $FormationProtocol$FormationResult
 "precheck"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IStructureValidator$$Type<T> = ($IStructureValidator<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IStructureValidator_<T> = $IStructureValidator$$Type<(T)>;
}}
declare module "mekanism.common.item.ItemDosimeter" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $ItemDosimeter extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "use"(world: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "interactLivingEntity"(stack: $ItemStack$$Type, player: $Player$$Type, entity: $LivingEntity$$Type, hand: $InteractionHand$$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDosimeter$$Type = ($ItemDosimeter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDosimeter_ = $ItemDosimeter$$Type;
}}
declare module "mekanism.common.advancements.triggers.AlloyUpgradeTrigger$TriggerInstance" {
import {$Criterion, $Criterion$$Type} from "net.minecraft.advancements.Criterion"
import {$ContextAwarePredicate, $ContextAwarePredicate$$Type} from "net.minecraft.advancements.critereon.ContextAwarePredicate"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$CriterionValidator, $CriterionValidator$$Type} from "net.minecraft.advancements.critereon.CriterionValidator"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$SimpleCriterionTrigger$SimpleInstance, $SimpleCriterionTrigger$SimpleInstance$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger$SimpleInstance"

export class $AlloyUpgradeTrigger$TriggerInstance extends $Record implements $SimpleCriterionTrigger$SimpleInstance {
static readonly "CODEC": $Codec<($AlloyUpgradeTrigger$TriggerInstance)>

constructor(player: $Optional$$Type<($ContextAwarePredicate$$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "player"(): $Optional<($ContextAwarePredicate)>
public static "upgraded"(): $Criterion<($AlloyUpgradeTrigger$TriggerInstance)>
public "validate"(arg0: $CriterionValidator$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlloyUpgradeTrigger$TriggerInstance$$Type = ({"player"?: ($ContextAwarePredicate$$Type)?}) | ([player?: ($ContextAwarePredicate$$Type)?]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlloyUpgradeTrigger$TriggerInstance_ = $AlloyUpgradeTrigger$TriggerInstance$$Type;
}}
declare module "mekanism.common.registration.impl.TileEntityTypeRegistryObject" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BlockEntityTicker, $BlockEntityTicker$$Type} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$MekanismDeferredHolder, $MekanismDeferredHolder$$Type} from "mekanism.common.registration.MekanismDeferredHolder"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $TileEntityTypeRegistryObject<BE extends $BlockEntity> extends $MekanismDeferredHolder<($BlockEntityType<(any)>), ($BlockEntityType<(BE)>)> {

constructor(key: $ResourceKey$$Type<($BlockEntityType<(any)>)>)

public "getTicker"(isClient: boolean): $BlockEntityTicker<(BE)>
public "getId"(): $ResourceLocation
public static "direct"<T>(arg0: T): $Holder<(T)>
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityTypeRegistryObject$$Type<BE> = ($TileEntityTypeRegistryObject<(BE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityTypeRegistryObject_<BE> = $TileEntityTypeRegistryObject$$Type<(BE)>;
}}
declare module "mekanism.common.tile.interfaces.IBoundingBlock" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$IComparatorSupport, $IComparatorSupport$$Type} from "mekanism.common.tile.interfaces.IComparatorSupport"
import {$TileComponentUpgrade, $TileComponentUpgrade$$Type} from "mekanism.common.tile.component.TileComponentUpgrade"
import {$Vec3i, $Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$Upgrade, $Upgrade$$Type} from "mekanism.api.Upgrade"
import {$IUpgradeTile, $IUpgradeTile$$Type} from "mekanism.common.tile.interfaces.IUpgradeTile"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IOffsetCapability, $IOffsetCapability$$Type} from "mekanism.common.capabilities.IOffsetCapability"

export interface $IBoundingBlock extends $IComparatorSupport, $IOffsetCapability, $IUpgradeTile {

 "getBoundingComparatorSignal"(offset: $Vec3i$$Type): integer
 "getOffsetCapabilityIfEnabled"<T>(capability: $BlockCapability$$Type<(T), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): T
 "isOffsetCapabilityDisabled"(capability: $BlockCapability$$Type<(any), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): boolean
 "triggerBoundingEvent"(offset: $Vec3i$$Type, id: integer, param: integer): boolean
 "onBoundingBlockPowerChange"(boundingPos: $BlockPos$$Type, oldLevel: integer, newLevel: integer): void
 "supportsComparator"(): boolean
 "getCurrentRedstoneLevel"(): integer
 "getRedstoneLevel"(): integer
 "getOffsetCapability"<T>(capability: $BlockCapability$$Type<(T), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): T
 "getComponent"(): $TileComponentUpgrade
 "recalculateUpgrades"(upgradeType: $Upgrade$$Type): void
 "supportsUpgrade"(upgradeType: $Upgrade$$Type): boolean
 "supportsUpgrades"(): boolean
get "currentRedstoneLevel"(): integer
get "redstoneLevel"(): integer
get "component"(): $TileComponentUpgrade
}

export namespace $IBoundingBlock {
const probejs$$marker: never
}
export class $IBoundingBlock$$Static implements $IBoundingBlock {


 "getBoundingComparatorSignal"(offset: $Vec3i$$Type): integer
 "getOffsetCapabilityIfEnabled"<T>(capability: $BlockCapability$$Type<(T), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): T
 "isOffsetCapabilityDisabled"(capability: $BlockCapability$$Type<(any), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): boolean
 "triggerBoundingEvent"(offset: $Vec3i$$Type, id: integer, param: integer): boolean
 "onBoundingBlockPowerChange"(boundingPos: $BlockPos$$Type, oldLevel: integer, newLevel: integer): void
 "supportsComparator"(): boolean
 "getCurrentRedstoneLevel"(): integer
 "getRedstoneLevel"(): integer
 "getOffsetCapability"<T>(capability: $BlockCapability$$Type<(T), ($Direction$$Type)>, side: $Direction$$Type, offset: $Vec3i$$Type): T
 "getComponent"(): $TileComponentUpgrade
 "recalculateUpgrades"(upgradeType: $Upgrade$$Type): void
 "supportsUpgrade"(upgradeType: $Upgrade$$Type): boolean
 "supportsUpgrades"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IBoundingBlock$$Type = ($IBoundingBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IBoundingBlock_ = $IBoundingBlock$$Type;
}}
declare module "mekanism.common.world.height.AnchorType" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$IHasTranslationKey$IHasEnumNameTranslationKey, $IHasTranslationKey$IHasEnumNameTranslationKey$$Type} from "mekanism.api.text.IHasTranslationKey$IHasEnumNameTranslationKey"
import {$WorldGenerationContext, $WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export class $AnchorType extends $Enum<($AnchorType)> implements $IHasTranslationKey$IHasEnumNameTranslationKey {
static readonly "ABSOLUTE": $AnchorType
static readonly "ABOVE_BOTTOM": $AnchorType
static readonly "BELOW_TOP": $AnchorType


public static "values"(): ($AnchorType)[]
public static "valueOf"(name: string): $AnchorType
public "resolveY"(context: $WorldGenerationContext$$Type, value: integer): integer
public "getTranslationKey"(): string
public "getTranslatedName"(): $Component
get "translationKey"(): string
get "translatedName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnchorType$$Type = (("absolute") | ("above_bottom") | ("below_top"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnchorType_ = $AnchorType$$Type;
}}
declare module "mekanism.common.lib.inventory.HashedItem$UUIDAwareHashedItem" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$HashedItem, $HashedItem$$Type} from "mekanism.common.lib.inventory.HashedItem"

export class $HashedItem$UUIDAwareHashedItem extends $HashedItem {
static readonly "CODEC": $Codec<($HashedItem)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($HashedItem)>

constructor(stack: $ItemStack$$Type, uuid: $UUID$$Type)
constructor(other: $HashedItem$$Type, uuid: $UUID$$Type)

public "equals"(obj: any): boolean
public "hashCode"(): integer
public "asRawHashedItem"(): $HashedItem
public "getUUID"(): $UUID
get "uUID"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HashedItem$UUIDAwareHashedItem$$Type = ($HashedItem$UUIDAwareHashedItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HashedItem$UUIDAwareHashedItem_ = $HashedItem$UUIDAwareHashedItem$$Type;
}}
declare module "mekanism.common.tile.base.TileEntityUpdateable" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ITileWrapper, $ITileWrapper$$Type} from "mekanism.common.tile.interfaces.ITileWrapper"
import {$List, $List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$$Type} from "mekanism.common.registration.impl.TileEntityTypeRegistryObject"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$ClientboundBlockEntityDataPacket, $ClientboundBlockEntityDataPacket$$Type} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$Connection, $Connection$$Type} from "net.minecraft.network.Connection"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityUpdateable extends $BlockEntity implements $ITileWrapper {
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(type: $TileEntityTypeRegistryObject$$Type<(any)>, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "setLevel"(world: $Level$$Type): void
public "markForSave"(): void
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "onDataPacket"(net: $Connection$$Type, pkt: $ClientboundBlockEntityDataPacket$$Type, provider: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "loadAdditional"(nbt: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getTileChunk"(): $Chunk3D
public "sendUpdatePacket"(): void
public "sendUpdatePacket"(tracking: $BlockEntity$$Type): void
public "getTileGlobalPos"(): $GlobalPos
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "setChanged"(): void
public "markDirtyComparator"(): void
public "isRemote"(): boolean
public "onAdded"(): void
public "handleUpdatePacket"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getWorldPositionLong"(): long
public "getRemapEntries"(): $List<($DataComponentType<(any)>)>
public "blockRemoved"(): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
set "level"(value: $Level$$Type)
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "remote"(): boolean
get "worldPositionLong"(): long
get "remapEntries"(): $List<($DataComponentType<(any)>)>
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityUpdateable$$Type = ($TileEntityUpdateable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityUpdateable_ = $TileEntityUpdateable$$Type;
}}
declare module "mekanism.common.lib.multiblock.IStructuralMultiblock" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$Structure, $Structure$$Type} from "mekanism.common.lib.multiblock.Structure"
import {$MultiblockManager, $MultiblockManager$$Type} from "mekanism.common.lib.multiblock.MultiblockManager"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$IMultiblockBase, $IMultiblockBase$$Type} from "mekanism.common.lib.multiblock.IMultiblockBase"
import {$MultiblockData, $MultiblockData$$Type} from "mekanism.common.lib.multiblock.MultiblockData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"

export interface $IStructuralMultiblock extends $IMultiblockBase {

 "multiblockFormed"(multiblock: $MultiblockData$$Type): void
 "multiblockUnformed"(structure: $Structure$$Type): void
 "canInterface"(manager: $MultiblockManager$$Type<(any)>): boolean
 "getStructureMap"(): $Map<($MultiblockManager<(any)>), ($Structure)>
 "hasFormedMultiblock"(): boolean
 "structuralGuiAccessAllowed"(): boolean
 "getStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
 "getMultiblockData"(manager: $MultiblockManager$$Type<(any)>): $MultiblockData
 "resetStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
 "hasStructure"(structure: $Structure$$Type): boolean
 "getDefaultData"(): $MultiblockData
 "setMultiblockData"(manager: $MultiblockManager$$Type<(any)>, multiblockData: $MultiblockData$$Type): void
 "resetForFormed"(): void
 "setStructure"(manager: $MultiblockManager$$Type<(any)>, structure: $Structure$$Type): void
 "onActivate"(player: $Player$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type): $ItemInteractionResult
 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
get "structureMap"(): $Map<($MultiblockManager<(any)>), ($Structure)>
get "defaultData"(): $MultiblockData
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}

export namespace $IStructuralMultiblock {
const probejs$$marker: never
}
export class $IStructuralMultiblock$$Static implements $IStructuralMultiblock {


 "multiblockFormed"(multiblock: $MultiblockData$$Type): void
 "multiblockUnformed"(structure: $Structure$$Type): void
 "canInterface"(manager: $MultiblockManager$$Type<(any)>): boolean
 "getStructureMap"(): $Map<($MultiblockManager<(any)>), ($Structure)>
 "hasFormedMultiblock"(): boolean
 "structuralGuiAccessAllowed"(): boolean
 "getStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
 "getMultiblockData"(manager: $MultiblockManager$$Type<(any)>): $MultiblockData
 "resetStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
 "hasStructure"(structure: $Structure$$Type): boolean
 "getDefaultData"(): $MultiblockData
 "setMultiblockData"(manager: $MultiblockManager$$Type<(any)>, multiblockData: $MultiblockData$$Type): void
 "resetForFormed"(): void
 "setStructure"(manager: $MultiblockManager$$Type<(any)>, structure: $Structure$$Type): void
 "onActivate"(player: $Player$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type): $ItemInteractionResult
 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IStructuralMultiblock$$Type = ($IStructuralMultiblock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IStructuralMultiblock_ = $IStructuralMultiblock$$Type;
}}
declare module "mekanism.common.tile.component.TileComponentConfig" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$ISlotInfo, $ISlotInfo$$Type} from "mekanism.common.tile.component.config.slot.ISlotInfo"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$TransmissionType, $TransmissionType$$Type} from "mekanism.common.lib.transmitter.TransmissionType"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$DataComponentMap$Builder, $DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$ITileComponent, $ITileComponent$$Type} from "mekanism.common.tile.component.ITileComponent"
import {$MekanismContainer$ISpecificContainerTracker, $MekanismContainer$ISpecificContainerTracker$$Type} from "mekanism.common.inventory.container.MekanismContainer$ISpecificContainerTracker"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$BaseSlotInfo, $BaseSlotInfo$$Type} from "mekanism.common.tile.component.config.slot.BaseSlotInfo"
import {$ISyncableData, $ISyncableData$$Type} from "mekanism.common.inventory.container.sync.ISyncableData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$DataType, $DataType$$Type} from "mekanism.common.tile.component.config.DataType"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$IPersistentConfigInfo, $IPersistentConfigInfo$$Type} from "mekanism.common.tile.component.config.IPersistentConfigInfo"
import {$BlockEntity$DataComponentInput, $BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$ConfigInfo, $ConfigInfo$$Type} from "mekanism.common.tile.component.config.ConfigInfo"
import {$RelativeSide, $RelativeSide$$Type} from "mekanism.api.RelativeSide"

export class $TileComponentConfig implements $ITileComponent, $MekanismContainer$ISpecificContainerTracker {
static readonly "LEGACY_ITEM_EJECT_KEY": string
static readonly "LEGACY_ITEM_CONFIG_KEY": string
readonly "tile": $TileEntityMekanism

constructor(tile: $TileEntityMekanism$$Type, types: $Set$$Type<($TransmissionType$$Type)>)

public static "write"(configInfo: $Map$$Type<($TransmissionType$$Type), ($IPersistentConfigInfo$$Type)>, full: boolean): $CompoundTag
public static "read"(configNBT: $CompoundTag$$Type, configInfo: $Map$$Type<($TransmissionType$$Type), ($ConfigInfo$$Type)>, onChange: $BiConsumer$$Type<($TransmissionType), ($RelativeSide)>): void
public static "read"(configNBT: $CompoundTag$$Type, configInfo: $Map$$Type<($TransmissionType$$Type), ($ConfigInfo$$Type)>): void
public "deserialize"(configNBT: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "supports"(type: $TransmissionType$$Type): boolean
public "serialize"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "getConfig"(type: $TransmissionType$$Type): $ConfigInfo
public static "createInfo"(type: $TransmissionType$$Type, input: boolean, output: boolean, containers: $List$$Type<(any)>): $BaseSlotInfo
public static "createInfo"(type: $TransmissionType$$Type, input: boolean, output: boolean, ...containers: (any)[]): $BaseSlotInfo
public "getDataType"(type: $TransmissionType$$Type, side: $RelativeSide$$Type): $DataType
public "sideChanged"(transmissionType: $TransmissionType$$Type, side: $RelativeSide$$Type): void
public "applyImplicitComponents"(input: $BlockEntity$DataComponentInput$$Type): void
public "collectImplicitComponents"(builder: $DataComponentMap$Builder$$Type): void
public "addToUpdateTag"(updateTag: $CompoundTag$$Type): void
public "readFromUpdateTag"(updateTag: $CompoundTag$$Type): void
public "getSpecificSyncableData"(): $List<($ISyncableData)>
public "getSlotInfo"(type: $TransmissionType$$Type, direction: $Direction$$Type): $ISlotInfo
public "setupInputConfig"(type: $TransmissionType$$Type, container: any): $ConfigInfo
public "setupItemIOConfig"(inputSlot: $IInventorySlot$$Type, outputSlot: $IInventorySlot$$Type, energySlot: $IInventorySlot$$Type): $ConfigInfo
public "setupItemIOConfig"(inputSlots: $List$$Type<($IInventorySlot$$Type)>, outputSlots: $List$$Type<($IInventorySlot$$Type)>, energySlot: $IInventorySlot$$Type, alwaysAllow: boolean): $ConfigInfo
public "setupIOConfig"(type: $TransmissionType$$Type, inputContainer: any, outputContainer: any, outputSide: $RelativeSide$$Type, alwaysAllow: boolean): $ConfigInfo
public "setupIOConfig"(type: $TransmissionType$$Type, inputContainer: any, outputContainer: any, outputSide: $RelativeSide$$Type, alwaysAllowInput: boolean, alwaysAllowOutput: boolean): $ConfigInfo
public "setupIOConfig"(type: $TransmissionType$$Type, info: any, outputSide: $RelativeSide$$Type, alwaysAllow: boolean): $ConfigInfo
public "setupIOConfig"(type: $TransmissionType$$Type, inputInfo: any, outputInfo: any, outputSide: $RelativeSide$$Type): $ConfigInfo
public "setupIOConfig"(type: $TransmissionType$$Type, info: any, outputSide: $RelativeSide$$Type): $ConfigInfo
public "setupOutputConfig"(type: $TransmissionType$$Type, container: any, ...sides: ($RelativeSide$$Type)[]): $ConfigInfo
public "addDisabledSides"(...sides: ($RelativeSide$$Type)[]): void
public "isCapabilityDisabled"(capability: $BlockCapability$$Type<(any), ($Direction$$Type)>, side: $Direction$$Type): boolean
public "getComponentKey"(): string
public "setupItemIOExtraConfig"(inputSlot: $IInventorySlot$$Type, outputSlot: $IInventorySlot$$Type, extraSlot: $IInventorySlot$$Type, energySlot: $IInventorySlot$$Type): $ConfigInfo
public "getTransmissions"(): $List<($TransmissionType)>
public "addConfigChangeListener"(transmissionType: $TransmissionType$$Type, listener: $Consumer$$Type<($Direction)>): void
public "write"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "read"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "removed"(): void
public "invalidate"(): void
public "trackForMainContainer"(container: $MekanismContainer$$Type): void
public "addRemapEntries"(remapEntries: $List$$Type<($DataComponentType$$Type<(any)>)>): void
get "specificSyncableData"(): $List<($ISyncableData)>
get "componentKey"(): string
get "transmissions"(): $List<($TransmissionType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileComponentConfig$$Type = ($TileComponentConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileComponentConfig_ = $TileComponentConfig$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.IInputRecipeCache" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IInputRecipeCache {

 "clear"(): void

(): void
}

export namespace $IInputRecipeCache {
const probejs$$marker: never
}
export class $IInputRecipeCache$$Static implements $IInputRecipeCache {


 "clear"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInputRecipeCache$$Type = (() => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInputRecipeCache_ = $IInputRecipeCache$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.SingleInputRecipeCache" {
import {$AbstractInputRecipeCache, $AbstractInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.AbstractInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$InputIngredient, $InputIngredient$$Type} from "mekanism.api.recipes.ingredients.InputIngredient"
import {$SingleInputRecipeCache$CheckRecipeType, $SingleInputRecipeCache$CheckRecipeType$$Type} from "mekanism.common.recipe.lookup.cache.SingleInputRecipeCache$CheckRecipeType"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IInputCache, $IInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.IInputCache"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TriPredicate, $TriPredicate$$Type} from "net.neoforged.neoforge.common.util.TriPredicate"

export class $SingleInputRecipeCache<INPUT, INGREDIENT extends $InputIngredient<(INPUT)>, RECIPE extends ($MekanismRecipe<(any)>) & ($Predicate<(INPUT)>), CACHE extends $IInputCache<(INPUT), (INGREDIENT), (RECIPE)>> extends $AbstractInputRecipeCache<(RECIPE)> {


public "clear"(): void
public "containsInput"(world: $Level$$Type, input: INPUT): boolean
public "findFirstRecipe"(world: $Level$$Type, input: INPUT): RECIPE
public "findTypeBasedRecipe"<DATA>(world: $Level$$Type, input: INPUT, data: DATA, matchCriteria: $TriPredicate$$Type<(RECIPE), (INPUT), (DATA)>): RECIPE
public "findTypeBasedRecipe"<DATA_1, DATA_2>(world: $Level$$Type, input: INPUT, data1: DATA_1, data2: DATA_2, matchCriteria: $SingleInputRecipeCache$CheckRecipeType$$Type<(INPUT), (RECIPE), (DATA_1), (DATA_2)>): RECIPE
public "findTypeBasedRecipe"(world: $Level$$Type, input: INPUT): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SingleInputRecipeCache$$Type<INPUT, INGREDIENT, RECIPE, CACHE> = ($SingleInputRecipeCache<(INPUT), (INGREDIENT), (RECIPE), (CACHE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SingleInputRecipeCache_<INPUT, INGREDIENT, RECIPE, CACHE> = $SingleInputRecipeCache$$Type<(INPUT), (INGREDIENT), (RECIPE), (CACHE)>;
}}
declare module "mekanism.common.recipe.lookup.cache.type.IInputCache" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$InputIngredient, $InputIngredient$$Type} from "mekanism.api.recipes.ingredients.InputIngredient"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"

export interface $IInputCache<INPUT, INGREDIENT extends $InputIngredient<(INPUT)>, RECIPE extends $MekanismRecipe<(any)>> {

 "clear"(): void
 "isEmpty"(input: INPUT): boolean
 "contains"(input: INPUT): boolean
 "contains"(input: INPUT, matchCriteria: $Predicate$$Type<(RECIPE)>): boolean
 "getRecipes"(input: INPUT): $Iterable<(RECIPE)>
 "findFirstRecipe"(input: INPUT, matchCriteria: $Predicate$$Type<(RECIPE)>): RECIPE
 "mapInputs"(recipe: RECIPE, inputIngredient: INGREDIENT): boolean
}

export namespace $IInputCache {
const probejs$$marker: never
}
export class $IInputCache$$Static<INPUT, INGREDIENT extends $InputIngredient<(INPUT)>, RECIPE extends $MekanismRecipe<(any)>> implements $IInputCache {


 "clear"(): void
 "isEmpty"(input: INPUT): boolean
 "contains"(input: INPUT): boolean
 "contains"(input: INPUT, matchCriteria: $Predicate$$Type<(RECIPE)>): boolean
 "getRecipes"(input: INPUT): $Iterable<(RECIPE)>
 "findFirstRecipe"(input: INPUT, matchCriteria: $Predicate$$Type<(RECIPE)>): RECIPE
 "mapInputs"(recipe: RECIPE, inputIngredient: INGREDIENT): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IInputCache$$Type<INPUT, INGREDIENT, RECIPE> = ($IInputCache<(INPUT), (INGREDIENT), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IInputCache_<INPUT, INGREDIENT, RECIPE> = $IInputCache$$Type<(INPUT), (INGREDIENT), (RECIPE)>;
}}
declare module "mekanism.common.advancements.triggers.UseTierInstallerTrigger" {
import {$UseTierInstallerTrigger$TriggerInstance, $UseTierInstallerTrigger$TriggerInstance$$Type} from "mekanism.common.advancements.triggers.UseTierInstallerTrigger$TriggerInstance"
import {$SimpleCriterionTrigger, $SimpleCriterionTrigger$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BaseTier, $BaseTier$$Type} from "mekanism.api.tier.BaseTier"

export class $UseTierInstallerTrigger extends $SimpleCriterionTrigger<($UseTierInstallerTrigger$TriggerInstance)> {

constructor()

public "trigger"(player: $ServerPlayer$$Type, tier: $BaseTier$$Type): void
public "codec"(): $Codec<($UseTierInstallerTrigger$TriggerInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UseTierInstallerTrigger$$Type = ($UseTierInstallerTrigger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UseTierInstallerTrigger_ = $UseTierInstallerTrigger$$Type;
}}
declare module "mekanism.common.content.blocktype.Machine" {
import {$ILangEntry, $ILangEntry$$Type} from "mekanism.api.text.ILangEntry"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$$Type} from "mekanism.common.registration.impl.TileEntityTypeRegistryObject"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"

export class $Machine<TILE extends $TileEntityMekanism> extends $BlockTypeTile<(TILE)> {

constructor(tileEntityRegistrar: $Supplier$$Type<($TileEntityTypeRegistryObject$$Type<(TILE)>)>, description: $ILangEntry$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Machine$$Type<TILE> = ($Machine<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Machine_<TILE> = $Machine$$Type<(TILE)>;
}}
declare module "mekanism.common.content.miner.MinerFilter" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$BaseFilter, $BaseFilter$$Type} from "mekanism.common.content.filter.BaseFilter"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$IFilter, $IFilter$$Type} from "mekanism.common.content.filter.IFilter"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MinerFilter<FILTER extends $MinerFilter<(FILTER)>> extends $BaseFilter<(FILTER)> {
 "replaceTarget": $Item
 "requiresReplacement": boolean
static readonly "GENERIC_CODEC": $Codec<($IFilter<(any)>)>
static readonly "GENERIC_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IFilter<(any)>)>


public "equals"(o: any): boolean
public "hashCode"(): integer
public "clone"(): $BaseFilter<(any)>
public "canFilter"(state: $BlockState$$Type): boolean
public "replaceTargetMatches"(target: $Item$$Type): boolean
public "hasBlacklistedElement"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinerFilter$$Type<FILTER> = ($MinerFilter<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MinerFilter_<FILTER> = $MinerFilter$$Type<(FILTER)>;
}}
declare module "mekanism.common.lib.inventory.CollectionTransitRequest" {
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$TransitRequest$ItemData, $TransitRequest$ItemData$$Type} from "mekanism.common.lib.inventory.TransitRequest$ItemData"
import {$TransitRequest, $TransitRequest$$Type} from "mekanism.common.lib.inventory.TransitRequest"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $CollectionTransitRequest extends $TransitRequest {

constructor()

public "isEmpty"(): boolean
public "iterator"(): $Iterator<($TransitRequest$ItemData)>
public "spliterator"(): $Spliterator<($TransitRequest$ItemData)>
public "forEach"(action: $Consumer$$Type<($TransitRequest$ItemData)>): void
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionTransitRequest$$Type = ($CollectionTransitRequest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionTransitRequest_ = $CollectionTransitRequest$$Type;
}}
declare module "mekanism.common.item.block.machine.ItemBlockResistiveHeater" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemBlockResistiveHeater extends $ItemBlockTooltip<($BlockTile<(any), (any)>)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockTile$$Type<(any), (any)>, properties: $Item$Properties$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockResistiveHeater$$Type = ($ItemBlockResistiveHeater);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockResistiveHeater_ = $ItemBlockResistiveHeater$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.DoubleInputRecipeCache" {
import {$DoubleInputRecipeCache$CheckRecipeType, $DoubleInputRecipeCache$CheckRecipeType$$Type} from "mekanism.common.recipe.lookup.cache.DoubleInputRecipeCache$CheckRecipeType"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$AbstractInputRecipeCache, $AbstractInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.AbstractInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$InputIngredient, $InputIngredient$$Type} from "mekanism.api.recipes.ingredients.InputIngredient"
import {$IInputCache, $IInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.IInputCache"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"

export class $DoubleInputRecipeCache<INPUT_A, INGREDIENT_A extends $InputIngredient<(INPUT_A)>, INPUT_B, INGREDIENT_B extends $InputIngredient<(INPUT_B)>, RECIPE extends ($MekanismRecipe<(any)>) & ($BiPredicate<(INPUT_A), (INPUT_B)>), CACHE_A extends $IInputCache<(INPUT_A), (INGREDIENT_A), (RECIPE)>, CACHE_B extends $IInputCache<(INPUT_B), (INGREDIENT_B), (RECIPE)>> extends $AbstractInputRecipeCache<(RECIPE)> {


public "clear"(): void
public "findFirstRecipe"(world: $Level$$Type, inputA: INPUT_A, inputB: INPUT_B): RECIPE
public "findFirstRecipe"(world: $Level$$Type, inputA: INPUT_A, inputB: INPUT_B, useCacheA: boolean): RECIPE
public "containsInputAB"(world: $Level$$Type, inputA: INPUT_A, inputB: INPUT_B): boolean
public "containsInputBA"(world: $Level$$Type, inputA: INPUT_A, inputB: INPUT_B): boolean
public "containsInputA"(world: $Level$$Type, input: INPUT_A): boolean
public "containsInputB"(world: $Level$$Type, input: INPUT_B): boolean
public "findTypeBasedRecipe"<DATA>(world: $Level$$Type, inputA: INPUT_A, inputB: INPUT_B, data: DATA, matchCriteria: $DoubleInputRecipeCache$CheckRecipeType$$Type<(INPUT_A), (INPUT_B), (RECIPE), (DATA)>): RECIPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleInputRecipeCache$$Type<INPUT_A, INGREDIENT_A, INPUT_B, INGREDIENT_B, RECIPE, CACHE_A, CACHE_B> = ($DoubleInputRecipeCache<(INPUT_A), (INGREDIENT_A), (INPUT_B), (INGREDIENT_B), (RECIPE), (CACHE_A), (CACHE_B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleInputRecipeCache_<INPUT_A, INGREDIENT_A, INPUT_B, INGREDIENT_B, RECIPE, CACHE_A, CACHE_B> = $DoubleInputRecipeCache$$Type<(INPUT_A), (INGREDIENT_A), (INPUT_B), (INGREDIENT_B), (RECIPE), (CACHE_A), (CACHE_B)>;
}}
declare module "mekanism.common.tile.qio.TileEntityQIOComponent" {
import {$List, $List$$Type} from "java.util.List"
import {$IQIOFrequency, $IQIOFrequency$$Type} from "mekanism.api.inventory.qio.IQIOFrequency"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$EnumColor, $EnumColor$$Type} from "mekanism.api.text.EnumColor"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$IQIOFrequencyHolder, $IQIOFrequencyHolder$$Type} from "mekanism.common.content.qio.IQIOFrequencyHolder"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$QIOFrequency, $QIOFrequency$$Type} from "mekanism.common.content.qio.QIOFrequency"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"

export class $TileEntityQIOComponent extends $TileEntityMekanism implements $IQIOFrequencyHolder {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getColor"(): $EnumColor
public "readSustainedData"(provider: $HolderLookup$Provider$$Type, dataMap: $CompoundTag$$Type): void
public "writeSustainedData"(provider: $HolderLookup$Provider$$Type, dataMap: $CompoundTag$$Type): void
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "getQIOFrequency"(): $IQIOFrequency
public "getPublicFrequencies"(): $List<($QIOFrequency)>
public "getPrivateFrequencies"(): $List<($QIOFrequency)>
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
get "color"(): $EnumColor
get "qIOFrequency"(): $IQIOFrequency
get "publicFrequencies"(): $List<($QIOFrequency)>
get "privateFrequencies"(): $List<($QIOFrequency)>
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityQIOComponent$$Type = ($TileEntityQIOComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityQIOComponent_ = $TileEntityQIOComponent$$Type;
}}
declare module "mekanism.common.attachments.containers.item.AttachedItems" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$IAttachedContainers, $IAttachedContainers$$Type} from "mekanism.common.attachments.containers.IAttachedContainers"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $AttachedItems extends $Record implements $IAttachedContainers<($ItemStack), ($AttachedItems)> {
static readonly "EMPTY": $AttachedItems
static readonly "CODEC": $Codec<($AttachedItems)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($AttachedItems)>

constructor(containers: $List$$Type<(any)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "create"(containers: $List$$Type<(any)>): $IAttachedContainers<(any), (any)>
public static "create"(containers: integer): $AttachedItems
public "containers"(): $List<($ItemStack)>
public "getEmptyStack"(): any
public "size"(): integer
public "get"(index: integer): $ItemStack
public "isEmpty"(): boolean
public "iterator"(): $Iterator<($ItemStack)>
public "spliterator"(): $Spliterator<($ItemStack)>
public "forEach"(action: $Consumer$$Type<($ItemStack)>): void
public "getOrDefault"(index: integer): $ItemStack
public "with"(index: integer, data: $ItemStack$$Type): $AttachedItems
[Symbol.iterator](): IterableIterator<$ItemStack>;
get "emptyStack"(): any
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedItems$$Type = ({"containers"?: $List$$Type<($ItemStack$$Type)>}) | ([containers?: $List$$Type<($ItemStack$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttachedItems_ = $AttachedItems$$Type;
}}
declare module "mekanism.common.registration.impl.FluidDeferredRegister$FluidTypeRenderProperties" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"

export class $FluidDeferredRegister$FluidTypeRenderProperties {


public static "builder"(): $FluidDeferredRegister$FluidTypeRenderProperties
public "texture"(still: $ResourceLocation$$Type, flowing: $ResourceLocation$$Type, overlay: $ResourceLocation$$Type): $FluidDeferredRegister$FluidTypeRenderProperties
public "texture"(still: $ResourceLocation$$Type, flowing: $ResourceLocation$$Type): $FluidDeferredRegister$FluidTypeRenderProperties
public "tint"(color: integer): $FluidDeferredRegister$FluidTypeRenderProperties
public "renderOverlay"(renderOverlay: $ResourceLocation$$Type): $FluidDeferredRegister$FluidTypeRenderProperties
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidDeferredRegister$FluidTypeRenderProperties$$Type = ($FluidDeferredRegister$FluidTypeRenderProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidDeferredRegister$FluidTypeRenderProperties_ = $FluidDeferredRegister$FluidTypeRenderProperties$$Type;
}}
declare module "mekanism.common.advancements.triggers.BlockLaserTrigger$TriggerInstance" {
import {$Criterion, $Criterion$$Type} from "net.minecraft.advancements.Criterion"
import {$ContextAwarePredicate, $ContextAwarePredicate$$Type} from "net.minecraft.advancements.critereon.ContextAwarePredicate"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$CriterionValidator, $CriterionValidator$$Type} from "net.minecraft.advancements.critereon.CriterionValidator"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$SimpleCriterionTrigger$SimpleInstance, $SimpleCriterionTrigger$SimpleInstance$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger$SimpleInstance"

export class $BlockLaserTrigger$TriggerInstance extends $Record implements $SimpleCriterionTrigger$SimpleInstance {
static readonly "CODEC": $Codec<($BlockLaserTrigger$TriggerInstance)>

constructor(player: $Optional$$Type<($ContextAwarePredicate$$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "block"(): $Criterion<($BlockLaserTrigger$TriggerInstance)>
public "player"(): $Optional<($ContextAwarePredicate)>
public "validate"(arg0: $CriterionValidator$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockLaserTrigger$TriggerInstance$$Type = ({"player"?: ($ContextAwarePredicate$$Type)?}) | ([player?: ($ContextAwarePredicate$$Type)?]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockLaserTrigger$TriggerInstance_ = $BlockLaserTrigger$TriggerInstance$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.InputRecipeCache$ItemChemical" {
import {$ChemicalInputCache, $ChemicalInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.ChemicalInputCache"
import {$ItemStackIngredient, $ItemStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ItemStackIngredient"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DoubleInputRecipeCache, $DoubleInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.DoubleInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$ChemicalStackIngredient, $ChemicalStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ChemicalStackIngredient"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$ItemInputCache, $ItemInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.ItemInputCache"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$MekanismRecipeType, $MekanismRecipeType$$Type} from "mekanism.common.recipe.MekanismRecipeType"

export class $InputRecipeCache$ItemChemical<RECIPE extends ($MekanismRecipe<(any)>) & ($BiPredicate<($ItemStack), ($ChemicalStack)>)> extends $DoubleInputRecipeCache<($ItemStack), ($ItemStackIngredient), ($ChemicalStack), ($ChemicalStackIngredient), (RECIPE), ($ItemInputCache<(RECIPE)>), ($ChemicalInputCache<(RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$$Type<(any), (RECIPE), (any)>, inputAExtractor: $Function$$Type<(RECIPE), ($ItemStackIngredient$$Type)>, inputBExtractor: $Function$$Type<(RECIPE), ($ChemicalStackIngredient$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$ItemChemical$$Type<RECIPE> = ($InputRecipeCache$ItemChemical<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$ItemChemical_<RECIPE> = $InputRecipeCache$ItemChemical$$Type<(RECIPE)>;
}}
declare module "mekanism.common.capabilities.holder.chemical.IChemicalTankHolder" {
import {$IHolder, $IHolder$$Type} from "mekanism.common.capabilities.holder.IHolder"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"

export interface $IChemicalTankHolder extends $IHolder {

 "getTanks"(side: $Direction$$Type): $List<($IChemicalTank)>
 "canExtract"(direction: $Direction$$Type): boolean
 "canInsert"(direction: $Direction$$Type): boolean

(side: $Direction): $List$$Type<($IChemicalTank$$Type)>
}

export namespace $IChemicalTankHolder {
const probejs$$marker: never
}
export class $IChemicalTankHolder$$Static implements $IChemicalTankHolder {


 "getTanks"(side: $Direction$$Type): $List<($IChemicalTank)>
 "canExtract"(direction: $Direction$$Type): boolean
 "canInsert"(direction: $Direction$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IChemicalTankHolder$$Type = ((side: $Direction) => $List$$Type<($IChemicalTank$$Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IChemicalTankHolder_ = $IChemicalTankHolder$$Type;
}}
declare module "mekanism.common.lib.frequency.TileComponentFrequency" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$DataComponentMap$Builder, $DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ITileComponent, $ITileComponent$$Type} from "mekanism.common.tile.component.ITileComponent"
import {$BlockEntity$DataComponentInput, $BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$$Type} from "mekanism.common.lib.frequency.Frequency$FrequencyIdentity"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $TileComponentFrequency implements $ITileComponent {

constructor(tile: $TileEntityMekanism$$Type)

public "deserialize"(frequencyNBT: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getFrequency"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): FREQ
public "serialize"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "track"(type: $FrequencyType$$Type<(any)>, needsSync: boolean, needsListCache: boolean, notifyNeighbors: boolean): void
public "applyImplicitComponents"(input: $BlockEntity$DataComponentInput$$Type): void
public "collectImplicitComponents"(builder: $DataComponentMap$Builder$$Type): void
public "getPublicCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
public "getTrustedCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
public "getPrivateCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
public "invalidate"(): void
public "setFrequencyFromData"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
public "removeFrequencyFromData"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
public "writeConfiguredFrequencies"(provider: $HolderLookup$Provider$$Type, data: $CompoundTag$$Type): void
public "trackForMainContainer"(container: $MekanismContainer$$Type): void
public "readConfiguredFrequencies"(provider: $HolderLookup$Provider$$Type, player: $Player$$Type, data: $CompoundTag$$Type): void
public "unsetFrequency"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): void
public "tickServer"(level: $Level$$Type, pos: $BlockPos$$Type): void
public "getComponentKey"(): string
public "addRemapEntries"(remapEntries: $List$$Type<($DataComponentType$$Type<(any)>)>): void
public "getCustomFrequencies"(): $Set<($FrequencyType<(any)>)>
public "hasCustomFrequencies"(): boolean
public "write"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "read"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "removed"(): void
public "addToUpdateTag"(updateTag: $CompoundTag$$Type): void
public "readFromUpdateTag"(updateTag: $CompoundTag$$Type): void
get "componentKey"(): string
get "customFrequencies"(): $Set<($FrequencyType<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileComponentFrequency$$Type = ($TileComponentFrequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileComponentFrequency_ = $TileComponentFrequency$$Type;
}}
declare module "mekanism.common.item.interfaces.IGuiItem" {
import {$ContainerTypeRegistryObject, $ContainerTypeRegistryObject$$Type} from "mekanism.common.registration.impl.ContainerTypeRegistryObject"

export interface $IGuiItem {

 "getContainerType"(): $ContainerTypeRegistryObject<(any)>

(): $ContainerTypeRegistryObject$$Type<(any)>
get "containerType"(): $ContainerTypeRegistryObject<(any)>
}

export namespace $IGuiItem {
const probejs$$marker: never
}
export class $IGuiItem$$Static implements $IGuiItem {


 "getContainerType"(): $ContainerTypeRegistryObject<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IGuiItem$$Type = (() => $ContainerTypeRegistryObject$$Type<(any)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IGuiItem_ = $IGuiItem$$Type;
}}
declare module "mekanism.common.block.prefab.BlockTile" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BlockBase, $BlockBase$$Type} from "mekanism.common.block.prefab.BlockBase"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IHasTileEntity, $IHasTileEntity$$Type} from "mekanism.common.block.interfaces.IHasTileEntity"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$$Type} from "mekanism.common.registration.impl.TileEntityTypeRegistryObject"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener, $GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$BlockEntityTicker, $BlockEntityTicker$$Type} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $BlockTile<TILE extends $TileEntityMekanism, TYPE extends $BlockTypeTile<(TILE)>> extends $BlockBase<(TYPE)> implements $IHasTileEntity<(TILE)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(type: TYPE, propertiesModifier: $UnaryOperator$$Type<($BlockBehaviour$Properties)>)
constructor(type: TYPE, properties: $BlockBehaviour$Properties$$Type)

public "animateTick"(state: $BlockState$$Type, world: $Level$$Type, pos: $BlockPos$$Type, random: $RandomSource$$Type): void
public "canConnectRedstone"(state: $BlockState$$Type, world: $BlockGetter$$Type, pos: $BlockPos$$Type, side: $Direction$$Type): boolean
public "getTileType"(): $TileEntityTypeRegistryObject<(TILE)>
public "getTicker"<T extends $BlockEntity>(level: $Level$$Type, state: $BlockState$$Type, blockEntityType: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(pos: $BlockPos$$Type, state: $BlockState$$Type): TILE
public "triggerBlockEntityEvent"(state: $BlockState$$Type, level: $Level$$Type, pos: $BlockPos$$Type, id: integer, param: integer): boolean
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "asHolder"(): $Holder<(any)>
get "tileType"(): $TileEntityTypeRegistryObject<(TILE)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTile$$Type<TILE, TYPE> = ($BlockTile<(TILE), (TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTile_<TILE, TYPE> = $BlockTile$$Type<(TILE), (TYPE)>;
}}
declare module "mekanism.common.item.gear.ItemFlamethrower$FlamethrowerMode" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$IIncrementalEnum, $IIncrementalEnum$$Type} from "mekanism.api.IIncrementalEnum"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$IHasTextComponent$IHasEnumNameTextComponent, $IHasTextComponent$IHasEnumNameTextComponent$$Type} from "mekanism.api.text.IHasTextComponent$IHasEnumNameTextComponent"

export class $ItemFlamethrower$FlamethrowerMode extends $Enum<($ItemFlamethrower$FlamethrowerMode)> implements $IIncrementalEnum<($ItemFlamethrower$FlamethrowerMode)>, $IHasTextComponent$IHasEnumNameTextComponent, $StringRepresentable {
static readonly "COMBAT": $ItemFlamethrower$FlamethrowerMode
static readonly "HEAT": $ItemFlamethrower$FlamethrowerMode
static readonly "INFERNO": $ItemFlamethrower$FlamethrowerMode
static readonly "CODEC": $Codec<($ItemFlamethrower$FlamethrowerMode)>
static readonly "BY_ID": $IntFunction<($ItemFlamethrower$FlamethrowerMode)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($ItemFlamethrower$FlamethrowerMode)>


public static "values"(): ($ItemFlamethrower$FlamethrowerMode)[]
public static "valueOf"(name: string): $ItemFlamethrower$FlamethrowerMode
public "byIndex"(index: integer): $ItemFlamethrower$FlamethrowerMode
public "getSerializedName"(): string
public "getTextComponent"(): $Component
public "ordinal"(): integer
public "adjust"(arg0: integer): $ItemFlamethrower$FlamethrowerMode
public "adjust"(arg0: integer, arg1: $Predicate$$Type<($ItemFlamethrower$FlamethrowerMode)>): $ItemFlamethrower$FlamethrowerMode
public "getNext"(arg0: $Predicate$$Type<($ItemFlamethrower$FlamethrowerMode)>): $ItemFlamethrower$FlamethrowerMode
public "getNext"(): $ItemFlamethrower$FlamethrowerMode
public "getPrevious"(): $ItemFlamethrower$FlamethrowerMode
public "getPrevious"(arg0: $Predicate$$Type<($ItemFlamethrower$FlamethrowerMode)>): $ItemFlamethrower$FlamethrowerMode
public "getTranslatedName"(): $Component
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "textComponent"(): $Component
get "next"(): $ItemFlamethrower$FlamethrowerMode
get "previous"(): $ItemFlamethrower$FlamethrowerMode
get "translatedName"(): $Component
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFlamethrower$FlamethrowerMode$$Type = (("combat") | ("heat") | ("inferno"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFlamethrower$FlamethrowerMode_ = $ItemFlamethrower$FlamethrowerMode$$Type;
}}
declare module "mekanism.common.integration.computer.MethodHelpData" {
import {$MethodHelpData$Returns, $MethodHelpData$Returns$$Type} from "mekanism.common.integration.computer.MethodHelpData$Returns"
import {$MethodRestriction, $MethodRestriction$$Type} from "mekanism.common.integration.computer.MethodRestriction"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$MethodData, $MethodData$$Type} from "mekanism.common.integration.computer.MethodData"
import {$BoundMethodHolder$BoundMethodData, $BoundMethodHolder$BoundMethodData$$Type} from "mekanism.common.integration.computer.BoundMethodHolder$BoundMethodData"
import {$List, $List$$Type} from "java.util.List"
import {$MethodHelpData$Param, $MethodHelpData$Param$$Type} from "mekanism.common.integration.computer.MethodHelpData$Param"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $MethodHelpData extends $Record {
static readonly "CODEC": $Codec<($MethodHelpData)>

constructor(methodName: string, params: $List$$Type<(any)>, returns: $MethodHelpData$Returns$$Type, description: string, restriction: $MethodRestriction$$Type, requiresPublicSecurity: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "methodName"(): string
public "hashCode"(): integer
public static "from"(data: $BoundMethodHolder$BoundMethodData$$Type<(any)>): $MethodHelpData
public static "from"(data: $MethodData$$Type<(any)>): $MethodHelpData
public "params"(): $List<($MethodHelpData$Param)>
public "description"(): string
public "restriction"(): $MethodRestriction
public "requiresPublicSecurity"(): boolean
public "returns"(): $MethodHelpData$Returns
public static "getEnumConstantNames"(argClass: $Class$$Type<(any)>): $List<(string)>
public static "getHumanType"(clazz: $Class$$Type<(any)>, extraTypes: ($Class$$Type<(any)>)[]): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodHelpData$$Type = ({"returns"?: $MethodHelpData$Returns$$Type, "requiresPublicSecurity"?: boolean, "params"?: $List$$Type<($MethodHelpData$Param$$Type)>, "methodName"?: string, "description"?: string, "restriction"?: $MethodRestriction$$Type}) | ([returns?: $MethodHelpData$Returns$$Type, requiresPublicSecurity?: boolean, params?: $List$$Type<($MethodHelpData$Param$$Type)>, methodName?: string, description?: string, restriction?: $MethodRestriction$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodHelpData_ = $MethodHelpData$$Type;
}}
declare module "mekanism.common.item.gear.ItemArmoredFreeRunners" {
import {$ArmorMaterial, $ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ItemAttributeModifiers, $ItemAttributeModifiers$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Equipable, $Equipable$$Type} from "net.minecraft.world.item.Equipable"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemFreeRunners, $ItemFreeRunners$$Type} from "mekanism.common.item.gear.ItemFreeRunners"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior, $DispenseItemBehavior$$Type} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ItemArmoredFreeRunners extends $ItemFreeRunners {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
readonly "type": $ArmorItem$Type
readonly "material": $Holder<($ArmorMaterial)>
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public static "displayModeChange"(player: $Player$$Type): void
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "get"(arg0: $ItemStack$$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemArmoredFreeRunners$$Type = ($ItemArmoredFreeRunners);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemArmoredFreeRunners_ = $ItemArmoredFreeRunners$$Type;
}}
declare module "mekanism.common.item.block.ItemBlockBin" {
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$IDroppableContents$IDroppableAttachmentContents, $IDroppableContents$IDroppableAttachmentContents$$Type} from "mekanism.common.item.interfaces.IDroppableContents$IDroppableAttachmentContents"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockBin, $BlockBin$$Type} from "mekanism.common.block.basic.BlockBin"

export class $ItemBlockBin extends $ItemBlockTooltip<($BlockBin)> implements $IDroppableContents$IDroppableAttachmentContents {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockBin$$Type, properties: $Item$Properties$$Type)

public "getTier"(): $ITier
public "canContentsDrop"(stack: $ItemStack$$Type): boolean
public "getDroppedSlots"(stack: $ItemStack$$Type): $List<($IInventorySlot)>
public "getScalar"(stack: $ItemStack$$Type): integer
get "tier"(): $ITier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockBin$$Type = ($ItemBlockBin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockBin_ = $ItemBlockBin$$Type;
}}
declare module "mekanism.common.inventory.container.item.PersonalStorageItemContainer" {
import {$ContainerListener, $ContainerListener$$Type} from "net.minecraft.world.inventory.ContainerListener"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$List, $List$$Type} from "java.util.List"
import {$MekanismItemContainer, $MekanismItemContainer$$Type} from "mekanism.common.inventory.container.item.MekanismItemContainer"
import {$ContainerSynchronizer, $ContainerSynchronizer$$Type} from "net.minecraft.world.inventory.ContainerSynchronizer"
import {$Inventory, $Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$MenuType, $MenuType$$Type} from "net.minecraft.world.inventory.MenuType"
import {$Set, $Set$$Type} from "java.util.Set"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"

export class $PersonalStorageItemContainer extends $MekanismItemContainer {
static readonly "BASE_Y_OFFSET": integer
static readonly "TRANSPORTER_CONFIG_WINDOW": integer
static readonly "SIDE_CONFIG_WINDOW": integer
static readonly "UPGRADE_WINDOW": integer
static readonly "SKIN_SELECT_WINDOW": integer
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
 "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
readonly "remoteSlots": $NonNullList<($ItemStack)>
 "remoteCarried": $ItemStack
 "stateId": integer
 "menuType": $MenuType<(any)>
 "containerId": integer
 "quickcraftType": integer
 "quickcraftStatus": integer
readonly "quickcraftSlots": $Set<($Slot)>
readonly "containerListeners": $List<($ContainerListener)>
 "synchronizer": $ContainerSynchronizer

constructor(id: integer, inv: $Inventory$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type, isRemote: boolean)

public "clicked"(slotId: integer, dragType: integer, clickType: $ClickType$$Type, player: $Player$$Type): void
public "getHand"(): $InteractionHand
get "hand"(): $InteractionHand
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PersonalStorageItemContainer$$Type = ($PersonalStorageItemContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PersonalStorageItemContainer_ = $PersonalStorageItemContainer$$Type;
}}
declare module "mekanism.common.capabilities.chemical.IChemicalTracker" {
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"

export interface $IChemicalTracker extends $IContentsListener {

 "getChemicalTanks"(side: $Direction$$Type): $List<($IChemicalTank)>
 "onContentsChanged"(): void
}

export namespace $IChemicalTracker {
const probejs$$marker: never
}
export class $IChemicalTracker$$Static implements $IChemicalTracker {


 "getChemicalTanks"(side: $Direction$$Type): $List<($IChemicalTank)>
 "onContentsChanged"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IChemicalTracker$$Type = ($IChemicalTracker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IChemicalTracker_ = $IChemicalTracker$$Type;
}}
declare module "mekanism.common.capabilities.fluid.BasicFluidTank" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler$FluidAction"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IExtendedFluidTank, $IExtendedFluidTank$$Type} from "mekanism.api.fluid.IExtendedFluidTank"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $BasicFluidTank implements $IExtendedFluidTank {
static readonly "alwaysTrue": $Predicate<($FluidStack)>
static readonly "alwaysFalse": $Predicate<($FluidStack)>
static readonly "alwaysTrueBi": $BiPredicate<($FluidStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($FluidStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($FluidStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($FluidStack), ($AutomationType)>


public "extract"(amount: integer, action: $Action$$Type, automationType: $AutomationType$$Type): $FluidStack
public "insert"(stack: $FluidStack$$Type, action: $Action$$Type, automationType: $AutomationType$$Type): $FluidStack
public "isEmpty"(): boolean
public static "create"(capacity: integer, canExtract: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, canInsert: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, validator: $Predicate$$Type<($FluidStack)>, listener: $IContentsListener$$Type): $BasicFluidTank
public static "create"(capacity: integer, listener: $IContentsListener$$Type): $BasicFluidTank
public static "create"(capacity: integer, canExtract: $Predicate$$Type<($FluidStack)>, canInsert: $Predicate$$Type<($FluidStack)>, listener: $IContentsListener$$Type): $BasicFluidTank
public static "create"(capacity: integer, validator: $Predicate$$Type<($FluidStack)>, listener: $IContentsListener$$Type): $BasicFluidTank
public static "create"(capacity: integer, canExtract: $Predicate$$Type<($FluidStack)>, canInsert: $Predicate$$Type<($FluidStack)>, validator: $Predicate$$Type<($FluidStack)>, listener: $IContentsListener$$Type): $BasicFluidTank
public static "input"(capacity: integer, validator: $Predicate$$Type<($FluidStack)>, listener: $IContentsListener$$Type): $BasicFluidTank
public static "input"(capacity: integer, canInsert: $Predicate$$Type<($FluidStack)>, validator: $Predicate$$Type<($FluidStack)>, listener: $IContentsListener$$Type): $BasicFluidTank
public static "output"(capacity: integer, listener: $IContentsListener$$Type): $BasicFluidTank
public "setStack"(stack: $FluidStack$$Type): void
public "getCapacity"(): integer
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $Tag
public "setStackSize"(amount: integer, action: $Action$$Type): integer
public "getFluid"(): $FluidStack
public "isFluidValid"(stack: $FluidStack$$Type): boolean
public "getFluidAmount"(): integer
public "onContentsChanged"(): void
public "isFluidEqual"(other: $FluidStack$$Type): boolean
public "setStackUnchecked"(stack: $FluidStack$$Type): void
public "growStack"(amount: integer, action: $Action$$Type): integer
/**
 * 
 * @deprecated
 */
public "fill"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): integer
public "setEmpty"(): void
/**
 * 
 * @deprecated
 */
public "drain"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
public "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): void
public "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $Tag$$Type): void
public "getNeeded"(): integer
public "shrinkStack"(arg0: integer, arg1: $Action$$Type): integer
get "empty"(): boolean
set "stack"(value: $FluidStack$$Type)
get "capacity"(): integer
get "fluid"(): $FluidStack
get "fluidAmount"(): integer
set "stackUnchecked"(value: $FluidStack$$Type)
get "needed"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicFluidTank$$Type = ($BasicFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicFluidTank_ = $BasicFluidTank$$Type;
}}
declare module "mekanism.common.registration.impl.CreativeTabDeferredRegister$ICustomCreativeTabContents" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $CreativeTabDeferredRegister$ICustomCreativeTabContents {

 "addDefault"(): boolean
 "addItems"(addToTab: $Consumer$$Type<($ItemStack)>): void

(addToTab: $Consumer<($ItemStack)>): void
}

export namespace $CreativeTabDeferredRegister$ICustomCreativeTabContents {
const probejs$$marker: never
}
export class $CreativeTabDeferredRegister$ICustomCreativeTabContents$$Static implements $CreativeTabDeferredRegister$ICustomCreativeTabContents {


 "addDefault"(): boolean
 "addItems"(addToTab: $Consumer$$Type<($ItemStack)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabDeferredRegister$ICustomCreativeTabContents$$Type = ((addToTab: $Consumer<($ItemStack)>) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabDeferredRegister$ICustomCreativeTabContents_ = $CreativeTabDeferredRegister$ICustomCreativeTabContents$$Type;
}}
declare module "mekanism.common.capabilities.heat.ITileHeatHandler" {
import {$IMekanismHeatHandler, $IMekanismHeatHandler$$Type} from "mekanism.api.heat.IMekanismHeatHandler"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$IHeatCapacitor, $IHeatCapacitor$$Type} from "mekanism.api.heat.IHeatCapacitor"
import {$HeatAPI$HeatTransfer, $HeatAPI$HeatTransfer$$Type} from "mekanism.api.heat.HeatAPI$HeatTransfer"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"

export interface $ITileHeatHandler extends $IMekanismHeatHandler {

 "simulateAdjacent"(): double
 "getAdjacent"(side: $Direction$$Type): $IHeatHandler
 "simulate"(): $HeatAPI$HeatTransfer
 "getAmbientTemperature"(side: $Direction$$Type): double
 "incrementAdjacentTransfer"(currentAdjacentTransfer: double, tempToTransfer: double, side: $Direction$$Type): double
 "simulateEnvironment"(): double
 "updateHeatCapacitors"(side: $Direction$$Type): void
 "getTemperature"(arg0: integer, arg1: $Direction$$Type): double
 "getHeatCapacitor"(arg0: integer, arg1: $Direction$$Type): $IHeatCapacitor
 "getHeatCapacity"(arg0: integer, arg1: $Direction$$Type): double
 "canHandleHeat"(): boolean
 "getTotalInverseInsulation"(arg0: $Direction$$Type): double
 "getTotalTemperature"(arg0: $Direction$$Type): double
 "getTotalHeatCapacity"(arg0: $Direction$$Type): double
 "getInverseConduction"(arg0: integer, arg1: $Direction$$Type): double
 "getHeatCapacitorCount"(arg0: $Direction$$Type): integer
 "getInverseInsulation"(arg0: integer, arg1: $Direction$$Type): double
 "getHeatCapacitors"(arg0: $Direction$$Type): $List<($IHeatCapacitor)>
 "getTotalInverseConductionCoefficient"(arg0: $Direction$$Type): double
 "handleHeat"(arg0: double, arg1: $Direction$$Type): void
 "handleHeat"(arg0: integer, arg1: double, arg2: $Direction$$Type): void
 "getTemperature"(arg0: integer): double
 "getHeatCapacity"(arg0: integer): double
 "getHeatSideFor"(): $Direction
 "getTotalTemperature"(): double
 "getTotalHeatCapacity"(): double
 "getInverseConduction"(arg0: integer): double
 "getHeatCapacitorCount"(): integer
 "getTotalInverseConduction"(): double
 "handleHeat"(arg0: double): void
 "handleHeat"(arg0: integer, arg1: double): void
 "onContentsChanged"(): void
get "heatSideFor"(): $Direction
get "totalTemperature"(): double
get "totalHeatCapacity"(): double
get "heatCapacitorCount"(): integer
get "totalInverseConduction"(): double
}

export namespace $ITileHeatHandler {
const probejs$$marker: never
}
export class $ITileHeatHandler$$Static implements $ITileHeatHandler {


 "simulateAdjacent"(): double
 "getAdjacent"(side: $Direction$$Type): $IHeatHandler
 "simulate"(): $HeatAPI$HeatTransfer
 "getAmbientTemperature"(side: $Direction$$Type): double
 "incrementAdjacentTransfer"(currentAdjacentTransfer: double, tempToTransfer: double, side: $Direction$$Type): double
 "simulateEnvironment"(): double
 "updateHeatCapacitors"(side: $Direction$$Type): void
 "getTemperature"(arg0: integer, arg1: $Direction$$Type): double
 "getHeatCapacitor"(arg0: integer, arg1: $Direction$$Type): $IHeatCapacitor
 "getHeatCapacity"(arg0: integer, arg1: $Direction$$Type): double
 "canHandleHeat"(): boolean
 "getTotalInverseInsulation"(arg0: $Direction$$Type): double
 "getTotalTemperature"(arg0: $Direction$$Type): double
 "getTotalHeatCapacity"(arg0: $Direction$$Type): double
 "getInverseConduction"(arg0: integer, arg1: $Direction$$Type): double
 "getHeatCapacitorCount"(arg0: $Direction$$Type): integer
 "getInverseInsulation"(arg0: integer, arg1: $Direction$$Type): double
 "getHeatCapacitors"(arg0: $Direction$$Type): $List<($IHeatCapacitor)>
 "getTotalInverseConductionCoefficient"(arg0: $Direction$$Type): double
 "handleHeat"(arg0: double, arg1: $Direction$$Type): void
 "handleHeat"(arg0: integer, arg1: double, arg2: $Direction$$Type): void
 "getTemperature"(arg0: integer): double
 "getHeatCapacity"(arg0: integer): double
 "getHeatSideFor"(): $Direction
 "getTotalTemperature"(): double
 "getTotalHeatCapacity"(): double
 "getInverseConduction"(arg0: integer): double
 "getHeatCapacitorCount"(): integer
 "getTotalInverseConduction"(): double
 "handleHeat"(arg0: double): void
 "handleHeat"(arg0: integer, arg1: double): void
 "onContentsChanged"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileHeatHandler$$Type = ($ITileHeatHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileHeatHandler_ = $ITileHeatHandler$$Type;
}}
declare module "mekanism.common.capabilities.energy.MachineEnergyContainer" {
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AttributeEnergy, $AttributeEnergy$$Type} from "mekanism.common.block.attribute.AttributeEnergy"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$BasicEnergyContainer, $BasicEnergyContainer$$Type} from "mekanism.common.capabilities.energy.BasicEnergyContainer"

export class $MachineEnergyContainer<TILE extends $TileEntityMekanism> extends $BasicEnergyContainer {
static readonly "alwaysTrue": $Predicate<($AutomationType)>
static readonly "alwaysFalse": $Predicate<($AutomationType)>
static readonly "internalOnly": $Predicate<($AutomationType)>
static readonly "manualOnly": $Predicate<($AutomationType)>
static readonly "notExternal": $Predicate<($AutomationType)>


public static "input"<TILE extends $TileEntityMekanism>(tile: TILE, listener: $IContentsListener$$Type): $MachineEnergyContainer<(TILE)>
public static "internal"<TILE extends $TileEntityMekanism>(tile: TILE, listener: $IContentsListener$$Type): $MachineEnergyContainer<(TILE)>
public "getMaxEnergy"(): long
public "updateEnergyPerTick"(): void
public "getBaseMaxEnergy"(): long
public "getBaseEnergyPerTick"(): long
public "getEnergyPerTick"(): long
public "adjustableRates"(): boolean
public "updateMaxEnergy"(): void
public "setEnergyPerTick"(energyPerTick: long): void
public "setMaxEnergy"(maxEnergy: long): void
public static "validateBlock"(tile: $TileEntityMekanism$$Type): $AttributeEnergy
get "maxEnergy"(): long
get "baseMaxEnergy"(): long
get "baseEnergyPerTick"(): long
get "energyPerTick"(): long
set "energyPerTick"(value: long)
set "maxEnergy"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MachineEnergyContainer$$Type<TILE> = ($MachineEnergyContainer<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MachineEnergyContainer_<TILE> = $MachineEnergyContainer$$Type<(TILE)>;
}}
declare module "mekanism.common.lib.transmitter.TransmissionType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$IHasTranslationKey$IHasEnumNameTranslationKey, $IHasTranslationKey$IHasEnumNameTranslationKey$$Type} from "mekanism.api.text.IHasTranslationKey$IHasEnumNameTranslationKey"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$ILangEntry, $ILangEntry$$Type} from "mekanism.api.text.ILangEntry"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Transmitter, $Transmitter$$Type} from "mekanism.common.content.network.transmitter.Transmitter"
import {$TileEntityTransmitter, $TileEntityTransmitter$$Type} from "mekanism.common.tile.transmitter.TileEntityTransmitter"

export class $TransmissionType extends $Enum<($TransmissionType)> implements $IHasTranslationKey$IHasEnumNameTranslationKey, $StringRepresentable {
static readonly "ENERGY": $TransmissionType
static readonly "FLUID": $TransmissionType
static readonly "CHEMICAL": $TransmissionType
static readonly "ITEM": $TransmissionType
static readonly "HEAT": $TransmissionType
static readonly "CODEC": $Codec<($TransmissionType)>
static readonly "BY_ID": $IntFunction<($TransmissionType)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($TransmissionType)>


public "getName"(): string
public static "values"(): ($TransmissionType)[]
public static "valueOf"(name: string): $TransmissionType
public "getSerializedName"(): string
public "getTranslationKey"(): string
public "checkTransmissionType"(transmitter: $Transmitter$$Type<(any), (any), (any)>): boolean
public "checkTransmissionType"(transmitter: $TileEntityTransmitter$$Type): boolean
public "getTransmission"(): string
public "getLangEntry"(): $ILangEntry
public "getLegacyOrdinal"(): integer
public "getTranslatedName"(): $Component
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "name"(): string
get "serializedName"(): string
get "translationKey"(): string
get "transmission"(): string
get "langEntry"(): $ILangEntry
get "legacyOrdinal"(): integer
get "translatedName"(): $Component
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransmissionType$$Type = (("energy") | ("fluids") | ("chemicals") | ("items") | ("heat"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransmissionType_ = $TransmissionType$$Type;
}}
declare module "mekanism.common.content.blocktype.Machine$FactoryMachine" {
import {$FactoryType, $FactoryType$$Type} from "mekanism.common.content.blocktype.FactoryType"
import {$ILangEntry, $ILangEntry$$Type} from "mekanism.api.text.ILangEntry"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$$Type} from "mekanism.common.registration.impl.TileEntityTypeRegistryObject"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$Machine, $Machine$$Type} from "mekanism.common.content.blocktype.Machine"

export class $Machine$FactoryMachine<TILE extends $TileEntityMekanism> extends $Machine<(TILE)> {

constructor(tileEntitySupplier: $Supplier$$Type<($TileEntityTypeRegistryObject$$Type<(TILE)>)>, description: $ILangEntry$$Type, factoryType: $FactoryType$$Type)

public "getFactoryType"(): $FactoryType
get "factoryType"(): $FactoryType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Machine$FactoryMachine$$Type<TILE> = ($Machine$FactoryMachine<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Machine$FactoryMachine_<TILE> = $Machine$FactoryMachine$$Type<(TILE)>;
}}
declare module "mekanism.common.advancements.triggers.MekanismDamageTrigger" {
import {$MekanismDamageTypes$MekanismDamageType, $MekanismDamageTypes$MekanismDamageType$$Type} from "mekanism.common.registries.MekanismDamageTypes$MekanismDamageType"
import {$SimpleCriterionTrigger, $SimpleCriterionTrigger$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MekanismDamageTrigger$TriggerInstance, $MekanismDamageTrigger$TriggerInstance$$Type} from "mekanism.common.advancements.triggers.MekanismDamageTrigger$TriggerInstance"

export class $MekanismDamageTrigger extends $SimpleCriterionTrigger<($MekanismDamageTrigger$TriggerInstance)> {

constructor()

public "trigger"(player: $ServerPlayer$$Type, damageType: $MekanismDamageTypes$MekanismDamageType$$Type, hardcoreTotem: boolean): void
public "codec"(): $Codec<($MekanismDamageTrigger$TriggerInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismDamageTrigger$$Type = ($MekanismDamageTrigger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismDamageTrigger_ = $MekanismDamageTrigger$$Type;
}}
declare module "mekanism.common.item.block.ItemBlockChemicalTank" {
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$TileEntityChemicalTank, $TileEntityChemicalTank$$Type} from "mekanism.common.tile.TileEntityChemicalTank"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$$Type} from "mekanism.common.block.prefab.BlockTile$BlockTileModel"
import {$Machine, $Machine$$Type} from "mekanism.common.content.blocktype.Machine"

export class $ItemBlockChemicalTank extends $ItemBlockTooltip<($BlockTile$BlockTileModel<($TileEntityChemicalTank), ($Machine<($TileEntityChemicalTank)>)>)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockTile$BlockTileModel$$Type<($TileEntityChemicalTank$$Type), ($Machine$$Type<($TileEntityChemicalTank$$Type)>)>, properties: $Item$Properties$$Type)

public "getTier"(): $ITier
public "getBarWidth"(stack: $ItemStack$$Type): integer
public "getBarColor"(stack: $ItemStack$$Type): integer
public "isBarVisible"(stack: $ItemStack$$Type): boolean
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
get "tier"(): $ITier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockChemicalTank$$Type = ($ItemBlockChemicalTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockChemicalTank_ = $ItemBlockChemicalTank$$Type;
}}
declare module "mekanism.common.lib.multiblock.MultiblockData" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$IExtendedFluidTank, $IExtendedFluidTank$$Type} from "mekanism.api.fluid.IExtendedFluidTank"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TileEntityStructuralMultiblock, $TileEntityStructuralMultiblock$$Type} from "mekanism.common.tile.prefab.TileEntityStructuralMultiblock"
import {$IMekanismFluidHandler, $IMekanismFluidHandler$$Type} from "mekanism.api.fluid.IMekanismFluidHandler"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$IEnergyContainer, $IEnergyContainer$$Type} from "mekanism.api.energy.IEnergyContainer"
import {$Structure, $Structure$$Type} from "mekanism.common.lib.multiblock.Structure"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$IHeatCapacitor, $IHeatCapacitor$$Type} from "mekanism.api.heat.IHeatCapacitor"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IShape, $IShape$$Type} from "mekanism.common.lib.math.voxel.IShape"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IMekanismChemicalHandler, $IMekanismChemicalHandler$$Type} from "mekanism.api.chemical.IMekanismChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler$FluidAction"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IMekanismStrictEnergyHandler, $IMekanismStrictEnergyHandler$$Type} from "mekanism.api.energy.IMekanismStrictEnergyHandler"
import {$IMekanismInventory, $IMekanismInventory$$Type} from "mekanism.api.inventory.IMekanismInventory"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$IValveHandler$ValveData, $IValveHandler$ValveData$$Type} from "mekanism.common.lib.multiblock.IValveHandler$ValveData"
import {$HeatAPI$HeatTransfer, $HeatAPI$HeatTransfer$$Type} from "mekanism.api.heat.HeatAPI$HeatTransfer"
import {$ITileHeatHandler, $ITileHeatHandler$$Type} from "mekanism.common.capabilities.heat.ITileHeatHandler"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$VoxelCuboid, $VoxelCuboid$$Type} from "mekanism.common.lib.math.voxel.VoxelCuboid"

export class $MultiblockData implements $IMekanismInventory, $IMekanismFluidHandler, $IMekanismStrictEnergyHandler, $ITileHeatHandler, $IMekanismChemicalHandler {
 "locations": $Set<($BlockPos)>
 "internalLocations": $Set<($BlockPos)>
 "valves": $Set<($IValveHandler$ValveData)>
 "inventoryID": $UUID
 "hasMaster": boolean
 "renderLocation": $BlockPos
 "recheckStructure": boolean

constructor(tile: $BlockEntity$$Type)

public "remove"(world: $Level$$Type, oldStructure: $Structure$$Type): void
public "equals"(obj: any): boolean
public "length"(): integer
public "hashCode"(): integer
public "getBounds"(): $VoxelCuboid
public "width"(): integer
public "tick"(world: $Level$$Type): boolean
public "isDirty"(): boolean
public "getLevel"(): $Level
public "writeUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "height"(): integer
public "getMaxPos"(): $BlockPos
public "getVolume"(): integer
public "setFormedForce"(formed: boolean): void
public "formedBiPred"<T>(): $BiPredicate<(T), ($AutomationType)>
public "meltdownHappened"(world: $Level$$Type): void
public "readUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getOutsideSide"(pos: $BlockPos$$Type): $Direction
public "isKnownLocation"(pos: $BlockPos$$Type): boolean
public "getValveData"(): $Collection<($IValveHandler$ValveData)>
public "getEnergyContainers"(side: $Direction$$Type): $List<($IEnergyContainer)>
public "setShape"(shape: $IShape$$Type): boolean
public "markDirty"(): void
public "getChemicalTanks"(side: $Direction$$Type): $List<($IChemicalTank)>
public "getInventorySlots"(side: $Direction$$Type): $List<($IInventorySlot)>
public "notifyAllUpdateComparator"(world: $Level$$Type): void
public "markDirtyComparator"(world: $Level$$Type): void
public "isPositionInsideBounds"<T extends $MultiblockData>(structure: $Structure$$Type, pos: $BlockPos$$Type): boolean
public "notExternalFormedBiPred"<T>(): $BiPredicate<(T), ($AutomationType)>
public "forceUpdateComparatorLevel"(): void
public "isPositionOutsideBounds"(pos: $BlockPos$$Type): boolean
public "allowsStructuralGuiAccess"(multiblock: $TileEntityStructuralMultiblock$$Type): boolean
public "getCurrentRedstoneLevel"(): integer
public "onContentsChanged"(): void
public "getFluidTanks"(side: $Direction$$Type): $List<($IExtendedFluidTank)>
public "getHeatCapacitors"(side: $Direction$$Type): $List<($IHeatCapacitor)>
public "resetDirty"(): void
public "setVolume"(volume: integer): void
public "isFormed"(): boolean
public "getMinPos"(): $BlockPos
public "onCreated"(world: $Level$$Type): void
public "getSlots"(arg0: $Direction$$Type): integer
public "getStackInSlot"(arg0: integer, arg1: $Direction$$Type): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: $Direction$$Type, arg3: $Action$$Type): $ItemStack
public "getSlotLimit"(arg0: integer, arg1: $Direction$$Type): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $ItemStack
public "getInventorySlot"(arg0: integer, arg1: $Direction$$Type): $IInventorySlot
public "hasInventory"(): boolean
public "isInventoryEmpty"(arg0: $Direction$$Type): boolean
public "isInventoryEmpty"(): boolean
public "getFluidTank"(arg0: integer, arg1: $Direction$$Type): $IExtendedFluidTank
public "getTanks"(arg0: $Direction$$Type): integer
public "getTankCapacity"(arg0: integer, arg1: $Direction$$Type): integer
public "getFluidInTank"(arg0: integer, arg1: $Direction$$Type): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type): void
public "canHandleFluid"(): boolean
public "extractFluid"(arg0: integer, arg1: $Direction$$Type, arg2: $Action$$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Direction$$Type, arg3: $Action$$Type): $FluidStack
public "insertFluid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $FluidStack
public "getEnergyContainerCount"(arg0: $Direction$$Type): integer
public "getMaxEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "extractEnergy"(arg0: long, arg1: $Direction$$Type, arg2: $Action$$Type): long
public "extractEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type, arg3: $Action$$Type): long
public "getNeededEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "getEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "setEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type): void
public "canHandleEnergy"(): boolean
public "getEnergyContainer"(arg0: integer, arg1: $Direction$$Type): $IEnergyContainer
public "insertEnergy"(arg0: long, arg1: $Direction$$Type, arg2: $Action$$Type): long
public "insertEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type, arg3: $Action$$Type): long
public "simulateAdjacent"(): double
public "getAdjacent"(side: $Direction$$Type): $IHeatHandler
public "simulate"(): $HeatAPI$HeatTransfer
public "getAmbientTemperature"(side: $Direction$$Type): double
public "incrementAdjacentTransfer"(currentAdjacentTransfer: double, tempToTransfer: double, side: $Direction$$Type): double
public "simulateEnvironment"(): double
public "updateHeatCapacitors"(side: $Direction$$Type): void
public "isValid"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Direction$$Type): boolean
public "getChemicalTank"(arg0: integer, arg1: $Direction$$Type): $IChemicalTank
public "getCountChemicalTanks"(arg0: $Direction$$Type): integer
public "getChemicalTankCapacity"(arg0: integer, arg1: $Direction$$Type): long
public "setChemicalInTank"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Direction$$Type): void
public "insertChemical"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $ChemicalStack
public "insertChemical"(arg0: $ChemicalStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: integer, arg1: long, arg2: $Direction$$Type, arg3: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: long, arg1: $Direction$$Type, arg2: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: $ChemicalStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $ChemicalStack
public "canHandleChemicals"(): boolean
public "getChemicalInTank"(arg0: integer, arg1: $Direction$$Type): $ChemicalStack
public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "getInventorySideFor"(): $Direction
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "getTanks"(): integer
public "getTankCapacity"(arg0: integer): integer
public "getFluidInTank"(arg0: integer): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$$Type): void
public "getFluidSideFor"(): $Direction
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Action$$Type): $FluidStack
public "insertFluid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Action$$Type): $FluidStack
public "getEnergyContainerCount"(): integer
public "getMaxEnergy"(arg0: integer): long
public "extractEnergy"(arg0: integer, arg1: long, arg2: $Action$$Type): long
public "getNeededEnergy"(arg0: integer): long
public "getEnergy"(arg0: integer): long
public "setEnergy"(arg0: integer, arg1: long): void
public "insertEnergy"(arg0: integer, arg1: long, arg2: $Action$$Type): long
public "getEnergySideFor"(): $Direction
public "getTemperature"(arg0: integer, arg1: $Direction$$Type): double
public "getHeatCapacitor"(arg0: integer, arg1: $Direction$$Type): $IHeatCapacitor
public "getHeatCapacity"(arg0: integer, arg1: $Direction$$Type): double
public "canHandleHeat"(): boolean
public "getTotalInverseInsulation"(arg0: $Direction$$Type): double
public "getTotalTemperature"(arg0: $Direction$$Type): double
public "getTotalHeatCapacity"(arg0: $Direction$$Type): double
public "getInverseConduction"(arg0: integer, arg1: $Direction$$Type): double
public "getHeatCapacitorCount"(arg0: $Direction$$Type): integer
public "getInverseInsulation"(arg0: integer, arg1: $Direction$$Type): double
public "getTotalInverseConductionCoefficient"(arg0: $Direction$$Type): double
public "handleHeat"(arg0: double, arg1: $Direction$$Type): void
public "handleHeat"(arg0: integer, arg1: double, arg2: $Direction$$Type): void
public "isValid"(arg0: integer, arg1: $ChemicalStack$$Type): boolean
public "getSideFor"(): $Direction
public "getChemicalTankCapacity"(arg0: integer): long
public "setChemicalInTank"(arg0: integer, arg1: $ChemicalStack$$Type): void
public "insertChemical"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: integer, arg1: long, arg2: $Action$$Type): $ChemicalStack
public "getChemicalTanks"(): integer
public "getChemicalInTank"(arg0: integer): $ChemicalStack
/**
 * 
 * @deprecated
 */
public "fill"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): integer
/**
 * 
 * @deprecated
 */
public "drain"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Action$$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$$Type, arg1: $Action$$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$$Type, arg1: $Action$$Type): $FluidStack
public "extractEnergy"(arg0: long, arg1: $Action$$Type): long
public "insertEnergy"(arg0: long, arg1: $Action$$Type): long
public "getTemperature"(arg0: integer): double
public "getHeatCapacity"(arg0: integer): double
public "getHeatSideFor"(): $Direction
public "getTotalTemperature"(): double
public "getTotalHeatCapacity"(): double
public "getInverseConduction"(arg0: integer): double
public "getHeatCapacitorCount"(): integer
public "getTotalInverseConduction"(): double
public "handleHeat"(arg0: double): void
public "handleHeat"(arg0: integer, arg1: double): void
public "insertChemical"(arg0: $ChemicalStack$$Type, arg1: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: long, arg1: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: $ChemicalStack$$Type, arg1: $Action$$Type): $ChemicalStack
public "kjs$self"(): $IItemHandler
public "getStackInSlot"(arg0: integer): $ItemStack
public "getSlots"(): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isMutable"(): boolean
public "getBlock"(arg0: $Level$$Type): $BlockContainerJS
public "asContainer"(): $Container
public "getHeight"(): integer
public "setChanged"(): void
public "insertItem"(arg0: $ItemStack$$Type, arg1: boolean): $ItemStack
public "getAllItems"(): $List<($ItemStack)>
public "countNonEmpty"(): integer
public "countNonEmpty"(arg0: $ItemPredicate$$Type): integer
public "getWidth"(): integer
public "isEmpty"(): boolean
public "find"(): integer
public "find"(arg0: $ItemPredicate$$Type): integer
public "clear"(arg0: $ItemPredicate$$Type): void
public "clear"(): void
public "count"(arg0: $ItemPredicate$$Type): integer
public "count"(): integer
get "bounds"(): $VoxelCuboid
get "dirty"(): boolean
get "level"(): $Level
get "maxPos"(): $BlockPos
get "volume"(): integer
set "formedForce"(value: boolean)
get "valveData"(): $Collection<($IValveHandler$ValveData)>
set "shape"(value: $IShape$$Type)
get "currentRedstoneLevel"(): integer
set "volume"(value: integer)
get "formed"(): boolean
get "minPos"(): $BlockPos
get "inventoryEmpty"(): boolean
get "slots"(): integer
get "inventorySideFor"(): $Direction
get "tanks"(): integer
get "fluidSideFor"(): $Direction
get "energyContainerCount"(): integer
get "energySideFor"(): $Direction
get "sideFor"(): $Direction
get "chemicalTanks"(): integer
get "heatSideFor"(): $Direction
get "totalTemperature"(): double
get "totalHeatCapacity"(): double
get "heatCapacitorCount"(): integer
get "totalInverseConduction"(): double
get "slots"(): integer
get "mutable"(): boolean
get "allItems"(): $List<($ItemStack)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockData$$Type = ($MultiblockData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockData_ = $MultiblockData$$Type;
}}
declare module "mekanism.common.lib.multiblock.IMultiblockBase" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ITileWrapper, $ITileWrapper$$Type} from "mekanism.common.tile.interfaces.ITileWrapper"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$Structure, $Structure$$Type} from "mekanism.common.lib.multiblock.Structure"
import {$MultiblockManager, $MultiblockManager$$Type} from "mekanism.common.lib.multiblock.MultiblockManager"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$MultiblockData, $MultiblockData$$Type} from "mekanism.common.lib.multiblock.MultiblockData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"

export interface $IMultiblockBase extends $ITileWrapper {

 "getStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
 "getMultiblockData"(manager: $MultiblockManager$$Type<(any)>): $MultiblockData
 "resetStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
 "hasStructure"(structure: $Structure$$Type): boolean
 "getDefaultData"(): $MultiblockData
 "setMultiblockData"(manager: $MultiblockManager$$Type<(any)>, multiblockData: $MultiblockData$$Type): void
 "resetForFormed"(): void
 "setStructure"(manager: $MultiblockManager$$Type<(any)>, structure: $Structure$$Type): void
 "onActivate"(player: $Player$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type): $ItemInteractionResult
 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
get "defaultData"(): $MultiblockData
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}

export namespace $IMultiblockBase {
const probejs$$marker: never
}
export class $IMultiblockBase$$Static implements $IMultiblockBase {


 "getStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
 "getMultiblockData"(manager: $MultiblockManager$$Type<(any)>): $MultiblockData
 "resetStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
 "hasStructure"(structure: $Structure$$Type): boolean
 "getDefaultData"(): $MultiblockData
 "setMultiblockData"(manager: $MultiblockManager$$Type<(any)>, multiblockData: $MultiblockData$$Type): void
 "resetForFormed"(): void
 "setStructure"(manager: $MultiblockManager$$Type<(any)>, structure: $Structure$$Type): void
 "onActivate"(player: $Player$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type): $ItemInteractionResult
 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IMultiblockBase$$Type = ($IMultiblockBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IMultiblockBase_ = $IMultiblockBase$$Type;
}}
declare module "mekanism.common.integration.computer.Convertable" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$BaseComputerHelper, $BaseComputerHelper$$Type} from "mekanism.common.integration.computer.BaseComputerHelper"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"

export class $Convertable<RAW> {


public "convert"(helper: $BaseComputerHelper$$Type): any
public static "of"(value: $FluidStack$$Type): $Convertable<($FluidStack)>
public static "of"(value: $ChemicalStack$$Type): $Convertable<($ChemicalStack)>
public static "of"<RAW>(value: RAW, converter: $BiFunction$$Type<($BaseComputerHelper), (RAW), (any)>): $Convertable<(RAW)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Convertable$$Type<RAW> = ($Convertable<(RAW)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Convertable_<RAW> = $Convertable$$Type<(RAW)>;
}}
declare module "mekanism.common.tier.FactoryTier" {
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$BaseTier, $BaseTier$$Type} from "mekanism.api.tier.BaseTier"

export class $FactoryTier extends $Enum<($FactoryTier)> implements $ITier {
static readonly "BASIC": $FactoryTier
static readonly "ADVANCED": $FactoryTier
static readonly "ELITE": $FactoryTier
static readonly "ULTIMATE": $FactoryTier
readonly "processes": integer


public static "values"(): ($FactoryTier)[]
public static "valueOf"(name: string): $FactoryTier
public "getBaseTier"(): $BaseTier
get "baseTier"(): $BaseTier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryTier$$Type = (("basic") | ("advanced") | ("elite") | ("ultimate"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FactoryTier_ = $FactoryTier$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.type.BaseInputCache" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$InputIngredient, $InputIngredient$$Type} from "mekanism.api.recipes.ingredients.InputIngredient"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IInputCache, $IInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.IInputCache"

export class $BaseInputCache<KEY, INPUT, INGREDIENT extends $InputIngredient<(INPUT)>, RECIPE extends $MekanismRecipe<(any)>> implements $IInputCache<(INPUT), (INGREDIENT), (RECIPE)> {

constructor()

public "clear"(): void
public "contains"(input: INPUT, matchCriteria: $Predicate$$Type<(RECIPE)>): boolean
public "contains"(input: INPUT): boolean
public "getRecipes"(input: INPUT): $Iterable<(RECIPE)>
public "findFirstRecipe"(input: INPUT, matchCriteria: $Predicate$$Type<(RECIPE)>): RECIPE
public "isEmpty"(input: INPUT): boolean
public "mapInputs"(recipe: RECIPE, inputIngredient: INGREDIENT): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseInputCache$$Type<KEY, INPUT, INGREDIENT, RECIPE> = ($BaseInputCache<(KEY), (INPUT), (INGREDIENT), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseInputCache_<KEY, INPUT, INGREDIENT, RECIPE> = $BaseInputCache$$Type<(KEY), (INPUT), (INGREDIENT), (RECIPE)>;
}}
declare module "mekanism.common.integration.computer.MethodHelpData$Returns" {
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$MethodData, $MethodData$$Type} from "mekanism.common.integration.computer.MethodData"
import {$List, $List$$Type} from "java.util.List"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $MethodHelpData$Returns extends $Record {
static readonly "NOTHING": $MethodHelpData$Returns
static readonly "CODEC": $Codec<($MethodHelpData$Returns)>

constructor(type: string, javaType: $Class$$Type<(any)>, javaExtra: ($Class$$Type<(any)>)[])
constructor(type: string, javaType: $Class$$Type<(any)>, javaExtra: ($Class$$Type<(any)>)[], values: $List$$Type<(string)>)

public "type"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "values"(): $List<(string)>
public "hashCode"(): integer
public static "from"(data: $MethodData$$Type<(any)>): $MethodHelpData$Returns
public "javaType"(): $Class<(any)>
public "javaExtra"(): ($Class<(any)>)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodHelpData$Returns$$Type = ({"javaExtra"?: ($Class$$Type<(never)>)[], "values"?: $List$$Type<(string)>, "type"?: string, "javaType"?: $Class$$Type<(never)>}) | ([javaExtra?: ($Class$$Type<(never)>)[], values?: $List$$Type<(string)>, type?: string, javaType?: $Class$$Type<(never)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodHelpData$Returns_ = $MethodHelpData$Returns$$Type;
}}
declare module "mekanism.common.recipe.serializer.RotaryRecipeSerializer" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ChemicalStackIngredient, $ChemicalStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ChemicalStackIngredient"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$Function4, $Function4$$Type} from "com.mojang.datafixers.util.Function4"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$FluidStackIngredient, $FluidStackIngredient$$Type} from "mekanism.api.recipes.ingredients.FluidStackIngredient"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Recipe, $Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"
import {$BasicRotaryRecipe, $BasicRotaryRecipe$$Type} from "mekanism.api.recipes.basic.BasicRotaryRecipe"
import {$RecipeSerializer, $RecipeSerializer$$Type} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $RotaryRecipeSerializer implements $RecipeSerializer<($BasicRotaryRecipe)> {

constructor(bothWaysFactory: $Function4$$Type<($FluidStackIngredient$$Type), ($ChemicalStackIngredient$$Type), ($ChemicalStack$$Type), ($FluidStack$$Type), ($BasicRotaryRecipe$$Type)>, toChemicalFactory: $BiFunction$$Type<($FluidStackIngredient), ($ChemicalStack), ($BasicRotaryRecipe$$Type)>, toFluidFactory: $BiFunction$$Type<($ChemicalStackIngredient), ($FluidStack), ($BasicRotaryRecipe$$Type)>)

public "codec"(): $MapCodec<($BasicRotaryRecipe)>
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($BasicRotaryRecipe)>
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotaryRecipeSerializer$$Type = ($RotaryRecipeSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RotaryRecipeSerializer_ = $RotaryRecipeSerializer$$Type;
}}
declare module "mekanism.common.item.ItemSeismicReader" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ItemEnergized, $ItemEnergized$$Type} from "mekanism.common.item.ItemEnergized"

export class $ItemSeismicReader extends $ItemEnergized {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "use"(world: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemSeismicReader$$Type = ($ItemSeismicReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemSeismicReader_ = $ItemSeismicReader$$Type;
}}
declare module "mekanism.common.lib.frequency.IFrequencyHandler" {
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$$Type} from "mekanism.common.lib.frequency.Frequency$FrequencyIdentity"
import {$TileComponentFrequency, $TileComponentFrequency$$Type} from "mekanism.common.lib.frequency.TileComponentFrequency"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"

export interface $IFrequencyHandler {

 "getFrequency"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): FREQ
 "getPublicCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "removeFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
 "getTrustedCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "getPrivateCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "setFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
 "getFrequencyComponent"(): $TileComponentFrequency

(): $TileComponentFrequency$$Type
get "frequencyComponent"(): $TileComponentFrequency
}

export namespace $IFrequencyHandler {
const probejs$$marker: never
}
export class $IFrequencyHandler$$Static implements $IFrequencyHandler {


 "getFrequency"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): FREQ
 "getPublicCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "removeFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
 "getTrustedCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "getPrivateCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "setFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
 "getFrequencyComponent"(): $TileComponentFrequency
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFrequencyHandler$$Type = (() => $TileComponentFrequency$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFrequencyHandler_ = $IFrequencyHandler$$Type;
}}
declare module "mekanism.common.integration.computer.MethodHelpData$Param" {
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$List, $List$$Type} from "java.util.List"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $MethodHelpData$Param extends $Record {
static readonly "CODEC": $Codec<($MethodHelpData$Param)>

constructor(name: string, type: string, javaType: $Class$$Type<(any)>)
constructor(name: string, type: string, javaType: $Class$$Type<(any)>, values: $List$$Type<(string)>)

public "name"(): string
public "type"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "values"(): $List<(string)>
public "hashCode"(): integer
public "javaType"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodHelpData$Param$$Type = ({"javaType"?: $Class$$Type<(never)>, "values"?: $List$$Type<(string)>, "name"?: string, "type"?: string}) | ([javaType?: $Class$$Type<(never)>, values?: $List$$Type<(string)>, name?: string, type?: string]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodHelpData$Param_ = $MethodHelpData$Param$$Type;
}}
declare module "mekanism.common.content.qio.QIOCraftingTransferHelper$HashedItemSource" {
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$QIOCraftingTransferHelper$SingularHashedItemSource, $QIOCraftingTransferHelper$SingularHashedItemSource$$Type} from "mekanism.common.content.qio.QIOCraftingTransferHelper$SingularHashedItemSource"

export class $QIOCraftingTransferHelper$HashedItemSource {

constructor()

public "use"(toUse: integer): $List<($QIOCraftingTransferHelper$SingularHashedItemSource)>
public "getAvailable"(): long
public "getSlotRemaining"(slot: byte): integer
public "getQIORemaining"(uuid: $UUID$$Type): long
public "hasQIOSources"(): boolean
public "hasMoreRemaining"(): boolean
public "matchFound"(): void
get "available"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOCraftingTransferHelper$HashedItemSource$$Type = ($QIOCraftingTransferHelper$HashedItemSource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOCraftingTransferHelper$HashedItemSource_ = $QIOCraftingTransferHelper$HashedItemSource$$Type;
}}
declare module "mekanism.common.lib.multiblock.MultiblockCache$RejectContents" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$List, $List$$Type} from "java.util.List"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"

export class $MultiblockCache$RejectContents {
readonly "rejectedItems": $List<($ItemStack)>
readonly "rejectedFluids": $List<($FluidStack)>
readonly "rejectedChemicals": $List<($ChemicalStack)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiblockCache$RejectContents$$Type = ($MultiblockCache$RejectContents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiblockCache$RejectContents_ = $MultiblockCache$RejectContents$$Type;
}}
declare module "mekanism.common.particle.LaserParticleType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ParticleType, $ParticleType$$Type} from "net.minecraft.core.particles.ParticleType"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$LaserParticleData, $LaserParticleData$$Type} from "mekanism.common.particle.LaserParticleData"

export class $LaserParticleType extends $ParticleType<($LaserParticleData)> {

constructor()

public "codec"(): $MapCodec<($LaserParticleData)>
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($LaserParticleData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LaserParticleType$$Type = ($LaserParticleType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LaserParticleType_ = $LaserParticleType$$Type;
}}
declare module "mekanism.common.advancements.triggers.ConfigurationCardTrigger" {
import {$ConfigurationCardTrigger$TriggerInstance, $ConfigurationCardTrigger$TriggerInstance$$Type} from "mekanism.common.advancements.triggers.ConfigurationCardTrigger$TriggerInstance"
import {$SimpleCriterionTrigger, $SimpleCriterionTrigger$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"

export class $ConfigurationCardTrigger extends $SimpleCriterionTrigger<($ConfigurationCardTrigger$TriggerInstance)> {

constructor()

public "trigger"(player: $ServerPlayer$$Type, copy: boolean): void
public "codec"(): $Codec<($ConfigurationCardTrigger$TriggerInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigurationCardTrigger$$Type = ($ConfigurationCardTrigger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigurationCardTrigger_ = $ConfigurationCardTrigger$$Type;
}}
declare module "mekanism.common.item.block.ItemBlockRadioactiveWasteBarrel" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$BlockRadioactiveWasteBarrel, $BlockRadioactiveWasteBarrel$$Type} from "mekanism.common.block.BlockRadioactiveWasteBarrel"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemBlockRadioactiveWasteBarrel extends $ItemBlockTooltip<($BlockRadioactiveWasteBarrel)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockRadioactiveWasteBarrel$$Type, properties: $Item$Properties$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockRadioactiveWasteBarrel$$Type = ($ItemBlockRadioactiveWasteBarrel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockRadioactiveWasteBarrel_ = $ItemBlockRadioactiveWasteBarrel$$Type;
}}
declare module "mekanism.common.integration.computer.IComputerTile" {
import {$BoundMethodHolder, $BoundMethodHolder$$Type} from "mekanism.common.integration.computer.BoundMethodHolder"

export interface $IComputerTile {

 "getComputerName"(): string
 "isComputerCapabilityPersistent"(): boolean
 "hasComputerSupport"(): boolean
 "getComputerMethods"(holder: $BoundMethodHolder$$Type): void

(): string
get "computerName"(): string
get "computerCapabilityPersistent"(): boolean
}

export namespace $IComputerTile {
const probejs$$marker: never
}
export class $IComputerTile$$Static implements $IComputerTile {


 "getComputerName"(): string
 "isComputerCapabilityPersistent"(): boolean
 "hasComputerSupport"(): boolean
 "getComputerMethods"(holder: $BoundMethodHolder$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IComputerTile$$Type = (() => string);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IComputerTile_ = $IComputerTile$$Type;
}}
declare module "mekanism.common.block.BlockPersonalChest" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IStateFluidLoggable, $IStateFluidLoggable$$Type} from "mekanism.common.block.states.IStateFluidLoggable"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$TileEntityPersonalChest, $TileEntityPersonalChest$$Type} from "mekanism.common.tile.TileEntityPersonalChest"
import {$Attribute, $Attribute$$Type} from "mekanism.common.block.attribute.Attribute"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IFluidLogType, $IFluidLogType$$Type} from "mekanism.common.block.states.IFluidLogType"
import {$BlockPersonalStorage, $BlockPersonalStorage$$Type} from "mekanism.common.block.BlockPersonalStorage"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$EnumProperty, $EnumProperty$$Type} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor, $LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $BlockPersonalChest extends $BlockPersonalStorage<($TileEntityPersonalChest), ($BlockTypeTile<($TileEntityPersonalChest)>)> implements $IStateFluidLoggable {
static readonly "PERSONAL_STORAGE_INVENTORY": $Attribute
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor()

public "setState"(state: $BlockState$$Type, fluid: $Fluid$$Type): $BlockState
public "isValidFluid"(fluid: $Fluid$$Type): boolean
public "canPlaceLiquid"(player: $Player$$Type, world: $BlockGetter$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluid: $Fluid$$Type): boolean
public "getPickupSound"(state: $BlockState$$Type): $Optional<($SoundEvent)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "pickupBlock"(player: $Player$$Type, world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type): $ItemStack
public "placeLiquid"(world: $LevelAccessor$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fluidState: $FluidState$$Type): boolean
public "getFluid"(state: $BlockState$$Type): $FluidState
public "getFluidLightLevel"(state: $BlockState$$Type): integer
public "updateFluids"(state: $BlockState$$Type, world: $LevelAccessor$$Type, currentPos: $BlockPos$$Type): void
public "getFluidLoggedProperty"(): $EnumProperty<($IFluidLogType)>
public "asHolder"(): $Holder<(any)>
get "pickupSound"(): $Optional<($SoundEvent)>
get "fluidLoggedProperty"(): $EnumProperty<($IFluidLogType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPersonalChest$$Type = ($BlockPersonalChest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPersonalChest_ = $BlockPersonalChest$$Type;
}}
declare module "mekanism.common.advancements.triggers.ViewVibrationsTrigger$TriggerInstance" {
import {$Criterion, $Criterion$$Type} from "net.minecraft.advancements.Criterion"
import {$ContextAwarePredicate, $ContextAwarePredicate$$Type} from "net.minecraft.advancements.critereon.ContextAwarePredicate"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$CriterionValidator, $CriterionValidator$$Type} from "net.minecraft.advancements.critereon.CriterionValidator"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$SimpleCriterionTrigger$SimpleInstance, $SimpleCriterionTrigger$SimpleInstance$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger$SimpleInstance"

export class $ViewVibrationsTrigger$TriggerInstance extends $Record implements $SimpleCriterionTrigger$SimpleInstance {
static readonly "CODEC": $Codec<($ViewVibrationsTrigger$TriggerInstance)>

constructor(player: $Optional$$Type<($ContextAwarePredicate$$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "view"(): $Criterion<($ViewVibrationsTrigger$TriggerInstance)>
public "player"(): $Optional<($ContextAwarePredicate)>
public "validate"(arg0: $CriterionValidator$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ViewVibrationsTrigger$TriggerInstance$$Type = ({"player"?: ($ContextAwarePredicate$$Type)?}) | ([player?: ($ContextAwarePredicate$$Type)?]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ViewVibrationsTrigger$TriggerInstance_ = $ViewVibrationsTrigger$TriggerInstance$$Type;
}}
declare module "mekanism.common.tile.TileEntityRadioactiveWasteBarrel" {
import {$IConfigurable, $IConfigurable$$Type} from "mekanism.api.IConfigurable"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$StackedWasteBarrel, $StackedWasteBarrel$$Type} from "mekanism.common.capabilities.chemical.StackedWasteBarrel"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IChemicalTankHolder, $IChemicalTankHolder$$Type} from "mekanism.common.capabilities.holder.chemical.IChemicalTankHolder"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"

export class $TileEntityRadioactiveWasteBarrel extends $TileEntityMekanism implements $IConfigurable {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(pos: $BlockPos$$Type, state: $BlockState$$Type)

public "getChemicalTank"(): $StackedWasteBarrel
public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "getInitialChemicalTanks"(listener: $IContentsListener$$Type): $IChemicalTankHolder
public "onRightClick"(player: $Player$$Type): $InteractionResult
public "getChemicalScale"(): double
public "getRedstoneLevel"(): integer
public "onSneakRightClick"(player: $Player$$Type): $InteractionResult
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "chemicalTank"(): $StackedWasteBarrel
get "chemicalScale"(): double
get "redstoneLevel"(): integer
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityRadioactiveWasteBarrel$$Type = ($TileEntityRadioactiveWasteBarrel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityRadioactiveWasteBarrel_ = $TileEntityRadioactiveWasteBarrel$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.SingleInputRecipeCache$CheckRecipeType" {
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"

export interface $SingleInputRecipeCache$CheckRecipeType<INPUT, RECIPE extends ($MekanismRecipe<(any)>) & ($Predicate<(INPUT)>), DATA_1, DATA_2> {

 "testType"(recipe: RECIPE, input: INPUT, data1: DATA_1, data2: DATA_2): boolean

(recipe: RECIPE, input: INPUT, data1: DATA_1, data2: DATA_2): boolean
}

export namespace $SingleInputRecipeCache$CheckRecipeType {
const probejs$$marker: never
}
export class $SingleInputRecipeCache$CheckRecipeType$$Static<INPUT, RECIPE extends ($MekanismRecipe<(any)>) & ($Predicate<(INPUT)>), DATA_1, DATA_2> implements $SingleInputRecipeCache$CheckRecipeType {


 "testType"(recipe: RECIPE, input: INPUT, data1: DATA_1, data2: DATA_2): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SingleInputRecipeCache$CheckRecipeType$$Type<INPUT, RECIPE, DATA_1, DATA_2> = ((recipe: RECIPE, input: INPUT, data1: DATA_1, data2: DATA_2) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SingleInputRecipeCache$CheckRecipeType_<INPUT, RECIPE, DATA_1, DATA_2> = $SingleInputRecipeCache$CheckRecipeType$$Type<(INPUT), (RECIPE), (DATA_1), (DATA_2)>;
}}
declare module "mekanism.common.content.blocktype.BlockType" {
import {$ILangEntry, $ILangEntry$$Type} from "mekanism.api.text.ILangEntry"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Attribute, $Attribute$$Type} from "mekanism.common.block.attribute.Attribute"

export class $BlockType {

constructor(description: $ILangEntry$$Type)

public "remove"(...attrs: ($Class$$Type<($Attribute$$Type)>)[]): void
public static "get"(block: $Block$$Type): $BlockType
public "get"<ATTRIBUTE extends $Attribute>(type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
public "add"(...attrs: ($Attribute$$Type)[]): void
public static "is"(block: $Block$$Type, ...types: ($BlockType$$Type)[]): boolean
public "getAll"(): $Collection<($Attribute)>
public "has"(type: $Class$$Type<($Attribute$$Type)>): boolean
public "getDescription"(): $ILangEntry
get "all"(): $Collection<($Attribute)>
get "description"(): $ILangEntry
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockType$$Type = ($BlockType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockType_ = $BlockType$$Type;
}}
declare module "mekanism.common.item.gear.ItemSpecialArmor" {
import {$ArmorMaterial, $ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent, $RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ItemAttributeModifiers, $ItemAttributeModifiers$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Enchantment, $Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Equipable, $Equipable$$Type} from "net.minecraft.world.item.Equipable"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ArmorItem, $ArmorItem$$Type} from "net.minecraft.world.item.ArmorItem"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior, $DispenseItemBehavior$$Type} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$ICapabilityAware, $ICapabilityAware$$Type} from "mekanism.common.capabilities.ICapabilityAware"

export class $ItemSpecialArmor extends $ArmorItem implements $ICapabilityAware {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
readonly "type": $ArmorItem$Type
readonly "material": $Holder<($ArmorMaterial)>
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean


public "isPrimaryItemFor"(stack: $ItemStack$$Type, enchantment: $Holder$$Type<($Enchantment)>): boolean
public "isBookEnchantable"(stack: $ItemStack$$Type, book: $ItemStack$$Type): boolean
public "isEnchantable"(stack: $ItemStack$$Type): boolean
public "attachCapabilities"(event: $RegisterCapabilitiesEvent$$Type): void
public static "get"(arg0: $ItemStack$$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemSpecialArmor$$Type = ($ItemSpecialArmor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemSpecialArmor_ = $ItemSpecialArmor$$Type;
}}
declare module "mekanism.common.inventory.slot.UpgradeInventorySlot" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Upgrade, $Upgrade$$Type} from "mekanism.api.Upgrade"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$InventoryContainerSlot, $InventoryContainerSlot$$Type} from "mekanism.common.inventory.container.slot.InventoryContainerSlot"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$BasicInventorySlot, $BasicInventorySlot$$Type} from "mekanism.common.inventory.slot.BasicInventorySlot"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $UpgradeInventorySlot extends $BasicInventorySlot {
static readonly "alwaysTrue": $Predicate<($ItemStack)>
static readonly "alwaysFalse": $Predicate<($ItemStack)>
static readonly "alwaysTrueBi": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($ItemStack), ($AutomationType)>


public static "input"(listener: $IContentsListener$$Type, supportedTypes: $Set$$Type<($Upgrade$$Type)>): $UpgradeInventorySlot
public static "output"(listener: $IContentsListener$$Type): $UpgradeInventorySlot
public "createContainerSlot"(): $InventoryContainerSlot
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $Tag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeInventorySlot$$Type = ($UpgradeInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UpgradeInventorySlot_ = $UpgradeInventorySlot$$Type;
}}
declare module "mekanism.common.item.interfaces.IDroppableContents" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"

export interface $IDroppableContents {

 "getScalar"(stack: $ItemStack$$Type): integer
 "canContentsDrop"(stack: $ItemStack$$Type): boolean
 "getDroppedSlots"(stack: $ItemStack$$Type): $List<($IInventorySlot)>

(stack: $ItemStack): $List$$Type<($IInventorySlot$$Type)>
}

export namespace $IDroppableContents {
const probejs$$marker: never
}
export class $IDroppableContents$$Static implements $IDroppableContents {


 "getScalar"(stack: $ItemStack$$Type): integer
 "canContentsDrop"(stack: $ItemStack$$Type): boolean
 "getDroppedSlots"(stack: $ItemStack$$Type): $List<($IInventorySlot)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDroppableContents$$Type = ((stack: $ItemStack) => $List$$Type<($IInventorySlot$$Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDroppableContents_ = $IDroppableContents$$Type;
}}
declare module "mekanism.common.advancements.triggers.UseTierInstallerTrigger$TierUsed" {
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"

export class $UseTierInstallerTrigger$TierUsed extends $Enum<($UseTierInstallerTrigger$TierUsed)> implements $StringRepresentable {
static readonly "ANY": $UseTierInstallerTrigger$TierUsed
static readonly "BASIC": $UseTierInstallerTrigger$TierUsed
static readonly "ADVANCED": $UseTierInstallerTrigger$TierUsed
static readonly "ELITE": $UseTierInstallerTrigger$TierUsed
static readonly "ULTIMATE": $UseTierInstallerTrigger$TierUsed
static readonly "CODEC": $Codec<($UseTierInstallerTrigger$TierUsed)>


public static "values"(): ($UseTierInstallerTrigger$TierUsed)[]
public static "valueOf"(name: string): $UseTierInstallerTrigger$TierUsed
public "getSerializedName"(): string
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UseTierInstallerTrigger$TierUsed$$Type = (("any") | ("basic") | ("advanced") | ("elite") | ("ultimate"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UseTierInstallerTrigger$TierUsed_ = $UseTierInstallerTrigger$TierUsed$$Type;
}}
declare module "mekanism.common.attachments.containers.ContainsRecipe" {
import {$IInputRecipeCache, $IInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.IInputRecipeCache"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"

export interface $ContainsRecipe<INPUT_CACHE extends $IInputRecipeCache, TYPE> {

 "check"(cache: INPUT_CACHE, level: $Level$$Type, value: TYPE): boolean

(cache: INPUT_CACHE, level: $Level, value: TYPE): boolean
}

export namespace $ContainsRecipe {
const probejs$$marker: never
}
export class $ContainsRecipe$$Static<INPUT_CACHE extends $IInputRecipeCache, TYPE> implements $ContainsRecipe {


 "check"(cache: INPUT_CACHE, level: $Level$$Type, value: TYPE): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainsRecipe$$Type<INPUT_CACHE, TYPE> = ((cache: INPUT_CACHE, level: $Level, value: TYPE) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContainsRecipe_<INPUT_CACHE, TYPE> = $ContainsRecipe$$Type<(INPUT_CACHE), (TYPE)>;
}}
declare module "mekanism.common.tile.interfaces.IRedstoneControl$RedstoneControl" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$IIncrementalEnum, $IIncrementalEnum$$Type} from "mekanism.api.IIncrementalEnum"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$IHasTextComponent$IHasEnumNameTextComponent, $IHasTextComponent$IHasEnumNameTextComponent$$Type} from "mekanism.api.text.IHasTextComponent$IHasEnumNameTextComponent"

export class $IRedstoneControl$RedstoneControl extends $Enum<($IRedstoneControl$RedstoneControl)> implements $IIncrementalEnum<($IRedstoneControl$RedstoneControl)>, $IHasTextComponent$IHasEnumNameTextComponent, $StringRepresentable {
static readonly "DISABLED": $IRedstoneControl$RedstoneControl
static readonly "HIGH": $IRedstoneControl$RedstoneControl
static readonly "LOW": $IRedstoneControl$RedstoneControl
static readonly "PULSE": $IRedstoneControl$RedstoneControl
static readonly "CODEC": $Codec<($IRedstoneControl$RedstoneControl)>
static readonly "BY_ID": $IntFunction<($IRedstoneControl$RedstoneControl)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($IRedstoneControl$RedstoneControl)>


public static "values"(): ($IRedstoneControl$RedstoneControl)[]
public static "valueOf"(name: string): $IRedstoneControl$RedstoneControl
public "byIndex"(index: integer): $IRedstoneControl$RedstoneControl
public "getSerializedName"(): string
public "getTextComponent"(): $Component
public "ordinal"(): integer
public "adjust"(arg0: integer): $IRedstoneControl$RedstoneControl
public "adjust"(arg0: integer, arg1: $Predicate$$Type<($IRedstoneControl$RedstoneControl)>): $IRedstoneControl$RedstoneControl
public "getNext"(arg0: $Predicate$$Type<($IRedstoneControl$RedstoneControl)>): $IRedstoneControl$RedstoneControl
public "getNext"(): $IRedstoneControl$RedstoneControl
public "getPrevious"(): $IRedstoneControl$RedstoneControl
public "getPrevious"(arg0: $Predicate$$Type<($IRedstoneControl$RedstoneControl)>): $IRedstoneControl$RedstoneControl
public "getTranslatedName"(): $Component
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "textComponent"(): $Component
get "next"(): $IRedstoneControl$RedstoneControl
get "previous"(): $IRedstoneControl$RedstoneControl
get "translatedName"(): $Component
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRedstoneControl$RedstoneControl$$Type = (("disabled") | ("high") | ("low") | ("pulse"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRedstoneControl$RedstoneControl_ = $IRedstoneControl$RedstoneControl$$Type;
}}
declare module "mekanism.common.advancements.triggers.UseGaugeDropperTrigger$TriggerInstance" {
import {$Criterion, $Criterion$$Type} from "net.minecraft.advancements.Criterion"
import {$ContextAwarePredicate, $ContextAwarePredicate$$Type} from "net.minecraft.advancements.critereon.ContextAwarePredicate"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$CriterionValidator, $CriterionValidator$$Type} from "net.minecraft.advancements.critereon.CriterionValidator"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$UseGaugeDropperTrigger$UseDropperAction, $UseGaugeDropperTrigger$UseDropperAction$$Type} from "mekanism.common.advancements.triggers.UseGaugeDropperTrigger$UseDropperAction"
import {$SimpleCriterionTrigger$SimpleInstance, $SimpleCriterionTrigger$SimpleInstance$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger$SimpleInstance"

export class $UseGaugeDropperTrigger$TriggerInstance extends $Record implements $SimpleCriterionTrigger$SimpleInstance {
static readonly "CODEC": $Codec<($UseGaugeDropperTrigger$TriggerInstance)>

constructor(player: $Optional$$Type<($ContextAwarePredicate$$Type)>, action: $UseGaugeDropperTrigger$UseDropperAction$$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "action"(): $UseGaugeDropperTrigger$UseDropperAction
public static "any"(): $Criterion<($UseGaugeDropperTrigger$TriggerInstance)>
public "player"(): $Optional<($ContextAwarePredicate)>
public "validate"(arg0: $CriterionValidator$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UseGaugeDropperTrigger$TriggerInstance$$Type = ({"player"?: ($ContextAwarePredicate$$Type)?, "action"?: $UseGaugeDropperTrigger$UseDropperAction$$Type}) | ([player?: ($ContextAwarePredicate$$Type)?, action?: $UseGaugeDropperTrigger$UseDropperAction$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UseGaugeDropperTrigger$TriggerInstance_ = $UseGaugeDropperTrigger$TriggerInstance$$Type;
}}
declare module "mekanism.common.tile.interfaces.ITileRadioactive" {
import {$List, $List$$Type} from "java.util.List"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"

export interface $ITileRadioactive {

 "getRadiationScale"(): float
 "getRadiationParticleCount"(): integer

(): float
get "radiationScale"(): float
get "radiationParticleCount"(): integer
}

export namespace $ITileRadioactive {
function calculateRadiationScale(tanks: $List$$Type<($IChemicalTank$$Type)>): float
const probejs$$marker: never
}
export class $ITileRadioactive$$Static implements $ITileRadioactive {


 "getRadiationScale"(): float
static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
 "getRadiationParticleCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileRadioactive$$Type = (() => float);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileRadioactive_ = $ITileRadioactive$$Type;
}}
declare module "mekanism.common.tier.FluidTankTier" {
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$BaseTier, $BaseTier$$Type} from "mekanism.api.tier.BaseTier"
import {$CachedIntValue, $CachedIntValue$$Type} from "mekanism.common.config.value.CachedIntValue"

export class $FluidTankTier extends $Enum<($FluidTankTier)> implements $ITier {
static readonly "BASIC": $FluidTankTier
static readonly "ADVANCED": $FluidTankTier
static readonly "ELITE": $FluidTankTier
static readonly "ULTIMATE": $FluidTankTier
static readonly "CREATIVE": $FluidTankTier


public static "values"(): ($FluidTankTier)[]
public static "valueOf"(name: string): $FluidTankTier
public "getOutput"(): integer
public "getStorage"(): integer
public "getBaseStorage"(): integer
public "getBaseOutput"(): integer
public "getBaseTier"(): $BaseTier
public "setConfigReference"(storageReference: $CachedIntValue$$Type, outputReference: $CachedIntValue$$Type): void
get "output"(): integer
get "storage"(): integer
get "baseStorage"(): integer
get "baseOutput"(): integer
get "baseTier"(): $BaseTier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankTier$$Type = (("basic") | ("advanced") | ("elite") | ("ultimate") | ("creative"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTankTier_ = $FluidTankTier$$Type;
}}
declare module "mekanism.common.content.qio.filter.QIOFilter" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$BaseFilter, $BaseFilter$$Type} from "mekanism.common.content.filter.BaseFilter"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Finder, $Finder$$Type} from "mekanism.common.lib.inventory.Finder"
import {$IFilter, $IFilter$$Type} from "mekanism.common.content.filter.IFilter"

export class $QIOFilter<FILTER extends $QIOFilter<(FILTER)>> extends $BaseFilter<(FILTER)> {
static readonly "GENERIC_CODEC": $Codec<($IFilter<(any)>)>
static readonly "GENERIC_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IFilter<(any)>)>


public "clone"(): $BaseFilter<(any)>
public "getFinder"(): $Finder
get "finder"(): $Finder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $QIOFilter$$Type<FILTER> = ($QIOFilter<(FILTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $QIOFilter_<FILTER> = $QIOFilter$$Type<(FILTER)>;
}}
declare module "mekanism.common.block.basic.BlockStructuralGlass" {
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$TileEntityStructuralMultiblock, $TileEntityStructuralMultiblock$$Type} from "mekanism.common.tile.prefab.TileEntityStructuralMultiblock"
import {$BlockTileGlass, $BlockTileGlass$$Type} from "mekanism.common.block.prefab.BlockTileGlass"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStructuralGlass<TILE extends $TileEntityStructuralMultiblock> extends $BlockTileGlass<(TILE), ($BlockTypeTile<(TILE)>)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(type: $BlockTypeTile$$Type<(TILE)>)

public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStructuralGlass$$Type<TILE> = ($BlockStructuralGlass<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStructuralGlass_<TILE> = $BlockStructuralGlass$$Type<(TILE)>;
}}
declare module "mekanism.common.recipe.serializer.MekanismRecipeSerializer" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$IBasicItemStackOutput, $IBasicItemStackOutput$$Type} from "mekanism.api.recipes.basic.IBasicItemStackOutput"
import {$BasicPressurizedReactionRecipe, $BasicPressurizedReactionRecipe$$Type} from "mekanism.api.recipes.basic.BasicPressurizedReactionRecipe"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$BasicElectrolysisRecipe, $BasicElectrolysisRecipe$$Type} from "mekanism.api.recipes.basic.BasicElectrolysisRecipe"
import {$ChemicalStackIngredient, $ChemicalStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ChemicalStackIngredient"
import {$Function7, $Function7$$Type} from "com.mojang.datafixers.util.Function7"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$Function5, $Function5$$Type} from "com.mojang.datafixers.util.Function5"
import {$Function4, $Function4$$Type} from "com.mojang.datafixers.util.Function4"
import {$BasicChemicalDissolutionRecipe, $BasicChemicalDissolutionRecipe$$Type} from "mekanism.api.recipes.basic.BasicChemicalDissolutionRecipe"
import {$BasicChemicalCrystallizerRecipe, $BasicChemicalCrystallizerRecipe$$Type} from "mekanism.api.recipes.basic.BasicChemicalCrystallizerRecipe"
import {$Function3, $Function3$$Type} from "com.mojang.datafixers.util.Function3"
import {$IBasicChemicalOutput, $IBasicChemicalOutput$$Type} from "mekanism.api.recipes.basic.IBasicChemicalOutput"
import {$ChemicalChemicalToChemicalRecipe, $ChemicalChemicalToChemicalRecipe$$Type} from "mekanism.api.recipes.ChemicalChemicalToChemicalRecipe"
import {$ItemStackIngredient, $ItemStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ItemStackIngredient"
import {$FluidStackIngredient, $FluidStackIngredient$$Type} from "mekanism.api.recipes.ingredients.FluidStackIngredient"
import {$BasicItemStackToEnergyRecipe, $BasicItemStackToEnergyRecipe$$Type} from "mekanism.api.recipes.basic.BasicItemStackToEnergyRecipe"
import {$WrappedShapedRecipe, $WrappedShapedRecipe$$Type} from "mekanism.common.recipe.WrappedShapedRecipe"
import {$ShapedRecipe, $ShapedRecipe$$Type} from "net.minecraft.world.item.crafting.ShapedRecipe"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BasicWashingRecipe, $BasicWashingRecipe$$Type} from "mekanism.api.recipes.basic.BasicWashingRecipe"
import {$ItemStackToChemicalRecipe, $ItemStackToChemicalRecipe$$Type} from "mekanism.api.recipes.ItemStackToChemicalRecipe"
import {$BasicItemStackToItemStackRecipe, $BasicItemStackToItemStackRecipe$$Type} from "mekanism.api.recipes.basic.BasicItemStackToItemStackRecipe"
import {$IIngredientCreator, $IIngredientCreator$$Type} from "mekanism.api.recipes.ingredients.creator.IIngredientCreator"
import {$BasicCombinerRecipe, $BasicCombinerRecipe$$Type} from "mekanism.api.recipes.basic.BasicCombinerRecipe"
import {$BasicNucleosynthesizingRecipe, $BasicNucleosynthesizingRecipe$$Type} from "mekanism.api.recipes.basic.BasicNucleosynthesizingRecipe"
import {$Chemical, $Chemical$$Type} from "mekanism.api.chemical.Chemical"
import {$ItemStackChemicalToItemStackRecipe, $ItemStackChemicalToItemStackRecipe$$Type} from "mekanism.api.recipes.ItemStackChemicalToItemStackRecipe"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$Recipe, $Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BasicFluidToFluidRecipe, $BasicFluidToFluidRecipe$$Type} from "mekanism.api.recipes.basic.BasicFluidToFluidRecipe"
import {$BasicChemicalToChemicalRecipe, $BasicChemicalToChemicalRecipe$$Type} from "mekanism.api.recipes.basic.BasicChemicalToChemicalRecipe"
import {$RecipeSerializer, $RecipeSerializer$$Type} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $MekanismRecipeSerializer<RECIPE extends $Recipe<(any)>> extends $Record implements $RecipeSerializer<(RECIPE)> {

constructor(codec: $MapCodec$$Type<(RECIPE)>, streamCodec: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (RECIPE)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "wrapped"<RECIPE extends $WrappedShapedRecipe>(wrapper: $Function$$Type<($ShapedRecipe), (RECIPE)>): $MekanismRecipeSerializer<(RECIPE)>
public "codec"(): $MapCodec<(RECIPE)>
public static "fluidToFluid"<RECIPE extends $BasicFluidToFluidRecipe>(factory: $BiFunction$$Type<($FluidStackIngredient), ($FluidStack), (RECIPE)>): $MekanismRecipeSerializer<(RECIPE)>
public static "reaction"(factory: $Function7$$Type<($ItemStackIngredient$$Type), ($FluidStackIngredient$$Type), ($ChemicalStackIngredient$$Type), (long), (integer), ($ItemStack$$Type), ($ChemicalStack$$Type), ($BasicPressurizedReactionRecipe$$Type)>): $MekanismRecipeSerializer<($BasicPressurizedReactionRecipe)>
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (RECIPE)>
public static "crystallizing"(factory: $BiFunction$$Type<($ChemicalStackIngredient), ($ItemStack), ($BasicChemicalCrystallizerRecipe$$Type)>): $MekanismRecipeSerializer<($BasicChemicalCrystallizerRecipe)>
public static "dissolution"(factory: $Function4$$Type<($ItemStackIngredient$$Type), ($ChemicalStackIngredient$$Type), ($ChemicalStack$$Type), (boolean), ($BasicChemicalDissolutionRecipe$$Type)>): $MekanismRecipeSerializer<($BasicChemicalDissolutionRecipe)>
public static "itemChemicalToItem"<RECIPE extends ($ItemStackChemicalToItemStackRecipe) & ($IBasicItemStackOutput)>(factory: $Function4$$Type<($ItemStackIngredient$$Type), ($ChemicalStackIngredient$$Type), ($ItemStack$$Type), (boolean), (RECIPE)>): $MekanismRecipeSerializer<(RECIPE)>
public static "itemToChemical"<RECIPE extends ($ItemStackToChemicalRecipe) & ($IBasicChemicalOutput)>(factory: $BiFunction$$Type<($ItemStackIngredient), ($ChemicalStack), (RECIPE)>, stackCodec: $MapCodec$$Type<($ChemicalStack$$Type)>, stackStreamCodec: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), ($ChemicalStack$$Type)>): $MekanismRecipeSerializer<(RECIPE)>
public static "chemicalChemicalToChemical"<RECIPE extends ($ChemicalChemicalToChemicalRecipe) & ($IBasicChemicalOutput)>(factory: $Function3$$Type<($ChemicalStackIngredient$$Type), ($ChemicalStackIngredient$$Type), ($ChemicalStack$$Type), (RECIPE)>, ingredientCreator: $IIngredientCreator$$Type<($Chemical$$Type), ($ChemicalStack$$Type), ($ChemicalStackIngredient$$Type)>, stackCodec: $MapCodec$$Type<($ChemicalStack$$Type)>, stackStreamCodec: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), ($ChemicalStack$$Type)>): $MekanismRecipeSerializer<(RECIPE)>
public static "chemicalToChemical"<RECIPE extends $BasicChemicalToChemicalRecipe>(factory: $BiFunction$$Type<($ChemicalStackIngredient), ($ChemicalStack), (RECIPE)>): $MekanismRecipeSerializer<(RECIPE)>
public static "combining"(factory: $Function3$$Type<($ItemStackIngredient$$Type), ($ItemStackIngredient$$Type), ($ItemStack$$Type), ($BasicCombinerRecipe$$Type)>): $MekanismRecipeSerializer<($BasicCombinerRecipe)>
public static "itemToItem"<RECIPE extends $BasicItemStackToItemStackRecipe>(factory: $BiFunction$$Type<($ItemStackIngredient), ($ItemStack), (RECIPE)>): $MekanismRecipeSerializer<(RECIPE)>
public static "nucleosynthesizing"(factory: $Function5$$Type<($ItemStackIngredient$$Type), ($ChemicalStackIngredient$$Type), ($ItemStack$$Type), (integer), (boolean), ($BasicNucleosynthesizingRecipe$$Type)>): $MekanismRecipeSerializer<($BasicNucleosynthesizingRecipe)>
public static "itemToEnergy"<RECIPE extends $BasicItemStackToEnergyRecipe>(factory: $BiFunction$$Type<($ItemStackIngredient), (long), (RECIPE)>): $MekanismRecipeSerializer<(RECIPE)>
public static "separating"(factory: $Function4$$Type<($FluidStackIngredient$$Type), (long), ($ChemicalStack$$Type), ($ChemicalStack$$Type), ($BasicElectrolysisRecipe$$Type)>): $MekanismRecipeSerializer<($BasicElectrolysisRecipe)>
public static "fluidChemicalToChemical"(factory: $Function3$$Type<($FluidStackIngredient$$Type), ($ChemicalStackIngredient$$Type), ($ChemicalStack$$Type), ($BasicWashingRecipe$$Type)>): $MekanismRecipeSerializer<($BasicWashingRecipe)>
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismRecipeSerializer$$Type<RECIPE> = ({"streamCodec"?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (never)>, "codec"?: $MapCodec$$Type<(never)>}) | ([streamCodec?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (never)>, codec?: $MapCodec$$Type<(never)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismRecipeSerializer_<RECIPE> = $MekanismRecipeSerializer$$Type<(RECIPE)>;
}}
declare module "mekanism.common.item.block.machine.ItemBlockQuantumEntangloporter" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$TileEntityQuantumEntangloporter, $TileEntityQuantumEntangloporter$$Type} from "mekanism.common.tile.TileEntityQuantumEntangloporter"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$$Type} from "mekanism.common.block.prefab.BlockTile$BlockTileModel"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$IFrequencyItem, $IFrequencyItem$$Type} from "mekanism.common.lib.frequency.IFrequencyItem"

export class $ItemBlockQuantumEntangloporter extends $ItemBlockTooltip<($BlockTile$BlockTileModel<($TileEntityQuantumEntangloporter), ($BlockTypeTile<($TileEntityQuantumEntangloporter)>)>)> implements $IFrequencyItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockTile$BlockTileModel$$Type<($TileEntityQuantumEntangloporter$$Type), ($BlockTypeTile$$Type<($TileEntityQuantumEntangloporter$$Type)>)>, properties: $Item$Properties$$Type)

public "getFrequencyType"(): $FrequencyType<(any)>
get "frequencyType"(): $FrequencyType<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockQuantumEntangloporter$$Type = ($ItemBlockQuantumEntangloporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockQuantumEntangloporter_ = $ItemBlockQuantumEntangloporter$$Type;
}}
declare module "mekanism.common.content.network.transmitter.LogisticalTransporterBase" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$TransporterStack, $TransporterStack$$Type} from "mekanism.common.content.transporter.TransporterStack"
import {$InventoryNetwork, $InventoryNetwork$$Type} from "mekanism.common.content.network.InventoryNetwork"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$DynamicNetwork, $DynamicNetwork$$Type} from "mekanism.common.lib.transmitter.DynamicNetwork"
import {$TransitRequest, $TransitRequest$$Type} from "mekanism.common.lib.inventory.TransitRequest"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$EnumColor, $EnumColor$$Type} from "mekanism.api.text.EnumColor"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$AcceptorCache, $AcceptorCache$$Type} from "mekanism.common.lib.transmitter.acceptor.AcceptorCache"
import {$TransporterTier, $TransporterTier$$Type} from "mekanism.common.tier.TransporterTier"
import {$LogisticalTransporterBase$PathCalculator, $LogisticalTransporterBase$PathCalculator$$Type} from "mekanism.common.content.network.transmitter.LogisticalTransporterBase$PathCalculator"
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$$Type} from "mekanism.common.lib.inventory.TransitRequest$TransitResponse"
import {$Transmitter, $Transmitter$$Type} from "mekanism.common.content.network.transmitter.Transmitter"
import {$TileEntityTransmitter, $TileEntityTransmitter$$Type} from "mekanism.common.tile.transmitter.TileEntityTransmitter"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$IAdvancedTransportEjector, $IAdvancedTransportEjector$$Type} from "mekanism.common.lib.inventory.IAdvancedTransportEjector"

export class $LogisticalTransporterBase extends $Transmitter<($IItemHandler), ($InventoryNetwork), ($LogisticalTransporterBase)> {
readonly "tier": $TransporterTier
 "currentTransmitterConnections": byte


public "remove"(): void
public "insert"(outputter: $BlockEntity$$Type, outputterPos: $BlockPos$$Type, request: $TransitRequest$$Type, color: $EnumColor$$Type, doEmit: boolean, min: integer): $TransitRequest$TransitResponse
public "write"(provider: $HolderLookup$Provider$$Type, nbtTags: $CompoundTag$$Type): $CompoundTag
public "read"(provider: $HolderLookup$Provider$$Type, nbtTags: $CompoundTag$$Type): void
public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getColor"(): $EnumColor
public "onUpdateServer"(): void
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type, updateTag: $CompoundTag$$Type): $CompoundTag
public "getCost"(): double
public "writeToNBT"(provider: $HolderLookup$Provider$$Type, nbtTags: $CompoundTag$$Type): void
public "createEmptyNetworkWithID"(networkID: $UUID$$Type): $DynamicNetwork<(any), (any), (any)>
public "isValidTransmitterBasic"(transmitter: $TileEntityTransmitter$$Type, side: $Direction$$Type): boolean
public "createNetworkByMerging"(networks: $Collection$$Type<(any)>): $DynamicNetwork<(any), (any), (any)>
public "insertMaybeRR"<BE extends ($BlockEntity) & ($IAdvancedTransportEjector)>(outputter: BE, outputterPos: $BlockPos$$Type, request: $TransitRequest$$Type, color: $EnumColor$$Type, doEmit: boolean, min: integer): $TransitRequest$TransitResponse
public "takeShare"(): void
public "onUpdateClient"(): void
public "getAcceptorCache"(): $AcceptorCache<($IItemHandler)>
public "getTransit"(): $Collection<($TransporterStack)>
public "addStack"(id: integer, s: $TransporterStack$$Type): void
public "canEmitTo"(side: $Direction$$Type): boolean
public "handlesRedstone"(): boolean
public "insertUnchecked"(outputterPos: $BlockPos$$Type, request: $TransitRequest$$Type, color: $EnumColor$$Type, doEmit: boolean, min: integer): $TransitRequest$TransitResponse
public "insertUnchecked"<BE extends $BlockEntity>(outputter: BE, request: $TransitRequest$$Type, color: $EnumColor$$Type, doEmit: boolean, min: integer, pathCalculator: $LogisticalTransporterBase$PathCalculator$$Type<(BE)>): $TransitRequest$TransitResponse
public "canReceiveFrom"(side: $Direction$$Type): boolean
public "createInsertStack"(outputterCoord: $BlockPos$$Type, color: $EnumColor$$Type): $TransporterStack
public "deleteStack"(id: integer): void
public "exposesInsertCap"(side: $Direction$$Type): boolean
get "color"(): $EnumColor
get "cost"(): double
get "acceptorCache"(): $AcceptorCache<($IItemHandler)>
get "transit"(): $Collection<($TransporterStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogisticalTransporterBase$$Type = ($LogisticalTransporterBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LogisticalTransporterBase_ = $LogisticalTransporterBase$$Type;
}}
declare module "mekanism.common.integration.computer.TableType" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$TableType$Builder, $TableType$Builder$$Type} from "mekanism.common.integration.computer.TableType$Builder"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$TableType$FieldType, $TableType$FieldType$$Type} from "mekanism.common.integration.computer.TableType$FieldType"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $TableType extends $Record {
static "CODEC": $Codec<($TableType)>
static "TABLE_MAP_CODEC": $Codec<($Map<($Class<(any)>), ($TableType)>)>

constructor(description: string, humanName: string, fields: $Map$$Type<(string), ($TableType$FieldType$$Type)>, extendedFrom: $Class$$Type<(any)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "builder"(clazz: $Class$$Type<(any)>, description: string): $TableType$Builder
public "fields"(): $Map<(string), ($TableType$FieldType)>
public "description"(): string
public "humanName"(): string
public "extendedFrom"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TableType$$Type = ({"humanName"?: string, "fields"?: $Map$$Type<(string), ($TableType$FieldType$$Type)>, "extendedFrom"?: $Class$$Type<(never)>, "description"?: string}) | ([humanName?: string, fields?: $Map$$Type<(string), ($TableType$FieldType$$Type)>, extendedFrom?: $Class$$Type<(never)>, description?: string]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TableType_ = $TableType$$Type;
}}
declare module "mekanism.common.capabilities.energy.LaserEnergyContainer" {
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$BasicEnergyContainer, $BasicEnergyContainer$$Type} from "mekanism.common.capabilities.energy.BasicEnergyContainer"

export class $LaserEnergyContainer extends $BasicEnergyContainer {
static readonly "alwaysTrue": $Predicate<($AutomationType)>
static readonly "alwaysFalse": $Predicate<($AutomationType)>
static readonly "internalOnly": $Predicate<($AutomationType)>
static readonly "manualOnly": $Predicate<($AutomationType)>
static readonly "notExternal": $Predicate<($AutomationType)>


public static "create"(canExtract: $Predicate$$Type<($AutomationType)>, canInsert: $Predicate$$Type<($AutomationType)>, tile: $TileEntityMekanism$$Type, listener: $IContentsListener$$Type): $LaserEnergyContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LaserEnergyContainer$$Type = ($LaserEnergyContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LaserEnergyContainer_ = $LaserEnergyContainer$$Type;
}}
declare module "mekanism.common.advancements.triggers.UnboxCardboardBoxTrigger$TriggerInstance" {
import {$Criterion, $Criterion$$Type} from "net.minecraft.advancements.Criterion"
import {$ContextAwarePredicate, $ContextAwarePredicate$$Type} from "net.minecraft.advancements.critereon.ContextAwarePredicate"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$CriterionValidator, $CriterionValidator$$Type} from "net.minecraft.advancements.critereon.CriterionValidator"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$SimpleCriterionTrigger$SimpleInstance, $SimpleCriterionTrigger$SimpleInstance$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger$SimpleInstance"

export class $UnboxCardboardBoxTrigger$TriggerInstance extends $Record implements $SimpleCriterionTrigger$SimpleInstance {
static readonly "CODEC": $Codec<($UnboxCardboardBoxTrigger$TriggerInstance)>

constructor(player: $Optional$$Type<($ContextAwarePredicate$$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "unbox"(): $Criterion<($UnboxCardboardBoxTrigger$TriggerInstance)>
public "player"(): $Optional<($ContextAwarePredicate)>
public "validate"(arg0: $CriterionValidator$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnboxCardboardBoxTrigger$TriggerInstance$$Type = ({"player"?: ($ContextAwarePredicate$$Type)?}) | ([player?: ($ContextAwarePredicate$$Type)?]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnboxCardboardBoxTrigger$TriggerInstance_ = $UnboxCardboardBoxTrigger$TriggerInstance$$Type;
}}
declare module "mekanism.common.capabilities.heat.BasicHeatCapacitor" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$DoubleSupplier, $DoubleSupplier$$Type} from "java.util.function.DoubleSupplier"
import {$IHeatCapacitor, $IHeatCapacitor$$Type} from "mekanism.api.heat.IHeatCapacitor"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $BasicHeatCapacitor implements $IHeatCapacitor {


public "update"(): void
public static "create"(heatCapacity: double, ambientTempSupplier: $DoubleSupplier$$Type, listener: $IContentsListener$$Type): $BasicHeatCapacitor
public static "create"(heatCapacity: double, inverseConductionCoefficient: double, inverseInsulationCoefficient: double, ambientTempSupplier: $DoubleSupplier$$Type, listener: $IContentsListener$$Type): $BasicHeatCapacitor
public "setHeatCapacityFromPacket"(newCapacity: double): void
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $CompoundTag$$Type): void
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $Tag$$Type): void
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $Tag
public "getTemperature"(): double
public "getHeatCapacity"(): double
public "getInverseConduction"(): double
public "getInverseInsulation"(): double
public "onContentsChanged"(): void
public "handleHeat"(transfer: double): void
public "setHeat"(heat: double): void
public "getHeat"(): double
public "setHeatCapacity"(newCapacity: double, updateHeat: boolean): void
set "heatCapacityFromPacket"(value: double)
get "temperature"(): double
get "heatCapacity"(): double
get "inverseConduction"(): double
get "inverseInsulation"(): double
set "heat"(value: double)
get "heat"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicHeatCapacitor$$Type = ($BasicHeatCapacitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicHeatCapacitor_ = $BasicHeatCapacitor$$Type;
}}
declare module "mekanism.common.capabilities.chemical.VariableCapacityChemicalTank" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ChemicalAttributeValidator, $ChemicalAttributeValidator$$Type} from "mekanism.api.chemical.attribute.ChemicalAttributeValidator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Chemical, $Chemical$$Type} from "mekanism.api.chemical.Chemical"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$LongSupplier, $LongSupplier$$Type} from "java.util.function.LongSupplier"
import {$BasicChemicalTank, $BasicChemicalTank$$Type} from "mekanism.api.chemical.BasicChemicalTank"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$MultiblockData, $MultiblockData$$Type} from "mekanism.common.lib.multiblock.MultiblockData"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"

export class $VariableCapacityChemicalTank extends $BasicChemicalTank {
static readonly "alwaysTrue": $Predicate<($Chemical)>
static readonly "alwaysFalse": $Predicate<($Chemical)>
static readonly "alwaysTrueBi": $BiPredicate<($Chemical), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($Chemical), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($Chemical), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($Chemical), ($AutomationType)>

constructor(capacity: $LongSupplier$$Type, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, validator: $Predicate$$Type<($Chemical)>, attributeValidator: $ChemicalAttributeValidator$$Type, listener: $IContentsListener$$Type)

public static "create"(capacity: $LongSupplier$$Type, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, validator: $Predicate$$Type<($Chemical)>, listener: $IContentsListener$$Type): $IChemicalTank
public static "create"(multiblock: $MultiblockData$$Type, capacity: $LongSupplier$$Type, validator: $Predicate$$Type<($Chemical)>, listener: $IContentsListener$$Type): $IChemicalTank
public static "create"(capacity: $LongSupplier$$Type, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, validator: $Predicate$$Type<($Chemical)>, attributeValidator: $ChemicalAttributeValidator$$Type, listener: $IContentsListener$$Type): $IChemicalTank
public static "input"(multiblock: $MultiblockData$$Type, capacity: $LongSupplier$$Type, validator: $Predicate$$Type<($Chemical)>, attributeValidator: $ChemicalAttributeValidator$$Type, listener: $IContentsListener$$Type): $IChemicalTank
public static "input"(multiblock: $MultiblockData$$Type, capacity: $LongSupplier$$Type, validator: $Predicate$$Type<($Chemical)>, listener: $IContentsListener$$Type): $IChemicalTank
public static "output"(multiblock: $MultiblockData$$Type, capacity: $LongSupplier$$Type, validator: $Predicate$$Type<($Chemical)>, listener: $IContentsListener$$Type): $IChemicalTank
public static "output"(capacity: $LongSupplier$$Type, validator: $Predicate$$Type<($Chemical)>, listener: $IContentsListener$$Type): $IChemicalTank
public static "output"(multiblock: $MultiblockData$$Type, capacity: $LongSupplier$$Type, validator: $Predicate$$Type<($Chemical)>, attributeValidator: $ChemicalAttributeValidator$$Type, listener: $IContentsListener$$Type): $IChemicalTank
public "getCapacity"(): long
public "setStackSize"(amount: long, action: $Action$$Type): long
public static "createAllValid"(capacity: $LongSupplier$$Type, listener: $IContentsListener$$Type): $IChemicalTank
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $Tag
get "capacity"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariableCapacityChemicalTank$$Type = ($VariableCapacityChemicalTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariableCapacityChemicalTank_ = $VariableCapacityChemicalTank$$Type;
}}
declare module "mekanism.common.tile.interfaces.IHasGasMode" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IHasGasMode {

 "nextMode"(tank: integer): void

(tank: integer): void
}

export namespace $IHasGasMode {
const probejs$$marker: never
}
export class $IHasGasMode$$Static implements $IHasGasMode {


 "nextMode"(tank: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHasGasMode$$Type = ((tank: integer) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHasGasMode_ = $IHasGasMode$$Type;
}}
declare module "mekanism.common.lib.inventory.TransitRequest" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LogisticalTransporterBase, $LogisticalTransporterBase$$Type} from "mekanism.common.content.network.transmitter.LogisticalTransporterBase"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$EnumColor, $EnumColor$$Type} from "mekanism.api.text.EnumColor"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$TransitRequest$SimpleTransitRequest, $TransitRequest$SimpleTransitRequest$$Type} from "mekanism.common.lib.inventory.TransitRequest$SimpleTransitRequest"
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$$Type} from "mekanism.common.lib.inventory.TransitRequest$TransitResponse"
import {$Finder, $Finder$$Type} from "mekanism.common.lib.inventory.Finder"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$TransitRequest$ItemData, $TransitRequest$ItemData$$Type} from "mekanism.common.lib.inventory.TransitRequest$ItemData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $TransitRequest implements $Iterable<($TransitRequest$ItemData)> {

constructor()

public "isEmpty"(): boolean
public static "simple"(stack: $ItemStack$$Type): $TransitRequest$SimpleTransitRequest
public "createResponse"(inserted: $ItemStack$$Type, data: $TransitRequest$ItemData$$Type): $TransitRequest$TransitResponse
public "addToInventory"(level: $Level$$Type, pos: $BlockPos$$Type, inventory: $IItemHandler$$Type, min: integer, force: boolean): $TransitRequest$TransitResponse
public static "definedItem"(inventory: $IItemHandler$$Type, min: integer, max: integer, finder: $Finder$$Type): $TransitRequest
public static "definedItem"(inventory: $IItemHandler$$Type, amount: integer, finder: $Finder$$Type): $TransitRequest
public "getEmptyResponse"(): $TransitRequest$TransitResponse
public "eject"(outputter: $BlockEntity$$Type, outputterPos: $BlockPos$$Type, target: $IItemHandler$$Type, min: integer, outputColor: $Function$$Type<($LogisticalTransporterBase), ($EnumColor$$Type)>): $TransitRequest$TransitResponse
public "eject"(outputter: $BlockEntity$$Type, target: $IItemHandler$$Type, min: integer, outputColor: $Function$$Type<($LogisticalTransporterBase), ($EnumColor$$Type)>): $TransitRequest$TransitResponse
public static "anyItem"(inventory: $IItemHandler$$Type, amount: integer): $TransitRequest
public "createSimpleResponse"(): $TransitRequest$TransitResponse
public "addToInventoryUnchecked"(inventory: $IItemHandler$$Type, min: integer): $TransitRequest$TransitResponse
public "iterator"(): $Iterator<($TransitRequest$ItemData)>
public "spliterator"(): $Spliterator<($TransitRequest$ItemData)>
public "forEach"(arg0: $Consumer$$Type<($TransitRequest$ItemData)>): void
[Symbol.iterator](): IterableIterator<$TransitRequest$ItemData>;
get "empty"(): boolean
get "emptyResponse"(): $TransitRequest$TransitResponse
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransitRequest$$Type = ($TransitRequest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransitRequest_ = $TransitRequest$$Type;
}}
declare module "mekanism.common.attachments.containers.chemical.merged.MergedTankCreator" {
import {$ComponentBackedChemicalTank, $ComponentBackedChemicalTank$$Type} from "mekanism.common.attachments.containers.chemical.ComponentBackedChemicalTank"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ComponentBackedFluidTank, $ComponentBackedFluidTank$$Type} from "mekanism.common.attachments.containers.fluid.ComponentBackedFluidTank"
import {$IBasicContainerCreator, $IBasicContainerCreator$$Type} from "mekanism.common.attachments.containers.creator.IBasicContainerCreator"
import {$ContainerType, $ContainerType$$Type} from "mekanism.common.attachments.containers.ContainerType"
import {$INBTSerializable, $INBTSerializable$$Type} from "net.neoforged.neoforge.common.util.INBTSerializable"

export class $MergedTankCreator implements $IBasicContainerCreator<(any)> {

constructor(chemicalCreator: $IBasicContainerCreator$$Type<($ComponentBackedChemicalTank$$Type)>, fluidCreator: $IBasicContainerCreator$$Type<($ComponentBackedFluidTank$$Type)>)

public "create"(containerType: $ContainerType$$Type<(any), (any), (any)>, attachedTo: $ItemStack$$Type, containerIndex: integer): $INBTSerializable<($CompoundTag)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MergedTankCreator$$Type = ($MergedTankCreator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MergedTankCreator_ = $MergedTankCreator$$Type;
}}
declare module "mekanism.common.tile.base.TileEntityMekanism" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IExtendedFluidTank, $IExtendedFluidTank$$Type} from "mekanism.api.fluid.IExtendedFluidTank"
import {$ITileRedstone, $ITileRedstone$$Type} from "mekanism.common.tile.interfaces.ITileRedstone"
import {$IMekanismFluidHandler, $IMekanismFluidHandler$$Type} from "mekanism.api.fluid.IMekanismFluidHandler"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$DataComponentMap$Builder, $DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$AttachedChemicals, $AttachedChemicals$$Type} from "mekanism.common.attachments.containers.chemical.AttachedChemicals"
import {$AttachedFluids, $AttachedFluids$$Type} from "mekanism.common.attachments.containers.fluid.AttachedFluids"
import {$IEnergyContainer, $IEnergyContainer$$Type} from "mekanism.api.energy.IEnergyContainer"
import {$SoundSource, $SoundSource$$Type} from "net.minecraft.sounds.SoundSource"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IRedstoneControl$RedstoneControl, $IRedstoneControl$RedstoneControl$$Type} from "mekanism.common.tile.interfaces.IRedstoneControl$RedstoneControl"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$IMekanismChemicalHandler, $IMekanismChemicalHandler$$Type} from "mekanism.api.chemical.IMekanismChemicalHandler"
import {$IComparatorSupport, $IComparatorSupport$$Type} from "mekanism.common.tile.interfaces.IComparatorSupport"
import {$TileComponentUpgrade, $TileComponentUpgrade$$Type} from "mekanism.common.tile.component.TileComponentUpgrade"
import {$ITileDirectional, $ITileDirectional$$Type} from "mekanism.common.tile.interfaces.ITileDirectional"
import {$IFrequencyHandler, $IFrequencyHandler$$Type} from "mekanism.common.lib.frequency.IFrequencyHandler"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$ITileSound, $ITileSound$$Type} from "mekanism.common.tile.interfaces.ITileSound"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$IMekanismStrictEnergyHandler, $IMekanismStrictEnergyHandler$$Type} from "mekanism.api.energy.IMekanismStrictEnergyHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$WrenchResult, $WrenchResult$$Type} from "mekanism.common.tile.base.WrenchResult"
import {$Nameable, $Nameable$$Type} from "net.minecraft.world.Nameable"
import {$IMekanismInventory, $IMekanismInventory$$Type} from "mekanism.api.inventory.IMekanismInventory"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ITileRadioactive, $ITileRadioactive$$Type} from "mekanism.common.tile.interfaces.ITileRadioactive"
import {$BlockEntity$DataComponentInput, $BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$ITrackableContainer, $ITrackableContainer$$Type} from "mekanism.common.inventory.container.ITrackableContainer"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$ITileActive, $ITileActive$$Type} from "mekanism.common.tile.interfaces.ITileActive"
import {$AttachedHeat, $AttachedHeat$$Type} from "mekanism.common.attachments.containers.heat.AttachedHeat"
import {$TileComponentSecurity, $TileComponentSecurity$$Type} from "mekanism.common.tile.component.TileComponentSecurity"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$ContainerType, $ContainerType$$Type} from "mekanism.common.attachments.containers.ContainerType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$IUpgradeData, $IUpgradeData$$Type} from "mekanism.common.upgrade.IUpgradeData"
import {$AttachedItems, $AttachedItems$$Type} from "mekanism.common.attachments.containers.item.AttachedItems"
import {$ISecurityTile, $ISecurityTile$$Type} from "mekanism.common.lib.security.ISecurityTile"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ITileComponent, $ITileComponent$$Type} from "mekanism.common.tile.component.ITileComponent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ITileUpgradable, $ITileUpgradable$$Type} from "mekanism.common.tile.interfaces.ITileUpgradable"
import {$AttachedEnergy, $AttachedEnergy$$Type} from "mekanism.common.attachments.containers.energy.AttachedEnergy"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$$Type} from "mekanism.common.lib.frequency.Frequency$FrequencyIdentity"
import {$IHeatCapacitor, $IHeatCapacitor$$Type} from "mekanism.api.heat.IHeatCapacitor"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$IComputerTile, $IComputerTile$$Type} from "mekanism.common.integration.computer.IComputerTile"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IChemicalTankHolder, $IChemicalTankHolder$$Type} from "mekanism.common.capabilities.holder.chemical.IChemicalTankHolder"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IFluidHandler$FluidAction, $IFluidHandler$FluidAction$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler$FluidAction"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$SecurityMode, $SecurityMode$$Type} from "mekanism.api.security.SecurityMode"
import {$ITierUpgradable, $ITierUpgradable$$Type} from "mekanism.common.tile.interfaces.ITierUpgradable"
import {$IConfigCardAccess, $IConfigCardAccess$$Type} from "mekanism.api.IConfigCardAccess"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$Upgrade, $Upgrade$$Type} from "mekanism.api.Upgrade"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$TileComponentFrequency, $TileComponentFrequency$$Type} from "mekanism.common.lib.frequency.TileComponentFrequency"
import {$BoundMethodHolder, $BoundMethodHolder$$Type} from "mekanism.common.integration.computer.BoundMethodHolder"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$HeatAPI$HeatTransfer, $HeatAPI$HeatTransfer$$Type} from "mekanism.api.heat.HeatAPI$HeatTransfer"
import {$ITileHeatHandler, $ITileHeatHandler$$Type} from "mekanism.common.capabilities.heat.ITileHeatHandler"

export class $TileEntityMekanism extends $CapabilityTileEntity implements $IFrequencyHandler, $ITileDirectional, $IConfigCardAccess, $ITileActive, $ITileSound, $ITileRedstone, $ISecurityTile, $IMekanismInventory, $ITileUpgradable, $ITierUpgradable, $IComparatorSupport, $ITrackableContainer, $IMekanismFluidHandler, $IMekanismStrictEnergyHandler, $ITileHeatHandler, $IMekanismChemicalHandler, $IComputerTile, $ITileRadioactive, $Nameable {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "getName"(): $Component
public "close"(player: $Player$$Type): void
public "open"(player: $Player$$Type): void
public "getDisplayName"(): $Component
public "getComponent"(): $TileComponentUpgrade
public "addComponent"(component: $ITileComponent$$Type): void
public "saveAdditional"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "loadAdditional"(nbt: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "setActive"(active: boolean): void
public "getComponents"(): $List<($ITileComponent)>
public "getRadiationScale"(): float
public "hasSecurity"(): boolean
public "canBeUpgraded"(): boolean
public "readSustainedData"(provider: $HolderLookup$Provider$$Type, data: $CompoundTag$$Type): void
public "isDirectional"(): boolean
public "supportsRedstone"(): boolean
public "supportsComparator"(): boolean
public "writeSustainedData"(provider: $HolderLookup$Provider$$Type, data: $CompoundTag$$Type): void
public "setRemoved"(): void
public "canHandleChemicals"(): boolean
public "getComputerName"(): string
public "getDirection"(): $Direction
public "getCustomName"(): $Component
public "setCustomName"(name: $Component$$Type): void
public "hasGui"(): boolean
public "getAdjacent"(side: $Direction$$Type): $IHeatHandler
public "canHandleHeat"(): boolean
public "getBlockType"(): $Block
public "getEnergyContainers"(side: $Direction$$Type): $List<($IEnergyContainer)>
public "openGui"(player: $Player$$Type): $InteractionResult
public "getActive"(): boolean
public "wasPowered"(): boolean
public "validateSecurityIsPublic"(): void
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "getBlockTypeRegistryName"(): $ResourceLocation
public "shouldDumpRadiation"(): boolean
public "getSupportedUpgrade"(): $Set<($Upgrade)>
public "getInitialChemicalTanks"(listener: $IContentsListener$$Type): $IChemicalTankHolder
public "recalculateUpgrades"(upgrade: $Upgrade$$Type): void
public "addContainerTrackers"(container: $MekanismContainer$$Type): void
public "getConfigurationData"(provider: $HolderLookup$Provider$$Type, player: $Player$$Type): $CompoundTag
public "applyInventorySlots"(input: $BlockEntity$DataComponentInput$$Type, slots: $List$$Type<($IInventorySlot$$Type)>, attachedItems: $AttachedItems$$Type): void
public "setConfigurationData"(provider: $HolderLookup$Provider$$Type, player: $Player$$Type, data: $CompoundTag$$Type): void
/**
 * 
 * @deprecated
 */
public "getLegacyInfuseTanks"(): $List<($IChemicalTank)>
public "configurationDataSet"(): void
public "collectInventorySlots"(builder: $DataComponentMap$Builder$$Type, slots: $List$$Type<($IInventorySlot$$Type)>): $AttachedItems
/**
 * 
 * @deprecated
 */
public "getLegacyPigmentTanks"(): $List<($IChemicalTank)>
public "applyHeatCapacitors"(input: $BlockEntity$DataComponentInput$$Type, capacitors: $List$$Type<($IHeatCapacitor$$Type)>, attachedHeat: $AttachedHeat$$Type): void
/**
 * 
 * @deprecated
 */
public "getLegacySlurryTanks"(): $List<($IChemicalTank)>
public "applyEnergyContainers"(input: $BlockEntity$DataComponentInput$$Type, containers: $List$$Type<($IEnergyContainer$$Type)>, attachedEnergy: $AttachedEnergy$$Type): void
public "getConfigurationDataType"(): $Block
public "collectChemicalTanks"(builder: $DataComponentMap$Builder$$Type, tanks: $List$$Type<($IChemicalTank$$Type)>): $AttachedChemicals
public "collectHeatCapacitors"(builder: $DataComponentMap$Builder$$Type, capacitors: $List$$Type<($IHeatCapacitor$$Type)>): $AttachedHeat
public "collectEnergyContainers"(builder: $DataComponentMap$Builder$$Type, containers: $List$$Type<($IEnergyContainer$$Type)>): $AttachedEnergy
/**
 * 
 * @deprecated
 */
public "removeComponentsFromTag"(tag: $CompoundTag$$Type): void
public "isActivatable"(): boolean
public "isPowered"(): boolean
public static "tickClient"(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, tile: $TileEntityMekanism$$Type): void
public static "tickServer"(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, tile: $TileEntityMekanism$$Type): void
/**
 * 
 * @deprecated
 */
public "setBlockState"(newState: $BlockState$$Type): void
public "onNeighborChange"(block: $Block$$Type, neighborPos: $BlockPos$$Type): void
public "getChemicalTanks"(side: $Direction$$Type): $List<($IChemicalTank)>
public "getInventorySlots"(side: $Direction$$Type): $List<($IInventorySlot)>
public "getInputRate"(): long
public "markDirtyComparator"(): void
public "getCurrentRedstoneLevel"(): integer
public "getAmbientTemperature"(side: $Direction$$Type): double
public "onContentsChanged"(): void
public "getFrequencyComponent"(): $TileComponentFrequency
public "onAdded"(): void
public "canHandleEnergy"(): boolean
public "getFluidTanks"(side: $Direction$$Type): $List<($IExtendedFluidTank)>
public "getHeatCapacitors"(side: $Direction$$Type): $List<($IHeatCapacitor)>
public "hasInventory"(): boolean
public "insertEnergy"(amount: long, side: $Direction$$Type, action: $Action$$Type): long
public "insertEnergy"(container: integer, amount: long, side: $Direction$$Type, action: $Action$$Type): long
public "canHandleFluid"(): boolean
public "supportsUpgrades"(): boolean
public "persists"(type: $ContainerType$$Type<(any), (any), (any)>): boolean
public "syncs"(type: $ContainerType$$Type<(any), (any), (any)>): boolean
public "hasSound"(): boolean
public "setFacing"(direction: $Direction$$Type): void
public "setFacing"(direction: $Direction$$Type, notifyCaps: boolean): void
public "isNameable"(): boolean
public "tryWrench"(state: $BlockState$$Type, player: $Player$$Type, stack: $ItemStack$$Type): $WrenchResult
public "hasComputerSupport"(): boolean
public "canFunction"(): boolean
public "setControlType"(type: $IRedstoneControl$RedstoneControl$$Type): void
public "updatePower"(): void
public "parseUpgradeData"(provider: $HolderLookup$Provider$$Type, data: $IUpgradeData$$Type): void
public "getRemapEntries"(): $List<($DataComponentType<(any)>)>
public "getRedstoneLevel"(): integer
public "getControlType"(): $IRedstoneControl$RedstoneControl
public "blockRemoved"(): void
public "getComputerMethods"(holder: $BoundMethodHolder$$Type): void
public "applyFluidTanks"(input: $BlockEntity$DataComponentInput$$Type, tanks: $List$$Type<($IExtendedFluidTank$$Type)>, attachedFluids: $AttachedFluids$$Type): void
public "collectFluidTanks"(builder: $DataComponentMap$Builder$$Type, tanks: $List$$Type<($IExtendedFluidTank$$Type)>): $AttachedFluids
/**
 * 
 * @deprecated
 */
public "getLegacyGasTanks"(): $List<($IChemicalTank)>
public "getSecurity"(): $TileComponentSecurity
public "applyChemicalTanks"(input: $BlockEntity$DataComponentInput$$Type, tanks: $List$$Type<($IChemicalTank$$Type)>, attachedChemicals: $AttachedChemicals$$Type): void
public "onSecurityChanged"(old: $SecurityMode$$Type, mode: $SecurityMode$$Type): void
public "getFrequency"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): FREQ
public "getPublicCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
public "removeFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
public "getTrustedCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
public "getPrivateCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
public "setFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
public "getOppositeDirection"(): $Direction
public "getLeftSide"(): $Direction
public "getRightSide"(): $Direction
public "isConfigurationDataCompatible"(arg0: $Block$$Type): boolean
public "getConfigCardName"(): string
public "getVolume"(): float
public "getSoundPos"(): $BlockPos
public "getSoundCategory"(): $SoundSource
public "getInitialVolume"(): float
public "supportsMode"(mode: $IRedstoneControl$RedstoneControl$$Type): boolean
public "onPowerChange"(): void
public "setOwnerUUID"(owner: $UUID$$Type): void
public "getOwnerUUID"(): $UUID
public "getOwnerName"(): string
public "setSecurityMode"(mode: $SecurityMode$$Type): void
public "getSecurityMode"(): $SecurityMode
public "getSlots"(arg0: $Direction$$Type): integer
public "getStackInSlot"(arg0: integer, arg1: $Direction$$Type): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: $Direction$$Type, arg3: $Action$$Type): $ItemStack
public "getSlotLimit"(arg0: integer, arg1: $Direction$$Type): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $ItemStack
public "getInventorySlot"(arg0: integer, arg1: $Direction$$Type): $IInventorySlot
public "isInventoryEmpty"(arg0: $Direction$$Type): boolean
public "isInventoryEmpty"(): boolean
public "getInfo"(upgrade: $Upgrade$$Type): $List<($Component)>
public "getUpgradeData"(provider: $HolderLookup$Provider$$Type): $IUpgradeData
public "getFluidTank"(arg0: integer, arg1: $Direction$$Type): $IExtendedFluidTank
public "getTanks"(arg0: $Direction$$Type): integer
public "getTankCapacity"(arg0: integer, arg1: $Direction$$Type): integer
public "getFluidInTank"(arg0: integer, arg1: $Direction$$Type): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type): void
public "extractFluid"(arg0: integer, arg1: $Direction$$Type, arg2: $Action$$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Direction$$Type, arg3: $Action$$Type): $FluidStack
public "insertFluid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $FluidStack
public "getEnergyContainerCount"(arg0: $Direction$$Type): integer
public "getMaxEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "extractEnergy"(arg0: long, arg1: $Direction$$Type, arg2: $Action$$Type): long
public "extractEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type, arg3: $Action$$Type): long
public "getNeededEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "getEnergy"(arg0: integer, arg1: $Direction$$Type): long
public "setEnergy"(arg0: integer, arg1: long, arg2: $Direction$$Type): void
public "getEnergyContainer"(arg0: integer, arg1: $Direction$$Type): $IEnergyContainer
public "simulateAdjacent"(): double
public "simulate"(): $HeatAPI$HeatTransfer
public "incrementAdjacentTransfer"(currentAdjacentTransfer: double, tempToTransfer: double, side: $Direction$$Type): double
public "simulateEnvironment"(): double
public "updateHeatCapacitors"(side: $Direction$$Type): void
public "isValid"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Direction$$Type): boolean
public "getChemicalTank"(arg0: integer, arg1: $Direction$$Type): $IChemicalTank
public "getCountChemicalTanks"(arg0: $Direction$$Type): integer
public "getChemicalTankCapacity"(arg0: integer, arg1: $Direction$$Type): long
public "setChemicalInTank"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Direction$$Type): void
public "insertChemical"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Direction$$Type, arg3: $Action$$Type): $ChemicalStack
public "insertChemical"(arg0: $ChemicalStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: integer, arg1: long, arg2: $Direction$$Type, arg3: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: long, arg1: $Direction$$Type, arg2: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: $ChemicalStack$$Type, arg1: $Direction$$Type, arg2: $Action$$Type): $ChemicalStack
public "getChemicalInTank"(arg0: integer, arg1: $Direction$$Type): $ChemicalStack
public "isComputerCapabilityPersistent"(): boolean
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getRadiationParticleCount"(): integer
public "hasCustomName"(): boolean
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "getInventorySideFor"(): $Direction
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "supportsUpgrade"(upgradeType: $Upgrade$$Type): boolean
public "getTanks"(): integer
public "getTankCapacity"(arg0: integer): integer
public "getFluidInTank"(arg0: integer): $FluidStack
public "isFluidValid"(arg0: integer, arg1: $FluidStack$$Type): boolean
public "setFluidInTank"(arg0: integer, arg1: $FluidStack$$Type): void
public "getFluidSideFor"(): $Direction
public "extractFluid"(arg0: integer, arg1: integer, arg2: $Action$$Type): $FluidStack
public "insertFluid"(arg0: integer, arg1: $FluidStack$$Type, arg2: $Action$$Type): $FluidStack
public "getEnergyContainerCount"(): integer
public "getMaxEnergy"(arg0: integer): long
public "extractEnergy"(arg0: integer, arg1: long, arg2: $Action$$Type): long
public "getNeededEnergy"(arg0: integer): long
public "getEnergy"(arg0: integer): long
public "setEnergy"(arg0: integer, arg1: long): void
public "insertEnergy"(arg0: integer, arg1: long, arg2: $Action$$Type): long
public "getEnergySideFor"(): $Direction
public "getTemperature"(arg0: integer, arg1: $Direction$$Type): double
public "getHeatCapacitor"(arg0: integer, arg1: $Direction$$Type): $IHeatCapacitor
public "getHeatCapacity"(arg0: integer, arg1: $Direction$$Type): double
public "getTotalInverseInsulation"(arg0: $Direction$$Type): double
public "getTotalTemperature"(arg0: $Direction$$Type): double
public "getTotalHeatCapacity"(arg0: $Direction$$Type): double
public "getInverseConduction"(arg0: integer, arg1: $Direction$$Type): double
public "getHeatCapacitorCount"(arg0: $Direction$$Type): integer
public "getInverseInsulation"(arg0: integer, arg1: $Direction$$Type): double
public "getTotalInverseConductionCoefficient"(arg0: $Direction$$Type): double
public "handleHeat"(arg0: double, arg1: $Direction$$Type): void
public "handleHeat"(arg0: integer, arg1: double, arg2: $Direction$$Type): void
public "isValid"(arg0: integer, arg1: $ChemicalStack$$Type): boolean
public "getSideFor"(): $Direction
public "getChemicalTankCapacity"(arg0: integer): long
public "setChemicalInTank"(arg0: integer, arg1: $ChemicalStack$$Type): void
public "insertChemical"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: integer, arg1: long, arg2: $Action$$Type): $ChemicalStack
public "getChemicalTanks"(): integer
public "getChemicalInTank"(arg0: integer): $ChemicalStack
public "ownerMatches"(arg0: $Player$$Type): boolean
/**
 * 
 * @deprecated
 */
public "fill"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): integer
/**
 * 
 * @deprecated
 */
public "drain"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
/**
 * 
 * @deprecated
 */
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
public "extractFluid"(arg0: integer, arg1: $Action$$Type): $FluidStack
public "extractFluid"(arg0: $FluidStack$$Type, arg1: $Action$$Type): $FluidStack
public "insertFluid"(arg0: $FluidStack$$Type, arg1: $Action$$Type): $FluidStack
public "extractEnergy"(arg0: long, arg1: $Action$$Type): long
public "insertEnergy"(arg0: long, arg1: $Action$$Type): long
public "getTemperature"(arg0: integer): double
public "getHeatCapacity"(arg0: integer): double
public "getHeatSideFor"(): $Direction
public "getTotalTemperature"(): double
public "getTotalHeatCapacity"(): double
public "getInverseConduction"(arg0: integer): double
public "getHeatCapacitorCount"(): integer
public "getTotalInverseConduction"(): double
public "handleHeat"(arg0: double): void
public "handleHeat"(arg0: integer, arg1: double): void
public "insertChemical"(arg0: $ChemicalStack$$Type, arg1: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: long, arg1: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: $ChemicalStack$$Type, arg1: $Action$$Type): $ChemicalStack
public "kjs$self"(): $IItemHandler
public "getStackInSlot"(arg0: integer): $ItemStack
public "getSlots"(): integer
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isMutable"(): boolean
public "getBlock"(arg0: $Level$$Type): $BlockContainerJS
public "asContainer"(): $Container
public "getHeight"(): integer
public "setChanged"(): void
public "insertItem"(arg0: $ItemStack$$Type, arg1: boolean): $ItemStack
public "getAllItems"(): $List<($ItemStack)>
public "countNonEmpty"(): integer
public "countNonEmpty"(arg0: $ItemPredicate$$Type): integer
public "getWidth"(): integer
public "isEmpty"(): boolean
public "find"(): integer
public "find"(arg0: $ItemPredicate$$Type): integer
public "clear"(arg0: $ItemPredicate$$Type): void
public "clear"(): void
public "count"(arg0: $ItemPredicate$$Type): integer
public "count"(): integer
get "name"(): $Component
get "displayName"(): $Component
get "component"(): $TileComponentUpgrade
set "active"(value: boolean)
get "components"(): $List<($ITileComponent)>
get "radiationScale"(): float
get "directional"(): boolean
get "computerName"(): string
get "direction"(): $Direction
get "customName"(): $Component
set "customName"(value: $Component$$Type)
get "blockType"(): $Block
get "active"(): boolean
get "blockTypeRegistryName"(): $ResourceLocation
get "supportedUpgrade"(): $Set<($Upgrade)>
get "legacyInfuseTanks"(): $List<($IChemicalTank)>
get "legacyPigmentTanks"(): $List<($IChemicalTank)>
get "legacySlurryTanks"(): $List<($IChemicalTank)>
get "configurationDataType"(): $Block
get "activatable"(): boolean
get "powered"(): boolean
set "blockState"(value: $BlockState$$Type)
get "inputRate"(): long
get "currentRedstoneLevel"(): integer
get "frequencyComponent"(): $TileComponentFrequency
set "facing"(value: $Direction$$Type)
get "nameable"(): boolean
set "controlType"(value: $IRedstoneControl$RedstoneControl$$Type)
get "remapEntries"(): $List<($DataComponentType<(any)>)>
get "redstoneLevel"(): integer
get "controlType"(): $IRedstoneControl$RedstoneControl
get "legacyGasTanks"(): $List<($IChemicalTank)>
get "security"(): $TileComponentSecurity
get "oppositeDirection"(): $Direction
get "leftSide"(): $Direction
get "rightSide"(): $Direction
get "configCardName"(): string
get "volume"(): float
get "soundPos"(): $BlockPos
get "soundCategory"(): $SoundSource
get "initialVolume"(): float
set "ownerUUID"(value: $UUID$$Type)
get "ownerUUID"(): $UUID
get "ownerName"(): string
set "securityMode"(value: $SecurityMode$$Type)
get "securityMode"(): $SecurityMode
get "inventoryEmpty"(): boolean
get "computerCapabilityPersistent"(): boolean
get "radiationParticleCount"(): integer
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
get "slots"(): integer
get "inventorySideFor"(): $Direction
get "tanks"(): integer
get "fluidSideFor"(): $Direction
get "energyContainerCount"(): integer
get "energySideFor"(): $Direction
get "sideFor"(): $Direction
get "chemicalTanks"(): integer
get "heatSideFor"(): $Direction
get "totalTemperature"(): double
get "totalHeatCapacity"(): double
get "heatCapacitorCount"(): integer
get "totalInverseConduction"(): double
get "slots"(): integer
get "mutable"(): boolean
get "height"(): integer
get "allItems"(): $List<($ItemStack)>
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityMekanism$$Type = ($TileEntityMekanism);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityMekanism_ = $TileEntityMekanism$$Type;
}}
declare module "mekanism.common.block.BlockPersonalStorage" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TileEntityPersonalStorage, $TileEntityPersonalStorage$$Type} from "mekanism.common.tile.TileEntityPersonalStorage"
import {$Attribute, $Attribute$$Type} from "mekanism.common.block.attribute.Attribute"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockPersonalStorage<TILE extends $TileEntityPersonalStorage, BLOCK extends $BlockTypeTile<(TILE)>> extends $BlockTile<(TILE), (BLOCK)> {
static readonly "PERSONAL_STORAGE_INVENTORY": $Attribute
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(type: BLOCK, propertiesModifier: $UnaryOperator$$Type<($BlockBehaviour$Properties)>)

public "setPlacedBy"(world: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, placer: $LivingEntity$$Type, stack: $ItemStack$$Type): void
public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPersonalStorage$$Type<TILE, BLOCK> = ($BlockPersonalStorage<(TILE), (BLOCK)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPersonalStorage_<TILE, BLOCK> = $BlockPersonalStorage$$Type<(TILE), (BLOCK)>;
}}
declare module "mekanism.common.registration.impl.RecipeTypeRegistryObject" {
import {$MekanismDeferredHolder, $MekanismDeferredHolder$$Type} from "mekanism.common.registration.MekanismDeferredHolder"
import {$IMekanismRecipeTypeProvider, $IMekanismRecipeTypeProvider$$Type} from "mekanism.common.recipe.IMekanismRecipeTypeProvider"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeType, $RecipeType$$Type} from "net.minecraft.world.item.crafting.RecipeType"
import {$RecipeManager, $RecipeManager$$Type} from "net.minecraft.world.item.crafting.RecipeManager"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MekanismRecipeType, $MekanismRecipeType$$Type} from "mekanism.common.recipe.MekanismRecipeType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$IInputRecipeCache, $IInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.IInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$RecipeHolder, $RecipeHolder$$Type} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"

export class $RecipeTypeRegistryObject<VANILLA_INPUT extends $RecipeInput, RECIPE extends $MekanismRecipe<(VANILLA_INPUT)>, INPUT_CACHE extends $IInputRecipeCache> extends $MekanismDeferredHolder<($RecipeType<(any)>), ($MekanismRecipeType<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>)> implements $IMekanismRecipeTypeProvider<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)> {

constructor(key: $ResourceKey$$Type<($RecipeType<(any)>)>)

public "getRecipeType"(): $MekanismRecipeType<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>
public "stream"(world: $Level$$Type): $Stream<($RecipeHolder<(RECIPE)>)>
public "contains"(world: $Level$$Type, matchCriteria: $Predicate$$Type<(RECIPE)>): boolean
public "findFirst"(world: $Level$$Type, matchCriteria: $Predicate$$Type<(RECIPE)>): RECIPE
public "getRecipes"(recipeManager: $RecipeManager$$Type, world: $Level$$Type): $List<($RecipeHolder<(RECIPE)>)>
public "getRecipes"(world: $Level$$Type): $List<($RecipeHolder<(RECIPE)>)>
public "getRegistryName"(): $ResourceLocation
public "getInputCache"(): INPUT_CACHE
public "getId"(): $ResourceLocation
public static "direct"<T>(arg0: T): $Holder<(T)>
get "recipeType"(): $MekanismRecipeType<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>
get "registryName"(): $ResourceLocation
get "inputCache"(): INPUT_CACHE
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeTypeRegistryObject$$Type<VANILLA_INPUT, RECIPE, INPUT_CACHE> = ($RecipeTypeRegistryObject<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeTypeRegistryObject_<VANILLA_INPUT, RECIPE, INPUT_CACHE> = $RecipeTypeRegistryObject$$Type<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>;
}}
declare module "mekanism.common.tile.interfaces.ITileActive" {
import {$IntSupplier, $IntSupplier$$Type} from "java.util.function.IntSupplier"

export interface $ITileActive {

 "setActive"(active: boolean): void
 "getActive"(): boolean
 "isActivatable"(): boolean
set "active"(value: boolean)
get "active"(): boolean
get "activatable"(): boolean
}

export namespace $ITileActive {
const NO_DELAY: $IntSupplier
const probejs$$marker: never
}
export class $ITileActive$$Static implements $ITileActive {
static readonly "NO_DELAY": $IntSupplier


 "setActive"(active: boolean): void
 "getActive"(): boolean
 "isActivatable"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileActive$$Type = ($ITileActive);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileActive_ = $ITileActive$$Type;
}}
declare module "mekanism.common.inventory.GuiComponents$IDropdownEnum" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $GuiComponents$IDropdownEnum<TYPE extends ($Enum<(TYPE)>) & ($GuiComponents$IDropdownEnum<(TYPE)>)> {

 "getIcon"(): $ResourceLocation
 "getTooltip"(): $Component
 "getShortName"(): $Component
get "icon"(): $ResourceLocation
get "tooltip"(): $Component
get "shortName"(): $Component
}

export namespace $GuiComponents$IDropdownEnum {
const probejs$$marker: never
}
export class $GuiComponents$IDropdownEnum$$Static<TYPE extends ($Enum<(TYPE)>) & ($GuiComponents$IDropdownEnum<(TYPE)>)> implements $GuiComponents$IDropdownEnum {


 "getIcon"(): $ResourceLocation
 "getTooltip"(): $Component
 "getShortName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GuiComponents$IDropdownEnum$$Type<TYPE> = ($GuiComponents$IDropdownEnum<(TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GuiComponents$IDropdownEnum_<TYPE> = $GuiComponents$IDropdownEnum$$Type<(TYPE)>;
}}
declare module "mekanism.common.advancements.triggers.UseTierInstallerTrigger$TriggerInstance" {
import {$Criterion, $Criterion$$Type} from "net.minecraft.advancements.Criterion"
import {$UseTierInstallerTrigger$TierUsed, $UseTierInstallerTrigger$TierUsed$$Type} from "mekanism.common.advancements.triggers.UseTierInstallerTrigger$TierUsed"
import {$ContextAwarePredicate, $ContextAwarePredicate$$Type} from "net.minecraft.advancements.critereon.ContextAwarePredicate"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$CriterionValidator, $CriterionValidator$$Type} from "net.minecraft.advancements.critereon.CriterionValidator"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$SimpleCriterionTrigger$SimpleInstance, $SimpleCriterionTrigger$SimpleInstance$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger$SimpleInstance"

export class $UseTierInstallerTrigger$TriggerInstance extends $Record implements $SimpleCriterionTrigger$SimpleInstance {
static readonly "CODEC": $Codec<($UseTierInstallerTrigger$TriggerInstance)>

constructor(player: $Optional$$Type<($ContextAwarePredicate$$Type)>, action: $UseTierInstallerTrigger$TierUsed$$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "action"(): $UseTierInstallerTrigger$TierUsed
public static "any"(): $Criterion<($UseTierInstallerTrigger$TriggerInstance)>
public "player"(): $Optional<($ContextAwarePredicate)>
public "validate"(arg0: $CriterionValidator$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UseTierInstallerTrigger$TriggerInstance$$Type = ({"player"?: ($ContextAwarePredicate$$Type)?, "action"?: $UseTierInstallerTrigger$TierUsed$$Type}) | ([player?: ($ContextAwarePredicate$$Type)?, action?: $UseTierInstallerTrigger$TierUsed$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UseTierInstallerTrigger$TriggerInstance_ = $UseTierInstallerTrigger$TriggerInstance$$Type;
}}
declare module "mekanism.common.item.gear.ItemArmoredJetpack" {
import {$ArmorMaterial, $ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$IJetpackItem$JetpackMode, $IJetpackItem$JetpackMode$$Type} from "mekanism.common.item.interfaces.IJetpackItem$JetpackMode"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$ItemAttributeModifiers, $ItemAttributeModifiers$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Equipable, $Equipable$$Type} from "net.minecraft.world.item.Equipable"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$DispenseItemBehavior, $DispenseItemBehavior$$Type} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$ItemJetpack, $ItemJetpack$$Type} from "mekanism.common.item.gear.ItemJetpack"

export class $ItemArmoredJetpack extends $ItemJetpack {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
readonly "type": $ArmorItem$Type
readonly "material": $Holder<($ArmorMaterial)>
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "getDefaultMode"(): any
public static "getActiveJetpack"(entity: $LivingEntity$$Type): $ItemStack
public static "getPrimaryJetpack"(entity: $LivingEntity$$Type): $ItemStack
public static "getPlayerJetpackMode"<PLAYER extends $Player>(player: PLAYER, mode: $IJetpackItem$JetpackMode$$Type, ascendingCheck: $Predicate$$Type<(PLAYER)>): $IJetpackItem$JetpackMode
public static "handleJetpackMotion"<PLAYER extends $Player>(player: PLAYER, mode: $IJetpackItem$JetpackMode$$Type, thrust: double, ascendingCheck: $Predicate$$Type<(PLAYER)>): boolean
public static "displayModeChange"(player: $Player$$Type): void
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "get"(arg0: $ItemStack$$Type): $Equipable
get "defaultMode"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemArmoredJetpack$$Type = ($ItemArmoredJetpack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemArmoredJetpack_ = $ItemArmoredJetpack$$Type;
}}
declare module "mekanism.common.lib.transmitter.ConnectionType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$IIncrementalEnum, $IIncrementalEnum$$Type} from "mekanism.api.IIncrementalEnum"
import {$IHasTranslationKey, $IHasTranslationKey$$Type} from "mekanism.api.text.IHasTranslationKey"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$IHasTextComponent$IHasEnumNameTextComponent, $IHasTextComponent$IHasEnumNameTextComponent$$Type} from "mekanism.api.text.IHasTextComponent$IHasEnumNameTextComponent"

export class $ConnectionType extends $Enum<($ConnectionType)> implements $IIncrementalEnum<($ConnectionType)>, $StringRepresentable, $IHasTranslationKey, $IHasTextComponent$IHasEnumNameTextComponent {
static readonly "NORMAL": $ConnectionType
static readonly "PUSH": $ConnectionType
static readonly "PULL": $ConnectionType
static readonly "NONE": $ConnectionType
static readonly "BY_ID": $IntFunction<($ConnectionType)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($ConnectionType)>


public static "values"(): ($ConnectionType)[]
public static "valueOf"(name: string): $ConnectionType
public "byIndex"(index: integer): $Enum<(any)>
public "getSerializedName"(): string
public "getTranslationKey"(): string
public "getTextComponent"(): $Component
public "canAccept"(): boolean
public "canSendTo"(): boolean
public "ordinal"(): integer
public "adjust"(arg0: integer): $ConnectionType
public "adjust"(arg0: integer, arg1: $Predicate$$Type<($ConnectionType)>): $ConnectionType
public "getNext"(arg0: $Predicate$$Type<($ConnectionType)>): $ConnectionType
public "getNext"(): $ConnectionType
public "getPrevious"(): $ConnectionType
public "getPrevious"(arg0: $Predicate$$Type<($ConnectionType)>): $ConnectionType
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
public "getTranslatedName"(): $Component
get "serializedName"(): string
get "translationKey"(): string
get "textComponent"(): $Component
get "next"(): $ConnectionType
get "previous"(): $ConnectionType
get "remappedEnumConstantName"(): string
get "translatedName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConnectionType$$Type = (("normal") | ("push") | ("pull") | ("none"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConnectionType_ = $ConnectionType$$Type;
}}
declare module "mekanism.common.block.attribute.AttributeEnergy" {
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Attribute, $Attribute$$Type} from "mekanism.common.block.attribute.Attribute"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$LongSupplier, $LongSupplier$$Type} from "java.util.function.LongSupplier"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$BaseTier, $BaseTier$$Type} from "mekanism.api.tier.BaseTier"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AttributeEnergy implements $Attribute {

constructor(energyUsage: $LongSupplier$$Type, energyStorage: $LongSupplier$$Type)

public "getUsage"(): long
public "getStorage"(): long
public "getConfigStorage"(): long
public static "get"<ATTRIBUTE extends $Attribute>(state: $BlockState$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
public static "get"<ATTRIBUTE extends $Attribute>(block: $Block$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
public static "matches"<ATTRIBUTE extends $Attribute>(block: $Block$$Type, type: $Class$$Type<(ATTRIBUTE)>, checker: $Predicate$$Type<(ATTRIBUTE)>): boolean
public static "isActive"(state: $BlockState$$Type): boolean
public static "ifPresent"<ATTRIBUTE extends $Attribute>(block: $Block$$Type, type: $Class$$Type<(ATTRIBUTE)>, action: $Consumer$$Type<(ATTRIBUTE)>): void
public static "getAll"(block: $Block$$Type): $Collection<($Attribute)>
public static "has"(state: $BlockState$$Type, type: $Class$$Type<($Attribute$$Type)>): boolean
public static "has"(block: $Block$$Type, type: $Class$$Type<($Attribute$$Type)>): boolean
public static "getOrThrow"<ATTRIBUTE extends $Attribute>(block: $Block$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
public static "getOrThrow"<ATTRIBUTE extends $Attribute>(blockProvider: $IBlockProvider$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
public static "getOrThrow"<ATTRIBUTE extends $Attribute>(state: $BlockState$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
public static "setActive"(state: $BlockState$$Type, active: boolean): $BlockState
public static "getTier"<TIER extends $ITier>(block: $Block$$Type, tierClass: $Class$$Type<(TIER)>): TIER
public static "getTier"<TIER extends $ITier>(blockProvider: $IBlockProvider$$Type, tierClass: $Class$$Type<(TIER)>): TIER
public "adjustProperties"(props: $BlockBehaviour$Properties$$Type): void
public static "getFacing"(state: $BlockState$$Type): $Direction
public static "setFacing"(state: $BlockState$$Type, facing: $Direction$$Type): $BlockState
public static "getBaseTier"(block: $Block$$Type): $BaseTier
get "usage"(): long
get "storage"(): long
get "configStorage"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeEnergy$$Type = ($AttributeEnergy);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttributeEnergy_ = $AttributeEnergy$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.DoubleInputRecipeCache$CheckRecipeType" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"

export interface $DoubleInputRecipeCache$CheckRecipeType<INPUT_A, INPUT_B, RECIPE extends ($MekanismRecipe<(any)>) & ($BiPredicate<(INPUT_A), (INPUT_B)>), DATA> {

 "testType"(recipe: RECIPE, inputA: INPUT_A, inputB: INPUT_B, data: DATA): boolean

(recipe: RECIPE, inputA: INPUT_A, inputB: INPUT_B, data: DATA): boolean
}

export namespace $DoubleInputRecipeCache$CheckRecipeType {
const probejs$$marker: never
}
export class $DoubleInputRecipeCache$CheckRecipeType$$Static<INPUT_A, INPUT_B, RECIPE extends ($MekanismRecipe<(any)>) & ($BiPredicate<(INPUT_A), (INPUT_B)>), DATA> implements $DoubleInputRecipeCache$CheckRecipeType {


 "testType"(recipe: RECIPE, inputA: INPUT_A, inputB: INPUT_B, data: DATA): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleInputRecipeCache$CheckRecipeType$$Type<INPUT_A, INPUT_B, RECIPE, DATA> = ((recipe: RECIPE, inputA: INPUT_A, inputB: INPUT_B, data: DATA) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleInputRecipeCache$CheckRecipeType_<INPUT_A, INPUT_B, RECIPE, DATA> = $DoubleInputRecipeCache$CheckRecipeType$$Type<(INPUT_A), (INPUT_B), (RECIPE), (DATA)>;
}}
declare module "mekanism.common.tile.prefab.TileEntityMultiblock" {
import {$IMultiblock, $IMultiblock$$Type} from "mekanism.common.lib.multiblock.IMultiblock"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$IConfigurable, $IConfigurable$$Type} from "mekanism.api.IConfigurable"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$ContainerType, $ContainerType$$Type} from "mekanism.common.attachments.containers.ContainerType"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Structure, $Structure$$Type} from "mekanism.common.lib.multiblock.Structure"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$MultiblockData, $MultiblockData$$Type} from "mekanism.common.lib.multiblock.MultiblockData"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$FormationProtocol, $FormationProtocol$$Type} from "mekanism.common.lib.multiblock.FormationProtocol"
import {$MultiblockManager, $MultiblockManager$$Type} from "mekanism.common.lib.multiblock.MultiblockManager"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$BoundMethodHolder, $BoundMethodHolder$$Type} from "mekanism.common.integration.computer.BoundMethodHolder"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"

export class $TileEntityMultiblock<T extends $MultiblockData> extends $TileEntityMekanism implements $IMultiblock<(T)>, $IConfigurable {
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "saveAdditional"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "handleUpdateTag"(tag: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "loadAdditional"(nbt: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "getStructure"(): $Structure
public "setRemoved"(): void
public "resetCache"(): void
public "getReducedUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "shouldDumpRadiation"(): boolean
public "addContainerTrackers"(container: $MekanismContainer$$Type): void
public "onNeighborChange"(block: $Block$$Type, neighborPos: $BlockPos$$Type): void
public "onRightClick"(player: $Player$$Type): $InteractionResult
public "isComputerCapabilityPersistent"(): boolean
public "canBeMaster"(): boolean
public "getDefaultData"(): T
public "resetForFormed"(): void
public "getCacheID"(): $UUID
public "persists"(type: $ContainerType$$Type<(any), (any), (any)>): boolean
public "getComputerMethods"(holder: $BoundMethodHolder$$Type): void
public "setStructure"(structure: $Structure$$Type): void
public "onSneakRightClick"(player: $Player$$Type): $InteractionResult
public "exposesMultiblockToComputer"(): boolean
public "isMaster"(): boolean
public "onActivate"(player: $Player$$Type, hand: $InteractionHand$$Type, stack: $ItemStack$$Type): $ItemInteractionResult
public "getManager"(): $MultiblockManager<(T)>
public "getStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
public "getMultiblock"(): T
public "hasStructure"(structure: $Structure$$Type): boolean
public "createMultiblock"(): T
public "setStructure"(manager: $MultiblockManager$$Type<(any)>, structure: $Structure$$Type): void
public "createFormationProtocol"(): $FormationProtocol<(T)>
public "getMultiblockData"(manager: $MultiblockManager$$Type<(any)>): $MultiblockData
public "resetStructure"(manager: $MultiblockManager$$Type<(any)>): $Structure
public "setMultiblockData"(manager: $MultiblockManager$$Type<(any)>, multiblockData: $MultiblockData$$Type): void
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "structure"(): $Structure
get "computerCapabilityPersistent"(): boolean
get "defaultData"(): T
get "cacheID"(): $UUID
set "structure"(value: $Structure$$Type)
get "master"(): boolean
get "manager"(): $MultiblockManager<(T)>
get "multiblock"(): T
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityMultiblock$$Type<T> = ($TileEntityMultiblock<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityMultiblock_<T> = $TileEntityMultiblock$$Type<(T)>;
}}
declare module "mekanism.common.capabilities.fluid.item.FluidTankSpec$TankFromSpecCreator" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IExtendedFluidTank, $IExtendedFluidTank$$Type} from "mekanism.api.fluid.IExtendedFluidTank"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$IntSupplier, $IntSupplier$$Type} from "java.util.function.IntSupplier"

export interface $FluidTankSpec$TankFromSpecCreator<TANK extends $IExtendedFluidTank> {

 "create"(rate: $IntSupplier$$Type, capacity: $IntSupplier$$Type, canExtract: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, canInsert: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, isValid: $Predicate$$Type<($FluidStack)>, listener: $IContentsListener$$Type): TANK
 "create"(rate: $IntSupplier$$Type, capacity: $IntSupplier$$Type, canExtract: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, canInsert: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, isValid: $Predicate$$Type<($FluidStack)>): TANK

(rate: $IntSupplier, capacity: $IntSupplier, canExtract: $BiPredicate<($FluidStack), ($AutomationType)>, canInsert: $BiPredicate<($FluidStack), ($AutomationType)>, isValid: $Predicate<($FluidStack)>, listener: $IContentsListener): TANK
}

export namespace $FluidTankSpec$TankFromSpecCreator {
const probejs$$marker: never
}
export class $FluidTankSpec$TankFromSpecCreator$$Static<TANK extends $IExtendedFluidTank> implements $FluidTankSpec$TankFromSpecCreator {


 "create"(rate: $IntSupplier$$Type, capacity: $IntSupplier$$Type, canExtract: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, canInsert: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, isValid: $Predicate$$Type<($FluidStack)>, listener: $IContentsListener$$Type): TANK
 "create"(rate: $IntSupplier$$Type, capacity: $IntSupplier$$Type, canExtract: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, canInsert: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, isValid: $Predicate$$Type<($FluidStack)>): TANK
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankSpec$TankFromSpecCreator$$Type<TANK> = ((rate: $IntSupplier, capacity: $IntSupplier, canExtract: $BiPredicate<($FluidStack), ($AutomationType)>, canInsert: $BiPredicate<($FluidStack), ($AutomationType)>, isValid: $Predicate<($FluidStack)>, listener: $IContentsListener) => TANK);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTankSpec$TankFromSpecCreator_<TANK> = $FluidTankSpec$TankFromSpecCreator$$Type<(TANK)>;
}}
declare module "mekanism.common.recipe.MekanismRecipeType" {
import {$SawmillRecipe, $SawmillRecipe$$Type} from "mekanism.api.recipes.SawmillRecipe"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$NucleosynthesizingRecipe, $NucleosynthesizingRecipe$$Type} from "mekanism.api.recipes.NucleosynthesizingRecipe"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$ItemStackToChemicalRecipe, $ItemStackToChemicalRecipe$$Type} from "mekanism.api.recipes.ItemStackToChemicalRecipe"
import {$SingleFluidChemicalRecipeInput, $SingleFluidChemicalRecipeInput$$Type} from "mekanism.api.recipes.vanilla_input.SingleFluidChemicalRecipeInput"
import {$SingleFluidRecipeInput, $SingleFluidRecipeInput$$Type} from "mekanism.api.recipes.vanilla_input.SingleFluidRecipeInput"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$RotaryInputRecipeCache, $RotaryInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.RotaryInputRecipeCache"
import {$RotaryRecipe, $RotaryRecipe$$Type} from "mekanism.api.recipes.RotaryRecipe"
import {$InputRecipeCache$DoubleItem, $InputRecipeCache$DoubleItem$$Type} from "mekanism.common.recipe.lookup.cache.InputRecipeCache$DoubleItem"
import {$ChemicalCrystallizerRecipe, $ChemicalCrystallizerRecipe$$Type} from "mekanism.api.recipes.ChemicalCrystallizerRecipe"
import {$PressurizedReactionRecipe, $PressurizedReactionRecipe$$Type} from "mekanism.api.recipes.PressurizedReactionRecipe"
import {$SingleRecipeInput, $SingleRecipeInput$$Type} from "net.minecraft.world.item.crafting.SingleRecipeInput"
import {$ItemStackToEnergyRecipe, $ItemStackToEnergyRecipe$$Type} from "mekanism.api.recipes.ItemStackToEnergyRecipe"
import {$RecipeManager, $RecipeManager$$Type} from "net.minecraft.world.item.crafting.RecipeManager"
import {$IInputRecipeCache, $IInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.IInputRecipeCache"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$InputRecipeCache$SingleItem, $InputRecipeCache$SingleItem$$Type} from "mekanism.common.recipe.lookup.cache.InputRecipeCache$SingleItem"
import {$RecipeHolder, $RecipeHolder$$Type} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$ItemStackToItemStackRecipe, $ItemStackToItemStackRecipe$$Type} from "mekanism.api.recipes.ItemStackToItemStackRecipe"
import {$CombinerRecipe, $CombinerRecipe$$Type} from "mekanism.api.recipes.CombinerRecipe"
import {$RecipeTypeRegistryObject, $RecipeTypeRegistryObject$$Type} from "mekanism.common.registration.impl.RecipeTypeRegistryObject"
import {$FluidChemicalToChemicalRecipe, $FluidChemicalToChemicalRecipe$$Type} from "mekanism.api.recipes.FluidChemicalToChemicalRecipe"
import {$FluidToFluidRecipe, $FluidToFluidRecipe$$Type} from "mekanism.api.recipes.FluidToFluidRecipe"
import {$ReactionRecipeInput, $ReactionRecipeInput$$Type} from "mekanism.api.recipes.vanilla_input.ReactionRecipeInput"
import {$BiChemicalRecipeInput, $BiChemicalRecipeInput$$Type} from "mekanism.api.recipes.vanilla_input.BiChemicalRecipeInput"
import {$List, $List$$Type} from "java.util.List"
import {$RotaryRecipeInput, $RotaryRecipeInput$$Type} from "mekanism.api.recipes.vanilla_input.RotaryRecipeInput"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$InputRecipeCache$ItemChemical, $InputRecipeCache$ItemChemical$$Type} from "mekanism.common.recipe.lookup.cache.InputRecipeCache$ItemChemical"
import {$ElectrolysisRecipe, $ElectrolysisRecipe$$Type} from "mekanism.api.recipes.ElectrolysisRecipe"
import {$InputRecipeCache$FluidChemical, $InputRecipeCache$FluidChemical$$Type} from "mekanism.common.recipe.lookup.cache.InputRecipeCache$FluidChemical"
import {$ChemicalChemicalToChemicalRecipe, $ChemicalChemicalToChemicalRecipe$$Type} from "mekanism.api.recipes.ChemicalChemicalToChemicalRecipe"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeTypeDeferredRegister, $RecipeTypeDeferredRegister$$Type} from "mekanism.common.registration.impl.RecipeTypeDeferredRegister"
import {$InputRecipeCache$SingleChemical, $InputRecipeCache$SingleChemical$$Type} from "mekanism.common.recipe.lookup.cache.InputRecipeCache$SingleChemical"
import {$SingleChemicalRecipeInput, $SingleChemicalRecipeInput$$Type} from "mekanism.api.recipes.vanilla_input.SingleChemicalRecipeInput"
import {$InputRecipeCache$SingleFluid, $InputRecipeCache$SingleFluid$$Type} from "mekanism.common.recipe.lookup.cache.InputRecipeCache$SingleFluid"
import {$InputRecipeCache$ItemFluidChemical, $InputRecipeCache$ItemFluidChemical$$Type} from "mekanism.common.recipe.lookup.cache.InputRecipeCache$ItemFluidChemical"
import {$IMekanismRecipeTypeProvider, $IMekanismRecipeTypeProvider$$Type} from "mekanism.common.recipe.IMekanismRecipeTypeProvider"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$RecipeType, $RecipeType$$Type} from "net.minecraft.world.item.crafting.RecipeType"
import {$ItemStackChemicalToItemStackRecipe, $ItemStackChemicalToItemStackRecipe$$Type} from "mekanism.api.recipes.ItemStackChemicalToItemStackRecipe"
import {$InputRecipeCache$EitherSideChemical, $InputRecipeCache$EitherSideChemical$$Type} from "mekanism.common.recipe.lookup.cache.InputRecipeCache$EitherSideChemical"
import {$ChemicalDissolutionRecipe, $ChemicalDissolutionRecipe$$Type} from "mekanism.api.recipes.ChemicalDissolutionRecipe"
import {$SingleItemChemicalRecipeInput, $SingleItemChemicalRecipeInput$$Type} from "mekanism.api.recipes.vanilla_input.SingleItemChemicalRecipeInput"
import {$Recipe, $Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"
import {$ChemicalToChemicalRecipe, $ChemicalToChemicalRecipe$$Type} from "mekanism.api.recipes.ChemicalToChemicalRecipe"

export class $MekanismRecipeType<VANILLA_INPUT extends $RecipeInput, RECIPE extends $MekanismRecipe<(VANILLA_INPUT)>, INPUT_CACHE extends $IInputRecipeCache> implements $RecipeType<(RECIPE)>, $IMekanismRecipeTypeProvider<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)> {
static readonly "RECIPE_TYPES": $RecipeTypeDeferredRegister
static readonly "CRUSHING": $RecipeTypeRegistryObject<($SingleRecipeInput), ($ItemStackToItemStackRecipe), ($InputRecipeCache$SingleItem<($ItemStackToItemStackRecipe)>)>
static readonly "ENRICHING": $RecipeTypeRegistryObject<($SingleRecipeInput), ($ItemStackToItemStackRecipe), ($InputRecipeCache$SingleItem<($ItemStackToItemStackRecipe)>)>
static readonly "SMELTING": $RecipeTypeRegistryObject<($SingleRecipeInput), ($ItemStackToItemStackRecipe), ($InputRecipeCache$SingleItem<($ItemStackToItemStackRecipe)>)>
static readonly "CHEMICAL_INFUSING": $RecipeTypeRegistryObject<($BiChemicalRecipeInput), ($ChemicalChemicalToChemicalRecipe), ($InputRecipeCache$EitherSideChemical<($ChemicalChemicalToChemicalRecipe)>)>
static readonly "COMBINING": $RecipeTypeRegistryObject<($RecipeInput), ($CombinerRecipe), ($InputRecipeCache$DoubleItem<($CombinerRecipe)>)>
static readonly "SEPARATING": $RecipeTypeRegistryObject<($SingleFluidRecipeInput), ($ElectrolysisRecipe), ($InputRecipeCache$SingleFluid<($ElectrolysisRecipe)>)>
static readonly "WASHING": $RecipeTypeRegistryObject<($SingleFluidChemicalRecipeInput), ($FluidChemicalToChemicalRecipe), ($InputRecipeCache$FluidChemical<($FluidChemicalToChemicalRecipe)>)>
static readonly "EVAPORATING": $RecipeTypeRegistryObject<($SingleFluidRecipeInput), ($FluidToFluidRecipe), ($InputRecipeCache$SingleFluid<($FluidToFluidRecipe)>)>
static readonly "ACTIVATING": $RecipeTypeRegistryObject<($SingleChemicalRecipeInput), ($ChemicalToChemicalRecipe), ($InputRecipeCache$SingleChemical<($ChemicalToChemicalRecipe)>)>
static readonly "CENTRIFUGING": $RecipeTypeRegistryObject<($SingleChemicalRecipeInput), ($ChemicalToChemicalRecipe), ($InputRecipeCache$SingleChemical<($ChemicalToChemicalRecipe)>)>
static readonly "CRYSTALLIZING": $RecipeTypeRegistryObject<($SingleChemicalRecipeInput), ($ChemicalCrystallizerRecipe), ($InputRecipeCache$SingleChemical<($ChemicalCrystallizerRecipe)>)>
static readonly "DISSOLUTION": $RecipeTypeRegistryObject<($SingleItemChemicalRecipeInput), ($ChemicalDissolutionRecipe), ($InputRecipeCache$ItemChemical<($ChemicalDissolutionRecipe)>)>
static readonly "COMPRESSING": $RecipeTypeRegistryObject<($SingleItemChemicalRecipeInput), ($ItemStackChemicalToItemStackRecipe), ($InputRecipeCache$ItemChemical<($ItemStackChemicalToItemStackRecipe)>)>
static readonly "PURIFYING": $RecipeTypeRegistryObject<($SingleItemChemicalRecipeInput), ($ItemStackChemicalToItemStackRecipe), ($InputRecipeCache$ItemChemical<($ItemStackChemicalToItemStackRecipe)>)>
static readonly "INJECTING": $RecipeTypeRegistryObject<($SingleItemChemicalRecipeInput), ($ItemStackChemicalToItemStackRecipe), ($InputRecipeCache$ItemChemical<($ItemStackChemicalToItemStackRecipe)>)>
static readonly "NUCLEOSYNTHESIZING": $RecipeTypeRegistryObject<($SingleItemChemicalRecipeInput), ($NucleosynthesizingRecipe), ($InputRecipeCache$ItemChemical<($NucleosynthesizingRecipe)>)>
static readonly "ENERGY_CONVERSION": $RecipeTypeRegistryObject<($SingleRecipeInput), ($ItemStackToEnergyRecipe), ($InputRecipeCache$SingleItem<($ItemStackToEnergyRecipe)>)>
static readonly "CHEMICAL_CONVERSION": $RecipeTypeRegistryObject<($SingleRecipeInput), ($ItemStackToChemicalRecipe), ($InputRecipeCache$SingleItem<($ItemStackToChemicalRecipe)>)>
static readonly "OXIDIZING": $RecipeTypeRegistryObject<($SingleRecipeInput), ($ItemStackToChemicalRecipe), ($InputRecipeCache$SingleItem<($ItemStackToChemicalRecipe)>)>
static readonly "PIGMENT_EXTRACTING": $RecipeTypeRegistryObject<($SingleRecipeInput), ($ItemStackToChemicalRecipe), ($InputRecipeCache$SingleItem<($ItemStackToChemicalRecipe)>)>
static readonly "PIGMENT_MIXING": $RecipeTypeRegistryObject<($BiChemicalRecipeInput), ($ChemicalChemicalToChemicalRecipe), ($InputRecipeCache$EitherSideChemical<($ChemicalChemicalToChemicalRecipe)>)>
static readonly "METALLURGIC_INFUSING": $RecipeTypeRegistryObject<($SingleItemChemicalRecipeInput), ($ItemStackChemicalToItemStackRecipe), ($InputRecipeCache$ItemChemical<($ItemStackChemicalToItemStackRecipe)>)>
static readonly "PAINTING": $RecipeTypeRegistryObject<($SingleItemChemicalRecipeInput), ($ItemStackChemicalToItemStackRecipe), ($InputRecipeCache$ItemChemical<($ItemStackChemicalToItemStackRecipe)>)>
static readonly "REACTION": $RecipeTypeRegistryObject<($ReactionRecipeInput), ($PressurizedReactionRecipe), ($InputRecipeCache$ItemFluidChemical<($PressurizedReactionRecipe)>)>
static readonly "ROTARY": $RecipeTypeRegistryObject<($RotaryRecipeInput), ($RotaryRecipe), ($RotaryInputRecipeCache)>
static readonly "SAWING": $RecipeTypeRegistryObject<($SingleRecipeInput), ($SawmillRecipe), ($InputRecipeCache$SingleItem<($SawmillRecipe)>)>


public "toString"(): string
public static "clearCache"(): void
public static "byKey"(level: $Level$$Type, id: $ResourceLocation$$Type): $Optional<($RecipeHolder<(any)>)>
public static "getRecipeFor"<I extends $RecipeInput, RECIPE_TYPE extends $Recipe<(I)>>(recipeType: $RecipeType$$Type<(RECIPE_TYPE)>, input: I, level: $Level$$Type): $Optional<($RecipeHolder<(RECIPE_TYPE)>)>
public "getRecipes"(world: $Level$$Type): $List<($RecipeHolder<(RECIPE)>)>
public "getRecipes"(recipeManager: $RecipeManager$$Type, world: $Level$$Type): $List<($RecipeHolder<(RECIPE)>)>
public "getRecipeType"(): $MekanismRecipeType<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>
public "getRegistryName"(): $ResourceLocation
public "getInputCache"(): INPUT_CACHE
public static "register"<T extends $Recipe<(any)>>(arg0: string): $RecipeType<(RECIPE)>
public static "simple"<T extends $Recipe<(any)>>(arg0: $ResourceLocation$$Type): $RecipeType<(RECIPE)>
public "stream"(world: $Level$$Type): $Stream<($RecipeHolder<(RECIPE)>)>
public "contains"(world: $Level$$Type, matchCriteria: $Predicate$$Type<(RECIPE)>): boolean
public "findFirst"(world: $Level$$Type, matchCriteria: $Predicate$$Type<(RECIPE)>): RECIPE
get "recipeType"(): $MekanismRecipeType<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>
get "registryName"(): $ResourceLocation
get "inputCache"(): INPUT_CACHE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismRecipeType$$Type<VANILLA_INPUT, RECIPE, INPUT_CACHE> = ($MekanismRecipeType<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismRecipeType_<VANILLA_INPUT, RECIPE, INPUT_CACHE> = $MekanismRecipeType$$Type<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>;
}}
declare module "mekanism.common.tile.transmitter.TileEntityMechanicalPipe" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$TransmitterModelData, $TransmitterModelData$$Type} from "mekanism.client.model.data.TransmitterModelData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IConfigurable, $IConfigurable$$Type} from "mekanism.api.IConfigurable"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TransmitterType, $TransmitterType$$Type} from "mekanism.common.block.states.TransmitterType"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ModelProperty, $ModelProperty$$Type} from "net.neoforged.neoforge.client.model.data.ModelProperty"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$ConnectionType, $ConnectionType$$Type} from "mekanism.common.lib.transmitter.ConnectionType"
import {$Transmitter, $Transmitter$$Type} from "mekanism.common.content.network.transmitter.Transmitter"
import {$TileEntityTransmitter, $TileEntityTransmitter$$Type} from "mekanism.common.tile.transmitter.TileEntityTransmitter"
import {$BoundMethodHolder, $BoundMethodHolder$$Type} from "mekanism.common.integration.computer.BoundMethodHolder"
import {$IComputerTile, $IComputerTile$$Type} from "mekanism.common.integration.computer.IComputerTile"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TileEntityMechanicalPipe extends $TileEntityTransmitter implements $IComputerTile {
static readonly "CONFIGURABLE_PROVIDER": $ICapabilityProvider<($TileEntityTransmitter), ($Direction), ($IConfigurable)>
static readonly "TRANSMITTER_PROPERTY": $ModelProperty<($TransmitterModelData)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "getUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "sideChanged"(side: $Direction$$Type, old: $ConnectionType$$Type, type: $ConnectionType$$Type): void
public "getComputerName"(): string
public "getTransmitter"(): $Transmitter<(any), (any), (any)>
public "redstoneChanged"(powered: boolean): void
public "getTransmitterType"(): $TransmitterType
public "isComputerCapabilityPersistent"(): boolean
public "hasComputerSupport"(): boolean
public "getComputerMethods"(holder: $BoundMethodHolder$$Type): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
get "computerName"(): string
get "transmitter"(): $Transmitter<(any), (any), (any)>
get "transmitterType"(): $TransmitterType
get "computerCapabilityPersistent"(): boolean
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityMechanicalPipe$$Type = ($TileEntityMechanicalPipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityMechanicalPipe_ = $TileEntityMechanicalPipe$$Type;
}}
declare module "mekanism.common.content.blocktype.BlockTypeTile" {
import {$ILangEntry, $ILangEntry$$Type} from "mekanism.api.text.ILangEntry"
import {$TileEntityUpdateable, $TileEntityUpdateable$$Type} from "mekanism.common.tile.base.TileEntityUpdateable"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$$Type} from "mekanism.common.registration.impl.TileEntityTypeRegistryObject"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$BlockType, $BlockType$$Type} from "mekanism.common.content.blocktype.BlockType"

export class $BlockTypeTile<TILE extends $TileEntityUpdateable> extends $BlockType {

constructor(tileEntityRegistrar: $Supplier$$Type<($TileEntityTypeRegistryObject$$Type<(TILE)>)>, description: $ILangEntry$$Type)

public "getTileType"(): $TileEntityTypeRegistryObject<(TILE)>
get "tileType"(): $TileEntityTypeRegistryObject<(TILE)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTypeTile$$Type<TILE> = ($BlockTypeTile<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTypeTile_<TILE> = $BlockTypeTile$$Type<(TILE)>;
}}
declare module "mekanism.common.item.gear.ItemMekaSuitArmor" {
import {$ArmorMaterial, $ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$$Type} from "mekanism.common.registration.impl.CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent, $RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$IJetpackItem$JetpackMode, $IJetpackItem$JetpackMode$$Type} from "mekanism.common.item.interfaces.IJetpackItem$JetpackMode"
import {$ItemAttributeModifiers, $ItemAttributeModifiers$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$List, $List$$Type} from "java.util.List"
import {$ItemAttributeModifierEvent, $ItemAttributeModifierEvent$$Type} from "net.neoforged.neoforge.event.ItemAttributeModifierEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IModuleContainer, $IModuleContainer$$Type} from "mekanism.api.gear.IModuleContainer"
import {$IEventBus, $IEventBus$$Type} from "net.neoforged.bus.api.IEventBus"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ChemicalTankSpec, $ChemicalTankSpec$$Type} from "mekanism.common.capabilities.chemical.item.ChemicalTankSpec"
import {$ItemEnchantments, $ItemEnchantments$$Type} from "net.minecraft.world.item.enchantment.ItemEnchantments"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$FluidTankSpec, $FluidTankSpec$$Type} from "mekanism.common.capabilities.fluid.item.FluidTankSpec"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior, $DispenseItemBehavior$$Type} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HolderLookup$RegistryLookup, $HolderLookup$RegistryLookup$$Type} from "net.minecraft.core.HolderLookup$RegistryLookup"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$IModule, $IModule$$Type} from "mekanism.api.gear.IModule"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$IModuleDataProvider, $IModuleDataProvider$$Type} from "mekanism.api.providers.IModuleDataProvider"
import {$ItemSpecialArmor, $ItemSpecialArmor$$Type} from "mekanism.common.item.gear.ItemSpecialArmor"
import {$EnderMan, $EnderMan$$Type} from "net.minecraft.world.entity.monster.EnderMan"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$Enchantment, $Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$Equipable, $Equipable$$Type} from "net.minecraft.world.item.Equipable"
import {$IAttachmentAware, $IAttachmentAware$$Type} from "mekanism.common.attachments.IAttachmentAware"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ICustomModule, $ICustomModule$$Type} from "mekanism.api.gear.ICustomModule"
import {$IModuleContainerItem, $IModuleContainerItem$$Type} from "mekanism.common.content.gear.IModuleContainerItem"
import {$IJetpackItem, $IJetpackItem$$Type} from "mekanism.common.item.interfaces.IJetpackItem"

export class $ItemMekaSuitArmor extends $ItemSpecialArmor implements $IModuleContainerItem, $IJetpackItem, $CreativeTabDeferredRegister$ICustomCreativeTabContents, $IAttachmentAware {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
readonly "type": $ArmorItem$Type
readonly "material": $Holder<($ArmorMaterial)>
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(armorType: $ArmorItem$Type$$Type, properties: $Item$Properties$$Type)

public "getToughness"(): float
public "onDestroyed"(item: $ItemEntity$$Type, damageSource: $DamageSource$$Type): void
public "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public "getAllEnchantments"(stack: $ItemStack$$Type, lookup: $HolderLookup$RegistryLookup$$Type<($Enchantment$$Type)>): $ItemEnchantments
public "isEnderMask"(stack: $ItemStack$$Type, player: $Player$$Type, enderman: $EnderMan$$Type): boolean
public "isNotReplaceableByPickAction"(stack: $ItemStack$$Type, player: $Player$$Type, inventorySlot: integer): boolean
public "getBarWidth"(stack: $ItemStack$$Type): integer
public "getBarColor"(stack: $ItemStack$$Type): integer
public "isBarVisible"(stack: $ItemStack$$Type): boolean
public "elytraFlightTick"(stack: $ItemStack$$Type, entity: $LivingEntity$$Type, flightTicks: integer): boolean
public "canElytraFly"(stack: $ItemStack$$Type, entity: $LivingEntity$$Type): boolean
public "damageItem"<T extends $LivingEntity>(stack: $ItemStack$$Type, amount: integer, entity: T, onBroken: $Consumer$$Type<($Item)>): integer
public "makesPiglinsNeutral"(stack: $ItemStack$$Type, wearer: $LivingEntity$$Type): boolean
public "canWalkOnPowderedSnow"(stack: $ItemStack$$Type, wearer: $LivingEntity$$Type): boolean
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "getDefense"(): integer
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$$Type, newStack: $ItemStack$$Type, slotChanged: boolean): boolean
public "shouldCauseBlockBreakReset"(oldStack: $ItemStack$$Type, newStack: $ItemStack$$Type): boolean
public "getEnchantmentLevel"(stack: $ItemStack$$Type, enchantment: $Holder$$Type<($Enchantment)>): integer
public "addItems"(tabOutput: $Consumer$$Type<($ItemStack)>): void
public "inventoryTick"(stack: $ItemStack$$Type, level: $Level$$Type, entity: $Entity$$Type, slotId: integer, isSelected: boolean): void
public "attachAttachments"(eventBus: $IEventBus$$Type): void
public "attachCapabilities"(event: $RegisterCapabilitiesEvent$$Type): void
public static "getDamageAbsorbed"(player: $Player$$Type, source: $DamageSource$$Type, amount: float): float
public "useJetpackFuel"(stack: $ItemStack$$Type): void
public "getJetpackThrust"(stack: $ItemStack$$Type): double
public "canUseJetpack"(stack: $ItemStack$$Type): boolean
public "getFluidTankSpecs"(): $List<($FluidTankSpec)>
public "getJetpackMode"(stack: $ItemStack$$Type): $IJetpackItem$JetpackMode
public "getChemicalTankSpecs"(): $List<($ChemicalTankSpec)>
public "getModules"(stack: $ItemStack$$Type): $Collection<($IModule<(any)>)>
public "adjustAttributes"(event: $ItemAttributeModifierEvent$$Type): void
public "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
public "hasModule"(stack: $ItemStack$$Type, type: $IModuleDataProvider$$Type<(any)>): boolean
public "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
public "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
public "isModuleEnabled"(stack: $ItemStack$$Type, type: $IModuleDataProvider$$Type<(any)>): boolean
public "addModuleDetails"(stack: $ItemStack$$Type, tooltip: $List$$Type<($Component$$Type)>): void
public "getEnabledModule"<MODULE extends $ICustomModule<(MODULE)>>(stack: $ItemStack$$Type, typeProvider: $IModuleDataProvider$$Type<(MODULE)>): $IModule<(MODULE)>
public "moduleContainer"(stack: $ItemStack$$Type): $IModuleContainer
public "hasInstalledModules"(stack: $ItemStack$$Type): boolean
public static "getActiveJetpack"(entity: $LivingEntity$$Type): $ItemStack
public static "getPrimaryJetpack"(entity: $LivingEntity$$Type): $ItemStack
public static "getPlayerJetpackMode"<PLAYER extends $Player>(player: PLAYER, mode: $IJetpackItem$JetpackMode$$Type, ascendingCheck: $Predicate$$Type<(PLAYER)>): $IJetpackItem$JetpackMode
public static "handleJetpackMotion"<PLAYER extends $Player>(player: PLAYER, mode: $IJetpackItem$JetpackMode$$Type, thrust: double, ascendingCheck: $Predicate$$Type<(PLAYER)>): boolean
public "addDefault"(): boolean
public static "displayModeChange"(player: $Player$$Type): void
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
public "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void
public static "get"(arg0: $ItemStack$$Type): $Equipable
get "toughness"(): float
get "defense"(): integer
get "fluidTankSpecs"(): $List<($FluidTankSpec)>
get "chemicalTankSpecs"(): $List<($ChemicalTankSpec)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemMekaSuitArmor$$Type = ($ItemMekaSuitArmor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemMekaSuitArmor_ = $ItemMekaSuitArmor$$Type;
}}
declare module "mekanism.common.item.ItemGeigerCounter" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemGeigerCounter extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(props: $Item$Properties$$Type)

public "use"(world: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemGeigerCounter$$Type = ($ItemGeigerCounter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemGeigerCounter_ = $ItemGeigerCounter$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.type.ComponentSensitiveInputCache" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$InputIngredient, $InputIngredient$$Type} from "mekanism.api.recipes.ingredients.InputIngredient"
import {$BaseInputCache, $BaseInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.BaseInputCache"

export class $ComponentSensitiveInputCache<KEY, INPUT, INGREDIENT extends $InputIngredient<(INPUT)>, RECIPE extends $MekanismRecipe<(any)>> extends $BaseInputCache<(KEY), (INPUT), (INGREDIENT), (RECIPE)> {


public "clear"(): void
public "contains"(input: INPUT): boolean
public "getRecipes"(input: INPUT): $Iterable<(RECIPE)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentSensitiveInputCache$$Type<KEY, INPUT, INGREDIENT, RECIPE> = ($ComponentSensitiveInputCache<(KEY), (INPUT), (INGREDIENT), (RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentSensitiveInputCache_<KEY, INPUT, INGREDIENT, RECIPE> = $ComponentSensitiveInputCache$$Type<(KEY), (INPUT), (INGREDIENT), (RECIPE)>;
}}
declare module "mekanism.common.config.value.CachedValue" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$CachedValue$IConfigValueInvalidationListener, $CachedValue$IConfigValueInvalidationListener$$Type} from "mekanism.common.config.value.CachedValue$IConfigValueInvalidationListener"

export class $CachedValue<T> {


public "clearCache"(unloading: boolean): void
public "removeInvalidationListenersMatching"<DATA>(data: DATA, checker: $BiPredicate$$Type<($CachedValue$IConfigValueInvalidationListener), (DATA)>): void
public "addInvalidationListener"(listener: $CachedValue$IConfigValueInvalidationListener$$Type): void
public "hasInvalidationListeners"(): boolean
public "removeInvalidationListener"(listener: $CachedValue$IConfigValueInvalidationListener$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedValue$$Type<T> = ($CachedValue<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedValue_<T> = $CachedValue$$Type<(T)>;
}}
declare module "mekanism.common.lib.math.voxel.VoxelCuboid" {
import {$VoxelPlane, $VoxelPlane$$Type} from "mekanism.common.lib.math.voxel.VoxelPlane"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$VoxelCuboid$CuboidRelative, $VoxelCuboid$CuboidRelative$$Type} from "mekanism.common.lib.math.voxel.VoxelCuboid$CuboidRelative"
import {$IShape, $IShape$$Type} from "mekanism.common.lib.math.voxel.IShape"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AABB, $AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$VoxelCuboid$WallRelative, $VoxelCuboid$WallRelative$$Type} from "mekanism.common.lib.math.voxel.VoxelCuboid$WallRelative"

export class $VoxelCuboid implements $IShape {

constructor(minPos: $BlockPos$$Type, maxPos: $BlockPos$$Type)
constructor(length: integer, height: integer, width: integer)

public "equals"(obj: any): boolean
public "length"(): integer
public "toString"(): string
public "hashCode"(): integer
public static "from"(p1: $VoxelPlane$$Type, p2: $VoxelPlane$$Type, p1Pos: integer, p2Pos: integer): $VoxelCuboid
public "width"(): integer
public "greaterOrEqual"(other: $VoxelCuboid$$Type): boolean
public "height"(): integer
public "isOnCorner"(pos: $BlockPos$$Type): boolean
public "getSide"(pos: $BlockPos$$Type): $Direction
public "getMaxPos"(): $BlockPos
public "getMatches"(pos: $BlockPos$$Type): integer
public "getCenter"(): $BlockPos
public "getRelativeLocation"(pos: $BlockPos$$Type): $VoxelCuboid$CuboidRelative
public "getWallRelative"(pos: $BlockPos$$Type): $VoxelCuboid$WallRelative
public "isOnEdge"(pos: $BlockPos$$Type): boolean
public "getMinPos"(): $BlockPos
public "asAABB"(): $AABB
public "setMinPos"(minPos: $BlockPos$$Type): void
public "setMaxPos"(maxPos: $BlockPos$$Type): void
public "isOnSide"(pos: $BlockPos$$Type): boolean
get "maxPos"(): $BlockPos
get "center"(): $BlockPos
get "minPos"(): $BlockPos
set "minPos"(value: $BlockPos$$Type)
set "maxPos"(value: $BlockPos$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VoxelCuboid$$Type = ($VoxelCuboid);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VoxelCuboid_ = $VoxelCuboid$$Type;
}}
declare module "mekanism.common.advancements.triggers.ConfigurationCardTrigger$TriggerInstance" {
import {$Criterion, $Criterion$$Type} from "net.minecraft.advancements.Criterion"
import {$ContextAwarePredicate, $ContextAwarePredicate$$Type} from "net.minecraft.advancements.critereon.ContextAwarePredicate"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$CriterionValidator, $CriterionValidator$$Type} from "net.minecraft.advancements.critereon.CriterionValidator"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$SimpleCriterionTrigger$SimpleInstance, $SimpleCriterionTrigger$SimpleInstance$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger$SimpleInstance"

export class $ConfigurationCardTrigger$TriggerInstance extends $Record implements $SimpleCriterionTrigger$SimpleInstance {
static readonly "CODEC": $Codec<($ConfigurationCardTrigger$TriggerInstance)>

constructor(player: $Optional$$Type<($ContextAwarePredicate$$Type)>, copy: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "copy"(): boolean
public "player"(): $Optional<($ContextAwarePredicate)>
public static "pasteTrigger"(): $Criterion<($ConfigurationCardTrigger$TriggerInstance)>
public static "copyTrigger"(): $Criterion<($ConfigurationCardTrigger$TriggerInstance)>
public "validate"(arg0: $CriterionValidator$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigurationCardTrigger$TriggerInstance$$Type = ({"copy"?: boolean, "player"?: ($ContextAwarePredicate$$Type)?}) | ([copy?: boolean, player?: ($ContextAwarePredicate$$Type)?]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigurationCardTrigger$TriggerInstance_ = $ConfigurationCardTrigger$TriggerInstance$$Type;
}}
declare module "mekanism.common.capabilities.merged.MergedTank$CurrentType" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $MergedTank$CurrentType extends $Enum<($MergedTank$CurrentType)> {
static readonly "EMPTY": $MergedTank$CurrentType
static readonly "FLUID": $MergedTank$CurrentType
static readonly "CHEMICAL": $MergedTank$CurrentType


public static "values"(): ($MergedTank$CurrentType)[]
public static "valueOf"(name: string): $MergedTank$CurrentType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MergedTank$CurrentType$$Type = (("empty") | ("fluid") | ("chemical"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MergedTank$CurrentType_ = $MergedTank$CurrentType$$Type;
}}
declare module "mekanism.common.integration.computer.MethodData" {
import {$ComputerMethodFactory$ComputerFunctionCaller, $ComputerMethodFactory$ComputerFunctionCaller$$Type} from "mekanism.common.integration.computer.ComputerMethodFactory$ComputerFunctionCaller"
import {$MethodRestriction, $MethodRestriction$$Type} from "mekanism.common.integration.computer.MethodRestriction"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$MethodData$Builder, $MethodData$Builder$$Type} from "mekanism.common.integration.computer.MethodData$Builder"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $MethodData<T> extends $Record {

constructor(name: string, restriction: $MethodRestriction$$Type, requiredMods: (string)[], threadSafe: boolean, argumentNames: (string)[], argClasses: ($Class$$Type<(any)>)[], returnType: $Class$$Type<(any)>, returnExtra: ($Class$$Type<(any)>)[], handler: $ComputerMethodFactory$ComputerFunctionCaller$$Type<(any)>, methodDescription: string, requiresPublicSecurity: boolean)

public "returnType"(): $Class<(any)>
public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "builder"<T>(methodName: string, handler: $ComputerMethodFactory$ComputerFunctionCaller$$Type<(T)>): $MethodData$Builder<(T)>
public "handler"(): $ComputerMethodFactory$ComputerFunctionCaller<(T)>
public "threadSafe"(): boolean
public "supports"(subject: T): boolean
public "methodDescription"(): string
public "restriction"(): $MethodRestriction
public "argClasses"(): ($Class<(any)>)[]
public "requiresPublicSecurity"(): boolean
public "argumentNames"(): (string)[]
public "returnExtra"(): ($Class<(any)>)[]
public "requiredMods"(): (string)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodData$$Type<T> = ({"requiresPublicSecurity"?: boolean, "handler"?: $ComputerMethodFactory$ComputerFunctionCaller$$Type<(never)>, "restriction"?: $MethodRestriction$$Type, "returnType"?: $Class$$Type<(never)>, "requiredMods"?: (string)[], "methodDescription"?: string, "threadSafe"?: boolean, "name"?: string, "returnExtra"?: ($Class$$Type<(never)>)[], "argumentNames"?: (string)[], "argClasses"?: ($Class$$Type<(never)>)[]}) | ([requiresPublicSecurity?: boolean, handler?: $ComputerMethodFactory$ComputerFunctionCaller$$Type<(never)>, restriction?: $MethodRestriction$$Type, returnType?: $Class$$Type<(never)>, requiredMods?: (string)[], methodDescription?: string, threadSafe?: boolean, name?: string, returnExtra?: ($Class$$Type<(never)>)[], argumentNames?: (string)[], argClasses?: ($Class$$Type<(never)>)[]]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodData_<T> = $MethodData$$Type<(T)>;
}}
declare module "mekanism.common.tile.interfaces.ITileUpgradable" {
import {$TileComponentUpgrade, $TileComponentUpgrade$$Type} from "mekanism.common.tile.component.TileComponentUpgrade"
import {$Upgrade$IUpgradeInfoHandler, $Upgrade$IUpgradeInfoHandler$$Type} from "mekanism.api.Upgrade$IUpgradeInfoHandler"
import {$Upgrade, $Upgrade$$Type} from "mekanism.api.Upgrade"
import {$IUpgradeTile, $IUpgradeTile$$Type} from "mekanism.common.tile.interfaces.IUpgradeTile"
import {$List, $List$$Type} from "java.util.List"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $ITileUpgradable extends $IUpgradeTile, $Upgrade$IUpgradeInfoHandler {

 "getInfo"(upgrade: $Upgrade$$Type): $List<($Component)>
 "getSupportedUpgrade"(): $Set<($Upgrade)>
 "getComponent"(): $TileComponentUpgrade
 "recalculateUpgrades"(upgradeType: $Upgrade$$Type): void
 "supportsUpgrade"(upgradeType: $Upgrade$$Type): boolean
 "supportsUpgrades"(): boolean
get "supportedUpgrade"(): $Set<($Upgrade)>
get "component"(): $TileComponentUpgrade
}

export namespace $ITileUpgradable {
const probejs$$marker: never
}
export class $ITileUpgradable$$Static implements $ITileUpgradable {


 "getInfo"(upgrade: $Upgrade$$Type): $List<($Component)>
 "getSupportedUpgrade"(): $Set<($Upgrade)>
 "getComponent"(): $TileComponentUpgrade
 "recalculateUpgrades"(upgradeType: $Upgrade$$Type): void
 "supportsUpgrade"(upgradeType: $Upgrade$$Type): boolean
 "supportsUpgrades"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileUpgradable$$Type = ($ITileUpgradable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileUpgradable_ = $ITileUpgradable$$Type;
}}
declare module "mekanism.common.inventory.container.MekanismContainer" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IInsertableSlot, $IInsertableSlot$$Type} from "mekanism.common.inventory.container.slot.IInsertableSlot"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$MekanismContainer$ISpecificContainerTracker, $MekanismContainer$ISpecificContainerTracker$$Type} from "mekanism.common.inventory.container.MekanismContainer$ISpecificContainerTracker"
import {$SelectedWindowData, $SelectedWindowData$$Type} from "mekanism.common.inventory.container.SelectedWindowData"
import {$InventoryContainerSlot, $InventoryContainerSlot$$Type} from "mekanism.common.inventory.container.slot.InventoryContainerSlot"
import {$Set, $Set$$Type} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MainInventorySlot, $MainInventorySlot$$Type} from "mekanism.common.inventory.container.slot.MainInventorySlot"
import {$ISyncableData, $ISyncableData$$Type} from "mekanism.common.inventory.container.sync.ISyncableData"
import {$ContainerListener, $ContainerListener$$Type} from "net.minecraft.world.inventory.ContainerListener"
import {$HotBarSlot, $HotBarSlot$$Type} from "mekanism.common.inventory.container.slot.HotBarSlot"
import {$ContainerSynchronizer, $ContainerSynchronizer$$Type} from "net.minecraft.world.inventory.ContainerSynchronizer"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$MenuType, $MenuType$$Type} from "net.minecraft.world.inventory.MenuType"
import {$ISecurityContainer, $ISecurityContainer$$Type} from "mekanism.common.inventory.container.ISecurityContainer"

export class $MekanismContainer extends $AbstractContainerMenu implements $ISecurityContainer {
static readonly "BASE_Y_OFFSET": integer
static readonly "TRANSPORTER_CONFIG_WINDOW": integer
static readonly "SIDE_CONFIG_WINDOW": integer
static readonly "UPGRADE_WINDOW": integer
static readonly "SKIN_SELECT_WINDOW": integer
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
 "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
readonly "remoteSlots": $NonNullList<($ItemStack)>
 "remoteCarried": $ItemStack
 "stateId": integer
 "menuType": $MenuType<(any)>
 "containerId": integer
 "quickcraftType": integer
 "quickcraftStatus": integer
readonly "quickcraftSlots": $Set<($Slot)>
readonly "containerListeners": $List<($ContainerListener)>
 "synchronizer": $ContainerSynchronizer


public "removed"(player: $Player$$Type): void
public "getLevel"(): $Level
public "track"(data: $ISyncableData$$Type): void
public "sendAllDataToRemote"(): void
public "broadcastChanges"(): void
public static "insertItem"<SLOT extends ($Slot) & ($IInsertableSlot)>(slots: $List$$Type<(SLOT)>, stack: $ItemStack$$Type, ignoreEmpty: boolean, selectedWindow: $SelectedWindowData$$Type, action: $Action$$Type): $ItemStack
public static "insertItem"<SLOT extends ($Slot) & ($IInsertableSlot)>(slots: $List$$Type<(SLOT)>, stack: $ItemStack$$Type, ignoreEmpty: boolean, checkAll: boolean, selectedWindow: $SelectedWindowData$$Type, action: $Action$$Type): $ItemStack
public static "insertItem"<SLOT extends ($Slot) & ($IInsertableSlot)>(slots: $List$$Type<(SLOT)>, stack: $ItemStack$$Type, selectedWindow: $SelectedWindowData$$Type): $ItemStack
public static "insertItem"<SLOT extends ($Slot) & ($IInsertableSlot)>(slots: $List$$Type<(SLOT)>, stack: $ItemStack$$Type, ignoreEmpty: boolean, selectedWindow: $SelectedWindowData$$Type): $ItemStack
public "quickMoveStack"(player: $Player$$Type, slotID: integer): $ItemStack
public "canTakeItemForPickAll"(stack: $ItemStack$$Type, slot: $Slot$$Type): boolean
public "startTrackingServer"(key: any, tracker: $MekanismContainer$ISpecificContainerTracker$$Type): void
public "getInventoryContainerSlots"(): $List<($InventoryContainerSlot)>
public "getMainInventorySlots"(): $List<($MainInventorySlot)>
public "handleWindowProperty"(property: short, value: $FluidStack$$Type): void
public "handleWindowProperty"(property: short, value: $BlockPos$$Type): void
public "handleWindowProperty"(property: short, value: $ChemicalStack$$Type): void
public "handleWindowProperty"(property: short, value: long): void
public "handleWindowProperty"(property: short, value: byte): void
public "handleWindowProperty"(property: short, value: boolean): void
public "handleWindowProperty"(property: short, value: float): void
public "handleWindowProperty"(property: short, value: double): void
public "handleWindowProperty"(property: short, value: integer): void
public "handleWindowProperty"(property: short, value: $ItemStack$$Type): void
public "handleWindowProperty"(property: short, value: short): void
public "handleWindowProperty"(property: short, value: (byte)[]): void
public static "insertItemCheckAll"<SLOT extends ($Slot) & ($IInsertableSlot)>(slots: $List$$Type<(SLOT)>, stack: $ItemStack$$Type, selectedWindow: $SelectedWindowData$$Type, action: $Action$$Type): $ItemStack
public "getSelectedWindow"(): $SelectedWindowData
public "getSelectedWindow"(player: $UUID$$Type): $SelectedWindowData
public "startTracking"(key: any, tracker: $MekanismContainer$ISpecificContainerTracker$$Type): $List<($ISyncableData)>
public "getHotBarSlots"(): $List<($HotBarSlot)>
public "getPlayerUUID"(): $UUID
public "setSelectedWindow"(selectedWindow: $SelectedWindowData$$Type): void
public "setSelectedWindow"(player: $UUID$$Type, selectedWindow: $SelectedWindowData$$Type): void
public "trackArray"(arrayIn: (byte)[]): void
public "trackArray"(arrayIn: (double)[]): void
public "trackArray"(arrayIn: (boolean)[]): void
public "trackArray"(arrayIn: ((boolean)[])[]): void
public "trackArray"(arrayIn: (short)[]): void
public "trackArray"(arrayIn: (long)[]): void
public "trackArray"(arrayIn: (integer)[]): void
public "trackArray"(arrayIn: (float)[]): void
public "stopTracking"(key: any): void
public "canPlayerAccess"(player: $Player$$Type): boolean
get "level"(): $Level
get "inventoryContainerSlots"(): $List<($InventoryContainerSlot)>
get "mainInventorySlots"(): $List<($MainInventorySlot)>
get "selectedWindow"(): $SelectedWindowData
get "hotBarSlots"(): $List<($HotBarSlot)>
get "playerUUID"(): $UUID
set "selectedWindow"(value: $SelectedWindowData$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismContainer$$Type = ($MekanismContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismContainer_ = $MekanismContainer$$Type;
}}
declare module "mekanism.common.block.states.TransmitterType" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$TransmitterType$Size, $TransmitterType$Size$$Type} from "mekanism.common.block.states.TransmitterType$Size"

export class $TransmitterType extends $Enum<($TransmitterType)> {
static readonly "UNIVERSAL_CABLE": $TransmitterType
static readonly "MECHANICAL_PIPE": $TransmitterType
static readonly "PRESSURIZED_TUBE": $TransmitterType
static readonly "LOGISTICAL_TRANSPORTER": $TransmitterType
static readonly "RESTRICTIVE_TRANSPORTER": $TransmitterType
static readonly "DIVERSION_TRANSPORTER": $TransmitterType
static readonly "THERMODYNAMIC_CONDUCTOR": $TransmitterType


public static "values"(): ($TransmitterType)[]
public static "valueOf"(name: string): $TransmitterType
public "getSize"(): $TransmitterType$Size
get "size"(): $TransmitterType$Size
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransmitterType$$Type = (("universal_cable") | ("mechanical_pipe") | ("pressurized_tube") | ("logistical_transporter") | ("restrictive_transporter") | ("diversion_transporter") | ("thermodynamic_conductor"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransmitterType_ = $TransmitterType$$Type;
}}
declare module "mekanism.common.integration.computer.BoundMethodHolder" {
import {$ListMultimap, $ListMultimap$$Type} from "com.google.common.collect.ListMultimap"
import {$BaseComputerHelper, $BaseComputerHelper$$Type} from "mekanism.common.integration.computer.BaseComputerHelper"
import {$MethodData, $MethodData$$Type} from "mekanism.common.integration.computer.MethodData"
import {$BoundMethodHolder$BoundMethodData, $BoundMethodHolder$BoundMethodData$$Type} from "mekanism.common.integration.computer.BoundMethodHolder$BoundMethodData"
import {$WeakReference, $WeakReference$$Type} from "java.lang.ref.WeakReference"

export class $BoundMethodHolder {


public "register"<T>(method: $MethodData$$Type<(T)>, subject: $WeakReference$$Type<(T)>, isHelpMethod: boolean): void
public static "generateHelp"(methods: $ListMultimap$$Type<(string), ($BoundMethodHolder$BoundMethodData$$Type<(any)>)>, helper: $BaseComputerHelper$$Type): any
public static "generateHelpSpecific"(methods: $ListMultimap$$Type<(string), ($BoundMethodHolder$BoundMethodData$$Type<(any)>)>, helper: $BaseComputerHelper$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoundMethodHolder$$Type = ($BoundMethodHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoundMethodHolder_ = $BoundMethodHolder$$Type;
}}
declare module "mekanism.common.registries.MekanismDamageTypes$MekanismDamageType" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$IHasTranslationKey, $IHasTranslationKey$$Type} from "mekanism.api.text.IHasTranslationKey"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$DamageType, $DamageType$$Type} from "net.minecraft.world.damagesource.DamageType"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $MekanismDamageTypes$MekanismDamageType extends $Record implements $IHasTranslationKey {

constructor(key: $ResourceKey$$Type<(any)>, exhaustion: float)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "source"(registryAccess: $RegistryAccess$$Type, position: $Vec3$$Type): $DamageSource
public "source"(level: $Level$$Type, position: $Vec3$$Type): $DamageSource
public "source"(registryAccess: $RegistryAccess$$Type): $DamageSource
public "source"(level: $Level$$Type): $DamageSource
public "key"(): $ResourceKey<($DamageType)>
public "getTranslationKey"(): string
public "exhaustion"(): float
public "getMsgId"(): string
public "registryName"(): $ResourceLocation
get "translationKey"(): string
get "msgId"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismDamageTypes$MekanismDamageType$$Type = ({"key"?: $ResourceKey$$Type<($DamageType)>, "exhaustion"?: float}) | ([key?: $ResourceKey$$Type<($DamageType)>, exhaustion?: float]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismDamageTypes$MekanismDamageType_ = $MekanismDamageTypes$MekanismDamageType$$Type;
}}
declare module "mekanism.common.inventory.container.SelectedWindowData$WindowType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$List, $List$$Type} from "java.util.List"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$SelectedWindowData$WindowType$ConfigSaveData, $SelectedWindowData$WindowType$ConfigSaveData$$Type} from "mekanism.common.inventory.container.SelectedWindowData$WindowType$ConfigSaveData"

export class $SelectedWindowData$WindowType extends $Enum<($SelectedWindowData$WindowType)> {
static readonly "COLOR": $SelectedWindowData$WindowType
static readonly "CONFIRMATION": $SelectedWindowData$WindowType
static readonly "CRAFTING": $SelectedWindowData$WindowType
static readonly "MEKA_SUIT_HELMET": $SelectedWindowData$WindowType
static readonly "RENAME": $SelectedWindowData$WindowType
static readonly "SKIN_SELECT": $SelectedWindowData$WindowType
static readonly "SIDE_CONFIG": $SelectedWindowData$WindowType
static readonly "TRANSPORTER_CONFIG": $SelectedWindowData$WindowType
static readonly "UPGRADE": $SelectedWindowData$WindowType
static readonly "UNSPECIFIED": $SelectedWindowData$WindowType
static readonly "BY_ID": $IntFunction<($SelectedWindowData$WindowType)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($SelectedWindowData$WindowType)>


public static "values"(): ($SelectedWindowData$WindowType)[]
public static "valueOf"(name: string): $SelectedWindowData$WindowType
public "isValid"(extraData: byte): boolean
public "canPin"(): boolean
public "getSavePaths"(): $List<($SelectedWindowData$WindowType$ConfigSaveData)>
get "savePaths"(): $List<($SelectedWindowData$WindowType$ConfigSaveData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SelectedWindowData$WindowType$$Type = (("color") | ("confirmation") | ("crafting") | ("meka_suit_helmet") | ("rename") | ("skin_select") | ("side_config") | ("transporter_config") | ("upgrade") | ("unspecified"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SelectedWindowData$WindowType_ = $SelectedWindowData$WindowType$$Type;
}}
declare module "mekanism.common.inventory.container.slot.InventoryContainerSlot" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$IInsertableSlot, $IInsertableSlot$$Type} from "mekanism.common.inventory.container.slot.IInsertableSlot"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$SlotOverlay, $SlotOverlay$$Type} from "mekanism.common.inventory.container.slot.SlotOverlay"
import {$SelectedWindowData, $SelectedWindowData$$Type} from "mekanism.common.inventory.container.SelectedWindowData"
import {$ContainerSlotType, $ContainerSlotType$$Type} from "mekanism.common.inventory.container.slot.ContainerSlotType"
import {$BasicInventorySlot, $BasicInventorySlot$$Type} from "mekanism.common.inventory.slot.BasicInventorySlot"
import {$ISupportsWarning, $ISupportsWarning$$Type} from "mekanism.common.inventory.warning.ISupportsWarning"

export class $InventoryContainerSlot extends $Slot implements $IInsertableSlot {
readonly "slot": integer
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer
 "animationProgress": float

constructor(slot: $BasicInventorySlot$$Type, x: integer, y: integer, slotType: $ContainerSlotType$$Type, slotOverlay: $SlotOverlay$$Type, warningAdder: $Consumer$$Type<($ISupportsWarning<(any)>)>, uncheckedSetter: $Consumer$$Type<($ItemStack)>)

public "remove"(amount: integer): $ItemStack
public "set"(stack: $ItemStack$$Type): void
public "getItem"(): $ItemStack
public "hasItem"(): boolean
public "getMaxStackSize"(stack: $ItemStack$$Type): integer
public "getMaxStackSize"(): integer
public "getSlotType"(): $ContainerSlotType
public "tryRemove"(count: integer, decrement: integer, player: $Player$$Type): $Optional<($ItemStack)>
public "setChanged"(): void
public "insertItem"(stack: $ItemStack$$Type, action: $Action$$Type): $ItemStack
public "mayPlace"(stack: $ItemStack$$Type): boolean
public "mayPickup"(player: $Player$$Type): boolean
public "addWarnings"(slot: $ISupportsWarning$$Type<(any)>): void
public "getInventorySlot"(): $IInventorySlot
public "getSlotOverlay"(): $SlotOverlay
public "exists"(windowData: $SelectedWindowData$$Type): boolean
public "canMergeWith"(stack: $ItemStack$$Type): boolean
get "item"(): $ItemStack
get "maxStackSize"(): integer
get "slotType"(): $ContainerSlotType
get "inventorySlot"(): $IInventorySlot
get "slotOverlay"(): $SlotOverlay
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryContainerSlot$$Type = ($InventoryContainerSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryContainerSlot_ = $InventoryContainerSlot$$Type;
}}
declare module "mekanism.common.world.ResizableOreFeatureConfig" {
import {$OreType$OreVeinType, $OreType$OreVeinType$$Type} from "mekanism.common.resource.ore.OreType$OreVeinType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature, $ConfiguredFeature$$Type} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration$TargetBlockState"
import {$FloatSupplier, $FloatSupplier$$Type} from "mekanism.api.functions.FloatSupplier"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$FeatureConfiguration, $FeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$IntSupplier, $IntSupplier$$Type} from "java.util.function.IntSupplier"

export class $ResizableOreFeatureConfig extends $Record implements $FeatureConfiguration {
static readonly "CODEC": $Codec<($ResizableOreFeatureConfig)>

constructor(targetStates: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>, oreVeinType: $OreType$OreVeinType$$Type, size: $IntSupplier$$Type, discardChanceOnAirExposure: $FloatSupplier$$Type)

public "size"(): $IntSupplier
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "discardChanceOnAirExposure"(): $FloatSupplier
public "targetStates"(): $List<($OreConfiguration$TargetBlockState)>
public "oreVeinType"(): $OreType$OreVeinType
public "getFeatures"(): $Stream<($ConfiguredFeature<(any), (any)>)>
get "features"(): $Stream<($ConfiguredFeature<(any), (any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResizableOreFeatureConfig$$Type = ({"discardChanceOnAirExposure"?: $FloatSupplier$$Type, "size"?: $IntSupplier$$Type, "oreVeinType"?: $OreType$OreVeinType$$Type, "targetStates"?: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>}) | ([discardChanceOnAirExposure?: $FloatSupplier$$Type, size?: $IntSupplier$$Type, oreVeinType?: $OreType$OreVeinType$$Type, targetStates?: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResizableOreFeatureConfig_ = $ResizableOreFeatureConfig$$Type;
}}
declare module "mekanism.common.content.qio.IQIODriveHolder" {
import {$QIOFrequency, $QIOFrequency$$Type} from "mekanism.common.content.qio.QIOFrequency"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$IQIOFrequency, $IQIOFrequency$$Type} from "mekanism.api.inventory.qio.IQIOFrequency"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$QIODriveData, $QIODriveData$$Type} from "mekanism.common.content.qio.QIODriveData"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$QIODriveSlot, $QIODriveSlot$$Type} from "mekanism.common.inventory.slot.QIODriveSlot"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$$Type} from "mekanism.common.lib.frequency.Frequency$FrequencyIdentity"
import {$TileComponentFrequency, $TileComponentFrequency$$Type} from "mekanism.common.lib.frequency.TileComponentFrequency"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"
import {$IQIOFrequencyHolder, $IQIOFrequencyHolder$$Type} from "mekanism.common.content.qio.IQIOFrequencyHolder"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"

export interface $IQIODriveHolder extends $IQIOFrequencyHolder {

 "save"(slot: integer, data: $QIODriveData$$Type): void
 "getDriveSlots"(): $List<($QIODriveSlot)>
 "onDataUpdate"(): void
 "getQIOFrequency"(): $IQIOFrequency
 "getPublicFrequencies"(): $List<($QIOFrequency)>
 "getPrivateFrequencies"(): $List<($QIOFrequency)>
 "getFrequency"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): FREQ
 "getPublicCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "removeFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
 "getTrustedCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "getPrivateCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "setFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
 "getFrequencyComponent"(): $TileComponentFrequency
 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
get "driveSlots"(): $List<($QIODriveSlot)>
get "qIOFrequency"(): $IQIOFrequency
get "publicFrequencies"(): $List<($QIOFrequency)>
get "privateFrequencies"(): $List<($QIOFrequency)>
get "frequencyComponent"(): $TileComponentFrequency
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}

export namespace $IQIODriveHolder {
const probejs$$marker: never
}
export class $IQIODriveHolder$$Static implements $IQIODriveHolder {


 "save"(slot: integer, data: $QIODriveData$$Type): void
 "getDriveSlots"(): $List<($QIODriveSlot)>
 "onDataUpdate"(): void
 "getQIOFrequency"(): $IQIOFrequency
 "getPublicFrequencies"(): $List<($QIOFrequency)>
 "getPrivateFrequencies"(): $List<($QIOFrequency)>
 "getFrequency"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): FREQ
 "getPublicCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "removeFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
 "getTrustedCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "getPrivateCache"<FREQ extends $Frequency>(type: $FrequencyType$$Type<(FREQ)>): $List<(FREQ)>
 "setFrequency"(type: $FrequencyType$$Type<(any)>, data: $Frequency$FrequencyIdentity$$Type, player: $UUID$$Type): void
 "getFrequencyComponent"(): $TileComponentFrequency
 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IQIODriveHolder$$Type = ($IQIODriveHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IQIODriveHolder_ = $IQIODriveHolder$$Type;
}}
declare module "mekanism.common.block.interfaces.IHasTileEntity" {
import {$EntityBlock, $EntityBlock$$Type} from "net.minecraft.world.level.block.EntityBlock"
import {$BlockEntityTicker, $BlockEntityTicker$$Type} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$$Type} from "mekanism.common.registration.impl.TileEntityTypeRegistryObject"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$GameEventListener, $GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $IHasTileEntity<TILE extends $BlockEntity> extends $EntityBlock {

 "getTicker"<T extends $BlockEntity>(level: $Level$$Type, state: $BlockState$$Type, blockEntityType: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
 "newBlockEntity"(pos: $BlockPos$$Type, state: $BlockState$$Type): TILE
 "getTileType"(): $TileEntityTypeRegistryObject<(TILE)>
 "triggerBlockEntityEvent"(state: $BlockState$$Type, level: $Level$$Type, pos: $BlockPos$$Type, id: integer, param: integer): boolean
 "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener

(): $TileEntityTypeRegistryObject$$Type<(TILE)>
get "tileType"(): $TileEntityTypeRegistryObject<(TILE)>
}

export namespace $IHasTileEntity {
const probejs$$marker: never
}
export class $IHasTileEntity$$Static<TILE extends $BlockEntity> implements $IHasTileEntity {


 "getTicker"<T extends $BlockEntity>(level: $Level$$Type, state: $BlockState$$Type, blockEntityType: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
 "newBlockEntity"(pos: $BlockPos$$Type, state: $BlockState$$Type): TILE
 "getTileType"(): $TileEntityTypeRegistryObject<(TILE)>
 "triggerBlockEntityEvent"(state: $BlockState$$Type, level: $Level$$Type, pos: $BlockPos$$Type, id: integer, param: integer): boolean
 "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IHasTileEntity$$Type<TILE> = (() => $TileEntityTypeRegistryObject$$Type<(TILE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IHasTileEntity_<TILE> = $IHasTileEntity$$Type<(TILE)>;
}}
declare module "mekanism.common.content.filter.FilterType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$IFilter, $IFilter$$Type} from "mekanism.common.content.filter.IFilter"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $FilterType extends $Enum<($FilterType)> implements $StringRepresentable {
static readonly "MINER_ITEMSTACK_FILTER": $FilterType
static readonly "MINER_MODID_FILTER": $FilterType
static readonly "MINER_TAG_FILTER": $FilterType
static readonly "SORTER_ITEMSTACK_FILTER": $FilterType
static readonly "SORTER_MODID_FILTER": $FilterType
static readonly "SORTER_TAG_FILTER": $FilterType
static readonly "OREDICTIONIFICATOR_ITEM_FILTER": $FilterType
static readonly "QIO_ITEMSTACK_FILTER": $FilterType
static readonly "QIO_MODID_FILTER": $FilterType
static readonly "QIO_TAG_FILTER": $FilterType
static readonly "CODEC": $Codec<($FilterType)>
static readonly "BY_ID": $IntFunction<($FilterType)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($FilterType)>


public static "values"(): ($FilterType)[]
public static "valueOf"(name: string): $FilterType
public "codec"(): $MapCodec<($IFilter<(any)>)>
public "getSerializedName"(): string
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($IFilter<(any)>)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterType$$Type = (("miner_itemstack_filter") | ("miner_modid_filter") | ("miner_tag_filter") | ("sorter_itemstack_filter") | ("sorter_modid_filter") | ("sorter_tag_filter") | ("oredictionificator_item_filter") | ("qio_itemstack_filter") | ("qio_modid_filter") | ("qio_tag_filter"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FilterType_ = $FilterType$$Type;
}}
declare module "mekanism.common.advancements.triggers.ViewVibrationsTrigger" {
import {$SimpleCriterionTrigger, $SimpleCriterionTrigger$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$ViewVibrationsTrigger$TriggerInstance, $ViewVibrationsTrigger$TriggerInstance$$Type} from "mekanism.common.advancements.triggers.ViewVibrationsTrigger$TriggerInstance"

export class $ViewVibrationsTrigger extends $SimpleCriterionTrigger<($ViewVibrationsTrigger$TriggerInstance)> {

constructor()

public "trigger"(player: $ServerPlayer$$Type): void
public "codec"(): $Codec<($ViewVibrationsTrigger$TriggerInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ViewVibrationsTrigger$$Type = ($ViewVibrationsTrigger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ViewVibrationsTrigger_ = $ViewVibrationsTrigger$$Type;
}}
declare module "mekanism.common.lib.transmitter.CompatibleTransmitterValidator" {
import {$Transmitter, $Transmitter$$Type} from "mekanism.common.content.network.transmitter.Transmitter"
import {$DynamicNetwork, $DynamicNetwork$$Type} from "mekanism.common.lib.transmitter.DynamicNetwork"

export class $CompatibleTransmitterValidator<ACCEPTOR, NETWORK extends $DynamicNetwork<(ACCEPTOR), (NETWORK), (TRANSMITTER)>, TRANSMITTER extends $Transmitter<(ACCEPTOR), (NETWORK), (TRANSMITTER)>> {

constructor()

public "isNetworkCompatible"(net: NETWORK): boolean
public "isTransmitterCompatible"(transmitter: $Transmitter$$Type<(any), (any), (any)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompatibleTransmitterValidator$$Type<ACCEPTOR, NETWORK, TRANSMITTER> = ($CompatibleTransmitterValidator<(ACCEPTOR), (NETWORK), (TRANSMITTER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompatibleTransmitterValidator_<ACCEPTOR, NETWORK, TRANSMITTER> = $CompatibleTransmitterValidator$$Type<(ACCEPTOR), (NETWORK), (TRANSMITTER)>;
}}
declare module "mekanism.common.tile.component.config.DataType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IHasTranslationKey$IHasEnumNameTranslationKey, $IHasTranslationKey$IHasEnumNameTranslationKey$$Type} from "mekanism.api.text.IHasTranslationKey$IHasEnumNameTranslationKey"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$EnumColor, $EnumColor$$Type} from "mekanism.api.text.EnumColor"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$IIncrementalEnum, $IIncrementalEnum$$Type} from "mekanism.api.IIncrementalEnum"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"

export class $DataType extends $Enum<($DataType)> implements $IIncrementalEnum<($DataType)>, $IHasTranslationKey$IHasEnumNameTranslationKey, $StringRepresentable {
static readonly "NONE": $DataType
static readonly "INPUT": $DataType
static readonly "INPUT_1": $DataType
static readonly "INPUT_2": $DataType
static readonly "OUTPUT": $DataType
static readonly "OUTPUT_1": $DataType
static readonly "OUTPUT_2": $DataType
static readonly "INPUT_OUTPUT": $DataType
static readonly "ENERGY": $DataType
static readonly "EXTRA": $DataType
static readonly "CODEC": $Codec<($DataType)>
static readonly "BY_ID": $IntFunction<($DataType)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($DataType)>


public static "values"(): ($DataType)[]
public static "valueOf"(name: string): $DataType
public "canOutput"(): boolean
public "byIndex"(index: integer): $Enum<(any)>
public "getColor"(): $EnumColor
public "getSerializedName"(): string
public "getTranslationKey"(): string
public "ordinal"(): integer
public "adjust"(arg0: integer): $DataType
public "adjust"(arg0: integer, arg1: $Predicate$$Type<($DataType)>): $DataType
public "getNext"(arg0: $Predicate$$Type<($DataType)>): $DataType
public "getNext"(): $DataType
public "getPrevious"(): $DataType
public "getPrevious"(arg0: $Predicate$$Type<($DataType)>): $DataType
public "getTranslatedName"(): $Component
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "color"(): $EnumColor
get "serializedName"(): string
get "translationKey"(): string
get "next"(): $DataType
get "previous"(): $DataType
get "translatedName"(): $Component
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataType$$Type = (("none") | ("input") | ("input_1") | ("input_2") | ("output") | ("output_1") | ("output_2") | ("input_output") | ("energy") | ("extra"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataType_ = $DataType$$Type;
}}
declare module "mekanism.common.inventory.container.SelectedWindowData$WindowPosition" {
import {$Record, $Record$$Type} from "java.lang.Record"

export class $SelectedWindowData$WindowPosition extends $Record {

constructor(x: integer, y: integer, pinned: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "x"(): integer
public "y"(): integer
public "pinned"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SelectedWindowData$WindowPosition$$Type = ({"pinned"?: boolean, "x"?: integer, "y"?: integer}) | ([pinned?: boolean, x?: integer, y?: integer]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SelectedWindowData$WindowPosition_ = $SelectedWindowData$WindowPosition$$Type;
}}
declare module "mekanism.common.tile.interfaces.ITileWrapper" {
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"

export interface $ITileWrapper {

 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}

export namespace $ITileWrapper {
const probejs$$marker: never
}
export class $ITileWrapper$$Static implements $ITileWrapper {


 "getLevel"(): $Level
 "getTileChunk"(): $Chunk3D
 "getTileGlobalPos"(): $GlobalPos
 "getBlockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITileWrapper$$Type = ($ITileWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ITileWrapper_ = $ITileWrapper$$Type;
}}
declare module "mekanism.common.block.prefab.BlockTileGlass" {
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$BlockAndTintGetter, $BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockTileGlass<TILE extends $TileEntityMekanism, TYPE extends $BlockTypeTile<(TILE)>> extends $BlockTile<(TILE), (TYPE)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(type: TYPE)

public "shouldDisplayFluidOverlay"(state: $BlockState$$Type, world: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type, fluidState: $FluidState$$Type): boolean
public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTileGlass$$Type<TILE, TYPE> = ($BlockTileGlass<(TILE), (TYPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTileGlass_<TILE, TYPE> = $BlockTileGlass$$Type<(TILE), (TYPE)>;
}}
declare module "mekanism.common.block.BlockPersonalBarrel" {
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Attribute, $Attribute$$Type} from "mekanism.common.block.attribute.Attribute"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$TileEntityPersonalBarrel, $TileEntityPersonalBarrel$$Type} from "mekanism.common.tile.TileEntityPersonalBarrel"
import {$BlockPersonalStorage, $BlockPersonalStorage$$Type} from "mekanism.common.block.BlockPersonalStorage"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockPersonalBarrel extends $BlockPersonalStorage<($TileEntityPersonalBarrel), ($BlockTypeTile<($TileEntityPersonalBarrel)>)> {
static readonly "PERSONAL_STORAGE_INVENTORY": $Attribute
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor()

public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPersonalBarrel$$Type = ($BlockPersonalBarrel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPersonalBarrel_ = $BlockPersonalBarrel$$Type;
}}
declare module "mekanism.common.tile.interfaces.IFluidContainerManager$ContainerEditMode" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$IIncrementalEnum, $IIncrementalEnum$$Type} from "mekanism.api.IIncrementalEnum"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$IHasTextComponent$IHasEnumNameTextComponent, $IHasTextComponent$IHasEnumNameTextComponent$$Type} from "mekanism.api.text.IHasTextComponent$IHasEnumNameTextComponent"

export class $IFluidContainerManager$ContainerEditMode extends $Enum<($IFluidContainerManager$ContainerEditMode)> implements $IIncrementalEnum<($IFluidContainerManager$ContainerEditMode)>, $IHasTextComponent$IHasEnumNameTextComponent, $StringRepresentable {
static readonly "BOTH": $IFluidContainerManager$ContainerEditMode
static readonly "FILL": $IFluidContainerManager$ContainerEditMode
static readonly "EMPTY": $IFluidContainerManager$ContainerEditMode
static readonly "CODEC": $Codec<($IFluidContainerManager$ContainerEditMode)>
static readonly "BY_ID": $IntFunction<($IFluidContainerManager$ContainerEditMode)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($IFluidContainerManager$ContainerEditMode)>


public static "values"(): ($IFluidContainerManager$ContainerEditMode)[]
public static "valueOf"(name: string): $IFluidContainerManager$ContainerEditMode
public "byIndex"(index: integer): $IFluidContainerManager$ContainerEditMode
public "getSerializedName"(): string
public "getTextComponent"(): $Component
public "ordinal"(): integer
public "adjust"(arg0: integer): $IFluidContainerManager$ContainerEditMode
public "adjust"(arg0: integer, arg1: $Predicate$$Type<($IFluidContainerManager$ContainerEditMode)>): $IFluidContainerManager$ContainerEditMode
public "getNext"(arg0: $Predicate$$Type<($IFluidContainerManager$ContainerEditMode)>): $IFluidContainerManager$ContainerEditMode
public "getNext"(): $IFluidContainerManager$ContainerEditMode
public "getPrevious"(): $IFluidContainerManager$ContainerEditMode
public "getPrevious"(arg0: $Predicate$$Type<($IFluidContainerManager$ContainerEditMode)>): $IFluidContainerManager$ContainerEditMode
public "getTranslatedName"(): $Component
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "textComponent"(): $Component
get "next"(): $IFluidContainerManager$ContainerEditMode
get "previous"(): $IFluidContainerManager$ContainerEditMode
get "translatedName"(): $Component
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IFluidContainerManager$ContainerEditMode$$Type = (("both") | ("fill") | ("empty"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IFluidContainerManager$ContainerEditMode_ = $IFluidContainerManager$ContainerEditMode$$Type;
}}
declare module "mekanism.common.capabilities.chemical.item.ChemicalTankSpec$ComponentTankFromSpecCreator" {
import {$LongSupplier, $LongSupplier$$Type} from "java.util.function.LongSupplier"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ComponentBackedChemicalTank, $ComponentBackedChemicalTank$$Type} from "mekanism.common.attachments.containers.chemical.ComponentBackedChemicalTank"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ChemicalAttributeValidator, $ChemicalAttributeValidator$$Type} from "mekanism.api.chemical.attribute.ChemicalAttributeValidator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Chemical, $Chemical$$Type} from "mekanism.api.chemical.Chemical"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"

export interface $ChemicalTankSpec$ComponentTankFromSpecCreator {

 "create"(attachedTo: $ItemStack$$Type, tankIndex: integer, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, isValid: $Predicate$$Type<($Chemical)>, rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, validator: $ChemicalAttributeValidator$$Type): $ComponentBackedChemicalTank
 "create"(attachedTo: $ItemStack$$Type, tankIndex: integer, rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, isValid: $Predicate$$Type<($Chemical)>): $ComponentBackedChemicalTank

(attachedTo: $ItemStack, tankIndex: integer, canExtract: $BiPredicate<($Chemical), ($AutomationType)>, canInsert: $BiPredicate<($Chemical), ($AutomationType)>, isValid: $Predicate<($Chemical)>, rate: $LongSupplier, capacity: $LongSupplier, validator: $ChemicalAttributeValidator): $ComponentBackedChemicalTank$$Type
}

export namespace $ChemicalTankSpec$ComponentTankFromSpecCreator {
const probejs$$marker: never
}
export class $ChemicalTankSpec$ComponentTankFromSpecCreator$$Static implements $ChemicalTankSpec$ComponentTankFromSpecCreator {


 "create"(attachedTo: $ItemStack$$Type, tankIndex: integer, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, isValid: $Predicate$$Type<($Chemical)>, rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, validator: $ChemicalAttributeValidator$$Type): $ComponentBackedChemicalTank
 "create"(attachedTo: $ItemStack$$Type, tankIndex: integer, rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, canExtract: $BiPredicate$$Type<($Chemical), ($AutomationType)>, canInsert: $BiPredicate$$Type<($Chemical), ($AutomationType)>, isValid: $Predicate$$Type<($Chemical)>): $ComponentBackedChemicalTank
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalTankSpec$ComponentTankFromSpecCreator$$Type = ((attachedTo: $ItemStack, tankIndex: integer, canExtract: $BiPredicate<($Chemical), ($AutomationType)>, canInsert: $BiPredicate<($Chemical), ($AutomationType)>, isValid: $Predicate<($Chemical)>, rate: $LongSupplier, capacity: $LongSupplier, validator: $ChemicalAttributeValidator) => $ComponentBackedChemicalTank$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalTankSpec$ComponentTankFromSpecCreator_ = $ChemicalTankSpec$ComponentTankFromSpecCreator$$Type;
}}
declare module "mekanism.common.tile.factory.TileEntityFactory" {
import {$FactoryType, $FactoryType$$Type} from "mekanism.common.content.blocktype.FactoryType"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$MachineEnergyContainer, $MachineEnergyContainer$$Type} from "mekanism.common.capabilities.energy.MachineEnergyContainer"
import {$CachedRecipe$OperationTracker$RecipeError, $CachedRecipe$OperationTracker$RecipeError$$Type} from "mekanism.api.recipes.cache.CachedRecipe$OperationTracker$RecipeError"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$IUpgradeData, $IUpgradeData$$Type} from "mekanism.common.upgrade.IUpgradeData"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$TileComponentConfig, $TileComponentConfig$$Type} from "mekanism.common.tile.component.TileComponentConfig"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IRecipeViewerRecipeType, $IRecipeViewerRecipeType$$Type} from "mekanism.client.recipe_viewer.type.IRecipeViewerRecipeType"
import {$TileComponentEjector, $TileComponentEjector$$Type} from "mekanism.common.tile.component.TileComponentEjector"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$FactoryRecipeAccessor, $FactoryRecipeAccessor$$Type} from "moe.wolfgirl.powerfuljs.mixin.mekanism.FactoryRecipeAccessor"
import {$IMekanismRecipeTypeProvider, $IMekanismRecipeTypeProvider$$Type} from "mekanism.common.recipe.IMekanismRecipeTypeProvider"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$BooleanSupplier, $BooleanSupplier$$Type} from "java.util.function.BooleanSupplier"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$FactoryRecipeCacheLookupMonitor, $FactoryRecipeCacheLookupMonitor$$Type} from "mekanism.common.recipe.lookup.monitor.FactoryRecipeCacheLookupMonitor"
import {$Upgrade, $Upgrade$$Type} from "mekanism.api.Upgrade"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$IRecipeLookupHandler, $IRecipeLookupHandler$$Type} from "mekanism.common.recipe.lookup.IRecipeLookupHandler"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$CachedRecipe, $CachedRecipe$$Type} from "mekanism.api.recipes.cache.CachedRecipe"
import {$TileEntityConfigurableMachine, $TileEntityConfigurableMachine$$Type} from "mekanism.common.tile.prefab.TileEntityConfigurableMachine"
import {$FactoryTier, $FactoryTier$$Type} from "mekanism.common.tier.FactoryTier"

export class $TileEntityFactory<RECIPE extends $MekanismRecipe<(any)>> extends $TileEntityConfigurableMachine implements $IRecipeLookupHandler<(RECIPE)>, $FactoryRecipeAccessor<(any)> {
 "tier": $FactoryTier
readonly "progress": (integer)[]
 "ejectorComponent": $TileComponentEjector
readonly "configComponent": $TileComponentConfig
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string


public "getInfo"(upgrade: $Upgrade$$Type): $List<($Component)>
public "getProgress"(cacheIndex: integer): integer
public "saveAdditional"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "loadAdditional"(nbt: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "readSustainedData"(provider: $HolderLookup$Provider$$Type, data: $CompoundTag$$Type): void
public "writeSustainedData"(provider: $HolderLookup$Provider$$Type, data: $CompoundTag$$Type): void
public "recalculateUpgrades"(upgrade: $Upgrade$$Type): void
public "addContainerTrackers"(container: $MekanismContainer$$Type): void
public "getScaledProgress"(i: integer, process: integer): double
public "isConfigurationDataCompatible"(blockType: $Block$$Type): boolean
public "getEnergyContainer"(): $MachineEnergyContainer<($TileEntityFactory<(any)>)>
public "getWarningCheck"(error: $CachedRecipe$OperationTracker$RecipeError$$Type, processIndex: integer): $BooleanSupplier
public "clearRecipeErrors"(cacheIndex: integer): void
public "getTicksRequired"(): integer
public "getLastUsage"(): long
public "isItemValidForSlot"(stack: $ItemStack$$Type): boolean
public "isValidInputItem"(stack: $ItemStack$$Type): boolean
public "toggleSorting"(): void
public "getFactoryType"(): $FactoryType
public "getSavedOperatingTicks"(cacheIndex: integer): integer
public "parseUpgradeData"(provider: $HolderLookup$Provider$$Type, upgradeData: $IUpgradeData$$Type): void
public "getRecipeCacheLookupMonitors"(): ($FactoryRecipeCacheLookupMonitor<(any)>)[]
public "isSorting"(): boolean
public "hasSecondaryResourceBar"(): boolean
public "inputProducesOutput"(process: integer, fallbackInput: $ItemStack$$Type, outputSlot: $IInventorySlot$$Type, secondaryOutputSlot: $IInventorySlot$$Type, updateCache: boolean): boolean
public "getLevel"(): $Level
public "getRecipe"(cacheIndex: integer): RECIPE
public "getRecipeType"(): $IMekanismRecipeTypeProvider<(any), (RECIPE), (any)>
public "recipeViewerType"(): $IRecipeViewerRecipeType<(RECIPE)>
public "onCachedRecipeChanged"(cachedRecipe: $CachedRecipe$$Type<(RECIPE)>, cacheIndex: integer): void
public "createNewCachedRecipe"(recipe: RECIPE, cacheIndex: integer): $CachedRecipe<(RECIPE)>
public "onContentsChanged"(): void
public "getDirection"(): $Direction
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "energyContainer"(): $MachineEnergyContainer<($TileEntityFactory<(any)>)>
get "ticksRequired"(): integer
get "lastUsage"(): long
get "factoryType"(): $FactoryType
get "recipeCacheLookupMonitors"(): ($FactoryRecipeCacheLookupMonitor<(any)>)[]
get "sorting"(): boolean
get "level"(): $Level
get "recipeType"(): $IMekanismRecipeTypeProvider<(any), (RECIPE), (any)>
get "direction"(): $Direction
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityFactory$$Type<RECIPE> = ($TileEntityFactory<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityFactory_<RECIPE> = $TileEntityFactory$$Type<(RECIPE)>;
}}
declare module "mekanism.common.tile.TileEntityLogisticalSorter" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$ContainerType, $ContainerType$$Type} from "mekanism.common.attachments.containers.ContainerType"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$EnumColor, $EnumColor$$Type} from "mekanism.api.text.EnumColor"
import {$TransporterPathfinder$Destination, $TransporterPathfinder$Destination$$Type} from "mekanism.common.content.transporter.TransporterPathfinder$Destination"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$TransitRequest$TransitResponse, $TransitRequest$TransitResponse$$Type} from "mekanism.common.lib.inventory.TransitRequest$TransitResponse"
import {$SorterFilter, $SorterFilter$$Type} from "mekanism.common.content.transporter.SorterFilter"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FilterManager, $FilterManager$$Type} from "mekanism.common.content.filter.FilterManager"
import {$IRedstoneControl$RedstoneControl, $IRedstoneControl$RedstoneControl$$Type} from "mekanism.common.tile.interfaces.IRedstoneControl$RedstoneControl"
import {$IAdvancedTransportEjector, $IAdvancedTransportEjector$$Type} from "mekanism.common.lib.inventory.IAdvancedTransportEjector"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ITileFilterHolder, $ITileFilterHolder$$Type} from "mekanism.common.tile.interfaces.ITileFilterHolder"
import {$TransitRequest, $TransitRequest$$Type} from "mekanism.common.lib.inventory.TransitRequest"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$SidedBlockPos, $SidedBlockPos$$Type} from "mekanism.common.lib.SidedBlockPos"

export class $TileEntityLogisticalSorter extends $TileEntityMekanism implements $ITileFilterHolder<($SorterFilter<(any)>)>, $IAdvancedTransportEjector {
 "color": $EnumColor
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(pos: $BlockPos$$Type, state: $BlockState$$Type)

public "saveAdditional"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "loadAdditional"(nbt: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "readSustainedData"(provider: $HolderLookup$Provider$$Type, dataMap: $CompoundTag$$Type): void
public "writeSustainedData"(provider: $HolderLookup$Provider$$Type, dataMap: $CompoundTag$$Type): void
public "changeColor"(color: $EnumColor$$Type): void
public "supportsMode"(mode: $IRedstoneControl$RedstoneControl$$Type): boolean
public "addContainerTrackers"(container: $MekanismContainer$$Type): void
/**
 * 
 * @deprecated
 */
public "removeComponentsFromTag"(tag: $CompoundTag$$Type): void
public "getCurrentRedstoneLevel"(): integer
public "toggleAutoEject"(): void
public "getAutoEject"(): boolean
public "toggleRoundRobin"(): void
public "canSendHome"(stack: $ItemStack$$Type): boolean
public "getRoundRobin"(): boolean
public "toggleSingleItem"(): void
public "getSingleItem"(): boolean
public "persists"(type: $ContainerType$$Type<(any), (any), (any)>): boolean
public "hasConnectedInventory"(): boolean
public "getFilterManager"(): $FilterManager<(any)>
public "getRemapEntries"(): $List<($DataComponentType<(any)>)>
public "getRedstoneLevel"(): integer
public "sendHome"(request: $TransitRequest$$Type): $TransitRequest$TransitResponse
public "setRoundRobinTarget"(target: $SidedBlockPos$$Type): void
public "getRoundRobinTarget"(): $SidedBlockPos
public "setRoundRobinTarget"(destination: $TransporterPathfinder$Destination$$Type): void
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "currentRedstoneLevel"(): integer
get "autoEject"(): boolean
get "roundRobin"(): boolean
get "singleItem"(): boolean
get "filterManager"(): $FilterManager<(any)>
get "remapEntries"(): $List<($DataComponentType<(any)>)>
get "redstoneLevel"(): integer
set "roundRobinTarget"(value: $SidedBlockPos$$Type)
get "roundRobinTarget"(): $SidedBlockPos
set "roundRobinTarget"(value: $TransporterPathfinder$Destination$$Type)
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityLogisticalSorter$$Type = ($TileEntityLogisticalSorter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityLogisticalSorter_ = $TileEntityLogisticalSorter$$Type;
}}
declare module "mekanism.common.inventory.slot.BinInventorySlot" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$BinTier, $BinTier$$Type} from "mekanism.common.tier.BinTier"
import {$ComponentBackedBinInventorySlot, $ComponentBackedBinInventorySlot$$Type} from "mekanism.common.attachments.containers.item.ComponentBackedBinInventorySlot"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$BasicInventorySlot, $BasicInventorySlot$$Type} from "mekanism.common.inventory.slot.BasicInventorySlot"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"

export class $BinInventorySlot extends $BasicInventorySlot {
static readonly "validator": $Predicate<($ItemStack)>
static readonly "alwaysTrue": $Predicate<($ItemStack)>
static readonly "alwaysFalse": $Predicate<($ItemStack)>
static readonly "alwaysTrueBi": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($ItemStack), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($ItemStack), ($AutomationType)>


public static "create"(listener: $IContentsListener$$Type, tier: $BinTier$$Type): $BinInventorySlot
public "isLocked"(): boolean
public "extractItem"(amount: integer, action: $Action$$Type, automationType: $AutomationType$$Type): $ItemStack
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $CompoundTag$$Type): void
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $Tag$$Type): void
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $Tag
public "setLocked"(lock: boolean): boolean
public "setStackSize"(amount: integer, action: $Action$$Type): integer
public "insertItem"(stack: $ItemStack$$Type, action: $Action$$Type, automationType: $AutomationType$$Type): $ItemStack
public "createContainerSlot"(): $Slot
public "getBottomStack"(): $ItemStack
public "getLockStack"(): $ItemStack
public static "getForStack"(stack: $ItemStack$$Type): $ComponentBackedBinInventorySlot
public "getRenderStack"(): $ItemStack
public "setLockStack"(stack: $ItemStack$$Type): void
get "locked"(): boolean
set "locked"(value: boolean)
get "bottomStack"(): $ItemStack
get "lockStack"(): $ItemStack
get "renderStack"(): $ItemStack
set "lockStack"(value: $ItemStack$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinInventorySlot$$Type = ($BinInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinInventorySlot_ = $BinInventorySlot$$Type;
}}
declare module "mekanism.common.tile.component.TileComponentUpgrade" {
import {$ISyncableData, $ISyncableData$$Type} from "mekanism.common.inventory.container.sync.ISyncableData"
import {$UpgradeInventorySlot, $UpgradeInventorySlot$$Type} from "mekanism.common.inventory.slot.UpgradeInventorySlot"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List, $List$$Type} from "java.util.List"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$DataComponentMap$Builder, $DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$TileEntityMekanism, $TileEntityMekanism$$Type} from "mekanism.common.tile.base.TileEntityMekanism"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ITileComponent, $ITileComponent$$Type} from "mekanism.common.tile.component.ITileComponent"
import {$BlockEntity$DataComponentInput, $BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$Upgrade, $Upgrade$$Type} from "mekanism.api.Upgrade"
import {$MekanismContainer$ISpecificContainerTracker, $MekanismContainer$ISpecificContainerTracker$$Type} from "mekanism.common.inventory.container.MekanismContainer$ISpecificContainerTracker"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$Set, $Set$$Type} from "java.util.Set"

export class $TileComponentUpgrade implements $ITileComponent, $MekanismContainer$ISpecificContainerTracker {

constructor(tile: $TileEntityMekanism$$Type)

public "deserialize"(upgradeNBT: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "supports"(upgrade: $Upgrade$$Type): boolean
public "getSupportedTypes"(): $Set<($Upgrade)>
public "serialize"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "addUpgrades"(upgrade: $Upgrade$$Type, maxAvailable: integer): integer
public "removeUpgrade"(upgrade: $Upgrade$$Type, removeAll: boolean): void
public "applyImplicitComponents"(input: $BlockEntity$DataComponentInput$$Type): void
public "collectImplicitComponents"(builder: $DataComponentMap$Builder$$Type): void
public "addToUpdateTag"(updateTag: $CompoundTag$$Type): void
public "readFromUpdateTag"(updateTag: $CompoundTag$$Type): void
public "tickServer"(): void
public "getSpecificSyncableData"(): $List<($ISyncableData)>
public "getUpgradeSlot"(): $UpgradeInventorySlot
public "isUpgradeInstalled"(upgrade: $Upgrade$$Type): boolean
public "getUpgrades"(upgrade: $Upgrade$$Type): integer
public "getComponentKey"(): string
public "getInstalledTypes"(): $Set<($Upgrade)>
public "getUpgradeOutputSlot"(): $UpgradeInventorySlot
public "getScaledUpgradeProgress"(): double
public "write"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "read"(nbtTags: $CompoundTag$$Type, provider: $HolderLookup$Provider$$Type): void
public "removed"(): void
public "invalidate"(): void
public "trackForMainContainer"(container: $MekanismContainer$$Type): void
public "addRemapEntries"(remapEntries: $List$$Type<($DataComponentType$$Type<(any)>)>): void
get "supportedTypes"(): $Set<($Upgrade)>
get "specificSyncableData"(): $List<($ISyncableData)>
get "upgradeSlot"(): $UpgradeInventorySlot
get "componentKey"(): string
get "installedTypes"(): $Set<($Upgrade)>
get "upgradeOutputSlot"(): $UpgradeInventorySlot
get "scaledUpgradeProgress"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileComponentUpgrade$$Type = ($TileComponentUpgrade);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileComponentUpgrade_ = $TileComponentUpgrade$$Type;
}}
declare module "mekanism.common.recipe.lookup.monitor.FactoryRecipeCacheLookupMonitor" {
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$IRecipeLookupHandler, $IRecipeLookupHandler$$Type} from "mekanism.common.recipe.lookup.IRecipeLookupHandler"
import {$RecipeCacheLookupMonitor, $RecipeCacheLookupMonitor$$Type} from "mekanism.common.recipe.lookup.monitor.RecipeCacheLookupMonitor"
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"

export class $FactoryRecipeCacheLookupMonitor<RECIPE extends $MekanismRecipe<(any)>> extends $RecipeCacheLookupMonitor<(RECIPE)> {

constructor(handler: $IRecipeLookupHandler$$Type<(RECIPE)>, cacheIndex: integer, setSortingNeeded: $Runnable$$Type)

public "onChange"(): void
public "updateCachedRecipe"(recipe: RECIPE): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryRecipeCacheLookupMonitor$$Type<RECIPE> = ($FactoryRecipeCacheLookupMonitor<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FactoryRecipeCacheLookupMonitor_<RECIPE> = $FactoryRecipeCacheLookupMonitor$$Type<(RECIPE)>;
}}
declare module "mekanism.common.item.ItemNutritionalPasteBucket" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent, $RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BucketItem, $BucketItem$$Type} from "net.minecraft.world.item.BucketItem"
import {$UseAnim, $UseAnim$$Type} from "net.minecraft.world.item.UseAnim"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ICapabilityAware, $ICapabilityAware$$Type} from "mekanism.common.capabilities.ICapabilityAware"

export class $ItemNutritionalPasteBucket extends $BucketItem implements $ICapabilityAware {
readonly "content": $Fluid
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(fluid: $Fluid$$Type, builder: $Item$Properties$$Type)

public "use"(level: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "finishUsingItem"(stack: $ItemStack$$Type, level: $Level$$Type, entity: $LivingEntity$$Type): $ItemStack
public "getUseAnimation"(stack: $ItemStack$$Type): $UseAnim
public "getUseDuration"(stack: $ItemStack$$Type, entity: $LivingEntity$$Type): integer
public "attachCapabilities"(event: $RegisterCapabilitiesEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemNutritionalPasteBucket$$Type = ($ItemNutritionalPasteBucket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemNutritionalPasteBucket_ = $ItemNutritionalPasteBucket$$Type;
}}
declare module "mekanism.common.lib.security.SecurityFrequency" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$$Type} from "mekanism.common.lib.frequency.Frequency$FrequencyIdentity"
import {$Frequency, $Frequency$$Type} from "mekanism.common.lib.frequency.Frequency"
import {$SecurityMode, $SecurityMode$$Type} from "mekanism.api.security.SecurityMode"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"

export class $SecurityFrequency extends $Frequency {
static readonly "SECURITY": string
static readonly "CODEC": $Codec<($SecurityFrequency)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($SecurityFrequency)>

constructor(uuid: $UUID$$Type, securityMode: $SecurityMode$$Type)

public "isTrusted"(subject: $UUID$$Type): boolean
public "getKey"(): any
public "getIdentity"(): $Frequency$FrequencyIdentity
public "isOverridden"(): boolean
public "setOverridden"(override: boolean): void
public "removeTrusted"(index: integer): $UUID
public "getSyncHash"(): integer
public "addTrusted"(uuid: $UUID$$Type, name: string): void
public "getTrustedUsernameCache"(): $List<(string)>
get "key"(): any
get "identity"(): $Frequency$FrequencyIdentity
get "overridden"(): boolean
set "overridden"(value: boolean)
get "syncHash"(): integer
get "trustedUsernameCache"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SecurityFrequency$$Type = ($SecurityFrequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SecurityFrequency_ = $SecurityFrequency$$Type;
}}
declare module "mekanism.common.attachments.containers.creator.BaseContainerCreator" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$IContainerCreator, $IContainerCreator$$Type} from "mekanism.common.attachments.containers.creator.IContainerCreator"
import {$IBasicContainerCreator, $IBasicContainerCreator$$Type} from "mekanism.common.attachments.containers.creator.IBasicContainerCreator"
import {$ContainerType, $ContainerType$$Type} from "mekanism.common.attachments.containers.ContainerType"
import {$INBTSerializable, $INBTSerializable$$Type} from "net.neoforged.neoforge.common.util.INBTSerializable"
import {$IAttachedContainers, $IAttachedContainers$$Type} from "mekanism.common.attachments.containers.IAttachedContainers"

export class $BaseContainerCreator<ATTACHED extends $IAttachedContainers<(any), (ATTACHED)>, CONTAINER extends $INBTSerializable<($CompoundTag)>> implements $IContainerCreator<(CONTAINER), (ATTACHED)> {

constructor(creators: $List$$Type<($IBasicContainerCreator$$Type<(CONTAINER)>)>)

public "create"(containerType: $ContainerType$$Type<(CONTAINER), (any), (any)>, attachedTo: $ItemStack$$Type, containerIndex: integer): CONTAINER
public "totalContainers"(): integer
public "initStorage"(containers: integer): ATTACHED
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseContainerCreator$$Type<ATTACHED, CONTAINER> = ($BaseContainerCreator<(ATTACHED), (CONTAINER)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseContainerCreator_<ATTACHED, CONTAINER> = $BaseContainerCreator$$Type<(ATTACHED), (CONTAINER)>;
}}
declare module "mekanism.common.lib.math.voxel.VoxelCuboid$CuboidRelative" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $VoxelCuboid$CuboidRelative extends $Enum<($VoxelCuboid$CuboidRelative)> {
static readonly "INSIDE": $VoxelCuboid$CuboidRelative
static readonly "OUTSIDE": $VoxelCuboid$CuboidRelative
static readonly "WALLS": $VoxelCuboid$CuboidRelative


public static "values"(): ($VoxelCuboid$CuboidRelative)[]
public static "valueOf"(name: string): $VoxelCuboid$CuboidRelative
public "isWall"(): boolean
get "wall"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VoxelCuboid$CuboidRelative$$Type = (("inside") | ("outside") | ("walls"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VoxelCuboid$CuboidRelative_ = $VoxelCuboid$CuboidRelative$$Type;
}}
declare module "mekanism.common.network.to_client.container.property.PropertyData" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$PropertyType, $PropertyType$$Type} from "mekanism.common.network.to_client.container.property.PropertyType"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"

export class $PropertyData {
static readonly "GENERIC_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($PropertyData)>


public "getProperty"(): short
public "getType"(): $PropertyType
public "handleWindowProperty"(container: $MekanismContainer$$Type): void
get "property"(): short
get "type"(): $PropertyType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyData$$Type = ($PropertyData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyData_ = $PropertyData$$Type;
}}
declare module "mekanism.common.item.ItemCraftingFormula" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemCraftingFormula extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "getName"(stack: $ItemStack$$Type): $Component
public "use"(world: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "appendHoverText"(itemStack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemCraftingFormula$$Type = ($ItemCraftingFormula);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemCraftingFormula_ = $ItemCraftingFormula$$Type;
}}
declare module "mekanism.common.lib.multiblock.FormationProtocol" {
import {$IMultiblock, $IMultiblock$$Type} from "mekanism.common.lib.multiblock.IMultiblock"
import {$Map, $Map$$Type} from "java.util.Map"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Long2ObjectMap, $Long2ObjectMap$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectMap"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ChunkAccess, $ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$MultiblockCache, $MultiblockCache$$Type} from "mekanism.common.lib.multiblock.MultiblockCache"
import {$Structure, $Structure$$Type} from "mekanism.common.lib.multiblock.Structure"
import {$FormationProtocol$FormationChecker, $FormationProtocol$FormationChecker$$Type} from "mekanism.common.lib.multiblock.FormationProtocol$FormationChecker"
import {$FormationProtocol$FormationResult, $FormationProtocol$FormationResult$$Type} from "mekanism.common.lib.multiblock.FormationProtocol$FormationResult"
import {$IValveHandler$ValveData, $IValveHandler$ValveData$$Type} from "mekanism.common.lib.multiblock.IValveHandler$ValveData"
import {$Set, $Set$$Type} from "java.util.Set"
import {$MultiblockData, $MultiblockData$$Type} from "mekanism.common.lib.multiblock.MultiblockData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $FormationProtocol<T extends $MultiblockData> {
static readonly "MAX_SIZE": integer
readonly "locations": $Set<($BlockPos)>
readonly "internalLocations": $Set<($BlockPos)>
readonly "valves": $Set<($IValveHandler$ValveData)>
readonly "idsFound": $Map<($UUID), ($MultiblockCache<(T)>)>

constructor(tile: $IMultiblock$$Type<(T)>, structure: $Structure$$Type)

public static "explore"<NODE>(level: $Level$$Type, chunkMap: $Long2ObjectMap$$Type<($ChunkAccess$$Type)>, start: $BlockPos$$Type, node: NODE, checker: $FormationProtocol$FormationChecker$$Type<(NODE)>, maxCount: integer): integer
public static "explore"<NODE>(level: $Level$$Type, chunkMap: $Long2ObjectMap$$Type<($ChunkAccess$$Type)>, start: $BlockPos$$Type, node: NODE, checker: $FormationProtocol$FormationChecker$$Type<(NODE)>): integer
public "doUpdate"(): $FormationProtocol$FormationResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FormationProtocol$$Type<T> = ($FormationProtocol<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FormationProtocol_<T> = $FormationProtocol$$Type<(T)>;
}}
declare module "mekanism.common.registration.impl.ItemRegistryObject" {
import {$IMekanismConfig, $IMekanismConfig$$Type} from "mekanism.common.config.IMekanismConfig"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$MekanismDeferredHolder, $MekanismDeferredHolder$$Type} from "mekanism.common.registration.MekanismDeferredHolder"
import {$ContainerType, $ContainerType$$Type} from "mekanism.common.attachments.containers.ContainerType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$INBTSerializable, $INBTSerializable$$Type} from "net.neoforged.neoforge.common.util.INBTSerializable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$IContainerCreator, $IContainerCreator$$Type} from "mekanism.common.attachments.containers.creator.IContainerCreator"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$IItemProvider, $IItemProvider$$Type} from "mekanism.api.providers.IItemProvider"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"

export class $ItemRegistryObject<ITEM extends $Item> extends $MekanismDeferredHolder<($Item), (ITEM)> implements $IItemProvider {

constructor(key: $ResourceKey$$Type<($Item)>)

public "asItem"(): ITEM
public "addAttachmentOnlyContainers"<CONTAINER extends $INBTSerializable<($CompoundTag)>>(containerType: $ContainerType$$Type<(CONTAINER), (any), (any)>, defaultCreator: $Supplier$$Type<($IContainerCreator$$Type<(CONTAINER), (any)>)>): $ItemRegistryObject<(ITEM)>
public "addAttachedContainerCapabilities"<CONTAINER extends $INBTSerializable<($CompoundTag)>>(containerType: $ContainerType$$Type<(CONTAINER), (any), (any)>, defaultCreator: $Supplier$$Type<($IContainerCreator$$Type<(CONTAINER), (any)>)>, ...requiredConfigs: ($IMekanismConfig$$Type)[]): $ItemRegistryObject<(ITEM)>
public "getItemStack"(): $ItemStack
public "getItemStack"(arg0: integer): $ItemStack
public "getTranslationKey"(): string
public "getRegistryName"(): $ResourceLocation
public "getTextComponent"(): $Component
public "getId"(): $ResourceLocation
public static "direct"<T>(arg0: T): $Holder<(T)>
get "itemStack"(): $ItemStack
get "translationKey"(): string
get "registryName"(): $ResourceLocation
get "textComponent"(): $Component
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemRegistryObject$$Type<ITEM> = ($ItemRegistryObject<(ITEM)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemRegistryObject_<ITEM> = $ItemRegistryObject$$Type<(ITEM)>;
}}
declare module "mekanism.common.block.basic.BlockResource" {
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockMekanism, $BlockMekanism$$Type} from "mekanism.common.block.BlockMekanism"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BlockResourceInfo, $BlockResourceInfo$$Type} from "mekanism.common.resource.BlockResourceInfo"

export class $BlockResource extends $BlockMekanism {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(resource: $BlockResourceInfo$$Type)

public "isPortalFrame"(state: $BlockState$$Type, world: $BlockGetter$$Type, pos: $BlockPos$$Type): boolean
public "getResourceInfo"(): $BlockResourceInfo
public "asHolder"(): $Holder<(any)>
get "resourceInfo"(): $BlockResourceInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockResource$$Type = ($BlockResource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockResource_ = $BlockResource$$Type;
}}
declare module "mekanism.common.block.BlockEnergyCube" {
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$TileEntityEnergyCube, $TileEntityEnergyCube$$Type} from "mekanism.common.tile.TileEntityEnergyCube"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$$Type} from "mekanism.common.block.prefab.BlockTile$BlockTileModel"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Machine, $Machine$$Type} from "mekanism.common.content.blocktype.Machine"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockEnergyCube extends $BlockTile$BlockTileModel<($TileEntityEnergyCube), ($Machine<($TileEntityEnergyCube)>)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(type: $Machine$$Type<($TileEntityEnergyCube$$Type)>)

public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEnergyCube$$Type = ($BlockEnergyCube);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEnergyCube_ = $BlockEnergyCube$$Type;
}}
declare module "mekanism.common.item.ItemConfigurator$ConfiguratorMode" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$TransmissionType, $TransmissionType$$Type} from "mekanism.common.lib.transmitter.TransmissionType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$EnumColor, $EnumColor$$Type} from "mekanism.api.text.EnumColor"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$IIncrementalEnum, $IIncrementalEnum$$Type} from "mekanism.api.IIncrementalEnum"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$IRadialMode, $IRadialMode$$Type} from "mekanism.api.radial.mode.IRadialMode"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$IHasTextComponent$IHasEnumNameTextComponent, $IHasTextComponent$IHasEnumNameTextComponent$$Type} from "mekanism.api.text.IHasTextComponent$IHasEnumNameTextComponent"

export class $ItemConfigurator$ConfiguratorMode extends $Enum<($ItemConfigurator$ConfiguratorMode)> implements $IIncrementalEnum<($ItemConfigurator$ConfiguratorMode)>, $IHasTextComponent$IHasEnumNameTextComponent, $IRadialMode, $StringRepresentable {
static readonly "CONFIGURATE_ITEMS": $ItemConfigurator$ConfiguratorMode
static readonly "CONFIGURATE_FLUIDS": $ItemConfigurator$ConfiguratorMode
static readonly "CONFIGURATE_CHEMICALS": $ItemConfigurator$ConfiguratorMode
static readonly "CONFIGURATE_ENERGY": $ItemConfigurator$ConfiguratorMode
static readonly "CONFIGURATE_HEAT": $ItemConfigurator$ConfiguratorMode
static readonly "EMPTY": $ItemConfigurator$ConfiguratorMode
static readonly "ROTATE": $ItemConfigurator$ConfiguratorMode
static readonly "WRENCH": $ItemConfigurator$ConfiguratorMode
static readonly "CODEC": $Codec<($ItemConfigurator$ConfiguratorMode)>
static readonly "BY_ID": $IntFunction<($ItemConfigurator$ConfiguratorMode)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($ItemConfigurator$ConfiguratorMode)>


public static "values"(): ($ItemConfigurator$ConfiguratorMode)[]
public static "valueOf"(name: string): $ItemConfigurator$ConfiguratorMode
public "color"(): $EnumColor
public "icon"(): $ResourceLocation
public "byIndex"(index: integer): $Enum<(any)>
public "isConfigurating"(): boolean
public "sliceName"(): $Component
public "getSerializedName"(): string
public "getTextComponent"(): $Component
public "getTransmission"(): $TransmissionType
public "ordinal"(): integer
public "adjust"(arg0: integer): $ItemConfigurator$ConfiguratorMode
public "adjust"(arg0: integer, arg1: $Predicate$$Type<($ItemConfigurator$ConfiguratorMode)>): $ItemConfigurator$ConfiguratorMode
public "getNext"(arg0: $Predicate$$Type<($ItemConfigurator$ConfiguratorMode)>): $ItemConfigurator$ConfiguratorMode
public "getNext"(): $ItemConfigurator$ConfiguratorMode
public "getPrevious"(): $ItemConfigurator$ConfiguratorMode
public "getPrevious"(arg0: $Predicate$$Type<($ItemConfigurator$ConfiguratorMode)>): $ItemConfigurator$ConfiguratorMode
public "getTranslatedName"(): $Component
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "configurating"(): boolean
get "serializedName"(): string
get "textComponent"(): $Component
get "transmission"(): $TransmissionType
get "next"(): $ItemConfigurator$ConfiguratorMode
get "previous"(): $ItemConfigurator$ConfiguratorMode
get "translatedName"(): $Component
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemConfigurator$ConfiguratorMode$$Type = (("configurate_items") | ("configurate_fluids") | ("configurate_chemicals") | ("configurate_energy") | ("configurate_heat") | ("empty") | ("rotate") | ("wrench"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemConfigurator$ConfiguratorMode_ = $ItemConfigurator$ConfiguratorMode$$Type;
}}
declare module "mekanism.common.resource.ore.OreType$OreVeinType" {
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$OreType, $OreType$$Type} from "mekanism.common.resource.ore.OreType"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $OreType$OreVeinType extends $Record {
static readonly "CODEC": $Codec<($OreType$OreVeinType)>

constructor(type: $OreType$$Type, index: integer)

public "index"(): integer
public "name"(): string
public "type"(): $OreType
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreType$OreVeinType$$Type = ({"type"?: $OreType$$Type, "index"?: integer}) | ([type?: $OreType$$Type, index?: integer]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OreType$OreVeinType_ = $OreType$OreVeinType$$Type;
}}
declare module "mekanism.common.capabilities.chemical.StackedWasteBarrel" {
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ChemicalAttributeValidator, $ChemicalAttributeValidator$$Type} from "mekanism.api.chemical.attribute.ChemicalAttributeValidator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Chemical, $Chemical$$Type} from "mekanism.api.chemical.Chemical"
import {$TileEntityRadioactiveWasteBarrel, $TileEntityRadioactiveWasteBarrel$$Type} from "mekanism.common.tile.TileEntityRadioactiveWasteBarrel"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$VariableCapacityChemicalTank, $VariableCapacityChemicalTank$$Type} from "mekanism.common.capabilities.chemical.VariableCapacityChemicalTank"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"

export class $StackedWasteBarrel extends $VariableCapacityChemicalTank implements $IChemicalHandler, $IChemicalTank {
static readonly "alwaysTrue": $Predicate<($Chemical)>
static readonly "alwaysFalse": $Predicate<($Chemical)>
static readonly "alwaysTrueBi": $BiPredicate<($Chemical), ($AutomationType)>
static readonly "internalOnly": $BiPredicate<($Chemical), ($AutomationType)>
static readonly "notExternal": $BiPredicate<($Chemical), ($AutomationType)>
static readonly "manualOnly": $BiPredicate<($Chemical), ($AutomationType)>


public "insert"(stack: $ChemicalStack$$Type, action: $Action$$Type, automationType: $AutomationType$$Type): $ChemicalStack
public static "create"(tile: $TileEntityRadioactiveWasteBarrel$$Type, listener: $IContentsListener$$Type): $StackedWasteBarrel
public "growStack"(amount: long, action: $Action$$Type): long
public "isValid"(arg0: integer, arg1: $ChemicalStack$$Type): boolean
public "getChemicalTankCapacity"(arg0: integer): long
public "setChemicalInTank"(arg0: integer, arg1: $ChemicalStack$$Type): void
public "insertChemical"(arg0: integer, arg1: $ChemicalStack$$Type, arg2: $Action$$Type): $ChemicalStack
public "insertChemical"(arg0: $ChemicalStack$$Type, arg1: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: integer, arg1: long, arg2: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: long, arg1: $Action$$Type): $ChemicalStack
public "extractChemical"(arg0: $ChemicalStack$$Type, arg1: $Action$$Type): $ChemicalStack
public "getChemicalTanks"(): integer
public "getChemicalInTank"(arg0: integer): $ChemicalStack
public "extract"(arg0: long, arg1: $Action$$Type, arg2: $AutomationType$$Type): $ChemicalStack
public "isEmpty"(): boolean
public "getType"(): $Chemical
public "getStack"(): $ChemicalStack
public "isValid"(arg0: $ChemicalStack$$Type): boolean
public "setStack"(arg0: $ChemicalStack$$Type): void
public "isTypeEqual"(arg0: $ChemicalStack$$Type): boolean
public "isTypeEqual"(arg0: $Chemical$$Type): boolean
public "getCapacity"(): long
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "setStackSize"(arg0: long, arg1: $Action$$Type): long
public "getStored"(): long
public "setStackUnchecked"(arg0: $ChemicalStack$$Type): void
public "getAttributeValidator"(): $ChemicalAttributeValidator
public "onContentsChanged"(): void
get "chemicalTanks"(): integer
get "empty"(): boolean
get "type"(): $Chemical
get "stack"(): $ChemicalStack
set "stack"(value: $ChemicalStack$$Type)
get "capacity"(): long
get "stored"(): long
set "stackUnchecked"(value: $ChemicalStack$$Type)
get "attributeValidator"(): $ChemicalAttributeValidator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StackedWasteBarrel$$Type = ($StackedWasteBarrel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StackedWasteBarrel_ = $StackedWasteBarrel$$Type;
}}
declare module "mekanism.common.tile.component.config.IPersistentConfigInfo" {
import {$DataType, $DataType$$Type} from "mekanism.common.tile.component.config.DataType"
import {$RelativeSide, $RelativeSide$$Type} from "mekanism.api.RelativeSide"

export interface $IPersistentConfigInfo {

 "getDataType"(side: $RelativeSide$$Type): $DataType
 "isEjecting"(): boolean
get "ejecting"(): boolean
}

export namespace $IPersistentConfigInfo {
const probejs$$marker: never
}
export class $IPersistentConfigInfo$$Static implements $IPersistentConfigInfo {


 "getDataType"(side: $RelativeSide$$Type): $DataType
 "isEjecting"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IPersistentConfigInfo$$Type = ($IPersistentConfigInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IPersistentConfigInfo_ = $IPersistentConfigInfo$$Type;
}}
declare module "mekanism.common.lib.multiblock.IValveHandler" {
import {$IMultiblock, $IMultiblock$$Type} from "mekanism.common.lib.multiblock.IMultiblock"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$IValveHandler$ValveData, $IValveHandler$ValveData$$Type} from "mekanism.common.lib.multiblock.IValveHandler$ValveData"

export interface $IValveHandler {

 "triggerValveTransfer"(multiblock: $IMultiblock$$Type<(any)>): void
 "writeValves"(updateTag: $CompoundTag$$Type): void
 "getValveData"(): $Collection<($IValveHandler$ValveData)>
 "readValves"(updateTag: $CompoundTag$$Type): void

(): $Collection$$Type<($IValveHandler$ValveData$$Type)>
get "valveData"(): $Collection<($IValveHandler$ValveData)>
}

export namespace $IValveHandler {
const probejs$$marker: never
}
export class $IValveHandler$$Static implements $IValveHandler {


 "triggerValveTransfer"(multiblock: $IMultiblock$$Type<(any)>): void
 "writeValves"(updateTag: $CompoundTag$$Type): void
 "getValveData"(): $Collection<($IValveHandler$ValveData)>
 "readValves"(updateTag: $CompoundTag$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IValveHandler$$Type = (() => $Collection$$Type<($IValveHandler$ValveData$$Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IValveHandler_ = $IValveHandler$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.RotaryInputRecipeCache" {
import {$RotaryRecipe, $RotaryRecipe$$Type} from "mekanism.api.recipes.RotaryRecipe"
import {$AbstractInputRecipeCache, $AbstractInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.AbstractInputRecipeCache"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MekanismRecipeType, $MekanismRecipeType$$Type} from "mekanism.common.recipe.MekanismRecipeType"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"

export class $RotaryInputRecipeCache extends $AbstractInputRecipeCache<($RotaryRecipe)> {

constructor(recipeType: $MekanismRecipeType$$Type<(any), ($RotaryRecipe$$Type), (any)>)

public "clear"(): void
public "containsInput"(world: $Level$$Type, input: $ChemicalStack$$Type): boolean
public "containsInput"(world: $Level$$Type, input: $FluidStack$$Type): boolean
public "findFirstRecipe"(world: $Level$$Type, input: $FluidStack$$Type): $RotaryRecipe
public "findFirstRecipe"(world: $Level$$Type, input: $ChemicalStack$$Type): $RotaryRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotaryInputRecipeCache$$Type = ($RotaryInputRecipeCache);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RotaryInputRecipeCache_ = $RotaryInputRecipeCache$$Type;
}}
declare module "mekanism.common.capabilities.ICapabilityAware" {
import {$RegisterCapabilitiesEvent, $RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"

export interface $ICapabilityAware {

 "attachCapabilities"(event: $RegisterCapabilitiesEvent$$Type): void

(event: $RegisterCapabilitiesEvent): void
}

export namespace $ICapabilityAware {
const probejs$$marker: never
}
export class $ICapabilityAware$$Static implements $ICapabilityAware {


 "attachCapabilities"(event: $RegisterCapabilitiesEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICapabilityAware$$Type = ((event: $RegisterCapabilitiesEvent) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ICapabilityAware_ = $ICapabilityAware$$Type;
}}
declare module "mekanism.common.registration.impl.CreativeTabDeferredRegister$MekanismCreativeTab" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$CreativeModeTab, $CreativeModeTab$$Type} from "net.minecraft.world.item.CreativeModeTab"
import {$List, $List$$Type} from "java.util.List"

export class $CreativeTabDeferredRegister$MekanismCreativeTab extends $CreativeModeTab {
static readonly "DEFAULT_BACKGROUND": $ResourceLocation
 "backgroundTexture": $ResourceLocation
 "alignedRight": boolean
readonly "tabsBefore": $List<($ResourceLocation)>
readonly "tabsAfter": $List<($ResourceLocation)>


public "getLabelColor"(): integer
get "labelColor"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabDeferredRegister$MekanismCreativeTab$$Type = ($CreativeTabDeferredRegister$MekanismCreativeTab);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabDeferredRegister$MekanismCreativeTab_ = $CreativeTabDeferredRegister$MekanismCreativeTab$$Type;
}}
declare module "mekanism.common.tile.base.CapabilityTileEntity" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$ICapabilityResolver, $ICapabilityResolver$$Type} from "mekanism.common.capabilities.resolver.ICapabilityResolver"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$TileEntityUpdateable, $TileEntityUpdateable$$Type} from "mekanism.common.tile.base.TileEntityUpdateable"
import {$TileEntityTypeRegistryObject, $TileEntityTypeRegistryObject$$Type} from "mekanism.common.registration.impl.TileEntityTypeRegistryObject"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CapabilityTileEntity extends $TileEntityUpdateable {
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(type: $TileEntityTypeRegistryObject$$Type<(any)>, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "clearRemoved"(): void
public "setRemoved"(): void
public "invalidateCapabilitiesFull"(): void
public "invalidateCapabilities"(capabilities: $Collection$$Type<($BlockCapability$$Type<(any), ($Direction$$Type)>)>, side: $Direction$$Type): void
public static "capabilityProvider"<TILE extends $CapabilityTileEntity, CAP>(capability: $BlockCapability$$Type<(CAP), ($Direction$$Type)>, resolverGetter: $BiFunction$$Type<(TILE), ($BlockCapability<(CAP), ($Direction)>), ($ICapabilityResolver$$Type<($Direction$$Type)>)>): $ICapabilityProvider<(TILE), ($Direction), (CAP)>
public static "basicCapabilityProvider"<CAP>(capability: $BlockCapability$$Type<(CAP), ($Direction$$Type)>): $ICapabilityProvider<($CapabilityTileEntity), ($Direction), (CAP)>
public "invalidateCapability"(capability: $BlockCapability$$Type<(any), ($Direction$$Type)>, side: $Direction$$Type): void
public "invalidateCapabilityAll"(capability: $BlockCapability$$Type<(any), ($Direction$$Type)>): void
public "invalidateCapabilitiesAll"(capabilities: $Collection$$Type<($BlockCapability$$Type<(any), ($Direction$$Type)>)>): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CapabilityTileEntity$$Type = ($CapabilityTileEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CapabilityTileEntity_ = $CapabilityTileEntity$$Type;
}}
declare module "mekanism.common.advancements.triggers.ChangeRobitSkinTrigger" {
import {$SimpleCriterionTrigger, $SimpleCriterionTrigger$$Type} from "net.minecraft.advancements.critereon.SimpleCriterionTrigger"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$ChangeRobitSkinTrigger$TriggerInstance, $ChangeRobitSkinTrigger$TriggerInstance$$Type} from "mekanism.common.advancements.triggers.ChangeRobitSkinTrigger$TriggerInstance"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$RobitSkin, $RobitSkin$$Type} from "mekanism.api.robit.RobitSkin"

export class $ChangeRobitSkinTrigger extends $SimpleCriterionTrigger<($ChangeRobitSkinTrigger$TriggerInstance)> {

constructor()

public "trigger"(player: $ServerPlayer$$Type, skin: $ResourceKey$$Type<($RobitSkin)>): void
public "codec"(): $Codec<($ChangeRobitSkinTrigger$TriggerInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChangeRobitSkinTrigger$$Type = ($ChangeRobitSkinTrigger);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChangeRobitSkinTrigger_ = $ChangeRobitSkinTrigger$$Type;
}}
declare module "mekanism.common.block.attribute.Attribute" {
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$BaseTier, $BaseTier$$Type} from "mekanism.api.tier.BaseTier"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $Attribute {

 "adjustProperties"(props: $BlockBehaviour$Properties$$Type): void
}

export namespace $Attribute {
function get<ATTRIBUTE extends $Attribute>(state: $BlockState$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
function get<ATTRIBUTE extends $Attribute>(block: $Block$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
function matches<ATTRIBUTE extends $Attribute>(block: $Block$$Type, type: $Class$$Type<(ATTRIBUTE)>, checker: $Predicate$$Type<(ATTRIBUTE)>): boolean
function isActive(state: $BlockState$$Type): boolean
function ifPresent<ATTRIBUTE extends $Attribute>(block: $Block$$Type, type: $Class$$Type<(ATTRIBUTE)>, action: $Consumer$$Type<(ATTRIBUTE)>): void
function getAll(block: $Block$$Type): $Collection<($Attribute)>
function has(state: $BlockState$$Type, type: $Class$$Type<($Attribute$$Type)>): boolean
function has(block: $Block$$Type, type: $Class$$Type<($Attribute$$Type)>): boolean
function getOrThrow<ATTRIBUTE extends $Attribute>(block: $Block$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
function getOrThrow<ATTRIBUTE extends $Attribute>(blockProvider: $IBlockProvider$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
function getOrThrow<ATTRIBUTE extends $Attribute>(state: $BlockState$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
function setActive(state: $BlockState$$Type, active: boolean): $BlockState
function getTier<TIER extends $ITier>(block: $Block$$Type, tierClass: $Class$$Type<(TIER)>): TIER
function getTier<TIER extends $ITier>(blockProvider: $IBlockProvider$$Type, tierClass: $Class$$Type<(TIER)>): TIER
function getFacing(state: $BlockState$$Type): $Direction
function setFacing(state: $BlockState$$Type, facing: $Direction$$Type): $BlockState
function getBaseTier(block: $Block$$Type): $BaseTier
const probejs$$marker: never
}
export class $Attribute$$Static implements $Attribute {


static "get"<ATTRIBUTE extends $Attribute>(state: $BlockState$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
static "get"<ATTRIBUTE extends $Attribute>(block: $Block$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
static "matches"<ATTRIBUTE extends $Attribute>(block: $Block$$Type, type: $Class$$Type<(ATTRIBUTE)>, checker: $Predicate$$Type<(ATTRIBUTE)>): boolean
static "isActive"(state: $BlockState$$Type): boolean
static "ifPresent"<ATTRIBUTE extends $Attribute>(block: $Block$$Type, type: $Class$$Type<(ATTRIBUTE)>, action: $Consumer$$Type<(ATTRIBUTE)>): void
static "getAll"(block: $Block$$Type): $Collection<($Attribute)>
static "has"(state: $BlockState$$Type, type: $Class$$Type<($Attribute$$Type)>): boolean
static "has"(block: $Block$$Type, type: $Class$$Type<($Attribute$$Type)>): boolean
static "getOrThrow"<ATTRIBUTE extends $Attribute>(block: $Block$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
static "getOrThrow"<ATTRIBUTE extends $Attribute>(blockProvider: $IBlockProvider$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
static "getOrThrow"<ATTRIBUTE extends $Attribute>(state: $BlockState$$Type, type: $Class$$Type<(ATTRIBUTE)>): ATTRIBUTE
static "setActive"(state: $BlockState$$Type, active: boolean): $BlockState
static "getTier"<TIER extends $ITier>(block: $Block$$Type, tierClass: $Class$$Type<(TIER)>): TIER
static "getTier"<TIER extends $ITier>(blockProvider: $IBlockProvider$$Type, tierClass: $Class$$Type<(TIER)>): TIER
 "adjustProperties"(props: $BlockBehaviour$Properties$$Type): void
static "getFacing"(state: $BlockState$$Type): $Direction
static "setFacing"(state: $BlockState$$Type, facing: $Direction$$Type): $BlockState
static "getBaseTier"(block: $Block$$Type): $BaseTier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Attribute$$Type = ($Attribute);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Attribute_ = $Attribute$$Type;
}}
declare module "mekanism.common.item.block.ItemBlockInductionCell" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$TileEntityInductionCell, $TileEntityInductionCell$$Type} from "mekanism.common.tile.multiblock.TileEntityInductionCell"
import {$BlockTypeTile, $BlockTypeTile$$Type} from "mekanism.common.content.blocktype.BlockTypeTile"

export class $ItemBlockInductionCell extends $ItemBlockTooltip<($BlockTile<($TileEntityInductionCell), ($BlockTypeTile<($TileEntityInductionCell)>)>)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockTile$$Type<($TileEntityInductionCell$$Type), ($BlockTypeTile$$Type<($TileEntityInductionCell$$Type)>)>, properties: $Item$Properties$$Type)

public "getTier"(): $ITier
get "tier"(): $ITier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockInductionCell$$Type = ($ItemBlockInductionCell);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockInductionCell_ = $ItemBlockInductionCell$$Type;
}}
declare module "mekanism.common.capabilities.fluid.item.FluidTankSpec$ComponentTankFromSpecCreator" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ComponentBackedFluidTank, $ComponentBackedFluidTank$$Type} from "mekanism.common.attachments.containers.fluid.ComponentBackedFluidTank"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$IntSupplier, $IntSupplier$$Type} from "java.util.function.IntSupplier"

export interface $FluidTankSpec$ComponentTankFromSpecCreator {

 "create"(attachedTo: $ItemStack$$Type, tankIndex: integer, canExtract: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, canInsert: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, isValid: $Predicate$$Type<($FluidStack)>, rate: $IntSupplier$$Type, capacity: $IntSupplier$$Type): $ComponentBackedFluidTank

(attachedTo: $ItemStack, tankIndex: integer, canExtract: $BiPredicate<($FluidStack), ($AutomationType)>, canInsert: $BiPredicate<($FluidStack), ($AutomationType)>, isValid: $Predicate<($FluidStack)>, rate: $IntSupplier, capacity: $IntSupplier): $ComponentBackedFluidTank$$Type
}

export namespace $FluidTankSpec$ComponentTankFromSpecCreator {
const probejs$$marker: never
}
export class $FluidTankSpec$ComponentTankFromSpecCreator$$Static implements $FluidTankSpec$ComponentTankFromSpecCreator {


 "create"(attachedTo: $ItemStack$$Type, tankIndex: integer, canExtract: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, canInsert: $BiPredicate$$Type<($FluidStack), ($AutomationType)>, isValid: $Predicate$$Type<($FluidStack)>, rate: $IntSupplier$$Type, capacity: $IntSupplier$$Type): $ComponentBackedFluidTank
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankSpec$ComponentTankFromSpecCreator$$Type = ((attachedTo: $ItemStack, tankIndex: integer, canExtract: $BiPredicate<($FluidStack), ($AutomationType)>, canInsert: $BiPredicate<($FluidStack), ($AutomationType)>, isValid: $Predicate<($FluidStack)>, rate: $IntSupplier, capacity: $IntSupplier) => $ComponentBackedFluidTank$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTankSpec$ComponentTankFromSpecCreator_ = $FluidTankSpec$ComponentTankFromSpecCreator$$Type;
}}
declare module "mekanism.common.attachments.qio.DriveMetadata" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$QIODriveData, $QIODriveData$$Type} from "mekanism.common.content.qio.QIODriveData"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $DriveMetadata extends $Record {
static readonly "EMPTY": $DriveMetadata
static readonly "CODEC": $Codec<($DriveMetadata)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($DriveMetadata)>

constructor(data: $QIODriveData$$Type)
constructor(count: long, types: integer)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "count"(): long
public "types"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DriveMetadata$$Type = ({"count"?: long, "types"?: integer}) | ([count?: long, types?: integer]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DriveMetadata_ = $DriveMetadata$$Type;
}}
declare module "mekanism.common.tile.TileEntityChemicalTank" {
import {$ChemicalTankUpgradeData, $ChemicalTankUpgradeData$$Type} from "mekanism.common.upgrade.ChemicalTankUpgradeData"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$IUpgradeData, $IUpgradeData$$Type} from "mekanism.common.upgrade.IUpgradeData"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$TileComponentConfig, $TileComponentConfig$$Type} from "mekanism.common.tile.component.TileComponentConfig"
import {$TileEntityChemicalTank$GasMode, $TileEntityChemicalTank$GasMode$$Type} from "mekanism.common.tile.TileEntityChemicalTank$GasMode"
import {$GlobalPos, $GlobalPos$$Type} from "net.minecraft.core.GlobalPos"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$MekanismContainer, $MekanismContainer$$Type} from "mekanism.common.inventory.container.MekanismContainer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IFluidHandler, $IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$Chunk3D, $Chunk3D$$Type} from "mekanism.api.Chunk3D"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IChemicalTankHolder, $IChemicalTankHolder$$Type} from "mekanism.common.capabilities.holder.chemical.IChemicalTankHolder"
import {$TileComponentEjector, $TileComponentEjector$$Type} from "mekanism.common.tile.component.TileComponentEjector"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IChemicalHandler, $IChemicalHandler$$Type} from "mekanism.api.chemical.IChemicalHandler"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IHasGasMode, $IHasGasMode$$Type} from "mekanism.common.tile.interfaces.IHasGasMode"
import {$IHeatHandler, $IHeatHandler$$Type} from "mekanism.api.heat.IHeatHandler"
import {$IBlockProvider, $IBlockProvider$$Type} from "mekanism.api.providers.IBlockProvider"
import {$ICapabilityProvider, $ICapabilityProvider$$Type} from "net.neoforged.neoforge.capabilities.ICapabilityProvider"
import {$CapabilityTileEntity, $CapabilityTileEntity$$Type} from "mekanism.common.tile.base.CapabilityTileEntity"
import {$ChemicalTankTier, $ChemicalTankTier$$Type} from "mekanism.common.tier.ChemicalTankTier"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$TileEntityConfigurableMachine, $TileEntityConfigurableMachine$$Type} from "mekanism.common.tile.prefab.TileEntityConfigurableMachine"

export class $TileEntityChemicalTank extends $TileEntityConfigurableMachine implements $IHasGasMode {
 "dumping": $TileEntityChemicalTank$GasMode
 "ejectorComponent": $TileComponentEjector
readonly "configComponent": $TileComponentConfig
readonly "playersUsing": $Set<($Player)>
 "ticker": integer
readonly "facingSupplier": $Supplier<($Direction)>
static readonly "CHEMICAL_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IChemicalHandler)>
static readonly "HEAT_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IHeatHandler)>
static readonly "ITEM_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IItemHandler)>
static readonly "FLUID_HANDLER_PROVIDER": $ICapabilityProvider<($CapabilityTileEntity), ($Direction), ($IFluidHandler)>
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(blockProvider: $IBlockProvider$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

public "getChemicalTank"(): $IChemicalTank
public "readSustainedData"(provider: $HolderLookup$Provider$$Type, data: $CompoundTag$$Type): void
public "writeSustainedData"(provider: $HolderLookup$Provider$$Type, dataMap: $CompoundTag$$Type): void
public "getTier"(): $ChemicalTankTier
public "nextMode"(tank: integer): void
public "shouldDumpRadiation"(): boolean
public "getInitialChemicalTanks"(listener: $IContentsListener$$Type): $IChemicalTankHolder
public "addContainerTrackers"(container: $MekanismContainer$$Type): void
public "getUpgradeData"(provider: $HolderLookup$Provider$$Type): $ChemicalTankUpgradeData
public "parseUpgradeData"(provider: $HolderLookup$Provider$$Type, upgradeData: $IUpgradeData$$Type): void
public "getRedstoneLevel"(): integer
public "getDirection"(): $Direction
public static "calculateRadiationScale"(tanks: $List$$Type<($IChemicalTank$$Type)>): float
public "getLevel"(): $Level
public "getTileChunk"(): $Chunk3D
public "getTileGlobalPos"(): $GlobalPos
public "getBlockPos"(): $BlockPos
get "chemicalTank"(): $IChemicalTank
get "tier"(): $ChemicalTankTier
get "redstoneLevel"(): integer
get "direction"(): $Direction
get "level"(): $Level
get "tileChunk"(): $Chunk3D
get "tileGlobalPos"(): $GlobalPos
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TileEntityChemicalTank$$Type = ($TileEntityChemicalTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TileEntityChemicalTank_ = $TileEntityChemicalTank$$Type;
}}
declare module "mekanism.common.item.block.transmitter.ItemBlockMechanicalPipe" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$TileEntityMechanicalPipe, $TileEntityMechanicalPipe$$Type} from "mekanism.common.tile.transmitter.TileEntityMechanicalPipe"
import {$BlockLargeTransmitter, $BlockLargeTransmitter$$Type} from "mekanism.common.block.transmitter.BlockLargeTransmitter"

export class $ItemBlockMechanicalPipe extends $ItemBlockTooltip<($BlockLargeTransmitter<($TileEntityMechanicalPipe)>)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockLargeTransmitter$$Type<($TileEntityMechanicalPipe$$Type)>, properties: $Item$Properties$$Type)

public "getTier"(): $ITier
get "tier"(): $ITier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockMechanicalPipe$$Type = ($ItemBlockMechanicalPipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockMechanicalPipe_ = $ItemBlockMechanicalPipe$$Type;
}}
declare module "mekanism.common.item.interfaces.IJetpackItem" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IJetpackItem$JetpackMode, $IJetpackItem$JetpackMode$$Type} from "mekanism.common.item.interfaces.IJetpackItem$JetpackMode"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export interface $IJetpackItem {

 "useJetpackFuel"(stack: $ItemStack$$Type): void
 "getJetpackThrust"(stack: $ItemStack$$Type): double
 "canUseJetpack"(stack: $ItemStack$$Type): boolean
 "getJetpackMode"(stack: $ItemStack$$Type): $IJetpackItem$JetpackMode
}

export namespace $IJetpackItem {
function getActiveJetpack(entity: $LivingEntity$$Type): $ItemStack
function getPrimaryJetpack(entity: $LivingEntity$$Type): $ItemStack
function getPlayerJetpackMode<PLAYER extends $Player>(player: PLAYER, mode: $IJetpackItem$JetpackMode$$Type, ascendingCheck: $Predicate$$Type<(PLAYER)>): $IJetpackItem$JetpackMode
function handleJetpackMotion<PLAYER extends $Player>(player: PLAYER, mode: $IJetpackItem$JetpackMode$$Type, thrust: double, ascendingCheck: $Predicate$$Type<(PLAYER)>): boolean
const probejs$$marker: never
}
export class $IJetpackItem$$Static implements $IJetpackItem {


static "getActiveJetpack"(entity: $LivingEntity$$Type): $ItemStack
 "useJetpackFuel"(stack: $ItemStack$$Type): void
 "getJetpackThrust"(stack: $ItemStack$$Type): double
 "canUseJetpack"(stack: $ItemStack$$Type): boolean
static "getPrimaryJetpack"(entity: $LivingEntity$$Type): $ItemStack
 "getJetpackMode"(stack: $ItemStack$$Type): $IJetpackItem$JetpackMode
static "getPlayerJetpackMode"<PLAYER extends $Player>(player: PLAYER, mode: $IJetpackItem$JetpackMode$$Type, ascendingCheck: $Predicate$$Type<(PLAYER)>): $IJetpackItem$JetpackMode
static "handleJetpackMotion"<PLAYER extends $Player>(player: PLAYER, mode: $IJetpackItem$JetpackMode$$Type, thrust: double, ascendingCheck: $Predicate$$Type<(PLAYER)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IJetpackItem$$Type = ($IJetpackItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IJetpackItem_ = $IJetpackItem$$Type;
}}
declare module "mekanism.common.attachments.containers.fluid.FluidTanksBuilder" {
import {$ComponentBackedFluidTank, $ComponentBackedFluidTank$$Type} from "mekanism.common.attachments.containers.fluid.ComponentBackedFluidTank"
import {$IMekanismRecipeTypeProvider, $IMekanismRecipeTypeProvider$$Type} from "mekanism.common.recipe.IMekanismRecipeTypeProvider"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IBasicContainerCreator, $IBasicContainerCreator$$Type} from "mekanism.common.attachments.containers.creator.IBasicContainerCreator"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$ContainsRecipe, $ContainsRecipe$$Type} from "mekanism.common.attachments.containers.ContainsRecipe"
import {$IntSupplier, $IntSupplier$$Type} from "java.util.function.IntSupplier"
import {$AttachedFluids, $AttachedFluids$$Type} from "mekanism.common.attachments.containers.fluid.AttachedFluids"
import {$BaseContainerCreator, $BaseContainerCreator$$Type} from "mekanism.common.attachments.containers.creator.BaseContainerCreator"
import {$IInputRecipeCache, $IInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.IInputRecipeCache"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"

export class $FluidTanksBuilder {


public static "builder"(): $FluidTanksBuilder
public "build"(): $BaseContainerCreator<($AttachedFluids), ($ComponentBackedFluidTank)>
public "addBasicExtractable"(rate: $IntSupplier$$Type, capacity: $IntSupplier$$Type, isValid: $Predicate$$Type<($FluidStack)>): $FluidTanksBuilder
public "addBasic"(capacity: $IntSupplier$$Type): $FluidTanksBuilder
public "addBasic"<VANILLA_INPUT extends $RecipeInput, RECIPE extends $MekanismRecipe<(VANILLA_INPUT)>, INPUT_CACHE extends $IInputRecipeCache>(capacity: integer, recipeType: $IMekanismRecipeTypeProvider$$Type<(VANILLA_INPUT), (RECIPE), (INPUT_CACHE)>, containsRecipe: $ContainsRecipe$$Type<(INPUT_CACHE), ($FluidStack)>): $FluidTanksBuilder
public "addBasic"(capacity: integer): $FluidTanksBuilder
public "addBasic"(capacity: integer, isValid: $Predicate$$Type<($FluidStack)>): $FluidTanksBuilder
public "addBasic"(capacity: $IntSupplier$$Type, isValid: $Predicate$$Type<($FluidStack)>): $FluidTanksBuilder
public "addTank"(tank: $IBasicContainerCreator$$Type<($ComponentBackedFluidTank$$Type)>): $FluidTanksBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTanksBuilder$$Type = ($FluidTanksBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTanksBuilder_ = $FluidTanksBuilder$$Type;
}}
declare module "mekanism.common.tile.interfaces.IUpgradeTile" {
import {$TileComponentUpgrade, $TileComponentUpgrade$$Type} from "mekanism.common.tile.component.TileComponentUpgrade"
import {$Upgrade, $Upgrade$$Type} from "mekanism.api.Upgrade"

export interface $IUpgradeTile {

 "getComponent"(): $TileComponentUpgrade
 "recalculateUpgrades"(upgradeType: $Upgrade$$Type): void
 "supportsUpgrade"(upgradeType: $Upgrade$$Type): boolean
 "supportsUpgrades"(): boolean
get "component"(): $TileComponentUpgrade
}

export namespace $IUpgradeTile {
const probejs$$marker: never
}
export class $IUpgradeTile$$Static implements $IUpgradeTile {


 "getComponent"(): $TileComponentUpgrade
 "recalculateUpgrades"(upgradeType: $Upgrade$$Type): void
 "supportsUpgrade"(upgradeType: $Upgrade$$Type): boolean
 "supportsUpgrades"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IUpgradeTile$$Type = ($IUpgradeTile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IUpgradeTile_ = $IUpgradeTile$$Type;
}}
declare module "mekanism.common.attachments.containers.item.ComponentBackedInventorySlot" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IInventorySlot, $IInventorySlot$$Type} from "mekanism.api.inventory.IInventorySlot"
import {$Action, $Action$$Type} from "mekanism.api.Action"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$AttachedItems, $AttachedItems$$Type} from "mekanism.common.attachments.containers.item.AttachedItems"
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ComponentBackedContainer, $ComponentBackedContainer$$Type} from "mekanism.common.attachments.containers.ComponentBackedContainer"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"

export class $ComponentBackedInventorySlot extends $ComponentBackedContainer<($ItemStack), ($AttachedItems)> implements $IInventorySlot {

constructor(attachedTo: $ItemStack$$Type, slotIndex: integer, canExtract: $BiPredicate$$Type<($ItemStack), ($AutomationType)>, canInsert: $BiPredicate$$Type<($ItemStack), ($AutomationType)>, validator: $Predicate$$Type<($ItemStack)>)
constructor(attachedTo: $ItemStack$$Type, slotIndex: integer, canExtract: $BiPredicate$$Type<($ItemStack), ($AutomationType)>, canInsert: $BiPredicate$$Type<($ItemStack), ($AutomationType)>, validator: $Predicate$$Type<($ItemStack)>, obeyStackLimit: boolean, limit: integer)

public "getStack"(): $ItemStack
public "getLimit"(stack: $ItemStack$$Type): integer
public "setStack"(stack: $ItemStack$$Type): void
public "extractItem"(amount: integer, action: $Action$$Type, automationType: $AutomationType$$Type): $ItemStack
public "isItemValid"(stack: $ItemStack$$Type): boolean
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $Tag$$Type): void
public "deserializeNBT"(provider: $HolderLookup$Provider$$Type, nbt: $CompoundTag$$Type): void
public "serializeNBT"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "setStackSize"(amount: integer, action: $Action$$Type): integer
public "insertItem"(attachedItems: $AttachedItems$$Type, current: $ItemStack$$Type, stack: $ItemStack$$Type, action: $Action$$Type, automationType: $AutomationType$$Type): $ItemStack
public "insertItem"(stack: $ItemStack$$Type, action: $Action$$Type, automationType: $AutomationType$$Type): $ItemStack
public "growStack"(amount: integer, action: $Action$$Type): integer
public "isEmpty"(): boolean
public "getCount"(): integer
public "setEmpty"(): void
public "shrinkStack"(arg0: integer, arg1: $Action$$Type): integer
public "createContainerSlot"(): $Slot
get "stack"(): $ItemStack
set "stack"(value: $ItemStack$$Type)
get "empty"(): boolean
get "count"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBackedInventorySlot$$Type = ($ComponentBackedInventorySlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBackedInventorySlot_ = $ComponentBackedInventorySlot$$Type;
}}
declare module "mekanism.common.item.block.transmitter.ItemBlockUniversalCable" {
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$ITier, $ITier$$Type} from "mekanism.api.tier.ITier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$TileEntityUniversalCable, $TileEntityUniversalCable$$Type} from "mekanism.common.tile.transmitter.TileEntityUniversalCable"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockSmallTransmitter, $BlockSmallTransmitter$$Type} from "mekanism.common.block.transmitter.BlockSmallTransmitter"

export class $ItemBlockUniversalCable extends $ItemBlockTooltip<($BlockSmallTransmitter<($TileEntityUniversalCable)>)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockSmallTransmitter$$Type<($TileEntityUniversalCable$$Type)>, properties: $Item$Properties$$Type)

public "getTier"(): $ITier
get "tier"(): $ITier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockUniversalCable$$Type = ($ItemBlockUniversalCable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockUniversalCable_ = $ItemBlockUniversalCable$$Type;
}}
declare module "mekanism.common.integration.computer.MethodData$Builder" {
import {$MethodRestriction, $MethodRestriction$$Type} from "mekanism.common.integration.computer.MethodRestriction"
import {$MethodData, $MethodData$$Type} from "mekanism.common.integration.computer.MethodData"
import {$Class, $Class$$Type} from "java.lang.Class"

export class $MethodData$Builder<T> {


public "returnType"(returnType: $Class$$Type<(any)>): $MethodData$Builder<(T)>
public "arguments"(argumentNames: (string)[], argClasses: ($Class$$Type<(any)>)[]): $MethodData$Builder<(T)>
public "build"(): $MethodData<(T)>
public "threadSafe"(): $MethodData$Builder<(T)>
public "methodDescription"(methodDescription: string): $MethodData$Builder<(T)>
public "restriction"(restriction: $MethodRestriction$$Type): $MethodData$Builder<(T)>
public "requiresPublicSecurity"(): $MethodData$Builder<(T)>
public "returnExtra"(...returnExtra: ($Class$$Type<(any)>)[]): $MethodData$Builder<(T)>
public "requiredMods"(...requiredMods: (string)[]): $MethodData$Builder<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodData$Builder$$Type<T> = ($MethodData$Builder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodData$Builder_<T> = $MethodData$Builder$$Type<(T)>;
}}
declare module "mekanism.common.tile.interfaces.IRedstoneControl" {
import {$IRedstoneControl$RedstoneControl, $IRedstoneControl$RedstoneControl$$Type} from "mekanism.common.tile.interfaces.IRedstoneControl$RedstoneControl"

export interface $IRedstoneControl {

 "supportsMode"(mode: $IRedstoneControl$RedstoneControl$$Type): boolean
 "wasPowered"(): boolean
 "isPowered"(): boolean
 "setControlType"(type: $IRedstoneControl$RedstoneControl$$Type): void
 "getControlType"(): $IRedstoneControl$RedstoneControl
get "powered"(): boolean
set "controlType"(value: $IRedstoneControl$RedstoneControl$$Type)
get "controlType"(): $IRedstoneControl$RedstoneControl
}

export namespace $IRedstoneControl {
const probejs$$marker: never
}
export class $IRedstoneControl$$Static implements $IRedstoneControl {


 "supportsMode"(mode: $IRedstoneControl$RedstoneControl$$Type): boolean
 "wasPowered"(): boolean
 "isPowered"(): boolean
 "setControlType"(type: $IRedstoneControl$RedstoneControl$$Type): void
 "getControlType"(): $IRedstoneControl$RedstoneControl
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRedstoneControl$$Type = ($IRedstoneControl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRedstoneControl_ = $IRedstoneControl$$Type;
}}
declare module "mekanism.common.attachments.containers.IAttachedContainers" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $IAttachedContainers<TYPE, ATTACHED extends $IAttachedContainers<(TYPE), (ATTACHED)>> extends $Iterable<(TYPE)> {

 "size"(): integer
 "get"(index: integer): TYPE
 "isEmpty"(): boolean
 "iterator"(): $Iterator<(TYPE)>
 "spliterator"(): $Spliterator<(TYPE)>
 "forEach"(action: $Consumer$$Type<(TYPE)>): void
 "getOrDefault"(index: integer): TYPE
 "with"(index: integer, data: TYPE): ATTACHED
 "create"(containers: $List$$Type<(TYPE)>): ATTACHED
 "containers"(): $List<(TYPE)>
 "getEmptyStack"(): TYPE
[Symbol.iterator](): IterableIterator<TYPE>;
get "empty"(): boolean
get "emptyStack"(): TYPE
}

export namespace $IAttachedContainers {
const probejs$$marker: never
}
export class $IAttachedContainers$$Static<TYPE, ATTACHED extends $IAttachedContainers<(TYPE), (ATTACHED)>> implements $IAttachedContainers {


 "size"(): integer
 "get"(index: integer): TYPE
 "isEmpty"(): boolean
 "iterator"(): $Iterator<(TYPE)>
 "spliterator"(): $Spliterator<(TYPE)>
 "forEach"(action: $Consumer$$Type<(TYPE)>): void
 "getOrDefault"(index: integer): TYPE
 "with"(index: integer, data: TYPE): ATTACHED
 "create"(containers: $List$$Type<(TYPE)>): ATTACHED
 "containers"(): $List<(TYPE)>
 "getEmptyStack"(): TYPE
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAttachedContainers$$Type<TYPE, ATTACHED> = ($IAttachedContainers<(TYPE), (ATTACHED)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IAttachedContainers_<TYPE, ATTACHED> = $IAttachedContainers$$Type<(TYPE), (ATTACHED)>;
}}
declare module "mekanism.common.lib.inventory.TransitRequest$TransitResponse" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$TransitRequest$ItemData, $TransitRequest$ItemData$$Type} from "mekanism.common.lib.inventory.TransitRequest$ItemData"

export class $TransitRequest$TransitResponse {

constructor(inserted: $ItemStack$$Type, slotData: $TransitRequest$ItemData$$Type)

public "equals"(o: any): boolean
public "hashCode"(): integer
public "isEmpty"(): boolean
public "use"(amount: integer): $ItemStack
public "getStack"(): $ItemStack
public "getSlotData"(): $TransitRequest$ItemData
public "getSendingAmount"(): integer
public "getRejected"(): $ItemStack
public "useAll"(): $ItemStack
get "empty"(): boolean
get "stack"(): $ItemStack
get "slotData"(): $TransitRequest$ItemData
get "sendingAmount"(): integer
get "rejected"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransitRequest$TransitResponse$$Type = ($TransitRequest$TransitResponse);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TransitRequest$TransitResponse_ = $TransitRequest$TransitResponse$$Type;
}}
declare module "mekanism.common.item.gear.ItemMekaTool" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$ItemAttributeModifierEvent, $ItemAttributeModifierEvent$$Type} from "net.neoforged.neoforge.event.ItemAttributeModifierEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$ItemAbility, $ItemAbility$$Type} from "net.neoforged.neoforge.common.ItemAbility"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IModuleContainer, $IModuleContainer$$Type} from "mekanism.api.gear.IModuleContainer"
import {$IEnergyContainer, $IEnergyContainer$$Type} from "mekanism.api.energy.IEnergyContainer"
import {$IRadialMode, $IRadialMode$$Type} from "mekanism.api.radial.mode.IRadialMode"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemEnchantments, $ItemEnchantments$$Type} from "net.minecraft.world.item.enchantment.ItemEnchantments"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$UseOnContext, $UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ItemEnergized, $ItemEnergized$$Type} from "mekanism.common.item.ItemEnergized"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$HolderLookup$RegistryLookup, $HolderLookup$RegistryLookup$$Type} from "net.minecraft.core.HolderLookup$RegistryLookup"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$IModule, $IModule$$Type} from "mekanism.api.gear.IModule"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$RadialData, $RadialData$$Type} from "mekanism.api.radial.RadialData"
import {$IModuleDataProvider, $IModuleDataProvider$$Type} from "mekanism.api.providers.IModuleDataProvider"
import {$IRadialModuleContainerItem, $IRadialModuleContainerItem$$Type} from "mekanism.common.content.gear.IRadialModuleContainerItem"
import {$IBlastingItem, $IBlastingItem$$Type} from "mekanism.common.content.gear.IBlastingItem"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Enchantment, $Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ICustomModule, $ICustomModule$$Type} from "mekanism.api.gear.ICustomModule"

export class $ItemMekaTool extends $ItemEnergized implements $IRadialModuleContainerItem, $IBlastingItem {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "use"(world: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "onDestroyed"(item: $ItemEntity$$Type, damageSource: $DamageSource$$Type): void
public "adjustAttributes"(event: $ItemAttributeModifierEvent$$Type): void
public "isPrimaryItemFor"(stack: $ItemStack$$Type, enchantment: $Holder$$Type<($Enchantment)>): boolean
public "getAllEnchantments"(stack: $ItemStack$$Type, lookup: $HolderLookup$RegistryLookup$$Type<($Enchantment$$Type)>): $ItemEnchantments
public "isBookEnchantable"(stack: $ItemStack$$Type, book: $ItemStack$$Type): boolean
public "isEnchantable"(stack: $ItemStack$$Type): boolean
public "getDestroySpeed"(stack: $ItemStack$$Type, state: $BlockState$$Type): float
public "isNotReplaceableByPickAction"(stack: $ItemStack$$Type, player: $Player$$Type, inventorySlot: integer): boolean
public "canPerformAction"(stack: $ItemStack$$Type, action: $ItemAbility$$Type): boolean
public "mineBlock"(stack: $ItemStack$$Type, world: $Level$$Type, state: $BlockState$$Type, pos: $BlockPos$$Type, entity: $LivingEntity$$Type): boolean
public "useOn"(context: $UseOnContext$$Type): $InteractionResult
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "interactLivingEntity"(stack: $ItemStack$$Type, player: $Player$$Type, entity: $LivingEntity$$Type, hand: $InteractionHand$$Type): $InteractionResult
public "hurtEnemy"(stack: $ItemStack$$Type, target: $LivingEntity$$Type, attacker: $LivingEntity$$Type): boolean
public "getEnchantmentLevel"(stack: $ItemStack$$Type, enchantment: $Holder$$Type<($Enchantment)>): integer
public static "getDestroyEnergy"(container: $IModuleContainer$$Type, hardness: float, silk: boolean): long
public static "getDestroyEnergy"(itemStack: $ItemStack$$Type, hardness: float, silk: boolean): long
public "getBlastedBlocks"(world: $Level$$Type, player: $Player$$Type, stack: $ItemStack$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type): $Map<($BlockPos), ($BlockState)>
public static "hasEnergyForDigAction"(container: $IModuleContainer$$Type, energyContainer: $IEnergyContainer$$Type): boolean
public "getRadialIdentifier"(): $ResourceLocation
public "setMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, player: $Player$$Type, radialData: $RadialData$$Type<(M)>, mode: M): void
public "getMode"<M extends $IRadialMode>(stack: $ItemStack$$Type, radialData: $RadialData$$Type<(M)>): M
public "getRadialData"(stack: $ItemStack$$Type): $RadialData<(any)>
public static "canBlastBlock"(world: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type): boolean
public static "findPositions"(world: $Level$$Type, targetPos: $BlockPos$$Type, player: $Player$$Type, radius: integer): $Map<($BlockPos), ($BlockState)>
public "getModules"(stack: $ItemStack$$Type): $Collection<($IModule<(any)>)>
public "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
public "hasModule"(stack: $ItemStack$$Type, type: $IModuleDataProvider$$Type<(any)>): boolean
public "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
public "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
public "isModuleEnabled"(stack: $ItemStack$$Type, type: $IModuleDataProvider$$Type<(any)>): boolean
public "addModuleDetails"(stack: $ItemStack$$Type, tooltip: $List$$Type<($Component$$Type)>): void
public "getEnabledModule"<MODULE extends $ICustomModule<(MODULE)>>(stack: $ItemStack$$Type, typeProvider: $IModuleDataProvider$$Type<(MODULE)>): $IModule<(MODULE)>
public "moduleContainer"(stack: $ItemStack$$Type): $IModuleContainer
public "hasInstalledModules"(stack: $ItemStack$$Type): boolean
public static "displayModeChange"(player: $Player$$Type): void
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
public "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void
get "radialIdentifier"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemMekaTool$$Type = ($ItemMekaTool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemMekaTool_ = $ItemMekaTool$$Type;
}}
declare module "mekanism.common.lib.multiblock.Structure$Axis" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$BlockPosBuilder, $BlockPosBuilder$$Type} from "mekanism.common.lib.math.voxel.BlockPosBuilder"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $Structure$Axis extends $Enum<($Structure$Axis)> {
static readonly "X": $Structure$Axis
static readonly "Y": $Structure$Axis
static readonly "Z": $Structure$Axis


public static "get"(side: $Direction$$Type): $Structure$Axis
public static "values"(): ($Structure$Axis)[]
public static "valueOf"(name: string): $Structure$Axis
public "set"(pos: $BlockPosBuilder$$Type, val: integer): void
public "horizontal"(): $Structure$Axis
public "vertical"(): $Structure$Axis
public "getCoord"(pos: $BlockPos$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Structure$Axis$$Type = (("x") | ("y") | ("z"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Structure$Axis_ = $Structure$Axis$$Type;
}}
declare module "mekanism.common.lib.math.voxel.BlockPosBuilder" {
import {$Structure$Axis, $Structure$Axis$$Type} from "mekanism.common.lib.multiblock.Structure$Axis"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $BlockPosBuilder {

constructor()

public "get"(axis: $Structure$Axis$$Type): integer
public "set"(axis: $Structure$Axis$$Type, value: integer): void
public "isSet"(axis: $Structure$Axis$$Type): boolean
public "build"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPosBuilder$$Type = ($BlockPosBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPosBuilder_ = $BlockPosBuilder$$Type;
}}
declare module "mekanism.common.block.basic.BlockLogisticalSorter" {
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$TileEntityLogisticalSorter, $TileEntityLogisticalSorter$$Type} from "mekanism.common.tile.TileEntityLogisticalSorter"
import {$BlockTile$BlockTileModel, $BlockTile$BlockTileModel$$Type} from "mekanism.common.block.prefab.BlockTile$BlockTileModel"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Machine, $Machine$$Type} from "mekanism.common.content.blocktype.Machine"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockLogisticalSorter extends $BlockTile$BlockTileModel<($TileEntityLogisticalSorter), ($Machine<($TileEntityLogisticalSorter)>)> {
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor()

public "getStateForPlacement"(context: $BlockPlaceContext$$Type): $BlockState
public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockLogisticalSorter$$Type = ($BlockLogisticalSorter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockLogisticalSorter_ = $BlockLogisticalSorter$$Type;
}}
declare module "mekanism.common.item.block.machine.ItemBlockFluidTank" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$IModeItem$IAttachmentBasedModeItem, $IModeItem$IAttachmentBasedModeItem$$Type} from "mekanism.common.item.interfaces.IModeItem$IAttachmentBasedModeItem"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$BlockTile, $BlockTile$$Type} from "mekanism.common.block.prefab.BlockTile"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$BlockFluidTank, $BlockFluidTank$$Type} from "mekanism.common.block.basic.BlockFluidTank"
import {$ItemBlockTooltip, $ItemBlockTooltip$$Type} from "mekanism.common.item.block.ItemBlockTooltip"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$FluidTankTier, $FluidTankTier$$Type} from "mekanism.common.tier.FluidTankTier"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$UseOnContext, $UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"

export class $ItemBlockFluidTank extends $ItemBlockTooltip<($BlockTile<(any), (any)>)> implements $IModeItem$IAttachmentBasedModeItem<(boolean)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(block: $BlockFluidTank$$Type, properties: $Item$Properties$$Type)

public "use"(world: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "getDefaultMode"(): any
public "getModeDataType"(): $DataComponentType<(boolean)>
public "getTier"(): $FluidTankTier
public "useOn"(context: $UseOnContext$$Type): $InteractionResult
public "interactLivingEntity"(stack: $ItemStack$$Type, player: $Player$$Type, entity: $LivingEntity$$Type, hand: $InteractionHand$$Type): $InteractionResult
public "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
public "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
public "setMode"(stack: $ItemStack$$Type, player: $Player$$Type, mode: boolean): void
public "getMode"(stack: $ItemStack$$Type): boolean
public "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "displayModeChange"(player: $Player$$Type): void
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
get "defaultMode"(): any
get "modeDataType"(): $DataComponentType<(boolean)>
get "tier"(): $FluidTankTier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBlockFluidTank$$Type = ($ItemBlockFluidTank);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBlockFluidTank_ = $ItemBlockFluidTank$$Type;
}}
declare module "mekanism.common.lib.multiblock.FormationProtocol$FormationResult" {
import {$ILangEntry, $ILangEntry$$Type} from "mekanism.api.text.ILangEntry"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $FormationProtocol$FormationResult {
static readonly "SUCCESS": $FormationProtocol$FormationResult
static readonly "FAIL": $FormationProtocol$FormationResult


public static "fail"(text: $Component$$Type): $FormationProtocol$FormationResult
public static "fail"(text: $Component$$Type, noIgnore: boolean): $FormationProtocol$FormationResult
public static "fail"(text: $ILangEntry$$Type, pos: $BlockPos$$Type): $FormationProtocol$FormationResult
public static "fail"(text: $ILangEntry$$Type, pos: $BlockPos$$Type, noIgnore: boolean): $FormationProtocol$FormationResult
public static "fail"(text: $ILangEntry$$Type): $FormationProtocol$FormationResult
public static "fail"(text: $ILangEntry$$Type, noIgnore: boolean): $FormationProtocol$FormationResult
public "getResultText"(): $Component
public "isNoIgnore"(): boolean
public "isFormed"(): boolean
get "resultText"(): $Component
get "noIgnore"(): boolean
get "formed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FormationProtocol$FormationResult$$Type = ($FormationProtocol$FormationResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FormationProtocol$FormationResult_ = $FormationProtocol$FormationResult$$Type;
}}
declare module "mekanism.common.capabilities.chemical.item.ChemicalTankSpec" {
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Chemical, $Chemical$$Type} from "mekanism.api.chemical.Chemical"
import {$GenericTankSpec, $GenericTankSpec$$Type} from "mekanism.common.capabilities.GenericTankSpec"
import {$ChemicalTankSpec$TankFromSpecCreator, $ChemicalTankSpec$TankFromSpecCreator$$Type} from "mekanism.common.capabilities.chemical.item.ChemicalTankSpec$TankFromSpecCreator"
import {$IChemicalTank, $IChemicalTank$$Type} from "mekanism.api.chemical.IChemicalTank"
import {$LongSupplier, $LongSupplier$$Type} from "java.util.function.LongSupplier"
import {$ChemicalTanksBuilder, $ChemicalTanksBuilder$$Type} from "mekanism.common.attachments.containers.chemical.ChemicalTanksBuilder"
import {$ToLongFunction, $ToLongFunction$$Type} from "java.util.function.ToLongFunction"
import {$ChemicalTankSpec$ComponentTankFromSpecCreator, $ChemicalTankSpec$ComponentTankFromSpecCreator$$Type} from "mekanism.common.capabilities.chemical.item.ChemicalTankSpec$ComponentTankFromSpecCreator"
import {$AutomationType, $AutomationType$$Type} from "mekanism.api.AutomationType"
import {$TriPredicate, $TriPredicate$$Type} from "net.neoforged.neoforge.common.util.TriPredicate"

export class $ChemicalTankSpec extends $GenericTankSpec<($Chemical)> {
readonly "isValid": $Predicate<(TYPE)>
readonly "canExtract": $BiPredicate<(TYPE), ($AutomationType)>
readonly "canInsert": $TriPredicate<(TYPE), ($AutomationType), ($ItemStack)>


public static "create"(rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type): $ChemicalTankSpec
public "createTank"(tankCreator: $ChemicalTankSpec$TankFromSpecCreator$$Type, stack: $ItemStack$$Type): $IChemicalTank
public "addTank"(builder: $ChemicalTanksBuilder$$Type, tankCreator: $ChemicalTankSpec$ComponentTankFromSpecCreator$$Type): void
public static "createFillOnly"(rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, isValid: $Predicate$$Type<($Chemical)>, supportsStack: $Predicate$$Type<($ItemStack)>): $ChemicalTankSpec
public static "createFillOnly"(rate: $LongSupplier$$Type, stackBasedCapacity: $ToLongFunction$$Type<($ItemStack)>, isValid: $Predicate$$Type<($Chemical)>, supportsStack: $Predicate$$Type<($ItemStack)>): $ChemicalTankSpec
public static "createFillOnly"(rate: $LongSupplier$$Type, capacity: $LongSupplier$$Type, isValid: $Predicate$$Type<($Chemical)>): $ChemicalTankSpec
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChemicalTankSpec$$Type = ($ChemicalTankSpec);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChemicalTankSpec_ = $ChemicalTankSpec$$Type;
}}
declare module "mekanism.common.recipe.lookup.cache.InputRecipeCache$DoubleItem" {
import {$ItemStackIngredient, $ItemStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ItemStackIngredient"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$MekanismRecipe, $MekanismRecipe$$Type} from "mekanism.api.recipes.MekanismRecipe"
import {$ItemInputCache, $ItemInputCache$$Type} from "mekanism.common.recipe.lookup.cache.type.ItemInputCache"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$DoubleInputRecipeCache$DoubleSameInputRecipeCache, $DoubleInputRecipeCache$DoubleSameInputRecipeCache$$Type} from "mekanism.common.recipe.lookup.cache.DoubleInputRecipeCache$DoubleSameInputRecipeCache"
import {$MekanismRecipeType, $MekanismRecipeType$$Type} from "mekanism.common.recipe.MekanismRecipeType"

export class $InputRecipeCache$DoubleItem<RECIPE extends ($MekanismRecipe<(any)>) & ($BiPredicate<($ItemStack), ($ItemStack)>)> extends $DoubleInputRecipeCache$DoubleSameInputRecipeCache<($ItemStack), ($ItemStackIngredient), (RECIPE), ($ItemInputCache<(RECIPE)>)> {

constructor(recipeType: $MekanismRecipeType$$Type<(any), (RECIPE), (any)>, inputAExtractor: $Function$$Type<(RECIPE), ($ItemStackIngredient$$Type)>, inputBExtractor: $Function$$Type<(RECIPE), ($ItemStackIngredient$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputRecipeCache$DoubleItem$$Type<RECIPE> = ($InputRecipeCache$DoubleItem<(RECIPE)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputRecipeCache$DoubleItem_<RECIPE> = $InputRecipeCache$DoubleItem$$Type<(RECIPE)>;
}}
declare module "mekanism.common.lib.frequency.Frequency" {
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Frequency$FrequencyIdentity, $Frequency$FrequencyIdentity$$Type} from "mekanism.common.lib.frequency.Frequency$FrequencyIdentity"
import {$FrequencyType, $FrequencyType$$Type} from "mekanism.common.lib.frequency.FrequencyType"
import {$SecurityMode, $SecurityMode$$Type} from "mekanism.api.security.SecurityMode"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$IFrequency, $IFrequency$$Type} from "mekanism.api.IFrequency"

export class $Frequency implements $IFrequency {


public "getName"(): string
public "equals"(obj: any): boolean
public "hashCode"(): integer
public "update"(tile: $BlockEntity$$Type): boolean
public "getKey"(): any
public "getType"(): $FrequencyType<(any)>
public "getOwner"(): $UUID
public "tick"(tickingNormally: boolean): boolean
public "isValid"(): boolean
public "onRemove"(): void
public "isRemoved"(): boolean
public "getIdentity"(): $Frequency$FrequencyIdentity
public "getOwnerName"(): string
public "setValid"(valid: boolean): void
public "ownerMatches"(toCheck: $UUID$$Type): boolean
public "setSecurityMode"(securityMode: $SecurityMode$$Type): void
public "getSecurity"(): $SecurityMode
public "getSyncHash"(): integer
public "onDeactivate"(tile: $BlockEntity$$Type): boolean
get "name"(): string
get "key"(): any
get "type"(): $FrequencyType<(any)>
get "owner"(): $UUID
get "valid"(): boolean
get "removed"(): boolean
get "identity"(): $Frequency$FrequencyIdentity
get "ownerName"(): string
set "valid"(value: boolean)
set "securityMode"(value: $SecurityMode$$Type)
get "security"(): $SecurityMode
get "syncHash"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Frequency$$Type = ($Frequency);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Frequency_ = $Frequency$$Type;
}}
declare module "mekanism.common.content.qio.IQIOCraftingWindowHolder" {
import {$QIOFrequency, $QIOFrequency$$Type} from "mekanism.common.content.qio.QIOFrequency"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IContentsListener, $IContentsListener$$Type} from "mekanism.api.IContentsListener"
import {$QIOCraftingWindow, $QIOCraftingWindow$$Type} from "mekanism.common.content.qio.QIOCraftingWindow"

export interface $IQIOCraftingWindowHolder extends $IContentsListener {

 "getLevel"(): $Level
 "getFrequency"(): $QIOFrequency
 "getCraftingWindows"(): ($QIOCraftingWindow)[]
 "onContentsChanged"(): void
get "level"(): $Level
get "frequency"(): $QIOFrequency
get "craftingWindows"(): ($QIOCraftingWindow)[]
}

export namespace $IQIOCraftingWindowHolder {
const MAX_CRAFTING_WINDOWS: byte
const probejs$$marker: never
}
export class $IQIOCraftingWindowHolder$$Static implements $IQIOCraftingWindowHolder {
static readonly "MAX_CRAFTING_WINDOWS": byte


 "getLevel"(): $Level
 "getFrequency"(): $QIOFrequency
 "getCraftingWindows"(): ($QIOCraftingWindow)[]
 "onContentsChanged"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IQIOCraftingWindowHolder$$Type = ($IQIOCraftingWindowHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IQIOCraftingWindowHolder_ = $IQIOCraftingWindowHolder$$Type;
}}
declare module "mekanism.common.item.gear.ItemChemicalArmor" {
import {$ArmorMaterial, $ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$$Type} from "mekanism.common.registration.impl.CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$IChemicalItem, $IChemicalItem$$Type} from "mekanism.common.item.interfaces.IChemicalItem"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ItemAttributeModifiers, $ItemAttributeModifiers$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ItemSpecialArmor, $ItemSpecialArmor$$Type} from "mekanism.common.item.gear.ItemSpecialArmor"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Equipable, $Equipable$$Type} from "net.minecraft.world.item.Equipable"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior, $DispenseItemBehavior$$Type} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ItemChemicalArmor extends $ItemSpecialArmor implements $IChemicalItem, $CreativeTabDeferredRegister$ICustomCreativeTabContents {
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
readonly "type": $ArmorItem$Type
readonly "material": $Holder<($ArmorMaterial)>
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean


public "getBarWidth"(stack: $ItemStack$$Type): integer
public "getBarColor"(stack: $ItemStack$$Type): integer
public "isBarVisible"(stack: $ItemStack$$Type): boolean
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "addItems"(tabOutput: $Consumer$$Type<($ItemStack)>): void
public "useChemical"(stack: $ItemStack$$Type, amount: long): $ChemicalStack
public "hasChemical"(stack: $ItemStack$$Type): boolean
public "addDefault"(): boolean
public static "get"(arg0: $ItemStack$$Type): $Equipable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemChemicalArmor$$Type = ($ItemChemicalArmor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemChemicalArmor_ = $ItemChemicalArmor$$Type;
}}
declare module "mekanism.common.item.gear.ItemFlamethrower" {
import {$CreativeTabDeferredRegister$ICustomCreativeTabContents, $CreativeTabDeferredRegister$ICustomCreativeTabContents$$Type} from "mekanism.common.registration.impl.CreativeTabDeferredRegister$ICustomCreativeTabContents"
import {$IChemicalItem, $IChemicalItem$$Type} from "mekanism.common.item.interfaces.IChemicalItem"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IModeItem$IAttachmentBasedModeItem, $IModeItem$IAttachmentBasedModeItem$$Type} from "mekanism.common.item.interfaces.IModeItem$IAttachmentBasedModeItem"
import {$List, $List$$Type} from "java.util.List"
import {$IItemHUDProvider, $IItemHUDProvider$$Type} from "mekanism.common.item.interfaces.IItemHUDProvider"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder, $InteractionResultHolder$$Type} from "net.minecraft.world.InteractionResultHolder"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$UseOnContext, $UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$IModeItem$DisplayChange, $IModeItem$DisplayChange$$Type} from "mekanism.common.item.interfaces.IModeItem$DisplayChange"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$TooltipContext, $Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Enchantment, $Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$ItemFlamethrower$FlamethrowerMode, $ItemFlamethrower$FlamethrowerMode$$Type} from "mekanism.common.item.gear.ItemFlamethrower$FlamethrowerMode"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $ItemFlamethrower extends $Item implements $IItemHUDProvider, $IChemicalItem, $CreativeTabDeferredRegister$ICustomCreativeTabContents, $IModeItem$IAttachmentBasedModeItem<($ItemFlamethrower$FlamethrowerMode)> {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "canRepair": boolean

constructor(properties: $Item$Properties$$Type)

public "use"(level: $Level$$Type, player: $Player$$Type, hand: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "getDefaultMode"(): any
public "getModeDataType"(): $DataComponentType<($ItemFlamethrower$FlamethrowerMode)>
public "addHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): void
public "onUseTick"(level: $Level$$Type, entity: $LivingEntity$$Type, stack: $ItemStack$$Type, remainingDuration: integer): void
public "isPrimaryItemFor"(stack: $ItemStack$$Type, enchantment: $Holder$$Type<($Enchantment)>): boolean
public "isBookEnchantable"(stack: $ItemStack$$Type, book: $ItemStack$$Type): boolean
public "isEnchantable"(stack: $ItemStack$$Type): boolean
public "getBarWidth"(stack: $ItemStack$$Type): integer
public "getBarColor"(stack: $ItemStack$$Type): integer
public "isBarVisible"(stack: $ItemStack$$Type): boolean
public "getUseDuration"(stack: $ItemStack$$Type, entity: $LivingEntity$$Type): integer
public "useOn"(context: $UseOnContext$$Type): $InteractionResult
public "appendHoverText"(stack: $ItemStack$$Type, context: $Item$TooltipContext$$Type, tooltip: $List$$Type<($Component$$Type)>, flag: $TooltipFlag$$Type): void
public "changeMode"(player: $Player$$Type, stack: $ItemStack$$Type, shift: integer, displayChange: $IModeItem$DisplayChange$$Type): void
public "shouldCauseReequipAnimation"(oldStack: $ItemStack$$Type, newStack: $ItemStack$$Type, slotChanged: boolean): boolean
public "addItems"(tabOutput: $Consumer$$Type<($ItemStack)>): void
public "getScrollTextComponent"(stack: $ItemStack$$Type): $Component
public static "isIdleFlamethrower"(player: $Player$$Type, hand: $InteractionHand$$Type): boolean
public "addCurioHUDStrings"(list: $List$$Type<($Component$$Type)>, player: $Player$$Type, stack: $ItemStack$$Type): void
public "useChemical"(stack: $ItemStack$$Type, amount: long): $ChemicalStack
public "hasChemical"(stack: $ItemStack$$Type): boolean
public "addDefault"(): boolean
public "setMode"(stack: $ItemStack$$Type, player: $Player$$Type, mode: $ItemFlamethrower$FlamethrowerMode$$Type): void
public "getMode"(stack: $ItemStack$$Type): $ItemFlamethrower$FlamethrowerMode
public "supportsSlotType"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "displayModeChange"(player: $Player$$Type): void
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type, allowRadial: boolean): boolean
public static "isModeItem"(stack: $ItemStack$$Type, slotType: $EquipmentSlot$$Type): boolean
public static "isModeItem"(player: $Player$$Type, slotType: $EquipmentSlot$$Type): boolean
get "defaultMode"(): any
get "modeDataType"(): $DataComponentType<($ItemFlamethrower$FlamethrowerMode)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFlamethrower$$Type = ($ItemFlamethrower);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFlamethrower_ = $ItemFlamethrower$$Type;
}}
declare module "mekanism.common.integration.computer.BoundMethodHolder$BoundMethodData" {
import {$ComputerMethodFactory$ComputerFunctionCaller, $ComputerMethodFactory$ComputerFunctionCaller$$Type} from "mekanism.common.integration.computer.ComputerMethodFactory$ComputerFunctionCaller"
import {$BaseComputerHelper, $BaseComputerHelper$$Type} from "mekanism.common.integration.computer.BaseComputerHelper"
import {$MethodData, $MethodData$$Type} from "mekanism.common.integration.computer.MethodData"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$WeakReference, $WeakReference$$Type} from "java.lang.ref.WeakReference"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $BoundMethodHolder$BoundMethodData<T> extends $Record {

constructor(method: $MethodData$$Type<(T)>, subject: $WeakReference$$Type<(T)>, isHelpMethod: boolean)

public "returnType"(): $Class<(any)>
public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "method"(): $MethodData<(T)>
public "hashCode"(): integer
public "handler"(): $ComputerMethodFactory$ComputerFunctionCaller<(T)>
public "call"(helper: $BaseComputerHelper$$Type): any
public "subject"(): $WeakReference<(T)>
public "threadSafe"(): boolean
public "argClasses"(): ($Class<(any)>)[]
public "isHelpMethod"(): boolean
public "argumentNames"(): (string)[]
get "helpMethod"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoundMethodHolder$BoundMethodData$$Type<T> = ({"subject"?: $WeakReference$$Type<(never)>, "method"?: $MethodData$$Type<(never)>, "isHelpMethod"?: boolean}) | ([subject?: $WeakReference$$Type<(never)>, method?: $MethodData$$Type<(never)>, isHelpMethod?: boolean]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoundMethodHolder$BoundMethodData_<T> = $BoundMethodHolder$BoundMethodData$$Type<(T)>;
}}
declare module "mekanism.common.world.height.HeightShape" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$IHasTranslationKey$IHasEnumNameTranslationKey, $IHasTranslationKey$IHasEnumNameTranslationKey$$Type} from "mekanism.api.text.IHasTranslationKey$IHasEnumNameTranslationKey"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export class $HeightShape extends $Enum<($HeightShape)> implements $IHasTranslationKey$IHasEnumNameTranslationKey {
static readonly "TRAPEZOID": $HeightShape
static readonly "UNIFORM": $HeightShape


public static "values"(): ($HeightShape)[]
public static "valueOf"(name: string): $HeightShape
public "getTranslationKey"(): string
public "getTranslatedName"(): $Component
get "translationKey"(): string
get "translatedName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeightShape$$Type = (("trapezoid") | ("uniform"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeightShape_ = $HeightShape$$Type;
}}
