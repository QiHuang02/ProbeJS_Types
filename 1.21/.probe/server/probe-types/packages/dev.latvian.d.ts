declare module "dev.latvian.mods.kubejs.recipe.RecipeKey" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$SequencedSet, $SequencedSet$$Type} from "java.util.SequencedSet"
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RecipeSchemaType, $RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$ComponentRole, $ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$RecipeOptional, $RecipeOptional$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional"

export class $RecipeKey<T> {
readonly "component": $RecipeComponent<(T)>
readonly "typeInfo": $TypeInfo
readonly "codec": $Codec<(T)>
readonly "name": string
readonly "role": $ComponentRole
readonly "names": $SequencedSet<(string)>
 "excluded": boolean

constructor(arg0: $RecipeComponent$$Type<(T)>, arg1: string, arg2: $ComponentRole$$Type)

public "toString"(): string
public "hashCode"(): integer
public "optional"(): boolean
public "optional"(arg0: $RecipeOptional$$Type<(T)>): $RecipeKey<(T)>
public "optional"(arg0: T): $RecipeKey<(T)>
public "alt"(...arg0: (string)[]): $RecipeKey<(T)>
public "alt"(arg0: string): $RecipeKey<(T)>
public "toJson"(arg0: $RecipeSchemaType$$Type, arg1: $DynamicOps$$Type<($JsonElement$$Type)>): $JsonObject
public "functionNames"(arg0: $List$$Type<(string)>): $RecipeKey<(T)>
public "alwaysWrite"(): $RecipeKey<(T)>
public "exclude"(): $RecipeKey<(T)>
public "allowEmpty"(): $RecipeKey<(T)>
public "defaultOptional"(): $RecipeKey<(T)>
public "noFunctions"(): $RecipeKey<(T)>
public "getPreferredBuilderKey"(): string
get "preferredBuilderKey"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeKey$$Type<T> = ($RecipeKey<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeKey_<T> = $RecipeKey$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.event.KubeStartupEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $KubeStartupEvent extends $KubeEvent {

/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}

export namespace $KubeStartupEvent {
const BASIC: $KubeStartupEvent
const probejs$$marker: never
}
export class $KubeStartupEvent$$Static implements $KubeStartupEvent {
static readonly "BASIC": $KubeStartupEvent


/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeStartupEvent$$Type = ($KubeStartupEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeStartupEvent_ = $KubeStartupEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.SizedIngredientKJS" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$ItemLike, $ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$IngredientSupplierKJS, $IngredientSupplierKJS$$Type} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$ItemMatch, $ItemMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ItemMatch"
import {$Replaceable, $Replaceable$$Type} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$SizedIngredient, $SizedIngredient$$Type} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

export interface $SizedIngredientKJS extends $Replaceable, $IngredientSupplierKJS, $ItemMatch {

 "matches"(arg1: $Ingredient$$Type, arg2: boolean): boolean
 "matches"(arg1: $ItemStack$$Type, arg2: boolean): boolean
 "kjs$asIngredient"(): $Ingredient
 "kjs$self"(): $SizedIngredient
 "replaceThisWith"(arg1: any): any
 "matches"(arg1: $ItemLike$$Type, arg2: boolean): boolean
 "matchesAny"(arg1: $Iterable$$Type<($ItemLike$$Type)>, arg2: boolean): boolean
}

export namespace $SizedIngredientKJS {
function wrap(arg1: any): $ReplacementMatch
const probejs$$marker: never
}
export class $SizedIngredientKJS$$Static implements $SizedIngredientKJS {


 "matches"(arg1: $Ingredient$$Type, arg2: boolean): boolean
 "matches"(arg1: $ItemStack$$Type, arg2: boolean): boolean
 "kjs$asIngredient"(): $Ingredient
 "kjs$self"(): $SizedIngredient
 "replaceThisWith"(arg1: any): any
 "matches"(arg1: $ItemLike$$Type, arg2: boolean): boolean
 "matchesAny"(arg1: $Iterable$$Type<($ItemLike$$Type)>, arg2: boolean): boolean
static "wrap"(arg1: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SizedIngredientKJS$$Type = ($SizedIngredientKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SizedIngredientKJS_ = $SizedIngredientKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.Lazy" {
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Class, $Class$$Type} from "java.lang.Class"

export class $Lazy<T> implements $Supplier<(T)> {


public "get"(): T
public static "of"<T>(arg0: $Supplier$$Type<(T)>): $Lazy<(T)>
public static "of"<T>(arg0: $Supplier$$Type<(T)>, arg1: long): $Lazy<(T)>
public static "serviceLoader"<T>(arg0: $Class$$Type<(T)>): $Lazy<(T)>
public "forget"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Lazy$$Type<T> = ($Lazy<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Lazy_<T> = $Lazy$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.util.JsonSerializable" {
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"

export interface $JsonSerializable {

 "toJson"(): $JsonElement

(): $JsonElement$$Type
}

export namespace $JsonSerializable {
const probejs$$marker: never
}
export class $JsonSerializable$$Static implements $JsonSerializable {


 "toJson"(): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonSerializable$$Type = (() => $JsonElement$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JsonSerializable_ = $JsonSerializable$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.callbacks.BlockStateRotateCallbackJS" {
import {$BlockStateModifyCallbackJS, $BlockStateModifyCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.BlockStateModifyCallbackJS"
import {$Rotation, $Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateRotateCallbackJS extends $BlockStateModifyCallbackJS {

constructor(arg0: $BlockState$$Type, arg1: $Rotation$$Type)

/**
 * Rotates the specified direction
 */
public "rotate"(arg0: $Direction$$Type): $Direction
/**
 * Get the Rotation that this block is being rotated by
 */
public "getRotation"(): $Rotation
get "rotation"(): $Rotation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateRotateCallbackJS$$Type = ($BlockStateRotateCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateRotateCallbackJS_ = $BlockStateRotateCallbackJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.MinecraftEnvironmentKJS" {
import {$ScheduledEvents$Callback, $ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScheduledEvents, $ScheduledEvents$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents"
import {$TemporalAmount, $TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"
import {$MessageSenderKJS, $MessageSenderKJS$$Type} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"

export interface $MinecraftEnvironmentKJS extends $MessageSenderKJS {

 "scheduleRepeatingInTicks"(arg0: long, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getScheduledEvents"(): $ScheduledEvents
 "scheduleRepeating"(arg0: $TemporalAmount$$Type, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(arg0: long, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "schedule"(arg0: $TemporalAmount$$Type, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void

(): $ScheduledEvents$$Type
get "scheduledEvents"(): $ScheduledEvents
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}

export namespace $MinecraftEnvironmentKJS {
const probejs$$marker: never
}
export class $MinecraftEnvironmentKJS$$Static implements $MinecraftEnvironmentKJS {


 "scheduleRepeatingInTicks"(arg0: long, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getScheduledEvents"(): $ScheduledEvents
 "scheduleRepeating"(arg0: $TemporalAmount$$Type, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(arg0: long, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "schedule"(arg0: $TemporalAmount$$Type, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftEnvironmentKJS$$Type = (() => $ScheduledEvents$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MinecraftEnvironmentKJS_ = $MinecraftEnvironmentKJS$$Type;
}}
declare module "dev.latvian.mods.rhino.ConstProperties" {
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"

export interface $ConstProperties {

 "putConst"(arg1: string, arg2: $Scriptable$$Type, arg3: any): void
 "isConst"(arg0: string): boolean
 "defineConst"(arg1: string, arg2: $Scriptable$$Type): void
}

export namespace $ConstProperties {
const probejs$$marker: never
}
export class $ConstProperties$$Static implements $ConstProperties {


 "putConst"(arg1: string, arg2: $Scriptable$$Type, arg3: any): void
 "isConst"(arg0: string): boolean
 "defineConst"(arg1: string, arg2: $Scriptable$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConstProperties$$Type = ($ConstProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConstProperties_ = $ConstProperties$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RegisterSubtypesKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$List, $List$$Type} from "java.util.List"
import {$SubtypeInterpreter, $SubtypeInterpreter$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.SubtypeInterpreter"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"

export interface $RegisterSubtypesKubeEvent<E, F> extends $KubeEvent {

 "register"(arg1: F, arg2: $SubtypeInterpreter$$Type): void
 "useComponents"(arg1: F): void
 "useComponents"(arg1: F, arg2: $List$$Type<($DataComponentType$$Type<(any)>)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}

export namespace $RegisterSubtypesKubeEvent {
const probejs$$marker: never
}
export class $RegisterSubtypesKubeEvent$$Static<E, F> implements $RegisterSubtypesKubeEvent {


 "register"(arg1: F, arg2: $SubtypeInterpreter$$Type): void
 "useComponents"(arg1: F): void
 "useComponents"(arg1: F, arg2: $List$$Type<($DataComponentType$$Type<(any)>)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterSubtypesKubeEvent$$Type<E, F> = ($RegisterSubtypesKubeEvent<(E), (F)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterSubtypesKubeEvent_<E, F> = $RegisterSubtypesKubeEvent$$Type<(E), (F)>;
}}
declare module "dev.latvian.mods.kubejs.bindings.UUIDWrapper" {
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"
import {$UUID, $UUID$$Type} from "java.util.UUID"

export interface $UUIDWrapper {

}

export namespace $UUIDWrapper {
function toString(arg0: $UUID$$Type): string
function digits(arg0: $StringBuilder$$Type, arg1: long, arg2: integer): void
function fromString(arg0: any): $UUID
const probejs$$marker: never
}
export class $UUIDWrapper$$Static implements $UUIDWrapper {


static "toString"(arg0: $UUID$$Type): string
static "digits"(arg0: $StringBuilder$$Type, arg1: long, arg2: integer): void
static "fromString"(arg0: any): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UUIDWrapper$$Type = ($UUIDWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UUIDWrapper_ = $UUIDWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.ConsoleLine" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$FriendlyByteBuf, $FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$ConsoleJS, $ConsoleJS$$Type} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$LogType, $LogType$$Type} from "dev.latvian.mods.kubejs.util.LogType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ConsoleLine implements $Supplier<($JsonElement)> {
static readonly "EMPTY_ARRAY": ($ConsoleLine)[]
static readonly "STREAM_CODEC": $StreamCodec<($FriendlyByteBuf), ($ConsoleLine)>
readonly "console": $ConsoleJS
readonly "timestamp": long
 "message": string
 "type": $LogType
 "group": string
 "sourceLines": $Collection<($SourceLine)>
 "externalFile": $Path
 "stackTrace": $List<(string)>

constructor(arg0: $ConsoleJS$$Type, arg1: long, arg2: string)

public "get"(): $JsonElement
public "toString"(): string
public "getText"(): string
public "toJson"(): $JsonObject
public "withExternalFile"(arg0: $Path$$Type): $ConsoleLine
public "customData"(arg0: string, arg1: $JsonElement$$Type, arg2: boolean): $ConsoleLine
public "withSourceLine"(arg0: $SourceLine$$Type): $ConsoleLine
public "withSourceLine"(arg0: string, arg1: integer): $ConsoleLine
get "text"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsoleLine$$Type = ($ConsoleLine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConsoleLine_ = $ConsoleLine$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Group" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $FluidData$Group extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData$Group)>

constructor(filter: $FluidIngredient$$Type, groupId: $ResourceLocation$$Type, description: $Component$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "filter"(): $FluidIngredient
public "description"(): $Component
public "groupId"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$Group$$Type = ({"filter"?: $FluidIngredient$$Type, "groupId"?: $ResourceLocation$$Type, "description"?: $Component$$Type}) | ([filter?: $FluidIngredient$$Type, groupId?: $ResourceLocation$$Type, description?: $Component$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidData$Group_ = $FluidData$Group$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ArmorMaterialBuilder" {
import {$ArmorMaterial, $ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ArmorMaterial$Layer, $ArmorMaterial$Layer$$Type} from "net.minecraft.world.item.ArmorMaterial$Layer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ArmorMaterialBuilder extends $BuilderBase<($ArmorMaterial)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "layers"(arg0: ($ArmorMaterial$Layer$$Type)[]): this
public "defense"(arg0: $Map$$Type<($ArmorItem$Type$$Type), (integer)>): this
public "equipSound"(arg0: $Holder$$Type<($SoundEvent)>): this
public "toughness"(arg0: float): this
public "enchantmentValue"(arg0: integer): this
public "repairIngredient"(arg0: $Supplier$$Type<($Ingredient$$Type)>): this
public "knockbackResistance"(arg0: float): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorMaterialBuilder$$Type = ($ArmorMaterialBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorMaterialBuilder_ = $ArmorMaterialBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.KubeJSContextFactory" {
import {$ContextFactory, $ContextFactory$$Type} from "dev.latvian.mods.rhino.ContextFactory"
import {$ScriptManager, $ScriptManager$$Type} from "dev.latvian.mods.kubejs.script.ScriptManager"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $KubeJSContextFactory extends $ContextFactory {
readonly "manager": $ScriptManager

constructor(arg0: $ScriptManager$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSContextFactory$$Type = ($KubeJSContextFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSContextFactory_ = $KubeJSContextFactory$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.BasicBlockJS$Builder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $BasicBlockJS$Builder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicBlockJS$Builder$$Type = ($BasicBlockJS$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicBlockJS$Builder_ = $BasicBlockJS$Builder$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaFunction" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"

export interface $RecipeSchemaFunction {

 "execute"(arg1: $KubeRecipe$$Type, arg2: (any)[]): void
 "getArgTypes"(): ($TypeInfo)[]

(arg1: $KubeRecipe, arg2: (any)[]): void
get "argTypes"(): ($TypeInfo)[]
}

export namespace $RecipeSchemaFunction {
const probejs$$marker: never
}
export class $RecipeSchemaFunction$$Static implements $RecipeSchemaFunction {


 "execute"(arg1: $KubeRecipe$$Type, arg2: (any)[]): void
 "getArgTypes"(): ($TypeInfo)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaFunction$$Type = ((arg1: $KubeRecipe, arg2: (any)[]) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeSchemaFunction_ = $RecipeSchemaFunction$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.special.ShapedKubeJSRecipe$SerializerKJS" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ShapedKubeJSRecipe, $ShapedKubeJSRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.special.ShapedKubeJSRecipe"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Recipe, $Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"
import {$RecipeSerializer, $RecipeSerializer$$Type} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $ShapedKubeJSRecipe$SerializerKJS implements $RecipeSerializer<($ShapedKubeJSRecipe)> {
static readonly "CODEC": $MapCodec<($ShapedKubeJSRecipe)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ShapedKubeJSRecipe)>

constructor()

public "codec"(): $MapCodec<($ShapedKubeJSRecipe)>
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ShapedKubeJSRecipe)>
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedKubeJSRecipe$SerializerKJS$$Type = ($ShapedKubeJSRecipe$SerializerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapedKubeJSRecipe$SerializerKJS_ = $ShapedKubeJSRecipe$SerializerKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.player.PlayerChatReceivedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ServerChatEvent, $ServerChatEvent$$Type} from "net.neoforged.neoforge.event.ServerChatEvent"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $PlayerChatReceivedKubeEvent implements $KubePlayerEvent {

constructor(arg0: $ServerChatEvent$$Type)

public "getMessage"(): string
public "getEntity"(): $Entity
public "getComponent"(): $Component
public "setComponent"(arg0: $Component$$Type): void
public "getUsername"(): string
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "message"(): string
get "entity"(): $Entity
get "component"(): $Component
set "component"(value: $Component$$Type)
get "username"(): string
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerChatReceivedKubeEvent$$Type = ($PlayerChatReceivedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerChatReceivedKubeEvent_ = $PlayerChatReceivedKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.GameRulesKJS" {
import {$GameRules$Value, $GameRules$Value$$Type} from "net.minecraft.world.level.GameRules$Value"

export interface $GameRulesKJS {

 "kjs$set"(arg0: string, arg1: string): void
 "kjs$get"(arg0: string): $GameRules$Value<(any)>
 "kjs$getBoolean"(arg0: string): boolean
 "kjs$getString"(arg0: string): string
 "kjs$getInt"(arg0: string): integer
}

export namespace $GameRulesKJS {
const probejs$$marker: never
}
export class $GameRulesKJS$$Static implements $GameRulesKJS {


 "kjs$set"(arg0: string, arg1: string): void
 "kjs$get"(arg0: string): $GameRules$Value<(any)>
 "kjs$getBoolean"(arg0: string): boolean
 "kjs$getString"(arg0: string): string
 "kjs$getInt"(arg0: string): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRulesKJS$$Type = ($GameRulesKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GameRulesKJS_ = $GameRulesKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.IngredientWrapper" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$SizedIngredient, $SizedIngredient$$Type} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * Various Ingredient related helper methods
 */
export interface $IngredientWrapper {

}

export namespace $IngredientWrapper {
const none: $Ingredient
const all: $Ingredient
function of(arg0: $Ingredient$$Type): $Ingredient
function of(arg0: $Ingredient$$Type, arg1: integer): $SizedIngredient
function first(arg0: $Ingredient$$Type): $ItemStack
function tagKeyOf(arg0: $Ingredient$$Type): $TagKey<($Item)>
function isIngredient(arg0: any): boolean
function containsAnyTag(arg0: $Ingredient$$Type): boolean
const probejs$$marker: never
}
export class $IngredientWrapper$$Static implements $IngredientWrapper {
/**
 * A completely empty ingredient that will only match air
 */
static readonly "none": $Ingredient
/**
 * An ingredient that matches everything
 */
static readonly "all": $Ingredient


/**
 * Returns an ingredient of the input
 */
static "of"(arg0: $Ingredient$$Type): $Ingredient
/**
 * Returns an ingredient of the input, with the specified count
 */
static "of"(arg0: $Ingredient$$Type, arg1: integer): $SizedIngredient
static "first"(arg0: $Ingredient$$Type): $ItemStack
static "tagKeyOf"(arg0: $Ingredient$$Type): $TagKey<($Item)>
/**
 * Checks if the passed in object is an Ingredient.
 * Note that this does not mean it will not function as an Ingredient if passed to something that requests one.
 */
static "isIngredient"(arg0: any): boolean
static "containsAnyTag"(arg0: $Ingredient$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientWrapper$$Type = ($IngredientWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientWrapper_ = $IngredientWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemSmeltedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an item is smelted by a player.
 */
export class $ItemSmeltedKubeEvent implements $KubePlayerEvent {

constructor(arg0: $Player$$Type, arg1: $ItemStack$$Type)

/**
 * The item that was smelted.
 */
public "getItem"(): $ItemStack
/**
 * The player that smelted the item.
 */
public "getEntity"(): $Player
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "item"(): $ItemStack
get "entity"(): $Player
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemSmeltedKubeEvent$$Type = ($ItemSmeltedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemSmeltedKubeEvent_ = $ItemSmeltedKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.BlockDropsKubeEvent" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockDropsEvent, $BlockDropsEvent$$Type} from "net.neoforged.neoforge.event.level.BlockDropsEvent"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$KubeEntityEvent, $KubeEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Modify dropped items and xp from block.
 */
export class $BlockDropsKubeEvent implements $KubeEntityEvent {

constructor(arg0: $BlockDropsEvent$$Type)

public "getLevel"(): $Level
public "getEntity"(): $Entity
public "removeItem"(arg0: $ItemPredicate$$Type): void
/**
 * The block that was broken.
 */
public "getBlock"(): $BlockContainerJS
public "addItem"(arg0: $ItemStack$$Type): $ItemEntity
/**
 * The experience dropped by the block.
 */
public "getXp"(): integer
/**
 * Sets the experience dropped by the block.
 */
public "setXp"(arg0: integer): void
/**
 * The tool used when breaking this block. May be null.
 */
public "getTool"(): $ItemStack
/**
 * Dropped items. Immutable.
 */
public "getItems"(): $List<($ItemStack)>
/**
 * Dropped item entities.
 */
public "getItemEntities"(): $List<($ItemEntity)>
public "containsItem"(arg0: $ItemPredicate$$Type): boolean
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "level"(): $Level
get "entity"(): $Entity
get "block"(): $BlockContainerJS
get "xp"(): integer
set "xp"(value: integer)
get "tool"(): $ItemStack
get "items"(): $List<($ItemStack)>
get "itemEntities"(): $List<($ItemEntity)>
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDropsKubeEvent$$Type = ($BlockDropsKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockDropsKubeEvent_ = $BlockDropsKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.SlotFilter" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $SlotFilter extends $Record {
static readonly "EMPTY": $SlotFilter
static readonly "TYPE_INFO": $TypeInfo
static readonly "CODEC": $Codec<($SlotFilter)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($SlotFilter)>

constructor(item: $Ingredient$$Type, index: integer)

public "index"(): integer
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "wrap"(arg1: any, arg2: $TypeInfo$$Type): $SlotFilter
public static "of"(arg0: $Ingredient$$Type, arg1: integer): $SlotFilter
public "item"(): $Ingredient
public "checkFilter"(arg0: integer, arg1: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotFilter$$Type = ({"item"?: $Ingredient$$Type, "index"?: integer}) | ([item?: $Ingredient$$Type, index?: integer]) | ((integer) | ($Ingredient$$Type) | ({"item"?: $Ingredient$$Type, "index"?: integer}) | ([item?: $Ingredient$$Type, index?: integer]));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotFilter_ = $SlotFilter$$Type;
}}
declare module "dev.latvian.mods.rhino.Callable" {
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"

export interface $Callable {

 "call"(arg1: $Scriptable$$Type, arg2: $Scriptable$$Type, arg3: (any)[]): any

(arg1: $Scriptable, arg2: $Scriptable, arg3: (any)[]): any
}

export namespace $Callable {
const probejs$$marker: never
}
export class $Callable$$Static implements $Callable {


 "call"(arg1: $Scriptable$$Type, arg2: $Scriptable$$Type, arg3: (any)[]): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Callable$$Type = ((arg1: $Scriptable, arg2: $Scriptable, arg3: (any)[]) => any);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Callable_ = $Callable$$Type;
}}
declare module "dev.latvian.mods.kubejs.event.TargetedEventHandler" {
import {$EventHandler, $EventHandler$$Type} from "dev.latvian.mods.kubejs.event.EventHandler"
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$EventGroup, $EventGroup$$Type} from "dev.latvian.mods.kubejs.event.EventGroup"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$DefaultValueTypeHint, $DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$ScriptTypeHolder, $ScriptTypeHolder$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$ScriptTypePredicate, $ScriptTypePredicate$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$EventHandlerContainer, $EventHandlerContainer$$Type} from "dev.latvian.mods.kubejs.event.EventHandlerContainer"
import {$EventResult, $EventResult$$Type} from "dev.latvian.mods.kubejs.event.EventResult"

export class $TargetedEventHandler<E> extends $EventHandler {
readonly "group": $EventGroup
readonly "name": string
readonly "scriptTypePredicate": $ScriptTypePredicate
readonly "eventType": $Supplier<($Class<($KubeEvent)>)>
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "post"(arg0: $ScriptTypeHolder$$Type, arg1: E, arg2: $KubeEvent$$Type): $EventResult
public "post"(arg0: $KubeEvent$$Type, arg1: E): $EventResult
public "hasListeners"(arg0: E): boolean
public "hasListeners"(): boolean
public "hasResult"(): $EventHandler
public "forEachListener"(arg0: $ScriptType$$Type, arg1: $Consumer$$Type<($EventHandlerContainer)>): void
public "findUniqueExtraIds"(arg0: $ScriptType$$Type): $Set<(E)>
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "getAllIds"(): (any)[]
public "getIds"(): (any)[]
public "getParentScope"(): $Scriptable
public "getPrototype"(): $Scriptable
public "setPrototype"(arg0: $Scriptable$$Type): void
public "setParentScope"(arg0: $Scriptable$$Type): void
get "allIds"(): (any)[]
get "ids"(): (any)[]
get "parentScope"(): $Scriptable
get "prototype"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
set "parentScope"(value: $Scriptable$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TargetedEventHandler$$Type<E> = ($TargetedEventHandler<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TargetedEventHandler_<E> = $TargetedEventHandler$$Type<(E)>;
}}
declare module "dev.latvian.mods.kubejs.block.BlockBrokenKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockEvent$BreakEvent, $BlockEvent$BreakEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$BreakEvent"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a block is destroyed by a player.
 */
export class $BlockBrokenKubeEvent implements $KubePlayerEvent {

constructor(arg0: $BlockEvent$BreakEvent$$Type)

/**
 * The player that broke the block.
 */
public "getEntity"(): $LivingEntity
/**
 * The block that was broken.
 */
public "getBlock"(): $BlockContainerJS
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "entity"(): $LivingEntity
get "block"(): $BlockContainerJS
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBrokenKubeEvent$$Type = ($BlockBrokenKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBrokenKubeEvent_ = $BlockBrokenKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.misc.VillagerTypeBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$VillagerType, $VillagerType$$Type} from "net.minecraft.world.entity.npc.VillagerType"

export class $VillagerTypeBuilder extends $BuilderBase<($VillagerType)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VillagerTypeBuilder$$Type = ($VillagerTypeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VillagerTypeBuilder_ = $VillagerTypeBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemDroppedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player drops an item.
 */
export class $ItemDroppedKubeEvent implements $KubePlayerEvent {

constructor(arg0: $Player$$Type, arg1: $ItemEntity$$Type)

/**
 * The item that was dropped.
 */
public "getItem"(): $ItemStack
/**
 * The player that dropped the item.
 */
public "getEntity"(): $Entity
/**
 * The item entity that was spawned when dropping.
 */
public "getItemEntity"(): $ItemEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "item"(): $ItemStack
get "entity"(): $Entity
get "itemEntity"(): $ItemEntity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDroppedKubeEvent$$Type = ($ItemDroppedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDroppedKubeEvent_ = $ItemDroppedKubeEvent$$Type;
}}
declare module "dev.latvian.apps.tinyserver.ws.WSSession" {
import {$Frame, $Frame$$Type} from "dev.latvian.apps.tinyserver.ws.Frame"
import {$WSCloseStatus, $WSCloseStatus$$Type} from "dev.latvian.apps.tinyserver.ws.WSCloseStatus"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Socket, $Socket$$Type} from "java.net.Socket"
import {$StatusCode, $StatusCode$$Type} from "dev.latvian.apps.tinyserver.StatusCode"
import {$Throwable, $Throwable$$Type} from "java.lang.Throwable"
import {$HTTPRequest, $HTTPRequest$$Type} from "dev.latvian.apps.tinyserver.http.HTTPRequest"
import {$InputStream, $InputStream$$Type} from "java.io.InputStream"
import {$OutputStream, $OutputStream$$Type} from "java.io.OutputStream"

export class $WSSession<REQ extends $HTTPRequest> {

constructor()

public "id"(): $UUID
public "start"(arg0: $Socket$$Type, arg1: $InputStream$$Type, arg2: $OutputStream$$Type): void
public "close"(arg0: $WSCloseStatus$$Type, arg1: string): void
public "onClose"(arg0: $StatusCode$$Type, arg1: boolean): void
public "send"(arg0: $Frame$$Type): void
public "onError"(arg0: $Throwable$$Type): void
public "sendText"(arg0: string): void
public "sendBinary"(arg0: (byte)[]): void
public "onBinaryMessage"(arg0: (byte)[]): void
public "onTextMessage"(arg0: string): void
public "onOpen"(arg0: REQ): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WSSession$$Type<REQ> = ($WSSession<(REQ)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WSSession_<REQ> = $WSSession$$Type<(REQ)>;
}}
declare module "dev.latvian.mods.kubejs.util.ID" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"

export interface $ID {

}

export namespace $ID {
const UNKNOWN: $ResourceLocation
const BLOCKSTATE: $UnaryOperator<(string)>
const BLOCK: $UnaryOperator<(string)>
const ITEM: $UnaryOperator<(string)>
const MODEL: $UnaryOperator<(string)>
const BLOCK_MODEL: $UnaryOperator<(string)>
const ITEM_MODEL: $UnaryOperator<(string)>
const BLOCK_LOOT_TABLE: $UnaryOperator<(string)>
const PNG_TEXTURE: $UnaryOperator<(string)>
const PNG_TEXTURE_MCMETA: $UnaryOperator<(string)>
const PARTICLE: $UnaryOperator<(string)>
function of(arg0: any, arg1: boolean): $ResourceLocation
function url(arg0: $ResourceLocation$$Type): string
function mc(arg0: any): $ResourceLocation
function path(arg0: string): string
function string(arg0: string): string
function isKey(arg0: any): boolean
function namespace(arg0: string): string
function kjs(arg0: any): $ResourceLocation
function kjsString(arg0: string): string
const probejs$$marker: never
}
export class $ID$$Static implements $ID {
static readonly "UNKNOWN": $ResourceLocation
static readonly "BLOCKSTATE": $UnaryOperator<(string)>
static readonly "BLOCK": $UnaryOperator<(string)>
static readonly "ITEM": $UnaryOperator<(string)>
static readonly "MODEL": $UnaryOperator<(string)>
static readonly "BLOCK_MODEL": $UnaryOperator<(string)>
static readonly "ITEM_MODEL": $UnaryOperator<(string)>
static readonly "BLOCK_LOOT_TABLE": $UnaryOperator<(string)>
static readonly "PNG_TEXTURE": $UnaryOperator<(string)>
static readonly "PNG_TEXTURE_MCMETA": $UnaryOperator<(string)>
static readonly "PARTICLE": $UnaryOperator<(string)>


static "of"(arg0: any, arg1: boolean): $ResourceLocation
static "url"(arg0: $ResourceLocation$$Type): string
static "mc"(arg0: any): $ResourceLocation
static "path"(arg0: string): string
static "string"(arg0: string): string
static "isKey"(arg0: any): boolean
static "namespace"(arg0: string): string
static "kjs"(arg0: any): $ResourceLocation
static "kjsString"(arg0: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ID$$Type = ($ID);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ID_ = $ID$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Model" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"

export class $VariantBlockStateGenerator$Model {

constructor()

public "x"(arg0: integer): $VariantBlockStateGenerator$Model
public "y"(arg0: integer): $VariantBlockStateGenerator$Model
public "model"(arg0: $ResourceLocation$$Type): $VariantBlockStateGenerator$Model
public "toJson"(): $JsonObject
public "uvlock"(): $VariantBlockStateGenerator$Model
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$Model$$Type = ($VariantBlockStateGenerator$Model);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariantBlockStateGenerator$Model_ = $VariantBlockStateGenerator$Model$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.BlockWrapper" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockEntityPredicate, $BlockEntityPredicate$$Type} from "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicate"
import {$BlockIDPredicate, $BlockIDPredicate$$Type} from "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate"
import {$BlockSetType, $BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$BlockPredicate, $BlockPredicate$$Type} from "dev.latvian.mods.kubejs.block.predicate.BlockPredicate"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

/**
 * Various block related helper functions
 */
export class $BlockWrapper {
static readonly "TYPE_INFO": $TypeInfo
static readonly "STATE_TYPE_INFO": $TypeInfo

constructor()

public static "id"(arg0: $ResourceLocation$$Type, arg1: $Map$$Type<(string), (any)>): $BlockIDPredicate
public static "id"(arg0: $ResourceLocation$$Type): $BlockIDPredicate
/**
 * Gets a blocks id from the Block
 */
public static "getId"(arg0: $Block$$Type): $ResourceLocation
public static "custom"(arg0: $BlockPredicate$$Type): $BlockPredicate
public static "withProperties"(arg0: $BlockState$$Type, arg1: $Map$$Type<(any), (any)>): $BlockState
public static "entity"(arg0: $ResourceLocation$$Type): $BlockEntityPredicate
/**
 * Gets a Block from a block id
 */
public static "getBlock"(arg0: $ResourceLocation$$Type): $Block
/**
 * Gets a list of the classname of all registered blocks
 */
public static "getTypeList"(): $List<(string)>
/**
 * Get a map of direction name to Direction. Functionally identical to Direction.ALL
 */
public static "getFacing"(): $Map<(string), ($Direction)>
/**
 * Parses a block state from the input string. May throw for invalid inputs!
 */
public static "wrapBlockState"(arg0: $RegistryAccessContainer$$Type, arg1: any): $BlockState
public static "setTypeOf"(arg1: any, arg2: $TypeInfo$$Type): $BlockSetType
public static "parseBlockState"(arg0: $RegistryAccessContainer$$Type, arg1: string): $BlockState
/**
 * Gets a list of all blocks with tags
 */
public static "getTaggedIds"(arg0: $ResourceLocation$$Type): $List<($ResourceLocation)>
public static "getAllBlockStates"(): $Collection<($BlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockWrapper$$Type = ($BlockWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockWrapper_ = $BlockWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Hoe" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DiggerItemBuilder, $DiggerItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem, $DiggerItem$$Type} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Hoe extends $DiggerItemBuilder {
static readonly "HOE_TAGS": ($ResourceLocation)[]
static readonly "HOE_MODEL": $ResourceLocation
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Hoe$$Type = ($DiggerItemBuilder$Hoe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DiggerItemBuilder$Hoe_ = $DiggerItemBuilder$Hoe$$Type;
}}
declare module "dev.latvian.mods.kubejs.fluid.FluidLike" {
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"

export interface $FluidLike extends $ReplacementMatch {

 "isEmpty"(): boolean
 "getFluid"(): $Fluid
 "getAmount"(): integer
 "copy"(arg0: integer): $FluidLike
get "empty"(): boolean
get "fluid"(): $Fluid
get "amount"(): integer
}

export namespace $FluidLike {
function wrap(arg1: any): $ReplacementMatch
const probejs$$marker: never
}
export class $FluidLike$$Static implements $FluidLike {


 "isEmpty"(): boolean
 "getFluid"(): $Fluid
 "getAmount"(): integer
 "copy"(arg0: integer): $FluidLike
static "wrap"(arg1: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidLike$$Type = ($FluidLike);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidLike_ = $FluidLike$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.special.SpecialRecipeSerializerManager" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Recipe, $Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"

export class $SpecialRecipeSerializerManager implements $KubeEvent {
static readonly "INSTANCE": $SpecialRecipeSerializerManager

constructor()

public "reset"(): void
public "ignoreSpecialFlag"(arg0: $ResourceLocation$$Type): void
public "ignoreSpecialMod"(arg0: string): void
public "addSpecialFlag"(arg0: $ResourceLocation$$Type): void
public "addSpecialMod"(arg0: string): void
public "isSpecial"(arg0: $Recipe$$Type<(any)>): boolean
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialRecipeSerializerManager$$Type = ($SpecialRecipeSerializerManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpecialRecipeSerializerManager_ = $SpecialRecipeSerializerManager$$Type;
}}
declare module "dev.latvian.mods.kubejs.mekanism.KubeChemicalBuilder$Pigment" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$KubeChemicalBuilder, $KubeChemicalBuilder$$Type} from "dev.latvian.mods.kubejs.mekanism.KubeChemicalBuilder"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $KubeChemicalBuilder$Pigment extends $KubeChemicalBuilder {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeChemicalBuilder$Pigment$$Type = ($KubeChemicalBuilder$Pigment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeChemicalBuilder$Pigment_ = $KubeChemicalBuilder$Pigment$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.FoodBuilder" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$FoodEatenKubeEvent, $FoodEatenKubeEvent$$Type} from "dev.latvian.mods.kubejs.item.FoodEatenKubeEvent"
import {$MobEffect, $MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$FoodProperties, $FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"

export class $FoodBuilder {

constructor()
constructor(arg0: $FoodProperties$$Type)

public "build"(): $FoodProperties
/**
 * Adds an effect to the food. Note that the effect duration is in ticks (20 ticks = 1 second).
 * 
 * @param mobEffectId - The id of the effect. Can be either a string or a ResourceLocation.
 * @param duration - The duration of the effect in ticks.
 * @param amplifier - The amplifier of the effect. 0 means level 1, 1 means level 2, etc.
 * @param probability - The probability of the effect being applied. 1 = 100%.
 */
public "effect"(arg0: $ResourceLocation$$Type, arg1: integer, arg2: integer, arg3: float): $FoodBuilder
/**
 * Sets the saturation modifier. Note that the saturation restored is hunger * saturation.
 */
public "saturation"(arg0: float): $FoodBuilder
/**
 * Sets a callback that is called when the food is eaten.
 * 
 * Note: This is currently not having effect in `ItemEvents.modification`,
 * as firing this callback requires an `ItemBuilder` instance in the `Item`.
 */
public "eaten"(arg0: $Consumer$$Type<($FoodEatenKubeEvent)>): $FoodBuilder
/**
 * Sets seconds it takes to eat the food.
 */
public "eatSeconds"(arg0: float): $FoodBuilder
public "usingConvertsTo"(arg0: $ItemStack$$Type): $FoodBuilder
/**
 * Removes an effect from the food.
 */
public "removeEffect"(arg0: $MobEffect$$Type): $FoodBuilder
/**
 * Sets the hunger restored.
 */
public "nutrition"(arg0: integer): $FoodBuilder
/**
 * Sets the food is fast to eat (having half of the eating time).
 */
public "fastToEat"(): $FoodBuilder
/**
 * Sets whether the food is always edible.
 */
public "alwaysEdible"(arg0: boolean): $FoodBuilder
/**
 * Sets the food is always edible.
 */
public "alwaysEdible"(): $FoodBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoodBuilder$$Type = ($FoodBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FoodBuilder_ = $FoodBuilder$$Type;
}}
declare module "dev.latvian.mods.rhino.type.TypeInfo" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Type, $Type$$Type} from "java.lang.reflect.Type"
import {$List, $List$$Type} from "java.util.List"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$RecordTypeInfo$Component, $RecordTypeInfo$Component$$Type} from "dev.latvian.mods.rhino.type.RecordTypeInfo$Component"
import {$TypeStringContext, $TypeStringContext$$Type} from "dev.latvian.mods.rhino.type.TypeStringContext"

export interface $TypeInfo {

 "signature"(): string
 "append"(ctx: $TypeStringContext$$Type, sb: $StringBuilder$$Type): void
 "isPrimitive"(): boolean
 "newArray"(length: integer): any
 "componentType"(): $TypeInfo
 "enumConstants"(): $List<(any)>
 "param"(index: integer): $TypeInfo
 "isVoid"(): boolean
 "is"(info: $TypeInfo$$Type): boolean
 "or"(info: $TypeInfo$$Type): $TypeInfo
 "isCharacter"(): boolean
 "isFloat"(): boolean
 "asArray"(): $TypeInfo
 "isBoolean"(): boolean
 "recordComponents"(): $Map<(string), ($RecordTypeInfo$Component)>
 "asClass"(): $Class<(any)>
 "getContainedComponentClasses"(): $Set<($Class<(any)>)>
 "collectContainedComponentClasses"(classes: $Collection$$Type<($Class$$Type<(any)>)>): void
 "withParams"(...params: ($TypeInfo$$Type)[]): $TypeInfo
 "isDouble"(): boolean
 "isFunctionalInterface"(): boolean
 "shouldConvert"(): boolean
 "isLong"(): boolean
 "isInt"(): boolean
 "isShort"(): boolean
 "isByte"(): boolean
 "createDefaultValue"(): any

(): $Class$$Type<(any)>
get "primitive"(): boolean
get "void"(): boolean
get "character"(): boolean
get "float"(): boolean
get "boolean"(): boolean
get "containedComponentClasses"(): $Set<($Class<(any)>)>
get "double"(): boolean
get "functionalInterface"(): boolean
get "long"(): boolean
get "int"(): boolean
get "short"(): boolean
get "byte"(): boolean
}

export namespace $TypeInfo {
const NONE: $TypeInfo
const EMPTY_ARRAY: ($TypeInfo)[]
const OBJECT: $TypeInfo
const OBJECT_ARRAY: $TypeInfo
const PRIMITIVE_VOID: $TypeInfo
const PRIMITIVE_BOOLEAN: $TypeInfo
const PRIMITIVE_BYTE: $TypeInfo
const PRIMITIVE_SHORT: $TypeInfo
const PRIMITIVE_INT: $TypeInfo
const PRIMITIVE_LONG: $TypeInfo
const PRIMITIVE_FLOAT: $TypeInfo
const PRIMITIVE_DOUBLE: $TypeInfo
const PRIMITIVE_CHARACTER: $TypeInfo
const VOID: $TypeInfo
const BOOLEAN: $TypeInfo
const BYTE: $TypeInfo
const SHORT: $TypeInfo
const INT: $TypeInfo
const LONG: $TypeInfo
const FLOAT: $TypeInfo
const DOUBLE: $TypeInfo
const CHARACTER: $TypeInfo
const NUMBER: $TypeInfo
const STRING: $TypeInfo
const STRING_ARRAY: $TypeInfo
const CLASS: $TypeInfo
const DATE: $TypeInfo
const RUNNABLE: $TypeInfo
const RAW_CONSUMER: $TypeInfo
const RAW_SUPPLIER: $TypeInfo
const RAW_FUNCTION: $TypeInfo
const RAW_PREDICATE: $TypeInfo
const RAW_LIST: $TypeInfo
const RAW_SET: $TypeInfo
const RAW_MAP: $TypeInfo
const RAW_OPTIONAL: $TypeInfo
const RAW_ENUM_SET: $TypeInfo
function of(type: $Type$$Type): $TypeInfo
function of(c: $Class$$Type<(any)>): $TypeInfo
function ofArray(array: ($Type$$Type)[]): ($TypeInfo)[]
const probejs$$marker: never
}
export class $TypeInfo$$Static implements $TypeInfo {
static readonly "NONE": $TypeInfo
static readonly "EMPTY_ARRAY": ($TypeInfo)[]
static readonly "OBJECT": $TypeInfo
static readonly "OBJECT_ARRAY": $TypeInfo
static readonly "PRIMITIVE_VOID": $TypeInfo
static readonly "PRIMITIVE_BOOLEAN": $TypeInfo
static readonly "PRIMITIVE_BYTE": $TypeInfo
static readonly "PRIMITIVE_SHORT": $TypeInfo
static readonly "PRIMITIVE_INT": $TypeInfo
static readonly "PRIMITIVE_LONG": $TypeInfo
static readonly "PRIMITIVE_FLOAT": $TypeInfo
static readonly "PRIMITIVE_DOUBLE": $TypeInfo
static readonly "PRIMITIVE_CHARACTER": $TypeInfo
static readonly "VOID": $TypeInfo
static readonly "BOOLEAN": $TypeInfo
static readonly "BYTE": $TypeInfo
static readonly "SHORT": $TypeInfo
static readonly "INT": $TypeInfo
static readonly "LONG": $TypeInfo
static readonly "FLOAT": $TypeInfo
static readonly "DOUBLE": $TypeInfo
static readonly "CHARACTER": $TypeInfo
static readonly "NUMBER": $TypeInfo
static readonly "STRING": $TypeInfo
static readonly "STRING_ARRAY": $TypeInfo
static readonly "CLASS": $TypeInfo
static readonly "DATE": $TypeInfo
static readonly "RUNNABLE": $TypeInfo
static readonly "RAW_CONSUMER": $TypeInfo
static readonly "RAW_SUPPLIER": $TypeInfo
static readonly "RAW_FUNCTION": $TypeInfo
static readonly "RAW_PREDICATE": $TypeInfo
static readonly "RAW_LIST": $TypeInfo
static readonly "RAW_SET": $TypeInfo
static readonly "RAW_MAP": $TypeInfo
static readonly "RAW_OPTIONAL": $TypeInfo
static readonly "RAW_ENUM_SET": $TypeInfo


 "signature"(): string
 "append"(ctx: $TypeStringContext$$Type, sb: $StringBuilder$$Type): void
 "isPrimitive"(): boolean
 "newArray"(length: integer): any
 "componentType"(): $TypeInfo
static "of"(type: $Type$$Type): $TypeInfo
static "of"(c: $Class$$Type<(any)>): $TypeInfo
 "enumConstants"(): $List<(any)>
 "param"(index: integer): $TypeInfo
 "isVoid"(): boolean
 "is"(info: $TypeInfo$$Type): boolean
 "or"(info: $TypeInfo$$Type): $TypeInfo
 "isCharacter"(): boolean
 "isFloat"(): boolean
 "asArray"(): $TypeInfo
 "isBoolean"(): boolean
 "recordComponents"(): $Map<(string), ($RecordTypeInfo$Component)>
 "asClass"(): $Class<(any)>
static "ofArray"(array: ($Type$$Type)[]): ($TypeInfo)[]
 "getContainedComponentClasses"(): $Set<($Class<(any)>)>
 "collectContainedComponentClasses"(classes: $Collection$$Type<($Class$$Type<(any)>)>): void
 "withParams"(...params: ($TypeInfo$$Type)[]): $TypeInfo
 "isDouble"(): boolean
 "isFunctionalInterface"(): boolean
 "shouldConvert"(): boolean
 "isLong"(): boolean
 "isInt"(): boolean
 "isShort"(): boolean
 "isByte"(): boolean
 "createDefaultValue"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeInfo$$Type = (() => $Class$$Type<(any)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeInfo_ = $TypeInfo$$Type;
}}
declare module "dev.latvian.mods.kubejs.player.InventoryChangedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player's inventory changes.
 */
export class $InventoryChangedKubeEvent implements $KubePlayerEvent {

constructor(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: integer)

/**
 * Gets the slot that was changed.
 */
public "getSlot"(): integer
/**
 * Gets the item that was changed.
 */
public "getItem"(): $ItemStack
/**
 * Gets the player that changed their inventory.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "slot"(): integer
get "item"(): $ItemStack
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryChangedKubeEvent$$Type = ($InventoryChangedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryChangedKubeEvent_ = $InventoryChangedKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Info" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $FluidData$Info extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData$Info)>

constructor(filter: $FluidIngredient$$Type, info: $List$$Type<($Component$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "filter"(): $FluidIngredient
public "info"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$Info$$Type = ({"filter"?: $FluidIngredient$$Type, "info"?: $List$$Type<($Component$$Type)>}) | ([filter?: $FluidIngredient$$Type, info?: $List$$Type<($Component$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidData$Info_ = $FluidData$Info$$Type;
}}
declare module "dev.latvian.mods.kubejs.component.MutableDataComponentHolderFunctions" {
import {$ComponentFunctions, $ComponentFunctions$$Type} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$Potion, $Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$MutableDataComponentHolder, $MutableDataComponentHolder$$Type} from "net.neoforged.neoforge.common.MutableDataComponentHolder"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$ItemAttributeModifiers$Entry, $ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$List, $List$$Type} from "java.util.List"
import {$Rarity, $Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents, $PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Unit, $Unit$$Type} from "net.minecraft.util.Unit"

export interface $MutableDataComponentHolderFunctions extends $ComponentFunctions {

 "set"(arg1: $DataComponentMap$$Type): this
 "patch"(arg1: $DataComponentPatch$$Type): $ComponentFunctions
 "getComponentHolder"(): $MutableDataComponentHolder
 "getComponentMap"(): $DataComponentMap
 "setAttributeModifiersWithTooltip"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
 "setUnit"(arg0: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "setLockCode"(arg0: string): void
 "setCustomData"(arg0: $CompoundTag$$Type): void
 "setRarity"(arg0: $Rarity$$Type): void
 "setCustomName"(arg0: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(arg0: $List$$Type<($Component$$Type)>): void
 "setLore"(arg0: $List$$Type<($Component$$Type)>, arg1: $List$$Type<($Component$$Type)>): void
 "setDyedColor"(arg0: $KubeColor$$Type): void
 "getCustomData"(): $CompoundTag
 "setPotionId"(arg0: $Holder$$Type<($Potion)>): void
 "setEntityData"(arg0: $CompoundTag$$Type): void
 "setProfile"(arg0: $GameProfile$$Type): void
 "setProfile"(arg0: string, arg1: $UUID$$Type): void
 "setBaseColor"(arg0: $DyeColor$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(arg0: $Map$$Type<(string), (string)>): void
 "setDyedColorWithTooltip"(arg0: $KubeColor$$Type): void
 "set"(arg1: $DataComponentType$$Type<(any)>, arg2: any): $ComponentFunctions
 "get"<T>(arg0: $DataComponentType$$Type<(T)>): T
 "remove"(arg0: $DataComponentType$$Type<(any)>): $ComponentFunctions
 "setPotionContents"(arg0: $PotionContents$$Type): void
 "setGlintOverride"(arg0: boolean): void
 "getComponentString"(): string
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
 "setTooltipHidden"(): void
 "setCustomModelData"(arg0: integer): void
 "resetComponents"(): $ComponentFunctions
 "setAttributeModifiers"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
get "componentHolder"(): $MutableDataComponentHolder
get "componentMap"(): $DataComponentMap
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
set "lockCode"(value: string)
set "customData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "customName"(value: $Component$$Type)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "dyedColor"(value: $KubeColor$$Type)
get "customData"(): $CompoundTag
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(string), (string)>)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
set "glintOverride"(value: boolean)
get "componentString"(): string
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
set "customModelData"(value: integer)
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
}

export namespace $MutableDataComponentHolderFunctions {
const probejs$$marker: never
}
export class $MutableDataComponentHolderFunctions$$Static implements $MutableDataComponentHolderFunctions {


 "set"(arg1: $DataComponentMap$$Type): this
 "patch"(arg1: $DataComponentPatch$$Type): $ComponentFunctions
 "getComponentHolder"(): $MutableDataComponentHolder
 "getComponentMap"(): $DataComponentMap
 "setAttributeModifiersWithTooltip"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
 "setUnit"(arg0: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "setLockCode"(arg0: string): void
 "setCustomData"(arg0: $CompoundTag$$Type): void
 "setRarity"(arg0: $Rarity$$Type): void
 "setCustomName"(arg0: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(arg0: $List$$Type<($Component$$Type)>): void
 "setLore"(arg0: $List$$Type<($Component$$Type)>, arg1: $List$$Type<($Component$$Type)>): void
 "setDyedColor"(arg0: $KubeColor$$Type): void
 "getCustomData"(): $CompoundTag
 "setPotionId"(arg0: $Holder$$Type<($Potion)>): void
 "setEntityData"(arg0: $CompoundTag$$Type): void
 "setProfile"(arg0: $GameProfile$$Type): void
 "setProfile"(arg0: string, arg1: $UUID$$Type): void
 "setBaseColor"(arg0: $DyeColor$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(arg0: $Map$$Type<(string), (string)>): void
 "setDyedColorWithTooltip"(arg0: $KubeColor$$Type): void
 "set"(arg1: $DataComponentType$$Type<(any)>, arg2: any): $ComponentFunctions
 "get"<T>(arg0: $DataComponentType$$Type<(T)>): T
 "remove"(arg0: $DataComponentType$$Type<(any)>): $ComponentFunctions
 "setPotionContents"(arg0: $PotionContents$$Type): void
 "setGlintOverride"(arg0: boolean): void
 "getComponentString"(): string
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
 "setTooltipHidden"(): void
 "setCustomModelData"(arg0: integer): void
 "resetComponents"(): $ComponentFunctions
 "setAttributeModifiers"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableDataComponentHolderFunctions$$Type = ($MutableDataComponentHolderFunctions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutableDataComponentHolderFunctions_ = $MutableDataComponentHolderFunctions$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.LangKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Pattern, $Pattern$$Type} from "java.util.regex.Pattern"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$LangKubeEvent$Key, $LangKubeEvent$Key$$Type} from "dev.latvian.mods.kubejs.client.LangKubeEvent$Key"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $LangKubeEvent extends $Record implements $KubeEvent {
static readonly "PATTERN": $Pattern

constructor(lang: string, map: $Map$$Type<($LangKubeEvent$Key$$Type), (string)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "add"(arg0: string, arg1: string, arg2: string): void
public "add"(arg0: string, arg1: string): void
public "map"(): $Map<($LangKubeEvent$Key), (string)>
public "addAll"(arg0: string, arg1: $Map$$Type<(string), (string)>): void
public "addAll"(arg0: $Map$$Type<(string), (string)>): void
public "lang"(): string
public "renameItem"(arg0: $ItemStack$$Type, arg1: string): void
public "renameBlock"(arg0: $Block$$Type, arg1: string): void
public "renameEntity"(arg0: $ResourceLocation$$Type, arg1: string): void
public "renameBiome"(arg0: $ResourceLocation$$Type, arg1: string): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LangKubeEvent$$Type = ({"map"?: $Map$$Type<($LangKubeEvent$Key$$Type), (string)>, "lang"?: string}) | ([map?: $Map$$Type<($LangKubeEvent$Key$$Type), (string)>, lang?: string]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LangKubeEvent_ = $LangKubeEvent$$Type;
}}
declare module "dev.latvian.apps.tinyserver.ws.Frame" {
import {$InputStream, $InputStream$$Type} from "java.io.InputStream"
import {$Opcode, $Opcode$$Type} from "dev.latvian.apps.tinyserver.ws.Opcode"
import {$OutputStream, $OutputStream$$Type} from "java.io.OutputStream"
import {$Random, $Random$$Type} from "java.util.Random"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $Frame extends $Record {

constructor(opcode: $Opcode$$Type, mask: boolean, fin: boolean, rsv1: boolean, rsv2: boolean, rsv3: boolean, payload: (byte)[])

public "payload"(): (byte)[]
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "write"(arg0: $Random$$Type, arg1: $OutputStream$$Type): void
public static "read"(arg0: $InputStream$$Type): $Frame
public "mask"(): boolean
public "appendTo"(arg0: $Frame$$Type): $Frame
public static "text"(arg0: string): $Frame
public "opcode"(): $Opcode
public "fin"(): boolean
public static "simple"(arg0: $Opcode$$Type, arg1: boolean, arg2: (byte)[]): $Frame
public static "binary"(arg0: (byte)[]): $Frame
public "rsv1"(): boolean
public "rsv2"(): boolean
public "rsv3"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Frame$$Type = ({"rsv1"?: boolean, "rsv2"?: boolean, "rsv3"?: boolean, "mask"?: boolean, "fin"?: boolean, "opcode"?: $Opcode$$Type, "payload"?: (byte)[]}) | ([rsv1?: boolean, rsv2?: boolean, rsv3?: boolean, mask?: boolean, fin?: boolean, opcode?: $Opcode$$Type, payload?: (byte)[]]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Frame_ = $Frame$$Type;
}}
declare module "dev.latvian.mods.kubejs.misc.VillagerProfessionBuilder" {
import {$VillagerProfession, $VillagerProfession$$Type} from "net.minecraft.world.entity.npc.VillagerProfession"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $VillagerProfessionBuilder extends $BuilderBase<($VillagerProfession)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "poiType"(arg0: $ResourceLocation$$Type): this
public "workSound"(arg0: $SoundEvent$$Type): this
public "secondaryPoi"(arg0: ($Block$$Type)[]): this
public "requestedItems"(arg0: ($Item$$Type)[]): this
public "poiTypeTag"(arg0: $ResourceLocation$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VillagerProfessionBuilder$$Type = ($VillagerProfessionBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VillagerProfessionBuilder_ = $VillagerProfessionBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.ConsoleJS" {
import {$ContextFactory, $ContextFactory$$Type} from "dev.latvian.mods.rhino.ContextFactory"
import {$KJSWSSession, $KJSWSSession$$Type} from "dev.latvian.mods.kubejs.web.KJSWSSession"
import {$Pattern, $Pattern$$Type} from "java.util.regex.Pattern"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$WeakReference, $WeakReference$$Type} from "java.lang.ref.WeakReference"
import {$LogType, $LogType$$Type} from "dev.latvian.mods.kubejs.util.LogType"
import {$HTTPResponse, $HTTPResponse$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPResponse"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Throwable, $Throwable$$Type} from "java.lang.Throwable"
import {$WSHandler, $WSHandler$$Type} from "dev.latvian.apps.tinyserver.ws.WSHandler"
import {$KJSHTTPRequest, $KJSHTTPRequest$$Type} from "dev.latvian.mods.kubejs.web.KJSHTTPRequest"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ConsoleLine, $ConsoleLine$$Type} from "dev.latvian.mods.kubejs.script.ConsoleLine"
import {$Logger, $Logger$$Type} from "org.slf4j.Logger"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ConsoleJS {
static "STARTUP": $ConsoleJS
static "SERVER": $ConsoleJS
static "CLIENT": $ConsoleJS
readonly "scriptType": $ScriptType
 "contextFactory": $WeakReference<($ContextFactory)>
 "wsBroadcaster": $WSHandler<($KJSHTTPRequest), ($KJSWSSession)>

constructor(arg0: $ScriptType$$Type, arg1: $Logger$$Type)

public "group"(): void
public "log"(...arg0: (any)[]): void
public "flush"(arg0: boolean): void
public "info"(arg0: any): $ConsoleLine
public "getLogger"(): $Logger
public "trace"(): void
public "debug"(arg0: any): $ConsoleLine
public "error"(arg0: string, arg1: $SourceLine$$Type, arg2: $Throwable$$Type, arg3: $Pattern$$Type): $ConsoleLine
public "error"(arg0: any): $ConsoleLine
public "error"(arg0: string, arg1: $Throwable$$Type, arg2: $Pattern$$Type): $ConsoleLine
public "error"(arg0: string, arg1: $Throwable$$Type): $ConsoleLine
public "warn"(arg0: string, arg1: $Throwable$$Type, arg2: $Pattern$$Type): $ConsoleLine
public "warn"(arg0: string, arg1: $SourceLine$$Type, arg2: $Throwable$$Type, arg3: $Pattern$$Type): $ConsoleLine
public "warn"(arg0: string, arg1: $Throwable$$Type): $ConsoleLine
public "warn"(arg0: any): $ConsoleLine
public "groupEnd"(): void
public "writeToFile"(arg0: $LogType$$Type, arg1: string): void
public "writeToFile"(arg0: $LogType$$Type, arg1: long, arg2: string): void
public "printObject"(arg0: any): void
public "printObject"(arg0: any, arg1: boolean): void
public "handleError"(arg0: $ConsoleLine$$Type, arg1: $Throwable$$Type, arg2: $Pattern$$Type, arg3: boolean): void
public static "getCurrent"(): $ConsoleJS
public "getErrorsResponse"(arg0: $KJSHTTPRequest$$Type): $HTTPResponse
public "getScriptLine"(): integer
public "getWriteToFile"(): boolean
public "shouldPrintDebug"(): boolean
public "getDebugEnabled"(): boolean
public "errorsComponent"(arg0: string): $Component
public "setWriteToFile"(arg0: boolean): void
public "startCapturingErrors"(): void
public "stopCapturingErrors"(): void
public "getWarningsResponse"(arg0: $KJSHTTPRequest$$Type): $HTTPResponse
public "setDebugEnabled"(arg0: boolean): void
public "resetFile"(): void
public "debugf"(arg0: string, ...arg1: (any)[]): $ConsoleLine
public "infof"(arg0: string, ...arg1: (any)[]): $ConsoleLine
public "printClass"(arg0: string, arg1: boolean): void
public "printClass"(arg0: string): void
public "setMuted"(arg0: boolean): void
public "getMuted"(): boolean
public "warnf"(arg0: string, ...arg1: (any)[]): $ConsoleLine
public "errorf"(arg0: string, ...arg1: (any)[]): $ConsoleLine
get "logger"(): $Logger
get "scriptLine"(): integer
get "debugEnabled"(): boolean
set "debugEnabled"(value: boolean)
set "muted"(value: boolean)
get "muted"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsoleJS$$Type = ($ConsoleJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConsoleJS_ = $ConsoleJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.fluid.FluidWrapper" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$StringReader, $StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$List, $List$$Type} from "java.util.List"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$SizedFluidIngredient, $SizedFluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"

export interface $FluidWrapper {

}

export namespace $FluidWrapper {
const TYPE_INFO: $TypeInfo
const FLUID_TYPE_INFO: $TypeInfo
const INGREDIENT_TYPE_INFO: $TypeInfo
const SIZED_INGREDIENT_TYPE_INFO: $TypeInfo
const EMPTY_SIZED: $SizedFluidIngredient
function of(arg0: $FluidStack$$Type, arg1: integer, arg2: $DataComponentMap$$Type): $FluidStack
function of(arg0: $FluidStack$$Type, arg1: integer): $FluidStack
function of(arg0: $FluidStack$$Type): $FluidStack
function of(arg0: $FluidStack$$Type, arg1: $DataComponentMap$$Type): $FluidStack
function read(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: $StringReader$$Type): $FluidStack
function getId(arg0: $Fluid$$Type): $ResourceLocation
function getType(arg0: $ResourceLocation$$Type): $Fluid
function exists(arg0: $ResourceLocation$$Type): boolean
function water(): $FluidStack
function water(arg0: integer): $FluidStack
function getTypes(): $List<(string)>
function ofString(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: string): $FluidStack
function lava(arg0: integer): $FluidStack
function lava(): $FluidStack
function sizedIngredientOf(arg0: $SizedFluidIngredient$$Type): $SizedFluidIngredient
function ingredientOfString(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: string): $FluidIngredient
function readIngredient(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: $StringReader$$Type): $FluidIngredient
function readFluidAmount(arg0: $StringReader$$Type): long
function ingredientOf(arg0: $FluidIngredient$$Type): $FluidIngredient
function readSizedIngredient(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: $StringReader$$Type): $SizedFluidIngredient
function sizedIngredientOfString(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: string): $SizedFluidIngredient
function getEmpty(): $FluidStack
const probejs$$marker: never
}
export class $FluidWrapper$$Static implements $FluidWrapper {
static readonly "TYPE_INFO": $TypeInfo
static readonly "FLUID_TYPE_INFO": $TypeInfo
static readonly "INGREDIENT_TYPE_INFO": $TypeInfo
static readonly "SIZED_INGREDIENT_TYPE_INFO": $TypeInfo
static readonly "EMPTY_SIZED": $SizedFluidIngredient


static "of"(arg0: $FluidStack$$Type, arg1: integer, arg2: $DataComponentMap$$Type): $FluidStack
static "of"(arg0: $FluidStack$$Type, arg1: integer): $FluidStack
static "of"(arg0: $FluidStack$$Type): $FluidStack
static "of"(arg0: $FluidStack$$Type, arg1: $DataComponentMap$$Type): $FluidStack
static "read"(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: $StringReader$$Type): $FluidStack
static "getId"(arg0: $Fluid$$Type): $ResourceLocation
static "getType"(arg0: $ResourceLocation$$Type): $Fluid
static "exists"(arg0: $ResourceLocation$$Type): boolean
static "water"(): $FluidStack
static "water"(arg0: integer): $FluidStack
static "getTypes"(): $List<(string)>
static "ofString"(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: string): $FluidStack
static "lava"(arg0: integer): $FluidStack
static "lava"(): $FluidStack
static "sizedIngredientOf"(arg0: $SizedFluidIngredient$$Type): $SizedFluidIngredient
static "ingredientOfString"(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: string): $FluidIngredient
static "readIngredient"(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: $StringReader$$Type): $FluidIngredient
static "readFluidAmount"(arg0: $StringReader$$Type): long
static "ingredientOf"(arg0: $FluidIngredient$$Type): $FluidIngredient
static "readSizedIngredient"(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: $StringReader$$Type): $SizedFluidIngredient
static "sizedIngredientOfString"(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: string): $SizedFluidIngredient
static "getEmpty"(): $FluidStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidWrapper$$Type = ($FluidWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidWrapper_ = $FluidWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.SizedFluidIngredientKJS" {
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$FluidMatch, $FluidMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.FluidMatch"
import {$SizedFluidIngredient, $SizedFluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Replaceable, $Replaceable$$Type} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"

export interface $SizedFluidIngredientKJS extends $Replaceable, $FluidMatch {

 "matches"(arg1: $FluidIngredient$$Type, arg2: boolean): boolean
 "matches"(arg1: $FluidStack$$Type, arg2: boolean): boolean
 "self"(): $SizedFluidIngredient
 "replaceThisWith"(arg1: any): any
}

export namespace $SizedFluidIngredientKJS {
function wrap(arg1: any): $ReplacementMatch
const probejs$$marker: never
}
export class $SizedFluidIngredientKJS$$Static implements $SizedFluidIngredientKJS {


 "matches"(arg1: $FluidIngredient$$Type, arg2: boolean): boolean
 "matches"(arg1: $FluidStack$$Type, arg2: boolean): boolean
 "self"(): $SizedFluidIngredient
 "replaceThisWith"(arg1: any): any
static "wrap"(arg1: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SizedFluidIngredientKJS$$Type = ($SizedFluidIngredientKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SizedFluidIngredientKJS_ = $SizedFluidIngredientKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent" {
import {$ChestMenuSlot, $ChestMenuSlot$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuSlot"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"

export class $ChestMenuClickEvent {
readonly "slot": $ChestMenuSlot
readonly "type": $ClickType
readonly "button": integer

constructor(arg0: $ChestMenuSlot$$Type, arg1: $ClickType$$Type, arg2: integer)

public "setHandled"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickEvent$$Type = ($ChestMenuClickEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuClickEvent_ = $ChestMenuClickEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.NBTUtils" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$FriendlyByteBuf, $FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$ListTag, $ListTag$$Type} from "net.minecraft.nbt.ListTag"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$TagType, $TagType$$Type} from "net.minecraft.nbt.TagType"
import {$CollectionTag, $CollectionTag$$Type} from "net.minecraft.nbt.CollectionTag"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$OrderedCompoundTag, $OrderedCompoundTag$$Type} from "dev.latvian.mods.kubejs.util.OrderedCompoundTag"

export interface $NBTUtils {

}

export namespace $NBTUtils {
const STRING_TAG_MAP_TYPE: $TypeInfo
const COMPOUND_TYPE: $TagType<($OrderedCompoundTag)>
const LIST_TYPE: $TagType<($ListTag)>
function i(arg0: integer): $Tag
function b(arg0: byte): $Tag
function ba(arg0: (byte)[]): $Tag
function s(arg0: short): $Tag
function f(arg0: float): $Tag
function l(arg0: long): $Tag
function d(arg0: double): $Tag
function read(arg0: $FriendlyByteBuf$$Type): $OrderedCompoundTag
function convertType(arg0: $TagType$$Type<(any)>): $TagType<(any)>
function ia(arg0: (integer)[]): $Tag
function stringTag(arg0: string): $Tag
function la(arg0: (long)[]): $Tag
function toJson(arg0: $Tag$$Type): $JsonElement
function compoundTag(): $Tag
function compoundTag(arg1: $Map$$Type<(any), (any)>): $Tag
function fromTag(arg0: $Tag$$Type): any
function shortTag(arg0: short): $Tag
function intTag(arg0: integer): $Tag
function longTag(arg0: long): $Tag
function floatTag(arg0: float): $Tag
function doubleTag(arg0: double): $Tag
function byteTag(arg0: byte): $Tag
function toTagCompound(arg1: any): $CompoundTag
function toTagCollection(arg1: any): $CollectionTag<(any)>
function toTagCollection(arg1: $Collection$$Type<(any)>): $CollectionTag<(any)>
function isTagCollection(arg0: any): boolean
function isTagCompound(arg0: any): boolean
function toTagList(arg1: any): $ListTag
function toTag(arg1: any): $Tag
function listTag(arg1: $List$$Type<(any)>): $Tag
function listTag(): $Tag
function longArrayTag(arg0: (long)[]): $Tag
function intArrayTag(arg0: (integer)[]): $Tag
function byteArrayTag(arg0: (byte)[]): $Tag
function accessTagMap(arg0: $CompoundTag$$Type): $Map<(string), ($Tag)>
function quoteAndEscapeForJS(arg0: $StringBuilder$$Type, arg1: string): void
const probejs$$marker: never
}
export class $NBTUtils$$Static implements $NBTUtils {
static readonly "STRING_TAG_MAP_TYPE": $TypeInfo
static readonly "COMPOUND_TYPE": $TagType<($OrderedCompoundTag)>
static readonly "LIST_TYPE": $TagType<($ListTag)>


static "i"(arg0: integer): $Tag
static "b"(arg0: byte): $Tag
static "ba"(arg0: (byte)[]): $Tag
static "s"(arg0: short): $Tag
static "f"(arg0: float): $Tag
static "l"(arg0: long): $Tag
static "d"(arg0: double): $Tag
static "read"(arg0: $FriendlyByteBuf$$Type): $OrderedCompoundTag
static "convertType"(arg0: $TagType$$Type<(any)>): $TagType<(any)>
static "ia"(arg0: (integer)[]): $Tag
static "stringTag"(arg0: string): $Tag
static "la"(arg0: (long)[]): $Tag
static "toJson"(arg0: $Tag$$Type): $JsonElement
static "compoundTag"(): $Tag
static "compoundTag"(arg1: $Map$$Type<(any), (any)>): $Tag
static "fromTag"(arg0: $Tag$$Type): any
static "shortTag"(arg0: short): $Tag
static "intTag"(arg0: integer): $Tag
static "longTag"(arg0: long): $Tag
static "floatTag"(arg0: float): $Tag
static "doubleTag"(arg0: double): $Tag
static "byteTag"(arg0: byte): $Tag
static "toTagCompound"(arg1: any): $CompoundTag
static "toTagCollection"(arg1: any): $CollectionTag<(any)>
static "toTagCollection"(arg1: $Collection$$Type<(any)>): $CollectionTag<(any)>
static "isTagCollection"(arg0: any): boolean
static "isTagCompound"(arg0: any): boolean
static "toTagList"(arg1: any): $ListTag
static "toTag"(arg1: any): $Tag
static "listTag"(arg1: $List$$Type<(any)>): $Tag
static "listTag"(): $Tag
static "longArrayTag"(arg0: (long)[]): $Tag
static "intArrayTag"(arg0: (integer)[]): $Tag
static "byteArrayTag"(arg0: (byte)[]): $Tag
static "accessTagMap"(arg0: $CompoundTag$$Type): $Map<(string), ($Tag)>
static "quoteAndEscapeForJS"(arg0: $StringBuilder$$Type, arg1: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTUtils$$Type = ($NBTUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NBTUtils_ = $NBTUtils$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.NBTSerializable" {
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"

export interface $NBTSerializable {

 "toNBT"(): $Tag

(): $Tag$$Type
}

export namespace $NBTSerializable {
const probejs$$marker: never
}
export class $NBTSerializable$$Static implements $NBTSerializable {


 "toNBT"(): $Tag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTSerializable$$Type = (() => $Tag$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NBTSerializable_ = $NBTSerializable$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.data.GeneratedData" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$IoSupplier, $IoSupplier$$Type} from "net.minecraft.server.packs.resources.IoSupplier"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$InputStream, $InputStream$$Type} from "java.io.InputStream"
import {$ZipFile, $ZipFile$$Type} from "java.util.zip.ZipFile"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$ZipEntry, $ZipEntry$$Type} from "java.util.zip.ZipEntry"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $GeneratedData extends $Record implements $IoSupplier<($InputStream)> {
static readonly "INTERNAL_RELOAD": $GeneratedData
static readonly "PACK_META": $GeneratedData
static readonly "PACK_ICON": $GeneratedData

constructor(id: $ResourceLocation$$Type, data: $Supplier$$Type<((byte)[])>)

public "get"(): any
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "data"(): $Supplier<((byte)[])>
public "id"(): $ResourceLocation
public static "json"(arg0: $ResourceLocation$$Type, arg1: $Supplier$$Type<($JsonElement$$Type)>): $GeneratedData
public static "create"(arg0: $Path$$Type): $IoSupplier<($InputStream)>
public static "create"(arg0: $ZipFile$$Type, arg1: $ZipEntry$$Type): $IoSupplier<($InputStream)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedData$$Type = ({"id"?: $ResourceLocation$$Type, "data"?: $Supplier$$Type<((byte)[])>}) | ([id?: $ResourceLocation$$Type, data?: $Supplier$$Type<((byte)[])>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratedData_ = $GeneratedData$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.LogType" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Logger, $Logger$$Type} from "org.slf4j.Logger"

export class $LogType extends $Enum<($LogType)> {
static readonly "INIT": $LogType
static readonly "DEBUG": $LogType
static readonly "INFO": $LogType
static readonly "WARN": $LogType
static readonly "ERROR": $LogType
static readonly "VALUES": ($LogType)[]
readonly "id": string
readonly "callback": $BiConsumer<($Logger), (string)>


public static "values"(): ($LogType)[]
public static "valueOf"(arg0: string): $LogType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogType$$Type = (("init") | ("debug") | ("info") | ("warn") | ("error"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LogType_ = $LogType$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.FireworkRocketEntityKJS" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $FireworkRocketEntityKJS {

 "setLifetimeKJS"(arg0: integer): void

(arg0: integer): void
set "lifetimeKJS"(value: integer)
}

export namespace $FireworkRocketEntityKJS {
const probejs$$marker: never
}
export class $FireworkRocketEntityKJS$$Static implements $FireworkRocketEntityKJS {


 "setLifetimeKJS"(arg0: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FireworkRocketEntityKJS$$Type = ((arg0: integer) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FireworkRocketEntityKJS_ = $FireworkRocketEntityKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.BlockLeftClickedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$PlayerInteractEvent$LeftClickBlock, $PlayerInteractEvent$LeftClickBlock$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$LeftClickBlock"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player left clicks on a block.
 */
export class $BlockLeftClickedKubeEvent implements $KubePlayerEvent {

constructor(arg0: $PlayerInteractEvent$LeftClickBlock$$Type)

/**
 * The item that was used to left click the block.
 */
public "getItem"(): $ItemStack
/**
 * The player that left clicked the block.
 */
public "getEntity"(): $Entity
/**
 * The block that was left clicked.
 */
public "getBlock"(): $BlockContainerJS
/**
 * The face of the block that was left clicked.
 */
public "getFacing"(): $Direction
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "item"(): $ItemStack
get "entity"(): $Entity
get "block"(): $BlockContainerJS
get "facing"(): $Direction
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockLeftClickedKubeEvent$$Type = ($BlockLeftClickedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockLeftClickedKubeEvent_ = $BlockLeftClickedKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.TextWrapper" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$MutableComponent, $MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ClickEvent, $ClickEvent$$Type} from "net.minecraft.network.chat.ClickEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * The hub for all things text components. Format text to your hearts content!
 */
export interface $TextWrapper {

}

export namespace $TextWrapper {
function isEmpty(arg0: $Component$$Type): boolean
function join(...arg0: ($Component$$Type)[]): $MutableComponent
function join(arg0: $MutableComponent$$Type, arg1: $Iterable$$Type<($Component$$Type)>): $MutableComponent
function of(arg1: $MutableComponent$$Type): $MutableComponent
function empty(): $MutableComponent
function info(arg0: $Component$$Type): $MutableComponent
function red(arg0: $MutableComponent$$Type): $MutableComponent
function string(arg0: string): $MutableComponent
function literal(arg0: string): $MutableComponent
function warn(arg0: $Component$$Type): $MutableComponent
function selector(arg0: string): $MutableComponent
function selector(arg0: string, arg1: $Component$$Type): $MutableComponent
function green(arg0: $MutableComponent$$Type): $MutableComponent
function yellow(arg0: $MutableComponent$$Type): $MutableComponent
function white(arg0: $MutableComponent$$Type): $MutableComponent
function black(arg0: $MutableComponent$$Type): $MutableComponent
function blue(arg0: $MutableComponent$$Type): $MutableComponent
function score(arg0: string, arg1: string): $MutableComponent
function darkAqua(arg0: $MutableComponent$$Type): $MutableComponent
function darkGreen(arg0: $MutableComponent$$Type): $MutableComponent
function darkBlue(arg0: $MutableComponent$$Type): $MutableComponent
function darkGray(arg0: $MutableComponent$$Type): $MutableComponent
function aqua(arg0: $MutableComponent$$Type): $MutableComponent
function darkPurple(arg0: $MutableComponent$$Type): $MutableComponent
function darkRed(arg0: $MutableComponent$$Type): $MutableComponent
function translate(arg0: string, ...arg1: (any)[]): $MutableComponent
function translate(arg0: string): $MutableComponent
function ofString(arg0: string): $MutableComponent
function gray(arg0: $MutableComponent$$Type): $MutableComponent
function keybind(arg0: string): $MutableComponent
function translatable(arg0: string): $MutableComponent
function translatable(arg0: string, ...arg1: (any)[]): $MutableComponent
function lightPurple(arg0: $MutableComponent$$Type): $MutableComponent
function gold(arg0: $MutableComponent$$Type): $MutableComponent
function clickEventOf(arg1: any): $ClickEvent
function prettyPrintNbt(arg0: $Tag$$Type): $Component
function ofTag(arg0: $Tag$$Type): $Component
const probejs$$marker: never
}
export class $TextWrapper$$Static implements $TextWrapper {


/**
 * Checks if the passed in component, and all its children are empty
 */
static "isEmpty"(arg0: $Component$$Type): boolean
/**
 * Joins all components
 */
static "join"(...arg0: ($Component$$Type)[]): $MutableComponent
/**
 * Joins all components in the list with the separator component
 */
static "join"(arg0: $MutableComponent$$Type, arg1: $Iterable$$Type<($Component$$Type)>): $MutableComponent
/**
 * Returns a Component of the input
 */
static "of"(arg1: $MutableComponent$$Type): $MutableComponent
/**
 * Returns an empty component
 */
static "empty"(): $MutableComponent
static "info"(arg0: $Component$$Type): $MutableComponent
/**
 * Returns a component of the input, colored red
 */
static "red"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a plain component of the passed in string, even if empty
 */
static "string"(arg0: string): $MutableComponent
/**
 * Returns a plain component of the input
 */
static "literal"(arg0: string): $MutableComponent
static "warn"(arg0: $Component$$Type): $MutableComponent
/**
 * Returns a component displaying all entities matching the input selector
 */
static "selector"(arg0: string): $MutableComponent
/**
 * Returns a component displaying all entities matching the input selector, with a custom separator
 */
static "selector"(arg0: string, arg1: $Component$$Type): $MutableComponent
/**
 * Returns a component of the input, colored green
 */
static "green"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored yellow
 */
static "yellow"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored white
 */
static "white"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored black
 */
static "black"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored blue
 */
static "blue"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a score component of the input objective, for the provided selector
 */
static "score"(arg0: string, arg1: string): $MutableComponent
/**
 * Returns a component of the input, colored dark aqua
 */
static "darkAqua"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark green
 */
static "darkGreen"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark blue
 */
static "darkBlue"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark gray
 */
static "darkGray"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored aqua
 */
static "aqua"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark purple
 */
static "darkPurple"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark red
 */
static "darkRed"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects
 */
static "translate"(arg0: string, ...arg1: (any)[]): $MutableComponent
/**
 * Returns a translatable component of the input key
 */
static "translate"(arg0: string): $MutableComponent
/**
 * Returns a plain component of the string, or empty if it is an empty string
 */
static "ofString"(arg0: string): $MutableComponent
/**
 * Returns a component of the input, colored gray
 */
static "gray"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a keybinding component of the input keybinding descriptor
 */
static "keybind"(arg0: string): $MutableComponent
/**
 * Returns a translatable component of the input key
 */
static "translatable"(arg0: string): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects
 */
static "translatable"(arg0: string, ...arg1: (any)[]): $MutableComponent
/**
 * Returns a component of the input, colored light purple
 */
static "lightPurple"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored gold
 */
static "gold"(arg0: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a ClickEvent of the input
 */
static "clickEventOf"(arg1: any): $ClickEvent
/**
 * Returns a colorful representation of the input nbt. Useful for displaying NBT to the player
 */
static "prettyPrintNbt"(arg0: $Tag$$Type): $Component
static "ofTag"(arg0: $Tag$$Type): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextWrapper$$Type = ($TextWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextWrapper_ = $TextWrapper$$Type;
}}
declare module "dev.latvian.mods.rhino.util.wrap.TypeWrapperFactory" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"

export interface $TypeWrapperFactory<T> {

 "wrap"(arg1: any, arg2: $TypeInfo$$Type): T

(arg1: any, arg2: $TypeInfo): T
}

export namespace $TypeWrapperFactory {
const probejs$$marker: never
}
export class $TypeWrapperFactory$$Static<T> implements $TypeWrapperFactory {


 "wrap"(arg1: any, arg2: $TypeInfo$$Type): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeWrapperFactory$$Type<T> = ((arg1: any, arg2: $TypeInfo) => T);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeWrapperFactory_<T> = $TypeWrapperFactory$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.recipe.component.PairRecipeComponent" {
import {$TinyMap, $TinyMap$$Type} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$RecipeComponentBuilder$Key, $RecipeComponentBuilder$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder$Key"
import {$Pair, $Pair$$Type} from "com.mojang.datafixers.util.Pair"
import {$ComponentRole, $ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo, $ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$EitherRecipeComponent, $EitherRecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$UniqueIdBuilder, $UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentValue, $RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $PairRecipeComponent<A, B> extends $Record implements $RecipeComponent<($Pair<(A), (B)>)> {

constructor(arg0: $RecipeComponent$$Type<(A)>, arg1: $RecipeComponent$$Type<(B)>)
constructor(a: $RecipeComponent$$Type<(A)>, b: $RecipeComponent$$Type<(B)>, codec: $Codec$$Type<($Pair$$Type<(A), (B)>)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(arg0: $Pair$$Type<(A), (B)>): boolean
public "isEmpty"(arg0: any): boolean
public "b"(): $RecipeComponent<(B)>
public "a"(): $RecipeComponent<(A)>
public "validate"(arg0: any): void
public "validate"(arg0: $Pair$$Type<(A), (B)>): void
public "typeInfo"(): $TypeInfo
public "codec"(): $Codec<($Pair<(A), (B)>)>
public "buildUniqueId"(arg0: $UniqueIdBuilder$$Type, arg1: any): void
public "buildUniqueId"(arg0: $UniqueIdBuilder$$Type, arg1: $Pair$$Type<(A), (B)>): void
public "wrap"(arg1: $KubeRecipe$$Type, arg2: any): $Pair<(A), (B)>
public "replace"(arg1: $KubeRecipe$$Type, arg2: $Pair$$Type<(A), (B)>, arg3: $ReplacementMatchInfo$$Type, arg4: any): $Pair<(A), (B)>
public "matches"(arg1: $KubeRecipe$$Type, arg2: $Pair$$Type<(A), (B)>, arg3: $ReplacementMatchInfo$$Type): boolean
public static "builder"(arg0: $List$$Type<($RecipeComponentBuilder$Key$$Type)>): $RecipeComponentBuilder
public static "builder"(...arg0: ($RecipeComponentBuilder$Key$$Type)[]): $RecipeComponentBuilder
public "key"(arg0: string, arg1: $ComponentRole$$Type): $RecipeKey<($Pair<(A), (B)>)>
public "asList"(): $RecipeComponent<($List<($Pair<(A), (B)>)>)>
public "or"<O>(arg0: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<($Pair<(A), (B)>), (O)>
public "and"<O>(arg0: $RecipeComponent$$Type<(O)>): $PairRecipeComponent<($Pair<(A), (B)>), (O)>
public "asMap"<K>(arg0: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($Pair<(A), (B)>)>)>
public "inputKey"(arg0: string): $RecipeKey<($Pair<(A), (B)>)>
public "outputKey"(arg0: string): $RecipeKey<($Pair<(A), (B)>)>
public "orSelf"(): $RecipeComponent<($Pair<(A), (B)>)>
public "withCodec"(arg0: $Codec$$Type<($Pair$$Type<(A), (B)>)>): $RecipeComponent<($Pair<(A), (B)>)>
public "otherKey"(arg0: string): $RecipeKey<($Pair<(A), (B)>)>
public "asConditionalListOrSelf"(): $RecipeComponent<($List<($Pair<(A), (B)>)>)>
public "writeToJson"(arg0: $KubeRecipe$$Type, arg1: $RecipeComponentValue$$Type<($Pair$$Type<(A), (B)>)>, arg2: $JsonObject$$Type): void
public "readFromJson"(arg0: $KubeRecipe$$Type, arg1: $RecipeComponentValue$$Type<($Pair$$Type<(A), (B)>)>, arg2: $JsonObject$$Type): void
public "asConditionalList"(): $RecipeComponent<($List<($Pair<(A), (B)>)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($Pair<(A), (B)>)>)>
public "hasPriority"(arg1: $KubeRecipe$$Type, arg2: any): boolean
public "asListOrSelf"(): $RecipeComponent<($List<($Pair<(A), (B)>)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PairRecipeComponent$$Type<A, B> = ({"codec"?: $Codec$$Type<($Pair$$Type<(never), (never)>)>, "a"?: $RecipeComponent$$Type<(never)>, "b"?: $RecipeComponent$$Type<(never)>}) | ([codec?: $Codec$$Type<($Pair$$Type<(never), (never)>)>, a?: $RecipeComponent$$Type<(never)>, b?: $RecipeComponent$$Type<(never)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PairRecipeComponent_<A, B> = $PairRecipeComponent$$Type<(A), (B)>;
}}
declare module "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator$Part" {
import {$VariantBlockStateGenerator$Model, $VariantBlockStateGenerator$Model$$Type} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Model"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"

export class $MultipartBlockStateGenerator$Part {

constructor()

public "model"(arg0: $ResourceLocation$$Type): $VariantBlockStateGenerator$Model
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartBlockStateGenerator$Part$$Type = ($MultipartBlockStateGenerator$Part);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultipartBlockStateGenerator$Part_ = $MultipartBlockStateGenerator$Part$$Type;
}}
declare module "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$FlowingFluid, $FlowingFluid$$Type} from "net.minecraft.world.level.material.FlowingFluid"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $FlowingFluidBuilder extends $BuilderBase<($FlowingFluid)> {
readonly "fluidBuilder": $FluidBuilder
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $FluidBuilder$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlowingFluidBuilder$$Type = ($FlowingFluidBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FlowingFluidBuilder_ = $FlowingFluidBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.event.EventHandler" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$EventGroup, $EventGroup$$Type} from "dev.latvian.mods.kubejs.event.EventGroup"
import {$BaseFunction, $BaseFunction$$Type} from "dev.latvian.mods.rhino.BaseFunction"
import {$IEventHandler, $IEventHandler$$Type} from "dev.latvian.mods.kubejs.event.IEventHandler"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$TargetedEventHandler, $TargetedEventHandler$$Type} from "dev.latvian.mods.kubejs.event.TargetedEventHandler"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$DefaultValueTypeHint, $DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$ScriptTypeHolder, $ScriptTypeHolder$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$ScriptTypePredicate, $ScriptTypePredicate$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$EventTargetType, $EventTargetType$$Type} from "dev.latvian.mods.kubejs.event.EventTargetType"
import {$EventHandlerContainer, $EventHandlerContainer$$Type} from "dev.latvian.mods.kubejs.event.EventHandlerContainer"
import {$EventResult, $EventResult$$Type} from "dev.latvian.mods.kubejs.event.EventResult"

export class $EventHandler extends $BaseFunction {
readonly "group": $EventGroup
readonly "name": string
readonly "scriptTypePredicate": $ScriptTypePredicate
readonly "eventType": $Supplier<($Class<($KubeEvent)>)>
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "toString"(): string
public "listen"(arg1: $ScriptType$$Type, arg2: any, arg3: $IEventHandler$$Type): void
public "call"(arg1: $Scriptable$$Type, arg2: $Scriptable$$Type, arg3: (any)[]): any
public "post"(arg0: $ScriptTypeHolder$$Type, arg1: $KubeEvent$$Type): $EventResult
public "post"(arg0: $KubeEvent$$Type): $EventResult
public "hasListeners"(): boolean
public "hasResult"(): $EventHandler
public "supportsTarget"<E>(arg0: $EventTargetType$$Type<(E)>): $TargetedEventHandler<(E)>
public "forEachListener"(arg0: $ScriptType$$Type, arg1: $Consumer$$Type<($EventHandlerContainer)>): void
public "requiredTarget"<E>(arg0: $EventTargetType$$Type<(E)>): $TargetedEventHandler<(E)>
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "getAllIds"(): (any)[]
public "getIds"(): (any)[]
public "getParentScope"(): $Scriptable
public "getPrototype"(): $Scriptable
public "setPrototype"(arg0: $Scriptable$$Type): void
public "setParentScope"(arg0: $Scriptable$$Type): void
get "allIds"(): (any)[]
get "ids"(): (any)[]
get "parentScope"(): $Scriptable
get "prototype"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
set "parentScope"(value: $Scriptable$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventHandler$$Type = ($EventHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventHandler_ = $EventHandler$$Type;
}}
declare module "dev.latvian.mods.rhino.ErrorReporter" {
import {$EvaluatorException, $EvaluatorException$$Type} from "dev.latvian.mods.rhino.EvaluatorException"

export interface $ErrorReporter {

 "error"(arg1: string, arg2: string, arg3: integer, arg4: string, arg5: integer): void
 "warning"(arg0: string, arg1: string, arg2: integer, arg3: string, arg4: integer): void
 "runtimeError"(arg1: string, arg2: string, arg3: integer, arg4: string, arg5: integer): $EvaluatorException
}

export namespace $ErrorReporter {
const probejs$$marker: never
}
export class $ErrorReporter$$Static implements $ErrorReporter {


 "error"(arg1: string, arg2: string, arg3: integer, arg4: string, arg5: integer): void
 "warning"(arg0: string, arg1: string, arg2: integer, arg3: string, arg4: integer): void
 "runtimeError"(arg1: string, arg2: string, arg3: integer, arg4: string, arg5: integer): $EvaluatorException
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ErrorReporter$$Type = ($ErrorReporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ErrorReporter_ = $ErrorReporter$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$SlotFilter, $SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"
import {$IngredientAction, $IngredientAction$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $IngredientActionHolder extends $Record {
static readonly "CODEC": $Codec<($IngredientActionHolder)>
static readonly "LIST_CODEC": $Codec<($List<($IngredientActionHolder)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IngredientActionHolder)>
static readonly "LIST_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($List<($IngredientActionHolder)>)>

constructor(action: $IngredientAction$$Type, filter: $SlotFilter$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "filter"(): $SlotFilter
public "action"(): $IngredientAction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientActionHolder$$Type = ({"filter"?: $SlotFilter$$Type, "action"?: $IngredientAction$$Type}) | ([filter?: $SlotFilter$$Type, action?: $IngredientAction$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientActionHolder_ = $IngredientActionHolder$$Type;
}}
declare module "dev.latvian.mods.rhino.util.CustomJavaToJsWrapper" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"

export interface $CustomJavaToJsWrapper {

 "convertJavaToJs"(arg1: $Scriptable$$Type, arg2: $TypeInfo$$Type): $Scriptable

(arg1: $Scriptable, arg2: $TypeInfo): $Scriptable$$Type
}

export namespace $CustomJavaToJsWrapper {
const probejs$$marker: never
}
export class $CustomJavaToJsWrapper$$Static implements $CustomJavaToJsWrapper {


 "convertJavaToJs"(arg1: $Scriptable$$Type, arg2: $TypeInfo$$Type): $Scriptable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomJavaToJsWrapper$$Type = ((arg1: $Scriptable, arg2: $TypeInfo) => $Scriptable$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomJavaToJsWrapper_ = $CustomJavaToJsWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.BlockStoppedFallingKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$FallingBlockEntity, $FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$KubeEntityEvent, $KubeEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a falling block finishes falling.
 */
export class $BlockStoppedFallingKubeEvent implements $KubeEntityEvent {
readonly "block": $BlockContainerJS
readonly "fallSpeed": double
readonly "replacedBlock": $BlockContainerJS

constructor(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FallingBlockEntity$$Type, arg4: double, arg5: $BlockState$$Type)

public "getLevel"(): $Level
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStoppedFallingKubeEvent$$Type = ($BlockStoppedFallingKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStoppedFallingKubeEvent_ = $BlockStoppedFallingKubeEvent$$Type;
}}
declare module "dev.latvian.mods.rhino.type.ClassTypeInfo" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"
import {$TypeInfoBase, $TypeInfoBase$$Type} from "dev.latvian.mods.rhino.type.TypeInfoBase"
import {$Type, $Type$$Type} from "java.lang.reflect.Type"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$TypeStringContext, $TypeStringContext$$Type} from "dev.latvian.mods.rhino.type.TypeStringContext"

export class $ClassTypeInfo extends $TypeInfoBase {


public "equals"(o: any): boolean
public "toString"(): string
public "append"(ctx: $TypeStringContext$$Type, sb: $StringBuilder$$Type): void
public "hashCode"(): integer
public "isVoid"(): boolean
public "isCharacter"(): boolean
public "isFloat"(): boolean
public "isBoolean"(): boolean
public "asClass"(): $Class<(any)>
public "getContainedComponentClasses"(): $Set<($Class<(any)>)>
public "isDouble"(): boolean
public "shouldConvert"(): boolean
public "isLong"(): boolean
public "isInt"(): boolean
public "isShort"(): boolean
public "isByte"(): boolean
public static "of"(type: $Type$$Type): $TypeInfo
public static "of"(c: $Class$$Type<(any)>): $TypeInfo
public static "ofArray"(array: ($Type$$Type)[]): ($TypeInfo)[]
get "void"(): boolean
get "character"(): boolean
get "float"(): boolean
get "boolean"(): boolean
get "containedComponentClasses"(): $Set<($Class<(any)>)>
get "double"(): boolean
get "long"(): boolean
get "int"(): boolean
get "short"(): boolean
get "byte"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassTypeInfo$$Type = ($ClassTypeInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassTypeInfo_ = $ClassTypeInfo$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RemoveRecipesKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"

export interface $RemoveRecipesKubeEvent extends $KubeEvent {

 "remove"(arg1: (Special.RecipeId)[]): void
 "removeFromCategory"(arg1: $ResourceLocation$$Type, arg2: ($ResourceLocation$$Type)[]): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any

(arg1: $ResourceLocation, arg2: ($ResourceLocation)[]): void
}

export namespace $RemoveRecipesKubeEvent {
const probejs$$marker: never
}
export class $RemoveRecipesKubeEvent$$Static implements $RemoveRecipesKubeEvent {


 "remove"(arg1: (Special.RecipeId)[]): void
 "removeFromCategory"(arg1: $ResourceLocation$$Type, arg2: ($ResourceLocation$$Type)[]): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveRecipesKubeEvent$$Type = ((arg1: $ResourceLocation, arg2: ($ResourceLocation)[]) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoveRecipesKubeEvent_ = $RemoveRecipesKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.component.ComponentRole" {
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"

export class $ComponentRole extends $Enum<($ComponentRole)> implements $StringRepresentable {
static readonly "INPUT": $ComponentRole
static readonly "OUTPUT": $ComponentRole
static readonly "OTHER": $ComponentRole
static readonly "CODEC": $Codec<($ComponentRole)>


public static "values"(): ($ComponentRole)[]
public static "valueOf"(arg0: string): $ComponentRole
public "isOther"(): boolean
public "isInput"(): boolean
public "isOutput"(): boolean
public "getSerializedName"(): string
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "other"(): boolean
get "input"(): boolean
get "output"(): boolean
get "serializedName"(): string
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentRole$$Type = (("input") | ("output") | ("other"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentRole_ = $ComponentRole$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeSchemaType, $RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$LinkedHashMap, $LinkedHashMap$$Type} from "java.util.LinkedHashMap"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$RecipeSchemaStorage, $RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"

export class $RecipeNamespace extends $LinkedHashMap<(string), ($RecipeSchemaType)> {
readonly "storage": $RecipeSchemaStorage
readonly "name": string

constructor(arg0: $RecipeSchemaStorage$$Type, arg1: string)

public "toString"(): string
public "register"(arg0: string, arg1: $RecipeSchema$$Type): $RecipeNamespace
public "shapeless"(arg0: string): $RecipeNamespace
public "shaped"(arg0: string): $RecipeNamespace
public "special"(arg0: string): $RecipeNamespace
public "registerBasic"(arg0: string, ...arg1: ($RecipeKey$$Type<(any)>)[]): $RecipeNamespace
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeNamespace$$Type = ($RecipeNamespace);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeNamespace_ = $RecipeNamespace$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.ShearsItemBuilder" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ItemBuilder, $ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ShearsItemBuilder extends $ItemBuilder {
static readonly "SHEAR_TAGS": ($ResourceLocation)[]
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "speedBaseline"(arg0: float): this
public static "isCustomShears"(arg0: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShearsItemBuilder$$Type = ($ShearsItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShearsItemBuilder_ = $ShearsItemBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.ButtonBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$BlockSetType, $BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $ButtonBlockBuilder extends $ShapedBlockBuilder {
static readonly "BUTTON_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "ticksToStayPressed"(arg0: integer): this
public "behaviour"(arg0: $BlockSetType$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonBlockBuilder$$Type = ($ButtonBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ButtonBlockBuilder_ = $ButtonBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.RecipeInputKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$List, $List$$Type} from "java.util.List"
import {$SlotFilter, $SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"

export interface $RecipeInputKJS {

 "find"(arg0: $SlotFilter$$Type): $ItemStack
 "find"(arg0: $SlotFilter$$Type, arg1: integer): $ItemStack
 "self"(): $RecipeInput
 "findAll"(arg0: $SlotFilter$$Type): $List<($ItemStack)>
 "findAll"(): $List<($ItemStack)>
}

export namespace $RecipeInputKJS {
const probejs$$marker: never
}
export class $RecipeInputKJS$$Static implements $RecipeInputKJS {


 "find"(arg0: $SlotFilter$$Type): $ItemStack
 "find"(arg0: $SlotFilter$$Type, arg1: integer): $ItemStack
 "self"(): $RecipeInput
 "findAll"(arg0: $SlotFilter$$Type): $List<($ItemStack)>
 "findAll"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeInputKJS$$Type = ($RecipeInputKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeInputKJS_ = $RecipeInputKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.PlayerSelector" {
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export interface $PlayerSelector {

 "or"(arg0: $PlayerSelector$$Type): $PlayerSelector
 "getPlayer"(arg0: $MinecraftServer$$Type): $ServerPlayer

(arg0: $MinecraftServer): $ServerPlayer$$Type
}

export namespace $PlayerSelector {
function name(arg0: string): $PlayerSelector
function of(arg0: any): $PlayerSelector
function identity(arg0: $ServerPlayer$$Type): $PlayerSelector
function uuid(arg0: $UUID$$Type): $PlayerSelector
function fuzzyName(arg0: string): $PlayerSelector
const probejs$$marker: never
}
export class $PlayerSelector$$Static implements $PlayerSelector {


static "name"(arg0: string): $PlayerSelector
static "of"(arg0: any): $PlayerSelector
static "identity"(arg0: $ServerPlayer$$Type): $PlayerSelector
 "or"(arg0: $PlayerSelector$$Type): $PlayerSelector
static "uuid"(arg0: $UUID$$Type): $PlayerSelector
 "getPlayer"(arg0: $MinecraftServer$$Type): $ServerPlayer
static "fuzzyName"(arg0: string): $PlayerSelector
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerSelector$$Type = (string) | ((arg0: $MinecraftServer) => $ServerPlayer$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerSelector_ = $PlayerSelector$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.IngredientKJS" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$ItemStackSet, $ItemStackSet$$Type} from "dev.latvian.mods.kubejs.item.ItemStackSet"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$WithCodec, $WithCodec$$Type} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$ItemMatch, $ItemMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ItemMatch"
import {$Replaceable, $Replaceable$$Type} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$ItemLike, $ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Set, $Set$$Type} from "java.util.Set"
import {$SizedIngredient, $SizedIngredient$$Type} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

export interface $IngredientKJS extends $ItemPredicate, $Replaceable, $WithCodec, $ItemMatch {

 "matches"(arg1: $ItemStack$$Type, arg2: boolean): boolean
 "matches"(arg1: $Ingredient$$Type, arg2: boolean): boolean
 "getCodec"(): $Codec<(any)>
 "asIngredient"(): $Ingredient
 "withCount"(arg0: integer): $SizedIngredient
 "self"(): $Ingredient
 "and"(arg0: $Ingredient$$Type): $Ingredient
 "or"(arg0: $Ingredient$$Type): $Ingredient
 "except"(arg0: $Ingredient$$Type): $Ingredient
 "isWildcard"(): boolean
 "replaceThisWith"(arg1: any): any
 "getStackArray"(): ($ItemStack)[]
 "getTagKey"(): $TagKey<($Item)>
 "containsAnyTag"(): boolean
 "asStack"(): $SizedIngredient
 "canBeUsedForMatching"(): boolean
 "getDisplayStacks"(): $ItemStackSet
 "getFirst"(): $ItemStack
 "getStacks"(): $ItemStackSet
 "testItem"(arg0: $Item$$Type): boolean
 "getItemTypes"(): $Set<($Item)>
 "getItemIds"(): $Set<(string)>
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
 "matches"(arg1: $ItemLike$$Type, arg2: boolean): boolean
 "matchesAny"(arg1: $Iterable$$Type<($ItemLike$$Type)>, arg2: boolean): boolean
 "test"(arg0: $ItemStack$$Type): boolean
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>

(arg0: $ItemStack): boolean
get "codec"(): $Codec<(any)>
get "wildcard"(): boolean
get "stackArray"(): ($ItemStack)[]
get "tagKey"(): $TagKey<($Item)>
get "displayStacks"(): $ItemStackSet
get "first"(): $ItemStack
get "stacks"(): $ItemStackSet
get "itemTypes"(): $Set<($Item)>
get "itemIds"(): $Set<(string)>
}

export namespace $IngredientKJS {
function wrap(arg1: any): $ItemPredicate
function not<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
function isEqual<T>(arg0: any): $Predicate<($ItemStack)>
const probejs$$marker: never
}
export class $IngredientKJS$$Static implements $IngredientKJS {


 "matches"(arg1: $ItemStack$$Type, arg2: boolean): boolean
 "matches"(arg1: $Ingredient$$Type, arg2: boolean): boolean
 "getCodec"(): $Codec<(any)>
 "asIngredient"(): $Ingredient
 "withCount"(arg0: integer): $SizedIngredient
 "self"(): $Ingredient
 "and"(arg0: $Ingredient$$Type): $Ingredient
 "or"(arg0: $Ingredient$$Type): $Ingredient
 "except"(arg0: $Ingredient$$Type): $Ingredient
 "isWildcard"(): boolean
 "replaceThisWith"(arg1: any): any
 "getStackArray"(): ($ItemStack)[]
 "getTagKey"(): $TagKey<($Item)>
 "containsAnyTag"(): boolean
 "asStack"(): $SizedIngredient
static "wrap"(arg1: any): $ItemPredicate
 "canBeUsedForMatching"(): boolean
 "getDisplayStacks"(): $ItemStackSet
 "getFirst"(): $ItemStack
 "getStacks"(): $ItemStackSet
 "testItem"(arg0: $Item$$Type): boolean
 "getItemTypes"(): $Set<($Item)>
 "getItemIds"(): $Set<(string)>
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
 "matches"(arg1: $ItemLike$$Type, arg2: boolean): boolean
 "matchesAny"(arg1: $Iterable$$Type<($ItemLike$$Type)>, arg2: boolean): boolean
 "test"(arg0: $ItemStack$$Type): boolean
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "not"<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "isEqual"<T>(arg0: any): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientKJS$$Type = ((arg0: $ItemStack) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientKJS_ = $IngredientKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder" {
import {$BlockRenderType, $BlockRenderType$$Type} from "dev.latvian.mods.kubejs.block.BlockRenderType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Rarity, $Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$PathType, $PathType$$Type} from "net.minecraft.world.level.pathfinder.PathType"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$FluidType, $FluidType$$Type} from "net.neoforged.neoforge.fluids.FluidType"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$SoundAction, $SoundAction$$Type} from "net.neoforged.neoforge.common.SoundAction"

export class $FluidTypeBuilder extends $BuilderBase<($FluidType)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "density"(arg0: integer): this
public "tint"(arg0: $KubeColor$$Type): this
public "canSwim"(arg0: boolean): this
public "canHydrate"(arg0: boolean): this
public "renderType"(arg0: $BlockRenderType$$Type): this
public "sound"(arg0: $SoundAction$$Type, arg1: $SoundEvent$$Type): this
public "flowingTexture"(arg0: $ResourceLocation$$Type): this
public "lightLevel"(arg0: integer): this
public "temperature"(arg0: integer): this
public "motionScale"(arg0: double): this
public "canPushEntity"(arg0: boolean): this
public "canExtinguish"(arg0: boolean): this
public "supportsBoating"(arg0: boolean): this
public "canConvertToSource"(arg0: boolean): this
public "fallDistanceModifier"(arg0: float): this
public "adjacentPathType"(arg0: $PathType$$Type): this
public "pathType"(arg0: $PathType$$Type): this
public "canDrown"(arg0: boolean): this
public "viscosity"(arg0: integer): this
public "rarity"(arg0: $Rarity$$Type): this
public "descriptionId"(arg0: string): this
public "addDripstoneDripping"(arg0: float, arg1: $ParticleOptions$$Type, arg2: $Block$$Type, arg3: $SoundEvent$$Type): this
public "stillTexture"(arg0: $ResourceLocation$$Type): this
public "screenOverlayTexture"(arg0: $ResourceLocation$$Type): this
public "blockOverlayTexture"(arg0: $ResourceLocation$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTypeBuilder$$Type = ($FluidTypeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTypeBuilder_ = $FluidTypeBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.registry.CustomBuilderObject" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $CustomBuilderObject extends $BuilderBase<(any)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type, arg1: $Supplier$$Type<(any)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomBuilderObject$$Type = ($CustomBuilderObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomBuilderObject_ = $CustomBuilderObject$$Type;
}}
declare module "dev.latvian.mods.kubejs.net.KubeServerData" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$ItemTooltipData, $ItemTooltipData$$Type} from "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData"
import {$RecipeViewerData, $RecipeViewerData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $KubeServerData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($KubeServerData)>

constructor(recipeViewerData: $Optional$$Type<($RecipeViewerData$$Type)>, itemTooltipData: $List$$Type<($ItemTooltipData$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "collect"(): $KubeServerData
public "itemTooltipData"(): $List<($ItemTooltipData)>
public "recipeViewerData"(): $Optional<($RecipeViewerData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeServerData$$Type = ({"recipeViewerData"?: ($RecipeViewerData$$Type)?, "itemTooltipData"?: $List$$Type<($ItemTooltipData$$Type)>}) | ([recipeViewerData?: ($RecipeViewerData$$Type)?, itemTooltipData?: $List$$Type<($ItemTooltipData$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeServerData_ = $KubeServerData$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaRegistry" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeNamespace, $RecipeNamespace$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace"
import {$RecipeSchemaStorage, $RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"

export class $RecipeSchemaRegistry implements $KubeEvent {

constructor(arg0: $RecipeSchemaStorage$$Type)

public "register"(arg0: $ResourceLocation$$Type, arg1: $RecipeSchema$$Type): void
public "namespace"(arg0: string): $RecipeNamespace
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaRegistry$$Type = ($RecipeSchemaRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeSchemaRegistry_ = $RecipeSchemaRegistry$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ItemData, $ItemData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData"
import {$CategoryData, $CategoryData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.CategoryData"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$FluidData, $FluidData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $RecipeViewerData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($RecipeViewerData)>

constructor(removedCategories: $List$$Type<($ResourceLocation$$Type)>, removedGlobalRecipes: $List$$Type<($ResourceLocation$$Type)>, categoryData: $List$$Type<($CategoryData$$Type)>, itemData: $ItemData$$Type, fluidData: $FluidData$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "collect"(): $RecipeViewerData
public "removedCategories"(): $List<($ResourceLocation)>
public "fluidData"(): $FluidData
public "itemData"(): $ItemData
public "categoryData"(): $List<($CategoryData)>
public "removedGlobalRecipes"(): $List<($ResourceLocation)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeViewerData$$Type = ({"itemData"?: $ItemData$$Type, "fluidData"?: $FluidData$$Type, "removedGlobalRecipes"?: $List$$Type<($ResourceLocation$$Type)>, "removedCategories"?: $List$$Type<($ResourceLocation$$Type)>, "categoryData"?: $List$$Type<($CategoryData$$Type)>}) | ([itemData?: $ItemData$$Type, fluidData?: $FluidData$$Type, removedGlobalRecipes?: $List$$Type<($ResourceLocation$$Type)>, removedCategories?: $List$$Type<($ResourceLocation$$Type)>, categoryData?: $List$$Type<($CategoryData$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeViewerData_ = $RecipeViewerData$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.ItemEntityKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$EntityKJS, $EntityKJS$$Type} from "dev.latvian.mods.kubejs.core.EntityKJS"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$RayTraceResultJS, $RayTraceResultJS$$Type} from "dev.latvian.mods.kubejs.entity.RayTraceResultJS"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"

export interface $ItemEntityKJS extends $EntityKJS {

 "setLifespan"(arg0: integer): void
 "setNoDespawn"(): void
 "getLifespan"(): integer
 "self"(): $Entity
 "getItem"(): $ItemStack
 "setDefaultPickUpDelay"(): void
 "getTicksUntilDespawn"(): integer
 "setTicksUntilDespawn"(arg0: integer): void
 "setInfinitePickUpDelay"(): void
 "setNoPickUpDelay"(): void
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "spawn"(): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isPlayer"(): boolean
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "getProfile"(): $GameProfile
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "isLiving"(): boolean
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
set "lifespan"(value: integer)
get "lifespan"(): integer
get "item"(): $ItemStack
get "ticksUntilDespawn"(): integer
set "ticksUntilDespawn"(value: integer)
set "nbt"(value: $CompoundTag$$Type)
get "nbt"(): $CompoundTag
set "y"(value: double)
set "x"(value: double)
set "z"(value: double)
get "name"(): $Component
get "displayName"(): $Component
get "passengers"(): $EntityArrayList
get "server"(): $MinecraftServer
get "type"(): string
set "position"(value: $BlockContainerJS$$Type)
get "player"(): boolean
get "monster"(): boolean
set "motionX"(value: double)
get "level"(): $Level
get "profile"(): $GameProfile
set "motionY"(value: double)
get "motionX"(): double
set "motionZ"(value: double)
get "block"(): $BlockContainerJS
get "living"(): boolean
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "motionZ"(): double
get "teamId"(): string
get "facing"(): $Direction
get "animal"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export namespace $ItemEntityKJS {
const probejs$$marker: never
}
export class $ItemEntityKJS$$Static implements $ItemEntityKJS {


 "setLifespan"(arg0: integer): void
 "setNoDespawn"(): void
 "getLifespan"(): integer
 "self"(): $Entity
 "getItem"(): $ItemStack
 "setDefaultPickUpDelay"(): void
 "getTicksUntilDespawn"(): integer
 "setTicksUntilDespawn"(arg0: integer): void
 "setInfinitePickUpDelay"(): void
 "setNoPickUpDelay"(): void
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "spawn"(): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isPlayer"(): boolean
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "getProfile"(): $GameProfile
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "isLiving"(): boolean
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEntityKJS$$Type = ($ItemEntityKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemEntityKJS_ = $ItemEntityKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.LazyComponentKJS" {
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $LazyComponentKJS extends $Supplier<($Component)> {

 "get"(): $Component

(): $Component$$Type
}

export namespace $LazyComponentKJS {
const probejs$$marker: never
}
export class $LazyComponentKJS$$Static implements $LazyComponentKJS {


 "get"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyComponentKJS$$Type = (() => $Component$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LazyComponentKJS_ = $LazyComponentKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.KubeJSFileWatcherThread" {
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Thread, $Thread$$Type} from "java.lang.Thread"
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"
import {$ScriptFile, $ScriptFile$$Type} from "dev.latvian.mods.kubejs.script.ScriptFile"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $KubeJSFileWatcherThread extends $Thread {
readonly "scriptType": $ScriptType
readonly "files": ($ScriptFile)[]
readonly "reload": $Runnable
static readonly "MIN_PRIORITY": integer
static readonly "NORM_PRIORITY": integer
static readonly "MAX_PRIORITY": integer

constructor(arg0: $ScriptType$$Type, arg1: ($ScriptFile$$Type)[], arg2: $Runnable$$Type)

public "run"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSFileWatcherThread$$Type = ($KubeJSFileWatcherThread);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSFileWatcherThread_ = $KubeJSFileWatcherThread$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate" {
import {$BlockIDPredicate$PropertyObject, $BlockIDPredicate$PropertyObject$$Type} from "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate$PropertyObject"
import {$BlockPredicate, $BlockPredicate$$Type} from "dev.latvian.mods.kubejs.block.predicate.BlockPredicate"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$List, $List$$Type} from "java.util.List"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockIDPredicate implements $BlockPredicate {

constructor(arg0: $ResourceLocation$$Type)

public "toString"(): string
public "with"(arg0: string, arg1: string): $BlockIDPredicate
public "check"(arg0: $BlockContainerJS$$Type): boolean
public "checkState"(arg0: $BlockState$$Type): boolean
public "getBlockState"(): $BlockState
public "getBlockProperties"(): $List<($BlockIDPredicate$PropertyObject)>
get "blockState"(): $BlockState
get "blockProperties"(): $List<($BlockIDPredicate$PropertyObject)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIDPredicate$$Type = ($BlockIDPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockIDPredicate_ = $BlockIDPredicate$$Type;
}}
declare module "dev.latvian.mods.kubejs.mekanism.KubeChemicalBuilder$Default" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$KubeChemicalBuilder, $KubeChemicalBuilder$$Type} from "dev.latvian.mods.kubejs.mekanism.KubeChemicalBuilder"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $KubeChemicalBuilder$Default extends $KubeChemicalBuilder {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "texture"(arg0: $ResourceLocation$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeChemicalBuilder$Default$$Type = ($KubeChemicalBuilder$Default);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeChemicalBuilder$Default_ = $KubeChemicalBuilder$Default$$Type;
}}
declare module "dev.latvian.mods.kubejs.player.StageChangedEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Stages, $Stages$$Type} from "dev.latvian.mods.kubejs.stages.Stages"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $StageChangedEvent implements $KubePlayerEvent {

constructor(arg0: $Player$$Type, arg1: $Stages$$Type, arg2: string)

public "getEntity"(): $LivingEntity
public "getStage"(): string
public "getPlayer"(): $Player
public "getPlayerStages"(): $Stages
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "entity"(): $LivingEntity
get "stage"(): string
get "player"(): $Player
get "playerStages"(): $Stages
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StageChangedEvent$$Type = ($StageChangedEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StageChangedEvent_ = $StageChangedEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.BlockStartedFallingKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$FallingBlockEntity, $FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$KubeEntityEvent, $KubeEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a falling block starts to fall.
 */
export class $BlockStartedFallingKubeEvent implements $KubeEntityEvent {

constructor(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FallingBlockEntity$$Type)

public "getLevel"(): $Level
public "getEntity"(): $Entity
public "getBlock"(): $BlockContainerJS
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "level"(): $Level
get "entity"(): $Entity
get "block"(): $BlockContainerJS
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStartedFallingKubeEvent$$Type = ($BlockStartedFallingKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStartedFallingKubeEvent_ = $BlockStartedFallingKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$KubeEntityEvent, $KubeEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export interface $KubeLivingEntityEvent extends $KubeEntityEvent {

 "getEntity"(): $LivingEntity
 "getLevel"(): $Level
 "getPlayer"(): $Player
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any

(): $LivingEntity$$Type
get "entity"(): $LivingEntity
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}

export namespace $KubeLivingEntityEvent {
const probejs$$marker: never
}
export class $KubeLivingEntityEvent$$Static implements $KubeLivingEntityEvent {


 "getEntity"(): $LivingEntity
 "getLevel"(): $Level
 "getPlayer"(): $Player
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeLivingEntityEvent$$Type = (() => $LivingEntity$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeLivingEntityEvent_ = $KubeLivingEntityEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.callbacks.BlockStateModifyCallbackJS" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Mirror, $Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$IntegerProperty, $IntegerProperty$$Type} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$Rotation, $Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty, $BooleanProperty$$Type} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty, $EnumProperty$$Type} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor, $LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $BlockStateModifyCallbackJS {

constructor(arg0: $BlockState$$Type)

/**
 * Gets the value of the pased in property
 */
public "get"<T extends $Comparable<(T)>>(arg0: $Property$$Type<(T)>): T
public "toString"(): string
/**
 * Gets the value of the passed in property
 */
public "getValue"<T extends $Comparable<(T)>>(arg0: $Property$$Type<(T)>): T
/**
 * Sets the value of the specified boolean property
 */
public "set"(arg0: $BooleanProperty$$Type, arg1: boolean): $BlockStateModifyCallbackJS
/**
 * Sets the value of the specified integer property
 */
public "set"(arg0: $IntegerProperty$$Type, arg1: integer): $BlockStateModifyCallbackJS
/**
 * Sets the value of the specified enum property
 */
public "set"<T extends ($Enum<(T)>) & ($StringRepresentable)>(arg0: $EnumProperty$$Type<(T)>, arg1: string): $BlockStateModifyCallbackJS
/**
 * Get the properties this block has that can be changed
 */
public "getProperties"(): $Collection<($Property<(any)>)>
/**
 * Gets the state. If it has been modified, gets the new state
 */
public "getState"(): $BlockState
/**
 * Sets the value of the specified property
 */
public "setValue"<T extends $Comparable<(T)>, V extends T>(arg0: $Property$$Type<(T)>, arg1: V): $BlockStateModifyCallbackJS
/**
 * Rotate the block using the specified Rotation
 */
public "rotate"(arg0: $Rotation$$Type): $BlockStateModifyCallbackJS
/**
 * Checks if this block has the specified property
 */
public "hasProperty"<T extends $Comparable<(T)>>(arg0: $Property$$Type<(T)>): boolean
/**
 * Get a map of this blocks properties to it's value
 */
public "getValues"(): $Map<($Property<(any)>), ($Comparable<(any)>)>
/**
 * Cycles the property
 */
public "cycle"<T extends $Comparable<(T)>>(arg0: $Property$$Type<(T)>): $BlockStateModifyCallbackJS
/**
 * Updates the shape of this block. Mostly used in waterloggable blocks to update the water flow
 */
public "updateShape"(arg0: $Direction$$Type, arg1: $BlockState$$Type, arg2: $LevelAccessor$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type): $BlockStateModifyCallbackJS
/**
 * Gets the value of the passed in property as an Optional. If the property does not exist in this block the Optional will be empty
 */
public "getOptionalValue"<T extends $Comparable<(T)>>(arg0: $Property$$Type<(T)>): $Optional<(T)>
public "populateNeighbours"(arg0: $Map$$Type<($Map$$Type<($Property$$Type<(any)>), ($Comparable$$Type<(any)>)>), ($BlockState$$Type)>): $BlockStateModifyCallbackJS
/**
 * Mirror the block using the specified Mirror
 */
public "mirror"(arg0: $Mirror$$Type): $BlockStateModifyCallbackJS
get "properties"(): $Collection<($Property<(any)>)>
get "state"(): $BlockState
get "values"(): $Map<($Property<(any)>), ($Comparable<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateModifyCallbackJS$$Type = ($BlockStateModifyCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateModifyCallbackJS_ = $BlockStateModifyCallbackJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.FallingBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $FallingBlockBuilder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "dustColor"(arg0: $KubeColor$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FallingBlockBuilder$$Type = ($FallingBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FallingBlockBuilder_ = $FallingBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.player.KubeJSInventoryListener" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ContainerListener, $ContainerListener$$Type} from "net.minecraft.world.inventory.ContainerListener"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"

export class $KubeJSInventoryListener implements $ContainerListener {
readonly "player": $Player

constructor(arg0: $Player$$Type)

public "dataChanged"(arg0: $AbstractContainerMenu$$Type, arg1: integer, arg2: integer): void
public "slotChanged"(arg0: $AbstractContainerMenu$$Type, arg1: integer, arg2: $ItemStack$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSInventoryListener$$Type = ($KubeJSInventoryListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSInventoryListener_ = $KubeJSInventoryListener$$Type;
}}
declare module "dev.latvian.mods.kubejs.entity.CheckLivingEntitySpawnKubeEvent" {
import {$SpawnerJS, $SpawnerJS$$Type} from "dev.latvian.mods.kubejs.level.SpawnerJS"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$MobSpawnType, $MobSpawnType$$Type} from "net.minecraft.world.entity.MobSpawnType"
import {$Either, $Either$$Type} from "com.mojang.datafixers.util.Either"
import {$KubeLivingEntityEvent, $KubeLivingEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked before an entity is spawned into the world.
 * 
 * Only entities from a `BaseSpawner` or world generation will trigger this event.
 */
export class $CheckLivingEntitySpawnKubeEvent implements $KubeLivingEntityEvent {
readonly "x": double
readonly "y": double
readonly "z": double

constructor(arg0: $LivingEntity$$Type, arg1: $Level$$Type, arg2: double, arg3: double, arg4: double, arg5: $MobSpawnType$$Type, arg6: $Either$$Type<($BlockEntity$$Type), ($Entity$$Type)>)

/**
 * The type of spawn.
 */
public "getType"(): $MobSpawnType
/**
 * The level the entity is being spawned into.
 */
public "getLevel"(): $Level
/**
 * The entity being spawned.
 */
public "getEntity"(): $Entity
/**
 * The block the entity is being spawned on.
 */
public "getBlock"(): $BlockContainerJS
/**
 * The spawner that spawned the entity. Can be null if the entity was spawned by worldgen.
 */
public "getSpawner"(): $SpawnerJS
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "type"(): $MobSpawnType
get "level"(): $Level
get "entity"(): $Entity
get "block"(): $BlockContainerJS
get "spawner"(): $SpawnerJS
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CheckLivingEntitySpawnKubeEvent$$Type = ($CheckLivingEntitySpawnKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CheckLivingEntitySpawnKubeEvent_ = $CheckLivingEntitySpawnKubeEvent$$Type;
}}
declare module "dev.latvian.mods.rhino.BaseFunction" {
import {$MemberType, $MemberType$$Type} from "dev.latvian.mods.rhino.MemberType"
import {$Context, $Context$$Type} from "dev.latvian.mods.rhino.Context"
import {$Function, $Function$$Type} from "dev.latvian.mods.rhino.Function"
import {$IdScriptableObject, $IdScriptableObject$$Type} from "dev.latvian.mods.rhino.IdScriptableObject"
import {$DefaultValueTypeHint, $DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$IdFunctionObject, $IdFunctionObject$$Type} from "dev.latvian.mods.rhino.IdFunctionObject"

export class $BaseFunction extends $IdScriptableObject implements $Function {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor()
constructor(isGenerator: boolean)
constructor(scope: $Scriptable$$Type, prototype: $Scriptable$$Type)

public "toString"(): string
public "getLength"(): integer
public "call"(scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args: (any)[]): any
public "getClassName"(): string
public "createObject"(scope: $Scriptable$$Type): $Scriptable
public "setImmunePrototypeProperty"(value: any): void
public "getTypeOf"(): $MemberType
public "construct"(scope: $Scriptable$$Type, args: (any)[]): $Scriptable
public "getFunctionName"(): string
public "hasInstance"(instance: $Scriptable$$Type): boolean
public "getArity"(): integer
public "execIdCall"(f: $IdFunctionObject$$Type, cx: $Context$$Type, scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args: (any)[]): any
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "getAllIds"(): (any)[]
public "getIds"(): (any)[]
public "getParentScope"(): $Scriptable
public "getPrototype"(): $Scriptable
public "setPrototype"(arg0: $Scriptable$$Type): void
public "setParentScope"(arg0: $Scriptable$$Type): void
get "length"(): integer
get "className"(): string
set "immunePrototypeProperty"(value: any)
get "typeOf"(): $MemberType
get "functionName"(): string
get "arity"(): integer
get "allIds"(): (any)[]
get "ids"(): (any)[]
get "parentScope"(): $Scriptable
get "prototype"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
set "parentScope"(value: $Scriptable$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseFunction$$Type = ($BaseFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseFunction_ = $BaseFunction$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.JukeboxSongBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$JukeboxSong, $JukeboxSong$$Type} from "net.minecraft.world.item.JukeboxSong"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $JukeboxSongBuilder extends $BuilderBase<($JukeboxSong)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "description"(arg0: $Component$$Type): this
public "song"(arg0: $Holder$$Type<($SoundEvent)>, arg1: float): this
public "comparatorOutput"(arg0: integer): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JukeboxSongBuilder$$Type = ($JukeboxSongBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JukeboxSongBuilder_ = $JukeboxSongBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.ContainerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$List, $List$$Type} from "java.util.List"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"

export interface $ContainerKJS extends $InventoryKJS {

 "self"(): $Container
 "asContainer"(): $Container
 "getStackInSlot"(arg0: integer): $ItemStack
 "getSlots"(): integer
 "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
 "getHeight"(): integer
 "setChanged"(): void
 "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
 "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
 "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
 "getSlotLimit"(arg0: integer): integer
 "isMutable"(): boolean
 "getWidth"(): integer
 "getBlock"(arg0: $Level$$Type): $BlockContainerJS
 "clear"(): void
 "insertItem"(arg0: $ItemStack$$Type, arg1: boolean): $ItemStack
 "getAllItems"(): $List<($ItemStack)>
 "countNonEmpty"(): integer
 "countNonEmpty"(arg0: $ItemPredicate$$Type): integer
 "isEmpty"(): boolean
 "find"(): integer
 "find"(arg0: $ItemPredicate$$Type): integer
 "clear"(arg0: $ItemPredicate$$Type): void
 "count"(arg0: $ItemPredicate$$Type): integer
 "count"(): integer
get "slots"(): integer
get "height"(): integer
get "mutable"(): boolean
get "width"(): integer
get "allItems"(): $List<($ItemStack)>
get "empty"(): boolean
}

export namespace $ContainerKJS {
const probejs$$marker: never
}
export class $ContainerKJS$$Static implements $ContainerKJS {


 "self"(): $Container
 "asContainer"(): $Container
 "getStackInSlot"(arg0: integer): $ItemStack
 "getSlots"(): integer
 "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
 "getHeight"(): integer
 "setChanged"(): void
 "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
 "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
 "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
 "getSlotLimit"(arg0: integer): integer
 "isMutable"(): boolean
 "getWidth"(): integer
 "getBlock"(arg0: $Level$$Type): $BlockContainerJS
 "clear"(): void
 "insertItem"(arg0: $ItemStack$$Type, arg1: boolean): $ItemStack
 "getAllItems"(): $List<($ItemStack)>
 "countNonEmpty"(): integer
 "countNonEmpty"(arg0: $ItemPredicate$$Type): integer
 "isEmpty"(): boolean
 "find"(): integer
 "find"(arg0: $ItemPredicate$$Type): integer
 "clear"(arg0: $ItemPredicate$$Type): void
 "count"(arg0: $ItemPredicate$$Type): integer
 "count"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerKJS$$Type = ($ContainerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContainerKJS_ = $ContainerKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.AdvancementNodeKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DisplayInfo, $DisplayInfo$$Type} from "net.minecraft.advancements.DisplayInfo"
import {$AdvancementNode, $AdvancementNode$$Type} from "net.minecraft.advancements.AdvancementNode"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $AdvancementNodeKJS {

 "getId"(): $ResourceLocation
 "self"(): $AdvancementNode
 "getTitle"(): $Component
 "hasDisplay"(): boolean
 "getParent"(): $AdvancementNode
 "addChild"(arg0: $AdvancementNode$$Type): void
 "getDescription"(): $Component
 "getChildren"(): $Set<($AdvancementNode)>
 "getDisplayText"(): $Component
 "getDisplay"(): $DisplayInfo
get "id"(): $ResourceLocation
get "title"(): $Component
get "parent"(): $AdvancementNode
get "description"(): $Component
get "children"(): $Set<($AdvancementNode)>
get "displayText"(): $Component
get "display"(): $DisplayInfo
}

export namespace $AdvancementNodeKJS {
const probejs$$marker: never
}
export class $AdvancementNodeKJS$$Static implements $AdvancementNodeKJS {


 "getId"(): $ResourceLocation
 "self"(): $AdvancementNode
 "getTitle"(): $Component
 "hasDisplay"(): boolean
 "getParent"(): $AdvancementNode
 "addChild"(arg0: $AdvancementNode$$Type): void
 "getDescription"(): $Component
 "getChildren"(): $Set<($AdvancementNode)>
 "getDisplayText"(): $Component
 "getDisplay"(): $DisplayInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdvancementNodeKJS$$Type = ($AdvancementNodeKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AdvancementNodeKJS_ = $AdvancementNodeKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.BlockEntityRendererRegistryKubeEvent" {
import {$ClientKubeEvent, $ClientKubeEvent$$Type} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityRendererProvider, $BlockEntityRendererProvider$$Type} from "net.minecraft.client.renderer.blockentity.BlockEntityRendererProvider"
import {$EntityRenderersEvent$RegisterRenderers, $EntityRenderersEvent$RegisterRenderers$$Type} from "net.neoforged.neoforge.client.event.EntityRenderersEvent$RegisterRenderers"
import {$Minecraft, $Minecraft$$Type} from "net.minecraft.client.Minecraft"

export class $BlockEntityRendererRegistryKubeEvent implements $ClientKubeEvent {

constructor(arg0: $EntityRenderersEvent$RegisterRenderers$$Type)

public "register"(arg0: $BlockEntityType$$Type<(any)>, arg1: $BlockEntityRendererProvider$$Type<(any)>): void
public "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityRendererRegistryKubeEvent$$Type = ($BlockEntityRendererRegistryKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityRendererRegistryKubeEvent_ = $BlockEntityRendererRegistryKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.drop.BlockDropSupplier" {
import {$BlockDrops, $BlockDrops$$Type} from "dev.latvian.mods.kubejs.block.drop.BlockDrops"

export interface $BlockDropSupplier {

 "get"(): $BlockDrops

(): $BlockDrops$$Type
}

export namespace $BlockDropSupplier {
const NO_DROPS: $BlockDropSupplier
const probejs$$marker: never
}
export class $BlockDropSupplier$$Static implements $BlockDropSupplier {
static readonly "NO_DROPS": $BlockDropSupplier


 "get"(): $BlockDrops
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDropSupplier$$Type = (() => $BlockDrops$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockDropSupplier_ = $BlockDropSupplier$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.minecraft.ShapedKubeRecipe" {
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction, $RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$KubeRecipeFactory, $KubeRecipeFactory$$Type} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ShapedKubeRecipe extends $KubeRecipe {
static readonly "RECIPE_FACTORY": $KubeRecipeFactory
static readonly "CHANGED_MARKER": string
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "sourceLine": $SourceLine
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean
 "creationError": boolean

constructor()

public "afterLoaded"(): void
public "getSerializationTypeFunction"(): $RecipeTypeFunction
get "serializationTypeFunction"(): $RecipeTypeFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedKubeRecipe$$Type = ($ShapedKubeRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapedKubeRecipe_ = $ShapedKubeRecipe$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemModificationKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemModificationKubeEvent$ItemModifications, $ItemModificationKubeEvent$ItemModifications$$Type} from "dev.latvian.mods.kubejs.item.ItemModificationKubeEvent$ItemModifications"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

/**
 * Invoked after all items are registered to modify them.
 */
export class $ItemModificationKubeEvent implements $KubeEvent {

constructor()

/**
 * Modifies items matching the given ingredient.
 * 
 * **NOTE**: tag ingredients are not supported at this time.
 */
public "modify"(arg0: $ItemPredicate$$Type, arg1: $Consumer$$Type<($ItemModificationKubeEvent$ItemModifications)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModificationKubeEvent$$Type = ($ItemModificationKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemModificationKubeEvent_ = $ItemModificationKubeEvent$$Type;
}}
declare module "dev.latvian.mods.rhino.Scriptable" {
import {$MemberType, $MemberType$$Type} from "dev.latvian.mods.rhino.MemberType"
import {$IdEnumerationIterator, $IdEnumerationIterator$$Type} from "dev.latvian.mods.rhino.IdEnumerationIterator"
import {$DefaultValueTypeHint, $DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $Scriptable extends $IdEnumerationIterator {

 "get"(arg1: integer, arg2: $Scriptable$$Type): any
 "get"(arg1: string, arg2: $Scriptable$$Type): any
 "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
 "put"(arg1: string, arg2: $Scriptable$$Type, arg3: any): void
 "delete"(arg1: string): void
 "delete"(arg1: integer): void
 "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
 "getClassName"(): string
 "has"(arg1: string, arg2: $Scriptable$$Type): boolean
 "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
 "getTypeOf"(): $MemberType
 "getAllIds"(): (any)[]
 "getIds"(): (any)[]
 "getParentScope"(): $Scriptable
 "getPrototype"(): $Scriptable
 "hasInstance"(arg1: $Scriptable$$Type): boolean
 "setPrototype"(arg0: $Scriptable$$Type): void
 "setParentScope"(arg0: $Scriptable$$Type): void
 "enumerationIteratorHasNext"(currentId: $Consumer$$Type<(any)>): boolean
 "enumerationIteratorNext"(currentId: $Consumer$$Type<(any)>): boolean
get "className"(): string
get "typeOf"(): $MemberType
get "allIds"(): (any)[]
get "ids"(): (any)[]
get "parentScope"(): $Scriptable
get "prototype"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
set "parentScope"(value: $Scriptable$$Type)
}

export namespace $Scriptable {
const NOT_FOUND: any
const probejs$$marker: never
}
export class $Scriptable$$Static implements $Scriptable {
static readonly "NOT_FOUND": any


 "get"(arg1: integer, arg2: $Scriptable$$Type): any
 "get"(arg1: string, arg2: $Scriptable$$Type): any
 "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
 "put"(arg1: string, arg2: $Scriptable$$Type, arg3: any): void
 "delete"(arg1: string): void
 "delete"(arg1: integer): void
 "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
 "getClassName"(): string
 "has"(arg1: string, arg2: $Scriptable$$Type): boolean
 "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
 "getTypeOf"(): $MemberType
 "getAllIds"(): (any)[]
 "getIds"(): (any)[]
 "getParentScope"(): $Scriptable
 "getPrototype"(): $Scriptable
 "hasInstance"(arg1: $Scriptable$$Type): boolean
 "setPrototype"(arg0: $Scriptable$$Type): void
 "setParentScope"(arg0: $Scriptable$$Type): void
 "enumerationIteratorHasNext"(currentId: $Consumer$$Type<(any)>): boolean
 "enumerationIteratorNext"(currentId: $Consumer$$Type<(any)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Scriptable$$Type = ($Scriptable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Scriptable_ = $Scriptable$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.BlockRightClickedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BlockHitResult, $BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player right clicks on a block.
 */
export class $BlockRightClickedKubeEvent implements $KubePlayerEvent {

constructor(arg0: $ItemStack$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type, arg3: $BlockPos$$Type, arg4: $Direction$$Type, arg5: $BlockHitResult$$Type)

/**
 * The position of the block that was right clicked.
 */
public "getItem"(): $ItemStack
/**
 * The player that right clicked the block.
 */
public "getEntity"(): $Player
/**
 * The block that was right clicked.
 */
public "getBlock"(): $BlockContainerJS
public "getHitResult"(): $BlockHitResult
/**
 * The hand that was used to right click the block.
 */
public "getHand"(): $InteractionHand
/**
 * The face of the block being right clicked.
 */
public "getFacing"(): $Direction
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "item"(): $ItemStack
get "entity"(): $Player
get "block"(): $BlockContainerJS
get "hitResult"(): $BlockHitResult
get "hand"(): $InteractionHand
get "facing"(): $Direction
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRightClickedKubeEvent$$Type = ($BlockRightClickedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockRightClickedKubeEvent_ = $BlockRightClickedKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.SmithingTemplateItemBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$List, $List$$Type} from "java.util.List"
import {$ItemBuilder, $ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $SmithingTemplateItemBuilder extends $ItemBuilder {
 "appliesToText": $Component
 "ingredientsText": $Component
 "appliesToSlotDescriptionText": $Component
 "ingredientSlotDescriptionText": $Component
readonly "appliesToEmptyIcons": $List<($ResourceLocation)>
readonly "ingredientsSlotEmptyIcons": $List<($ResourceLocation)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

/**
 * Sets the name for this smithing template.
 * Note that the normal display name for all smithing templates is the same and cannot be changed, this instead sets the name in the tooltip (see vanilla smithing templates for what this looks like).
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(arg0: $Component$$Type): $BuilderBase<(any)>
/**
 * Sets the description text that shows in the item tooltip to describe what ingredients can be added.
 * Using 'Ingots & Crystals' or 'Netherite Ingot' will use the vanilla language keys so it is translated into other languages automatically.
 * THIS IS PURELY VISUAL
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientsText` field.
 */
public "ingredients"(arg0: string): this
/**
 * Sets the description text that shows in the item tooltip to describe what it can be applied to.
 * Using 'Armor' or 'Diamond Equipment' will use the vanilla language keys so it is translated into other languages automatically.
 * THIS IS PURELY VISUAL
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientsText` field.
 */
public "appliesTo"(arg0: string): this
/**
 * Adds a helmet to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "helmetIcon"(): this
/**
 * Adds a shovel to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "shovelIcon"(): this
/**
 * Adds all basic tool icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "toolIcons"(): this
/**
 * Adds an ingot to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "ingotIcon"(): this
/**
 * Adds an amethyst shard to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "shardIcon"(): this
/**
 * Adds all armor icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "armorIcons"(): this
/**
 * Adds a dust to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "dustIcon"(): this
/**
 * Adds a quartz to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "quartzIcon"(): this
/**
 * Adds a lapis lazuli to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "lapisIcon"(): this
/**
 * Adds a sword to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "swordIcon"(): this
/**
 * Adds a axe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "axeIcon"(): this
/**
 * Adds a hoe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "hoeIcon"(): this
/**
 * Adds boots to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "bootsIcon"(): this
/**
 * Adds a pickaxe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "pickaxeIcon"(): this
/**
 * Adds a dust, diamond, emerald, quartz, lapis lazuli and amethyst shard icons to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "crystalIcons"(): this
/**
 * Adds a chestplate to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "chestplateIcon"(): this
/**
 * Adds a diamond to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "diamondIcon"(): this
/**
 * Adds leggings to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "leggingsIcon"(): this
/**
 * Adds all armor and basic tool icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "equipmentIcons"(): this
/**
 * Adds an emerald to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "emeraldIcon"(): this
/**
 * Adds an ingot, dust, diamond, emerald, quartz, lapis lazuli and amethyst shard icons to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "ingotAndCrystalIcons"(): this
/**
 * Adds the specified texture location to the list of base slot icons that the smithing table cycles through when this smithing template is put in.
 */
public "addAppliesToSlotIcon"(arg0: $ResourceLocation$$Type): this
/**
 * Adds the specified texture location to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "addIngredientsSlotIcon"(arg0: $ResourceLocation$$Type): this
/**
 * Sets the description text that shows when you hover over the base item slot when this item is put in smithing table as a template.
 * Using 'Add a piece of armor' or 'Add diamond armor, weapon, or tool' will use the vanilla language keys so it is translated into other languages automatically.
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `appliesToSlotDescriptionText` field.
 */
public "appliesToSlotDescription"(arg0: string): this
/**
 * Sets the description text that shows when you hover over the ingredient slot when this item is put in smithing table as a template.
 * Using 'Add ingot or crystal' or 'Add Netherite Ingot' will use the vanilla language keys so it is translated into other languages automatically.
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientSlotDescriptionText` field.
 */
public "ingredientsSlotDescription"(arg0: string): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmithingTemplateItemBuilder$$Type = ($SmithingTemplateItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SmithingTemplateItemBuilder_ = $SmithingTemplateItemBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.DynamicItemTooltipsKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$TooltipFlag, $TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"

export class $DynamicItemTooltipsKubeEvent implements $KubeEvent {
readonly "item": $ItemStack
readonly "lines": $List<($Component)>
readonly "startup": boolean
readonly "advanced": boolean
readonly "creative": boolean
readonly "shift": boolean
readonly "ctrl": boolean
readonly "alt": boolean

constructor(arg0: $ItemStack$$Type, arg1: $TooltipFlag$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: boolean)

public "add"(arg0: $List$$Type<($Component$$Type)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicItemTooltipsKubeEvent$$Type = ($DynamicItemTooltipsKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DynamicItemTooltipsKubeEvent_ = $DynamicItemTooltipsKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Variant" {
import {$VariantBlockStateGenerator$Model, $VariantBlockStateGenerator$Model$$Type} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Model"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"

export class $VariantBlockStateGenerator$Variant {

constructor()

public "model"(arg0: $ResourceLocation$$Type): $VariantBlockStateGenerator$Model
public "toJson"(): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$Variant$$Type = ($VariantBlockStateGenerator$Variant);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariantBlockStateGenerator$Variant_ = $VariantBlockStateGenerator$Variant$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.TextIcons" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Style, $Style$$Type} from "net.minecraft.network.chat.Style"
import {$MutableComponent, $MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $TextIcons {

}

export namespace $TextIcons {
const FONT: $ResourceLocation
const STYLE: $Style
const NAME: $Component
function info(): $MutableComponent
function id(): $MutableComponent
function copy(): $MutableComponent
function error(): $MutableComponent
function warn(): $MutableComponent
function minus(): $MutableComponent
function tag(): $MutableComponent
function plus(): $MutableComponent
function no(): $MutableComponent
function itemTag(): $MutableComponent
function yes(arg0: boolean): $MutableComponent
function yes(): $MutableComponent
function icon(arg0: $MutableComponent$$Type): $MutableComponent
function icons(arg0: string): $MutableComponent
function crafting(): $MutableComponent
function patchedComponent(): $MutableComponent
function prototypeComponent(): $MutableComponent
function entityTypeTag(): $MutableComponent
function blockTagIcon(): $MutableComponent
function smallSpace(): $MutableComponent
function tilde(): $MutableComponent
function fluidTag(): $MutableComponent
function logo(): $MutableComponent
const probejs$$marker: never
}
export class $TextIcons$$Static implements $TextIcons {
static readonly "FONT": $ResourceLocation
static readonly "STYLE": $Style
static readonly "NAME": $Component


static "info"(): $MutableComponent
static "id"(): $MutableComponent
static "copy"(): $MutableComponent
static "error"(): $MutableComponent
static "warn"(): $MutableComponent
static "minus"(): $MutableComponent
static "tag"(): $MutableComponent
static "plus"(): $MutableComponent
static "no"(): $MutableComponent
static "itemTag"(): $MutableComponent
static "yes"(arg0: boolean): $MutableComponent
static "yes"(): $MutableComponent
static "icon"(arg0: $MutableComponent$$Type): $MutableComponent
static "icons"(arg0: string): $MutableComponent
static "crafting"(): $MutableComponent
static "patchedComponent"(): $MutableComponent
static "prototypeComponent"(): $MutableComponent
static "entityTypeTag"(): $MutableComponent
static "blockTagIcon"(): $MutableComponent
static "smallSpace"(): $MutableComponent
static "tilde"(): $MutableComponent
static "fluidTag"(): $MutableComponent
static "logo"(): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextIcons$$Type = ($TextIcons);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextIcons_ = $TextIcons$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemPickedUpKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player picks up an item. Cancelling (in `ItemEvents.canPickUp`) will prevent the item from being picked up.
 */
export class $ItemPickedUpKubeEvent implements $KubePlayerEvent {

constructor(arg0: $Player$$Type, arg1: $ItemEntity$$Type, arg2: $ItemStack$$Type)

/**
 * The item that was picked up.
 */
public "getItem"(): $ItemStack
/**
 * The player that picked up the item.
 */
public "getEntity"(): $Entity
/**
 * The item entity that was picked up.
 */
public "getItemEntity"(): $ItemEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "item"(): $ItemStack
get "entity"(): $Entity
get "itemEntity"(): $ItemEntity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPickedUpKubeEvent$$Type = ($ItemPickedUpKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPickedUpKubeEvent_ = $ItemPickedUpKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.text.action.TextAction" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Map, $Map$$Type} from "java.util.Map"
import {$TooltipActionType, $TooltipActionType$$Type} from "dev.latvian.mods.kubejs.text.action.TooltipActionType"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $TextAction {

 "type"(): $TooltipActionType<(any)>
 "apply"(arg0: $List$$Type<($Component$$Type)>): void
}

export namespace $TextAction {
const MAP: $Map<(integer), ($TooltipActionType<(any)>)>
const STREAM_CODEC: $StreamCodec<($RegistryFriendlyByteBuf), ($TextAction)>
const probejs$$marker: never
}
export class $TextAction$$Static implements $TextAction {
static readonly "MAP": $Map<(integer), ($TooltipActionType<(any)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($TextAction)>


 "type"(): $TooltipActionType<(any)>
 "apply"(arg0: $List$$Type<($Component$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextAction$$Type = ($TextAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextAction_ = $TextAction$$Type;
}}
declare module "dev.latvian.mods.kubejs.level.ExplosionKubeEvent$Before" {
import {$Explosion, $Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ExplosionKubeEvent, $ExplosionKubeEvent$$Type} from "dev.latvian.mods.kubejs.level.ExplosionKubeEvent"

/**
 * Invoked right before an explosion happens.
 */
export class $ExplosionKubeEvent$Before extends $ExplosionKubeEvent {

constructor(arg0: $Level$$Type, arg1: $Explosion$$Type)

/**
 * Returns the size of the explosion.
 */
public "getSize"(): float
/**
 * Sets the size of the explosion.
 */
public "setSize"(arg0: float): void
get "size"(): float
set "size"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionKubeEvent$Before$$Type = ($ExplosionKubeEvent$Before);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionKubeEvent$Before_ = $ExplosionKubeEvent$Before$$Type;
}}
declare module "dev.latvian.mods.kubejs.server.ServerKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $ServerKubeEvent implements $KubeEvent {
readonly "server": $MinecraftServer

constructor(arg0: $MinecraftServer$$Type)

public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerKubeEvent$$Type = ($ServerKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerKubeEvent_ = $ServerKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.fluid.FluidBuilder" {
import {$BlockRenderType, $BlockRenderType$$Type} from "dev.latvian.mods.kubejs.block.BlockRenderType"
import {$FluidBucketItemBuilder, $FluidBucketItemBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder"
import {$FlowingFluid, $FlowingFluid$$Type} from "net.minecraft.world.level.material.FlowingFluid"
import {$FluidBlockBuilder, $FluidBlockBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder"
import {$FluidTypeBuilder, $FluidTypeBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$FlowingFluidBuilder, $FlowingFluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$BaseFlowingFluid$Properties, $BaseFlowingFluid$Properties$$Type} from "net.neoforged.neoforge.fluids.BaseFlowingFluid$Properties"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $FluidBuilder extends $BuilderBase<($FlowingFluid)> {
static readonly "WATER_COLOR": $KubeColor
 "fluidType": $FluidTypeBuilder
 "flowingFluid": $FlowingFluidBuilder
 "block": $FluidBlockBuilder
 "bucketItem": $FluidBucketItemBuilder
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "type"(arg0: $Consumer$$Type<($FluidTypeBuilder)>): this
public "createProperties"(): $BaseFlowingFluid$Properties
public "displayName"(arg0: $Component$$Type): $BuilderBase<($FlowingFluid)>
public "tag"(arg0: ($ResourceLocation$$Type)[]): $BuilderBase<($FlowingFluid)>
public "tint"(arg0: $KubeColor$$Type): this
public "tickRate"(arg0: integer): this
public "renderType"(arg0: $BlockRenderType$$Type): this
public "flowingTexture"(arg0: $ResourceLocation$$Type): this
public "translucent"(): this
public "explosionResistance"(arg0: float): this
public "slopeFindDistance"(arg0: integer): this
public "levelDecreasePerBlock"(arg0: integer): this
public "noBlock"(): this
public "noBucket"(): this
public "stillTexture"(arg0: $ResourceLocation$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBuilder$$Type = ($FluidBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidBuilder_ = $FluidBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.PlatformWrapper$ModInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $PlatformWrapper$ModInfo {

constructor(arg0: string)

public "getName"(): string
public "setName"(arg0: string): void
public "getId"(): string
public "getVersion"(): string
public "getCustomName"(): string
get "name"(): string
set "name"(value: string)
get "id"(): string
get "version"(): string
get "customName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformWrapper$ModInfo$$Type = ($PlatformWrapper$ModInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformWrapper$ModInfo_ = $PlatformWrapper$ModInfo$$Type;
}}
declare module "dev.latvian.mods.kubejs.player.ChestKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$InventoryKubeEvent, $InventoryKubeEvent$$Type} from "dev.latvian.mods.kubejs.player.InventoryKubeEvent"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"

/**
 * Invoked when a player opens a chest.
 * 
 * Same as `PlayerEvents.inventoryOpened`, but only for chests.
 */
export class $ChestKubeEvent extends $InventoryKubeEvent {

constructor(arg0: $Player$$Type, arg1: $AbstractContainerMenu$$Type)

/**
 * Gets the chest block.
 */
public "getBlock"(): $BlockContainerJS
/**
 * Gets the chest inventory.
 */
public "getInventory"(): $Container
/**
 * Gets the player that opened or closed the container.
 */
public "getEntity"(): $LivingEntity
get "block"(): $BlockContainerJS
get "inventory"(): $Container
get "entity"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestKubeEvent$$Type = ($ChestKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestKubeEvent_ = $ChestKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.fluid.ThickFluidBuilder" {
import {$FluidBucketItemBuilder, $FluidBucketItemBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder"
import {$FlowingFluidBuilder, $FlowingFluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$FluidBlockBuilder, $FluidBlockBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder"
import {$FluidTypeBuilder, $FluidTypeBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ThickFluidBuilder extends $FluidBuilder {
static readonly "WATER_COLOR": $KubeColor
 "fluidType": $FluidTypeBuilder
 "flowingFluid": $FlowingFluidBuilder
 "block": $FluidBlockBuilder
 "bucketItem": $FluidBucketItemBuilder
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThickFluidBuilder$$Type = ($ThickFluidBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThickFluidBuilder_ = $ThickFluidBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.JsonIO" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$DataOutputStream, $DataOutputStream$$Type} from "java.io.DataOutputStream"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$JsonArray, $JsonArray$$Type} from "com.google.gson.JsonArray"

export class $JsonIO {

constructor()

public static "toString"(arg0: $JsonElement$$Type): string
public static "toArray"(arg0: $JsonElement$$Type): $JsonArray
public static "write"(arg0: $Path$$Type, arg1: $JsonObject$$Type): void
public static "read"(arg0: $Path$$Type): $Map<(any), (any)>
public static "parse"(arg0: string): any
public static "readString"(arg0: $Path$$Type): string
public static "writeJsonHash"(arg0: $DataOutputStream$$Type, arg1: $JsonElement$$Type): void
public static "getJsonHashBytes"(arg0: $JsonElement$$Type): (byte)[]
public static "readJson"(arg0: $Path$$Type): $JsonElement
public static "toObject"(arg0: $JsonElement$$Type): any
public static "toPrimitive"(arg0: $JsonElement$$Type): any
public static "parseRaw"(arg0: string): $JsonElement
public static "getJsonHashString"(arg0: $JsonElement$$Type): string
public static "toPrettyString"(arg0: $JsonElement$$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonIO$$Type = ($JsonIO);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JsonIO_ = $JsonIO$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.LoadedTexture" {
import {$BufferedImage, $BufferedImage$$Type} from "java.awt.image.BufferedImage"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"

export class $LoadedTexture {
static readonly "EMPTY": $LoadedTexture
readonly "width": integer
readonly "height": integer
readonly "pixels": (integer)[]
readonly "mcmeta": (byte)[]

constructor(arg0: $BufferedImage$$Type, arg1: (byte)[])
constructor(arg0: integer, arg1: integer, arg2: (integer)[], arg3: (byte)[])

public "toBytes"(): (byte)[]
public static "load"(arg0: $ResourceLocation$$Type): $LoadedTexture
public "copy"(): $LoadedTexture
public "resize"(arg0: integer, arg1: integer): $LoadedTexture
public "tint"(arg0: $KubeColor$$Type): $LoadedTexture
public "remap"(arg0: $Map$$Type<($KubeColor$$Type), ($KubeColor$$Type)>): $LoadedTexture
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LoadedTexture$$Type = ($LoadedTexture);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LoadedTexture_ = $LoadedTexture$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionType" {
import {$Lazy, $Lazy$$Type} from "dev.latvian.mods.kubejs.util.Lazy"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$IngredientAction, $IngredientAction$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $IngredientActionType<T extends $IngredientAction> extends $Record {
static readonly "TYPES": $Lazy<($Map<(string), ($IngredientActionType<(any)>)>)>
static readonly "CODEC": $Codec<($IngredientActionType<(any)>)>

constructor(id: string, codec: $MapCodec$$Type<(T)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "id"(): string
public "codec"(): $MapCodec<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientActionType$$Type<T> = ({"id"?: string, "codec"?: $MapCodec$$Type<(never)>}) | ([id?: string, codec?: $MapCodec$$Type<(never)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientActionType_<T> = $IngredientActionType$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.core.RegistryObjectKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export interface $RegistryObjectKJS<T> {

 "getId"(): string
 "getKey"(): $ResourceKey<(T)>
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "asHolder"(): $Holder<(T)>
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
 "getRegistry"(): $Registry<(T)>
 "getRegistryId"(): $ResourceKey<($Registry<(T)>)>
get "id"(): string
get "key"(): $ResourceKey<(T)>
get "mod"(): string
get "idLocation"(): $ResourceLocation
get "tags"(): $Collection<($ResourceLocation)>
get "registry"(): $Registry<(T)>
get "registryId"(): $ResourceKey<($Registry<(T)>)>
}

export namespace $RegistryObjectKJS {
const probejs$$marker: never
}
export class $RegistryObjectKJS$$Static<T> implements $RegistryObjectKJS {


 "getId"(): string
 "getKey"(): $ResourceKey<(T)>
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "asHolder"(): $Holder<(T)>
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
 "getRegistry"(): $Registry<(T)>
 "getRegistryId"(): $ResourceKey<($Registry<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryObjectKJS$$Type<T> = ($RegistryObjectKJS<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryObjectKJS_<T> = $RegistryObjectKJS$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.client.KubeSessionData" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$List, $List$$Type} from "java.util.List"
import {$KubeServerData, $KubeServerData$$Type} from "dev.latvian.mods.kubejs.net.KubeServerData"
import {$ClientPacketListener, $ClientPacketListener$$Type} from "net.minecraft.client.multiplayer.ClientPacketListener"
import {$Minecraft, $Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$ItemTooltipData, $ItemTooltipData$$Type} from "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData"
import {$RecipeViewerData, $RecipeViewerData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData"

export class $KubeSessionData {
 "activePostShader": $ResourceLocation
 "recipeViewerData": $RecipeViewerData
 "itemTooltips": $List<($ItemTooltipData)>

constructor()

public static "of"(arg0: $Minecraft$$Type): $KubeSessionData
public static "of"(arg0: $ClientPacketListener$$Type): $KubeSessionData
public "sync"(arg0: $KubeServerData$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeSessionData$$Type = ($KubeSessionData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeSessionData_ = $KubeSessionData$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$DataComponentSubtypes" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $FluidData$DataComponentSubtypes extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData$DataComponentSubtypes)>

constructor(filter: $FluidIngredient$$Type, components: $List$$Type<($DataComponentType$$Type<(any)>)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "filter"(): $FluidIngredient
public "components"(): $List<($DataComponentType<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$DataComponentSubtypes$$Type = ({"filter"?: $FluidIngredient$$Type, "components"?: $List$$Type<($DataComponentType$$Type<(never)>)>}) | ([filter?: $FluidIngredient$$Type, components?: $List$$Type<($DataComponentType$$Type<(never)>)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidData$DataComponentSubtypes_ = $FluidData$DataComponentSubtypes$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.KubeRecipe" {
import {$CustomJavaToJsWrapper, $CustomJavaToJsWrapper$$Type} from "dev.latvian.mods.rhino.util.CustomJavaToJsWrapper"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$RecipeLikeKJS, $RecipeLikeKJS$$Type} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$ReplacementMatchInfo, $ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$RecipeComponentValue, $RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeTypeFunction, $RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$Recipe, $Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"
import {$SlotFilter, $SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$IngredientAction, $IngredientAction$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RecipeSerializer, $RecipeSerializer$$Type} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $KubeRecipe implements $RecipeLikeKJS, $CustomJavaToJsWrapper {
static readonly "CHANGED_MARKER": string
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "sourceLine": $SourceLine
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean
 "creationError": boolean

constructor()

public "group"(arg0: string): $KubeRecipe
public "remove"(): void
public "get"(arg0: string): any
public "toString"(): string
public "getValue"<T>(arg0: $RecipeKey$$Type<(T)>): T
public "merge"(arg0: $JsonObject$$Type): $KubeRecipe
public "id"(arg0: $ResourceLocation$$Type): $KubeRecipe
public "set"(arg1: string, arg2: any): $KubeRecipe
public "getId"(): string
public "save"(): void
public "setValue"<T>(arg0: $RecipeKey$$Type<(T)>, arg1: T): $KubeRecipe
public "getPath"(): string
public "stage"(arg0: string): $KubeRecipe
public "deserialize"(arg0: boolean): void
public "serialize"(): void
public "hasOutput"(arg1: $ReplacementMatchInfo$$Type): boolean
/**
 * 
 * @deprecated
 */
public "kjs$setGroup"(arg0: string): void
public "replaceInput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "kjs$getSerializer"(): $RecipeSerializer<(any)>
/**
 * 
 * @deprecated
 */
public "kjs$getGroup"(): string
/**
 * 
 * @deprecated
 */
public "kjs$getOrCreateId"(): $ResourceLocation
/**
 * 
 * @deprecated
 */
public "kjs$getSchema"(): $RecipeSchema
public "replaceOutput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "convertJavaToJs"(arg1: $Scriptable$$Type, arg2: $TypeInfo$$Type): $Scriptable
/**
 * 
 * @deprecated
 */
public "kjs$getType"(): $ResourceLocation
public "hasChanged"(): boolean
public "replaceIngredient"(arg0: $SlotFilter$$Type, arg1: $ItemStack$$Type): $KubeRecipe
public "damageIngredient"(arg0: $SlotFilter$$Type): $KubeRecipe
public "damageIngredient"(arg0: $SlotFilter$$Type, arg1: integer): $KubeRecipe
public "inputValues"(): ($RecipeComponentValue<(any)>)[]
public "outputValues"(): ($RecipeComponentValue<(any)>)[]
public "getOriginalRecipe"(): $Recipe<(any)>
public "keepIngredient"(arg0: $SlotFilter$$Type): $KubeRecipe
public "getFromToString"(): string
public "consumeIngredient"(arg0: $SlotFilter$$Type): $KubeRecipe
public "serializeChanges"(): $KubeRecipe
public "ingredientAction"(arg0: $SlotFilter$$Type, arg1: $IngredientAction$$Type): $KubeRecipe
public "afterLoaded"(): void
public "hasInput"(arg1: $ReplacementMatchInfo$$Type): boolean
public "getOriginalRecipeIngredients"(): $List<($Ingredient)>
public "getSerializationTypeFunction"(): $RecipeTypeFunction
public "modifyResult"(arg0: string): $KubeRecipe
public "initValues"(arg0: boolean): void
public "customIngredientAction"(arg0: $SlotFilter$$Type, arg1: string): $KubeRecipe
public "getOriginalRecipeResult"(): $ItemStack
public "kjs$getMod"(): string
get "path"(): string
get "originalRecipe"(): $Recipe<(any)>
get "fromToString"(): string
get "originalRecipeIngredients"(): $List<($Ingredient)>
get "serializationTypeFunction"(): $RecipeTypeFunction
get "originalRecipeResult"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRecipe$$Type = ($KubeRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeRecipe_ = $KubeRecipe$$Type;
}}
declare module "dev.latvian.apps.tinyserver.ws.Opcode" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $Opcode extends $Enum<($Opcode)> {
static readonly "CONTINUOUS": $Opcode
static readonly "TEXT": $Opcode
static readonly "BINARY": $Opcode
static readonly "CLOSING": $Opcode
static readonly "PING": $Opcode
static readonly "PONG": $Opcode
readonly "opcode": byte


public static "get"(arg0: integer): $Opcode
public static "values"(): ($Opcode)[]
public static "valueOf"(arg0: string): $Opcode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Opcode$$Type = (("continuous") | ("text") | ("binary") | ("closing") | ("ping") | ("pong"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Opcode_ = $Opcode$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.HolderSetWrapper" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $HolderSetWrapper<T> extends $Record implements $Iterable<(T)> {

constructor(registry: $Registry$$Type<(T)>, holders: $HolderSet$$Type<(T)>)

public "size"(): integer
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "iterator"(): $Iterator<(T)>
public "contains"(arg0: $ResourceLocation$$Type): boolean
public "containsValue"(arg0: T): boolean
public "getKeys"(): $Set<($ResourceLocation)>
public "holders"(): $HolderSet<(T)>
public "registry"(): $Registry<(T)>
public "getValues"(): $List<(T)>
public "getRandom"(arg0: $RandomSource$$Type): T
public "getRandom"(): T
public "spliterator"(): $Spliterator<(T)>
public "forEach"(arg0: $Consumer$$Type<(T)>): void
[Symbol.iterator](): IterableIterator<T>;
get "empty"(): boolean
get "keys"(): $Set<($ResourceLocation)>
get "values"(): $List<(T)>
get "random"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HolderSetWrapper$$Type<T> = ({"holders"?: $HolderSet$$Type<(never)>, "registry"?: $Registry$$Type<(never)>}) | ([holders?: $HolderSet$$Type<(never)>, registry?: $Registry$$Type<(never)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HolderSetWrapper_<T> = $HolderSetWrapper$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback" {
import {$ChestMenuClickEvent, $ChestMenuClickEvent$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent"

export interface $ChestMenuClickEvent$Callback {

 "onClick"(arg0: $ChestMenuClickEvent$$Type): void

(arg0: $ChestMenuClickEvent): void
}

export namespace $ChestMenuClickEvent$Callback {
const probejs$$marker: never
}
export class $ChestMenuClickEvent$Callback$$Static implements $ChestMenuClickEvent$Callback {


 "onClick"(arg0: $ChestMenuClickEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickEvent$Callback$$Type = ((arg0: $ChestMenuClickEvent) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuClickEvent$Callback_ = $ChestMenuClickEvent$Callback$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.ItemWrapper" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ItemAbility, $ItemAbility$$Type} from "net.neoforged.neoforge.common.ItemAbility"
import {$Fireworks, $Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

/**
 * Various item related helper methods
 */
export interface $ItemWrapper {

}

export namespace $ItemWrapper {
const ENTITY_TYPE_FIELD_CODEC: $MapCodec<($EntityType<(any)>)>
function of(arg0: $ItemStack$$Type): $ItemStack
function of(arg0: $ItemStack$$Type, arg1: integer): $ItemStack
function getId(arg0: $Item$$Type): $ResourceLocation
function exists(arg0: $ResourceLocation$$Type): boolean
function getVariants(arg0: $ItemStack$$Type): $Collection<($ItemStack)>
function getItem(arg0: $ResourceLocation$$Type): $Item
function getList(): $List<($ItemStack)>
function getTypeList(): $List<(string)>
function isItem(arg0: any): boolean
function fireworks(arg0: $Fireworks$$Type): $Fireworks
function playerHead(arg0: string): $ItemStack
function itemAbilityOf(arg0: any): $ItemAbility
function playerHeadFromUrl(arg0: string): $ItemStack
function getTypeToStackMap(): $Map<($ResourceLocation), ($Collection<($ItemStack)>)>
function playerHeadFromSkinHash(arg0: string): $ItemStack
function playerHeadFromBase64(arg0: $UUID$$Type, arg1: string): $ItemStack
function getEmpty(): $ItemStack
const probejs$$marker: never
}
export class $ItemWrapper$$Static implements $ItemWrapper {
static readonly "ENTITY_TYPE_FIELD_CODEC": $MapCodec<($EntityType<(any)>)>


/**
 * Returns an ItemStack of the input
 */
static "of"(arg0: $ItemStack$$Type): $ItemStack
/**
 * Returns an ItemStack of the input, with the specified count
 */
static "of"(arg0: $ItemStack$$Type, arg1: integer): $ItemStack
/**
 * Gets an items id from the Item
 */
static "getId"(arg0: $Item$$Type): $ResourceLocation
/**
 * Checks if the provided item id exists in the registry
 */
static "exists"(arg0: $ResourceLocation$$Type): boolean
static "getVariants"(arg0: $ItemStack$$Type): $Collection<($ItemStack)>
/**
 * Gets an Item from an item id
 */
static "getItem"(arg0: $ResourceLocation$$Type): $Item
/**
 * Get a list of most items in the game. Items not in a creative tab are ignored
 */
static "getList"(): $List<($ItemStack)>
/**
 * Get a list of all the item ids in the game
 */
static "getTypeList"(): $List<(string)>
/**
 * Checks if the passed in object is an ItemStack.
 * Note that this does not mean it will not function as an ItemStack if passed to something that requests one.
 */
static "isItem"(arg0: any): boolean
/**
 * Returns a Firework with the input properties
 */
static "fireworks"(arg0: $Fireworks$$Type): $Fireworks
static "playerHead"(arg0: string): $ItemStack
static "itemAbilityOf"(arg0: any): $ItemAbility
static "playerHeadFromUrl"(arg0: string): $ItemStack
static "getTypeToStackMap"(): $Map<($ResourceLocation), ($Collection<($ItemStack)>)>
static "playerHeadFromSkinHash"(arg0: string): $ItemStack
static "playerHeadFromBase64"(arg0: $UUID$$Type, arg1: string): $ItemStack
/**
 * Get the item that represents air/an empty slot
 */
static "getEmpty"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemWrapper$$Type = ($ItemWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemWrapper_ = $ItemWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.net.SyncServerDataPayload" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$PacketFlow, $PacketFlow$$Type} from "net.minecraft.network.protocol.PacketFlow"
import {$FriendlyByteBuf, $FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$KubeServerData, $KubeServerData$$Type} from "dev.latvian.mods.kubejs.net.KubeServerData"
import {$CustomPacketPayload$Type, $CustomPacketPayload$Type$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$Type"
import {$StreamDecoder, $StreamDecoder$$Type} from "net.minecraft.network.codec.StreamDecoder"
import {$CustomPacketPayload, $CustomPacketPayload$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload"
import {$IPayloadContext, $IPayloadContext$$Type} from "net.neoforged.neoforge.network.handling.IPayloadContext"
import {$StreamMemberEncoder, $StreamMemberEncoder$$Type} from "net.minecraft.network.codec.StreamMemberEncoder"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"
import {$ServerboundCustomPayloadPacket, $ServerboundCustomPayloadPacket$$Type} from "net.minecraft.network.protocol.common.ServerboundCustomPayloadPacket"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$ClientboundCustomPayloadPacket, $ClientboundCustomPayloadPacket$$Type} from "net.minecraft.network.protocol.common.ClientboundCustomPayloadPacket"
import {$ConnectionProtocol, $ConnectionProtocol$$Type} from "net.minecraft.network.ConnectionProtocol"
import {$CustomPacketPayload$TypeAndCodec, $CustomPacketPayload$TypeAndCodec$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$TypeAndCodec"
import {$CustomPacketPayload$FallbackProvider, $CustomPacketPayload$FallbackProvider$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$FallbackProvider"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $SyncServerDataPayload extends $Record implements $CustomPacketPayload {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($SyncServerDataPayload)>

constructor(data: $KubeServerData$$Type)

public "type"(): $CustomPacketPayload$Type<(any)>
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "data"(): $KubeServerData
public "handle"(arg0: $IPayloadContext$$Type): void
public static "codec"<B extends $FriendlyByteBuf>(arg0: $CustomPacketPayload$FallbackProvider$$Type<(B)>, arg1: $List$$Type<($CustomPacketPayload$TypeAndCodec$$Type<(B), (any)>)>, arg2: $ConnectionProtocol$$Type, arg3: $PacketFlow$$Type): $StreamCodec<(B), ($CustomPacketPayload)>
public static "codec"<B extends $ByteBuf, T extends $CustomPacketPayload>(arg0: $StreamMemberEncoder$$Type<(B), (T)>, arg1: $StreamDecoder$$Type<(B), (T)>): $StreamCodec<(B), (T)>
public static "createType"<T extends $CustomPacketPayload>(arg0: string): $CustomPacketPayload$Type<(T)>
public "toVanillaClientbound"(): $ClientboundCustomPayloadPacket
public "toVanillaServerbound"(): $ServerboundCustomPayloadPacket
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SyncServerDataPayload$$Type = ({"data"?: $KubeServerData$$Type}) | ([data?: $KubeServerData$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SyncServerDataPayload_ = $SyncServerDataPayload$$Type;
}}
declare module "dev.latvian.mods.kubejs.generator.KubeDataGenerator" {
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$KubeResourceGenerator, $KubeResourceGenerator$$Type} from "dev.latvian.mods.kubejs.generator.KubeResourceGenerator"

export interface $KubeDataGenerator extends $KubeResourceGenerator {

 "add"(arg0: $GeneratedData$$Type): void
 "text"(arg0: $ResourceLocation$$Type, arg1: string): void
 "json"(arg0: $ResourceLocation$$Type, arg1: $JsonElement$$Type): void
 "getGenerated"(arg0: $ResourceLocation$$Type): $GeneratedData
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}

export namespace $KubeDataGenerator {
const probejs$$marker: never
}
export class $KubeDataGenerator$$Static implements $KubeDataGenerator {


 "add"(arg0: $GeneratedData$$Type): void
 "text"(arg0: $ResourceLocation$$Type, arg1: string): void
 "json"(arg0: $ResourceLocation$$Type, arg1: $JsonElement$$Type): void
 "getGenerated"(arg0: $ResourceLocation$$Type): $GeneratedData
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeDataGenerator$$Type = ($KubeDataGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeDataGenerator_ = $KubeDataGenerator$$Type;
}}
declare module "dev.latvian.mods.kubejs.misc.PoiTypeBuilder" {
import {$PoiType, $PoiType$$Type} from "net.minecraft.world.entity.ai.village.poi.PoiType"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PoiTypeBuilder extends $BuilderBase<($PoiType)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "block"(arg0: $Block$$Type): this
public "blocks"(arg0: ($BlockState$$Type)[]): this
public "maxTickets"(arg0: integer): this
public "validRange"(arg0: integer): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PoiTypeBuilder$$Type = ($PoiTypeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PoiTypeBuilder_ = $PoiTypeBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.event.KubeEvent" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $KubeEvent {

/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}

export namespace $KubeEvent {
const probejs$$marker: never
}
export class $KubeEvent$$Static implements $KubeEvent {


/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeEvent$$Type = ($KubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeEvent_ = $KubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.server.ServerScriptManager" {
import {$VirtualDataPack, $VirtualDataPack$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualDataPack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$GeneratedDataStage, $GeneratedDataStage$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedDataStage"
import {$PackResources, $PackResources$$Type} from "net.minecraft.server.packs.PackResources"
import {$PreTagKubeEvent, $PreTagKubeEvent$$Type} from "dev.latvian.mods.kubejs.server.tag.PreTagKubeEvent"
import {$RecipeSchemaStorage, $RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$KubeJSContextFactory, $KubeJSContextFactory$$Type} from "dev.latvian.mods.kubejs.script.KubeJSContextFactory"
import {$SyncServerDataPayload, $SyncServerDataPayload$$Type} from "dev.latvian.mods.kubejs.net.SyncServerDataPayload"
import {$ScriptPack, $ScriptPack$$Type} from "dev.latvian.mods.kubejs.script.ScriptPack"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ScriptManager, $ScriptManager$$Type} from "dev.latvian.mods.kubejs.script.ScriptManager"

export class $ServerScriptManager extends $ScriptManager {
readonly "preTagEvents": $Map<($ResourceKey<(any)>), ($PreTagKubeEvent)>
readonly "recipeSchemaStorage": $RecipeSchemaStorage
 "serverData": $SyncServerDataPayload
readonly "internalDataPack": $VirtualDataPack
readonly "registriesDataPack": $VirtualDataPack
readonly "virtualPacks": $Map<($GeneratedDataStage), ($VirtualDataPack)>
 "firstLoad": boolean
readonly "scriptType": $ScriptType
readonly "packs": $Map<(string), ($ScriptPack)>
 "contextFactory": $KubeJSContextFactory
 "canListenEvents": boolean


public static "release"(): $ServerScriptManager
public "reload"(): void
public "loadAdditional"(): void
public "reloadAndCapture"(): void
public "loadFromDirectory"(): void
public static "createPackResources"(arg0: $List$$Type<($PackResources$$Type)>): $List<($PackResources)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerScriptManager$$Type = ($ServerScriptManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerScriptManager_ = $ServerScriptManager$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator$Element" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$ModelGenerator$Face, $ModelGenerator$Face$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator$Face"
import {$AABB, $AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $ModelGenerator$Element {

constructor()

public "size"(arg0: $AABB$$Type): $ModelGenerator$Element
public "toJson"(): $JsonObject
public "allFaces"(arg0: $Consumer$$Type<($ModelGenerator$Face)>): void
public "faces"(arg0: ($Direction$$Type)[], arg1: $Consumer$$Type<($ModelGenerator$Face)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Element$$Type = ($ModelGenerator$Element);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelGenerator$Element_ = $ModelGenerator$Element$$Type;
}}
declare module "dev.latvian.mods.kubejs.fluid.ThinFluidBuilder" {
import {$FluidBucketItemBuilder, $FluidBucketItemBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder"
import {$FlowingFluidBuilder, $FlowingFluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$FluidBlockBuilder, $FluidBlockBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder"
import {$FluidTypeBuilder, $FluidTypeBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ThinFluidBuilder extends $FluidBuilder {
static readonly "WATER_COLOR": $KubeColor
 "fluidType": $FluidTypeBuilder
 "flowingFluid": $FlowingFluidBuilder
 "block": $FluidBlockBuilder
 "bucketItem": $FluidBucketItemBuilder
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThinFluidBuilder$$Type = ($ThinFluidBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThinFluidBuilder_ = $ThinFluidBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.plugin.ClassFilter" {
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Class, $Class$$Type} from "java.lang.Class"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ClassFilter {
readonly "scriptType": $ScriptType

constructor(arg0: $ScriptType$$Type)

public "allow"(arg0: $Class$$Type<(any)>): void
public "allow"(arg0: string): void
public "deny"(arg0: $Class$$Type<(any)>): void
public "deny"(arg0: string): void
public "isAllowed"(arg0: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassFilter$$Type = ($ClassFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassFilter_ = $ClassFilter$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.NBTIOWrapper" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Path, $Path$$Type} from "java.nio.file.Path"

export interface $NBTIOWrapper {

}

export namespace $NBTIOWrapper {
function write(arg0: $Path$$Type, arg1: $CompoundTag$$Type): void
function read(arg0: $Path$$Type): $CompoundTag
const probejs$$marker: never
}
export class $NBTIOWrapper$$Static implements $NBTIOWrapper {


static "write"(arg0: $Path$$Type, arg1: $CompoundTag$$Type): void
static "read"(arg0: $Path$$Type): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTIOWrapper$$Type = ($NBTIOWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NBTIOWrapper_ = $NBTIOWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$HurtEnemyContext" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $ItemBuilder$HurtEnemyContext extends $Record {

constructor(getItem: $ItemStack$$Type, getTarget: $LivingEntity$$Type, getAttacker: $LivingEntity$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getTarget"(): $LivingEntity
public "getItem"(): $ItemStack
public "getAttacker"(): $LivingEntity
get "target"(): $LivingEntity
get "item"(): $ItemStack
get "attacker"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$HurtEnemyContext$$Type = ({"getAttacker"?: $LivingEntity$$Type, "getItem"?: $ItemStack$$Type, "getTarget"?: $LivingEntity$$Type}) | ([getAttacker?: $LivingEntity$$Type, getItem?: $ItemStack$$Type, getTarget?: $LivingEntity$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBuilder$HurtEnemyContext_ = $ItemBuilder$HurtEnemyContext$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction" {
import {$Pattern, $Pattern$$Type} from "java.util.regex.Pattern"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$WrappedJS, $WrappedJS$$Type} from "dev.latvian.mods.kubejs.util.WrappedJS"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$BaseFunction, $BaseFunction$$Type} from "dev.latvian.mods.rhino.BaseFunction"
import {$RecipeSchemaType, $RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$RecipesKubeEvent, $RecipesKubeEvent$$Type} from "dev.latvian.mods.kubejs.recipe.RecipesKubeEvent"
import {$DefaultValueTypeHint, $DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $RecipeTypeFunction extends $BaseFunction implements $WrappedJS {
static readonly "SKIP_ERROR": $Pattern
readonly "event": $RecipesKubeEvent
readonly "id": $ResourceLocation
readonly "idString": string
readonly "schemaType": $RecipeSchemaType
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(arg0: $RecipesKubeEvent$$Type, arg1: $RecipeSchemaType$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "call"(arg1: $Scriptable$$Type, arg2: $Scriptable$$Type, arg3: (any)[]): $KubeRecipe
public "createRecipe"(arg1: $SourceLine$$Type, arg2: (any)[]): $KubeRecipe
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "getAllIds"(): (any)[]
public "getIds"(): (any)[]
public "getParentScope"(): $Scriptable
public "getPrototype"(): $Scriptable
public "setPrototype"(arg0: $Scriptable$$Type): void
public "setParentScope"(arg0: $Scriptable$$Type): void
get "allIds"(): (any)[]
get "ids"(): (any)[]
get "parentScope"(): $Scriptable
get "prototype"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
set "parentScope"(value: $Scriptable$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeTypeFunction$$Type = ($RecipeTypeFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeTypeFunction_ = $RecipeTypeFunction$$Type;
}}
declare module "dev.latvian.apps.tinyserver.content.ResponseContent" {
import {$OutputStream, $OutputStream$$Type} from "java.io.OutputStream"

export interface $ResponseContent {

 "type"(): string
 "length"(): long
 "write"(arg0: $OutputStream$$Type): void

(arg0: $OutputStream): void
}

export namespace $ResponseContent {
const probejs$$marker: never
}
export class $ResponseContent$$Static implements $ResponseContent {


 "type"(): string
 "length"(): long
 "write"(arg0: $OutputStream$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResponseContent$$Type = ((arg0: $OutputStream) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResponseContent_ = $ResponseContent$$Type;
}}
declare module "dev.latvian.apps.tinyserver.StatusCode" {
import {$Record, $Record$$Type} from "java.lang.Record"

export class $StatusCode extends $Record {

constructor(code: integer, message: string)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "code"(): integer
public "message"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatusCode$$Type = ({"message"?: string, "code"?: integer}) | ([message?: string, code?: integer]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatusCode_ = $StatusCode$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator" {
import {$VariantBlockStateGenerator$Variant, $VariantBlockStateGenerator$Variant$$Type} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Variant"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $VariantBlockStateGenerator {

constructor()

public "variant"(arg0: string, arg1: $Consumer$$Type<($VariantBlockStateGenerator$Variant)>): void
public "toJson"(): $JsonObject
public "simpleVariant"(arg0: string, arg1: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$$Type = ($VariantBlockStateGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariantBlockStateGenerator_ = $VariantBlockStateGenerator$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder" {
import {$ArmorMaterial, $ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ItemBuilder, $ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $ArmorItemBuilder extends $ItemBuilder {
readonly "armorType": $ArmorItem$Type
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>


public "material"(arg0: $Holder$$Type<($ArmorMaterial)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$$Type = ($ArmorItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorItemBuilder_ = $ArmorItemBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.mekanism.KubeChemicalBuilder$Liquid" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$KubeChemicalBuilder, $KubeChemicalBuilder$$Type} from "dev.latvian.mods.kubejs.mekanism.KubeChemicalBuilder"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $KubeChemicalBuilder$Liquid extends $KubeChemicalBuilder {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeChemicalBuilder$Liquid$$Type = ($KubeChemicalBuilder$Liquid);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeChemicalBuilder$Liquid_ = $KubeChemicalBuilder$Liquid$$Type;
}}
declare module "dev.latvian.mods.kubejs.server.tag.TagKubeEvent" {
import {$EventExceptionHandler, $EventExceptionHandler$$Type} from "dev.latvian.mods.kubejs.event.EventExceptionHandler"
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Set, $Set$$Type} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$TagWrapper, $TagWrapper$$Type} from "dev.latvian.mods.kubejs.server.tag.TagWrapper"

export class $TagKubeEvent implements $KubeEvent {
static readonly "TAG_EVENT_HANDLER": $EventExceptionHandler
static readonly "SOURCE": string
readonly "registryKey": $ResourceKey<(any)>
readonly "vanillaRegistry": $Registry<(any)>
readonly "tags": $Map<($ResourceLocation), ($TagWrapper)>
 "totalAdded": integer
 "totalRemoved": integer

constructor(arg0: $ResourceKey$$Type<(any)>, arg1: $Registry$$Type<(any)>)

public "remove"(arg0: $ResourceLocation$$Type, ...arg1: (any)[]): $TagWrapper
public "get"(arg0: $ResourceLocation$$Type): $TagWrapper
public "add"(arg0: $ResourceLocation$$Type, ...arg1: (any)[]): $TagWrapper
public "getType"(): $ResourceLocation
public "removeAll"(arg0: $ResourceLocation$$Type): $TagWrapper
public "getElementIds"(): $Set<($ResourceLocation)>
public "removeAllTagsFrom"(...arg0: (any)[]): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "type"(): $ResourceLocation
get "elementIds"(): $Set<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagKubeEvent$$Type = ($TagKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagKubeEvent_ = $TagKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.minecraft.ShapelessKubeRecipe" {
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction, $RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$KubeRecipeFactory, $KubeRecipeFactory$$Type} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ShapelessKubeRecipe extends $KubeRecipe {
static readonly "RECIPE_FACTORY": $KubeRecipeFactory
static readonly "CHANGED_MARKER": string
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "sourceLine": $SourceLine
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean
 "creationError": boolean

constructor()

public "getSerializationTypeFunction"(): $RecipeTypeFunction
get "serializationTypeFunction"(): $RecipeTypeFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapelessKubeRecipe$$Type = ($ShapelessKubeRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapelessKubeRecipe_ = $ShapelessKubeRecipe$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.IngredientSupplierKJS" {
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"

export interface $IngredientSupplierKJS {

 "kjs$asIngredient"(): $Ingredient
}

export namespace $IngredientSupplierKJS {
const probejs$$marker: never
}
export class $IngredientSupplierKJS$$Static implements $IngredientSupplierKJS {


 "kjs$asIngredient"(): $Ingredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientSupplierKJS$$Type = ($IngredientSupplierKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientSupplierKJS_ = $IngredientSupplierKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.player.PlayerAdvancementKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$AdvancementNode, $AdvancementNode$$Type} from "net.minecraft.advancements.AdvancementNode"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player gets an advancement.
 */
export class $PlayerAdvancementKubeEvent implements $KubePlayerEvent {

constructor(arg0: $ServerPlayer$$Type, arg1: $AdvancementNode$$Type)

/**
 * Returns the player that got the advancement.
 */
public "getEntity"(): $Player
/**
 * Returns the advancement that was obtained.
 */
public "getAdvancement"(): $AdvancementNode
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "entity"(): $Player
get "advancement"(): $AdvancementNode
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerAdvancementKubeEvent$$Type = ($PlayerAdvancementKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerAdvancementKubeEvent_ = $PlayerAdvancementKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.RegistryWrapper" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ListIterator, $ListIterator$$Type} from "java.util.ListIterator"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Set, $Set$$Type} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$HolderSetWrapper, $HolderSetWrapper$$Type} from "dev.latvian.mods.kubejs.bindings.HolderSetWrapper"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $RegistryWrapper<T> extends $Record implements $Iterable<(T)> {

constructor(registry: $Registry$$Type<(T)>, unknownKey: $ResourceKey$$Type<(T)>)

public "get"(arg0: $ResourceLocation$$Type): T
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "iterator"(): $ListIterator<(T)>
public static "of"(arg1: $ResourceLocation$$Type): $RegistryWrapper<(any)>
public "contains"(arg0: $ResourceLocation$$Type): boolean
public "getKey"(arg0: T): $ResourceKey<(T)>
public static "access"(): $RegistryAccessContainer
public "getId"(arg0: T): $ResourceLocation
public "containsValue"(arg0: T): boolean
public "getKeys"(): $Set<($ResourceLocation)>
public "registry"(): $Registry<(T)>
public "getValues"(): $List<(T)>
public "getValues"(arg0: any): $HolderSetWrapper<(T)>
public "getRandom"(arg0: $RandomSource$$Type): T
public "getRandom"(): T
public "unknownKey"(): $ResourceKey<(T)>
public "getEntrySet"(): $Set<($Map$Entry<($ResourceLocation), (T)>)>
public "getValueMap"(): $Map<($ResourceLocation), (T)>
public "spliterator"(): $Spliterator<(T)>
public "forEach"(arg0: $Consumer$$Type<(T)>): void
[Symbol.iterator](): IterableIterator<T>;
get "keys"(): $Set<($ResourceLocation)>
get "values"(): $List<(T)>
get "random"(): T
get "entrySet"(): $Set<($Map$Entry<($ResourceLocation), (T)>)>
get "valueMap"(): $Map<($ResourceLocation), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryWrapper$$Type<T> = ({"registry"?: $Registry$$Type<(never)>, "unknownKey"?: $ResourceKey$$Type<(never)>}) | ([registry?: $Registry$$Type<(never)>, unknownKey?: $ResourceKey$$Type<(never)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryWrapper_<T> = $RegistryWrapper$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.command.ArgumentTypeWrappers" {
import {$CommandContext, $CommandContext$$Type} from "com.mojang.brigadier.context.CommandContext"
import {$ArgumentType, $ArgumentType$$Type} from "com.mojang.brigadier.arguments.ArgumentType"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$CommandRegistryKubeEvent, $CommandRegistryKubeEvent$$Type} from "dev.latvian.mods.kubejs.command.CommandRegistryKubeEvent"
import {$ArgumentTypeWrapper, $ArgumentTypeWrapper$$Type} from "dev.latvian.mods.kubejs.command.ArgumentTypeWrapper"
import {$CommandSourceStack, $CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"

export class $ArgumentTypeWrappers extends $Enum<($ArgumentTypeWrappers)> implements $ArgumentTypeWrapper {
static readonly "BOOLEAN": $ArgumentTypeWrappers
static readonly "FLOAT": $ArgumentTypeWrappers
static readonly "DOUBLE": $ArgumentTypeWrappers
static readonly "INTEGER": $ArgumentTypeWrappers
static readonly "LONG": $ArgumentTypeWrappers
static readonly "STRING": $ArgumentTypeWrappers
static readonly "GREEDY_STRING": $ArgumentTypeWrappers
static readonly "WORD": $ArgumentTypeWrappers
static readonly "ENTITY": $ArgumentTypeWrappers
static readonly "ENTITIES": $ArgumentTypeWrappers
static readonly "PLAYER": $ArgumentTypeWrappers
static readonly "PLAYERS": $ArgumentTypeWrappers
static readonly "GAME_PROFILE": $ArgumentTypeWrappers
static readonly "BLOCK_POS": $ArgumentTypeWrappers
static readonly "BLOCK_POS_LOADED": $ArgumentTypeWrappers
static readonly "COLUMN_POS": $ArgumentTypeWrappers
static readonly "VEC3": $ArgumentTypeWrappers
static readonly "VEC2": $ArgumentTypeWrappers
static readonly "VEC3_CENTERED": $ArgumentTypeWrappers
static readonly "VEC2_CENTERED": $ArgumentTypeWrappers
static readonly "BLOCK_STATE": $ArgumentTypeWrappers
static readonly "BLOCK_PREDICATE": $ArgumentTypeWrappers
static readonly "ITEM_STACK": $ArgumentTypeWrappers
static readonly "ITEM_PREDICATE": $ArgumentTypeWrappers
static readonly "COLOR": $ArgumentTypeWrappers
static readonly "COMPONENT": $ArgumentTypeWrappers
static readonly "MESSAGE": $ArgumentTypeWrappers
static readonly "NBT_COMPOUND": $ArgumentTypeWrappers
static readonly "NBT_TAG": $ArgumentTypeWrappers
static readonly "NBT_PATH": $ArgumentTypeWrappers
static readonly "PARTICLE": $ArgumentTypeWrappers
static readonly "ANGLE": $ArgumentTypeWrappers
static readonly "ROTATION": $ArgumentTypeWrappers
static readonly "SWIZZLE": $ArgumentTypeWrappers
static readonly "ITEM_SLOT": $ArgumentTypeWrappers
static readonly "RESOURCE_LOCATION": $ArgumentTypeWrappers
static readonly "ENTITY_ANCHOR": $ArgumentTypeWrappers
static readonly "INT_RANGE": $ArgumentTypeWrappers
static readonly "FLOAT_RANGE": $ArgumentTypeWrappers
static readonly "DIMENSION": $ArgumentTypeWrappers
static readonly "TIME": $ArgumentTypeWrappers
static readonly "UUID": $ArgumentTypeWrappers
static readonly "OBJECTIVE": $ArgumentTypeWrappers


public static "values"(): ($ArgumentTypeWrappers)[]
public static "valueOf"(arg0: string): $ArgumentTypeWrappers
public "time"(arg0: integer): $ArgumentTypeWrapper
public "create"(arg0: $CommandRegistryKubeEvent$$Type): $ArgumentType<(any)>
public "getResult"(arg0: $CommandContext$$Type<($CommandSourceStack$$Type)>, arg1: string): any
public static "byName"(arg0: $ResourceLocation$$Type): typeof any
public static "registry"<T>(arg0: $CommandRegistryKubeEvent$$Type, arg1: $ResourceLocation$$Type): $ArgumentTypeWrapper
public static "printAll"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArgumentTypeWrappers$$Type = (("boolean") | ("float") | ("double") | ("integer") | ("long") | ("string") | ("greedy_string") | ("word") | ("entity") | ("entities") | ("player") | ("players") | ("game_profile") | ("block_pos") | ("block_pos_loaded") | ("column_pos") | ("vec3") | ("vec2") | ("vec3_centered") | ("vec2_centered") | ("block_state") | ("block_predicate") | ("item_stack") | ("item_predicate") | ("color") | ("component") | ("message") | ("nbt_compound") | ("nbt_tag") | ("nbt_path") | ("particle") | ("angle") | ("rotation") | ("swizzle") | ("item_slot") | ("resource_location") | ("entity_anchor") | ("int_range") | ("float_range") | ("dimension") | ("time") | ("uuid") | ("objective"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArgumentTypeWrappers_ = $ArgumentTypeWrappers$$Type;
}}
declare module "dev.latvian.mods.kubejs.entity.EntitySpawnedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$KubeEntityEvent, $KubeEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an entity is about to be added to the world.
 * 
 * This event also fires for existing entities when they are loaded from a save.
 */
export class $EntitySpawnedKubeEvent implements $KubeEntityEvent {

constructor(arg0: $Entity$$Type, arg1: $Level$$Type)

/**
 * The level the entity is being added to.
 */
public "getLevel"(): $Level
/**
 * The entity being added to the world.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySpawnedKubeEvent$$Type = ($EntitySpawnedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntitySpawnedKubeEvent_ = $EntitySpawnedKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicate" {
import {$BlockPredicate, $BlockPredicate$$Type} from "dev.latvian.mods.kubejs.block.predicate.BlockPredicate"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BlockEntityPredicateDataCheck, $BlockEntityPredicateDataCheck$$Type} from "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicateDataCheck"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"

export class $BlockEntityPredicate implements $BlockPredicate {

constructor(arg0: $ResourceLocation$$Type)

public "toString"(): string
public "data"(arg0: $BlockEntityPredicateDataCheck$$Type): $BlockEntityPredicate
public "check"(arg0: $BlockContainerJS$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityPredicate$$Type = ($BlockEntityPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityPredicate_ = $BlockEntityPredicate$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$RecipeLikeKJS, $RecipeLikeKJS$$Type} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"

export interface $RecipeFilter {

 "test"(arg1: $RecipeLikeKJS$$Type): boolean

(arg1: $RecipeLikeKJS): boolean
}

export namespace $RecipeFilter {
function of(arg1: any): $RecipeFilter
const probejs$$marker: never
}
export class $RecipeFilter$$Static implements $RecipeFilter {


 "test"(arg1: $RecipeLikeKJS$$Type): boolean
static "of"(arg1: any): $RecipeFilter
}
export type RecipeFilterObject = {"or"?: $RecipeFilter$$Type, "not"?: $RecipeFilter$$Type, "id"?: Special.RecipeId, "type"?: Special.RecipeType, "group"?: string, "mod"?: Special.Mod, "input"?: $Ingredient$$Type, "output"?: $ItemStack$$Type};
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFilter$$Type = (RegExp) | ("*") | ("-") | (($RecipeFilter$$Type)[]) | (RecipeFilterObject) | ((arg1: $RecipeLikeKJS) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeFilter_ = $RecipeFilter$$Type;
}}
declare module "dev.latvian.mods.rhino.util.DataObject" {
import {$Context, $Context$$Type} from "dev.latvian.mods.rhino.Context"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$List, $List$$Type} from "java.util.List"

export interface $DataObject {

 "createDataObjectList"<T>(arg0: $Supplier$$Type<(T)>, arg1: $Context$$Type): $List<(T)>
 "createDataObject"<T>(arg0: $Supplier$$Type<(T)>, arg1: $Context$$Type): T
 "isDataObjectList"(): boolean
get "dataObjectList"(): boolean
}

export namespace $DataObject {
const probejs$$marker: never
}
export class $DataObject$$Static implements $DataObject {


 "createDataObjectList"<T>(arg0: $Supplier$$Type<(T)>, arg1: $Context$$Type): $List<(T)>
 "createDataObject"<T>(arg0: $Supplier$$Type<(T)>, arg1: $Context$$Type): T
 "isDataObjectList"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataObject$$Type = ($DataObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataObject_ = $DataObject$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.TickDuration" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$TemporalUnit, $TemporalUnit$$Type} from "java.time.temporal.TemporalUnit"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$List, $List$$Type} from "java.util.List"
import {$TemporalAmount, $TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$Temporal, $Temporal$$Type} from "java.time.temporal.Temporal"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $TickDuration extends $Record implements $TemporalAmount {
static readonly "ZERO": $TickDuration
static readonly "CODEC": $Codec<($TickDuration)>
static readonly "SECONDS_CODEC": $Codec<($TickDuration)>
static readonly "MINUTES_CODEC": $Codec<($TickDuration)>
static readonly "HOURS_CODEC": $Codec<($TickDuration)>
static readonly "TYPE_INFO": $TypeInfo

constructor(ticks: long)

public "get"(arg0: $TemporalUnit$$Type): long
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "wrap"(arg0: any): $TickDuration
public "getUnits"(): $List<($TemporalUnit)>
public "addTo"(arg0: $Temporal$$Type): $Temporal
public "subtractFrom"(arg0: $Temporal$$Type): $Temporal
public "ticks"(): long
get "units"(): $List<($TemporalUnit)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickDuration$$Type = ({"ticks"?: long}) | ([ticks?: long]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickDuration_ = $TickDuration$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.CachedTagLookup" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List, $List$$Type} from "java.util.List"
import {$Set, $Set$$Type} from "java.util.Set"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $CachedTagLookup<T> {
readonly "registry": $Registry<(T)>
readonly "originalMap": $Map<($ResourceLocation), ($List<($TagLoader$EntryWithSource)>)>

constructor(arg0: $Registry$$Type<(T)>, arg1: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>)

public "values"(arg0: $TagKey$$Type<(T)>): $Set<(T)>
public "isEmpty"(arg0: $TagKey$$Type<(T)>): boolean
public "keys"(arg0: T): $Set<($TagKey<(T)>)>
public "build"(arg0: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>): $Map<($ResourceLocation), ($Collection<(T)>)>
public "bindingMap"(): $Map<($TagKey<(T)>), ($List<($Holder<(T)>)>)>
public "tagMap"(): $Map<($ResourceLocation), ($Collection<($Holder<(T)>)>)>
public "keyToValue"(): $Map<($TagKey<(T)>), ($Set<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedTagLookup$$Type<T> = ($CachedTagLookup<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedTagLookup_<T> = $CachedTagLookup$$Type<(T)>;
}}
declare module "dev.latvian.mods.rhino.ContextFactory" {
import {$TypeWrappers, $TypeWrappers$$Type} from "dev.latvian.mods.rhino.util.wrap.TypeWrappers"
import {$Context, $Context$$Type} from "dev.latvian.mods.rhino.Context"

export class $ContextFactory {

constructor()

public "enter"(): $Context
public "getTypeWrappers"(): $TypeWrappers
get "typeWrappers"(): $TypeWrappers
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContextFactory$$Type = ($ContextFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContextFactory_ = $ContextFactory$$Type;
}}
declare module "dev.latvian.mods.kubejs.web.SessionInfo" {
import {$Set, $Set$$Type} from "java.util.Set"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $SessionInfo extends $Record {
static readonly "NONE": $SessionInfo

constructor(source: string, tags: $Set$$Type<(string)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "source"(): string
public "tags"(): $Set<(string)>
public static "fromJson"(arg0: $SessionInfo$$Type, arg1: $JsonObject$$Type): $SessionInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionInfo$$Type = ({"source"?: string, "tags"?: $Set$$Type<(string)>}) | ([source?: string, tags?: $Set$$Type<(string)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SessionInfo_ = $SessionInfo$$Type;
}}
declare module "dev.latvian.mods.rhino.Script" {
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"

export interface $Script {

 "exec"(arg1: $Scriptable$$Type): any

(arg1: $Scriptable): any
}

export namespace $Script {
const probejs$$marker: never
}
export class $Script$$Static implements $Script {


 "exec"(arg1: $Scriptable$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Script$$Type = ((arg1: $Scriptable) => any);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Script_ = $Script$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeNamespace, $RecipeNamespace$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace"
import {$RecipeSerializer, $RecipeSerializer$$Type} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $RecipeSchemaType {
readonly "namespace": $RecipeNamespace
readonly "id": $ResourceLocation
readonly "schema": $RecipeSchema
 "parent": $RecipeSchemaType

constructor(arg0: $RecipeNamespace$$Type, arg1: $ResourceLocation$$Type, arg2: $RecipeSchema$$Type)

public "toString"(): string
public "getSerializer"(): $RecipeSerializer<(any)>
get "serializer"(): $RecipeSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaType$$Type = ($RecipeSchemaType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeSchemaType_ = $RecipeSchemaType$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.ParticleProviderRegistryKubeEvent" {
import {$ParticleProvider, $ParticleProvider$$Type} from "net.minecraft.client.particle.ParticleProvider"
import {$RegisterParticleProvidersEvent, $RegisterParticleProvidersEvent$$Type} from "net.neoforged.neoforge.client.event.RegisterParticleProvidersEvent"
import {$ClientKubeEvent, $ClientKubeEvent$$Type} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$ParticleType, $ParticleType$$Type} from "net.minecraft.core.particles.ParticleType"
import {$Minecraft, $Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$KubeAnimatedParticle, $KubeAnimatedParticle$$Type} from "dev.latvian.mods.kubejs.client.KubeAnimatedParticle"
import {$ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider, $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Type} from "dev.latvian.mods.kubejs.client.ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $ParticleProviderRegistryKubeEvent implements $ClientKubeEvent {

constructor(arg0: $RegisterParticleProvidersEvent$$Type)

public "register"<T extends $ParticleOptions>(arg0: $ParticleType$$Type<(T)>): void
public "register"<T extends $ParticleOptions>(arg0: $ParticleType$$Type<(T)>, arg1: $Consumer$$Type<($KubeAnimatedParticle)>): void
public "register"<T extends $ParticleOptions>(arg0: $ParticleType$$Type<(T)>, arg1: $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Type<(T)>): void
public "registerSpecial"<T extends $ParticleOptions>(arg0: $ParticleType$$Type<(T)>, arg1: $ParticleProvider$$Type<(T)>): void
public "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleProviderRegistryKubeEvent$$Type = ($ParticleProviderRegistryKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParticleProviderRegistryKubeEvent_ = $ParticleProviderRegistryKubeEvent$$Type;
}}
declare module "dev.latvian.mods.rhino.type.JSObjectTypeInfo" {
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$List, $List$$Type} from "java.util.List"
import {$TypeStringContext, $TypeStringContext$$Type} from "dev.latvian.mods.rhino.type.TypeStringContext"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Type, $Type$$Type} from "java.lang.reflect.Type"
import {$JSOptionalParam, $JSOptionalParam$$Type} from "dev.latvian.mods.rhino.type.JSOptionalParam"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$RecordTypeInfo$Component, $RecordTypeInfo$Component$$Type} from "dev.latvian.mods.rhino.type.RecordTypeInfo$Component"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $JSObjectTypeInfo extends $Record implements $TypeInfo {

constructor(fields: $List$$Type<($JSOptionalParam$$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "append"(ctx: $TypeStringContext$$Type, sb: $StringBuilder$$Type): void
public "hashCode"(): integer
public static "of"(...fields: ($JSOptionalParam$$Type)[]): $JSObjectTypeInfo
public static "of"(field1: $JSOptionalParam$$Type, field2: $JSOptionalParam$$Type): $JSObjectTypeInfo
public static "of"(field: $JSOptionalParam$$Type): $JSObjectTypeInfo
public "fields"(): $List<($JSOptionalParam)>
public "asClass"(): $Class<(any)>
public "collectContainedComponentClasses"(classes: $Collection$$Type<($Class$$Type<(any)>)>): void
public "signature"(): string
public "isPrimitive"(): boolean
public "newArray"(length: integer): any
public "componentType"(): $TypeInfo
public static "of"(type: $Type$$Type): $TypeInfo
public static "of"(c: $Class$$Type<(any)>): $TypeInfo
public "enumConstants"(): $List<(any)>
public "param"(index: integer): $TypeInfo
public "isVoid"(): boolean
public "is"(info: $TypeInfo$$Type): boolean
public "or"(info: $TypeInfo$$Type): $TypeInfo
public "isCharacter"(): boolean
public "isFloat"(): boolean
public "asArray"(): $TypeInfo
public "isBoolean"(): boolean
public "recordComponents"(): $Map<(string), ($RecordTypeInfo$Component)>
public static "ofArray"(array: ($Type$$Type)[]): ($TypeInfo)[]
public "getContainedComponentClasses"(): $Set<($Class<(any)>)>
public "withParams"(...params: ($TypeInfo$$Type)[]): $TypeInfo
public "isDouble"(): boolean
public "isFunctionalInterface"(): boolean
public "shouldConvert"(): boolean
public "isLong"(): boolean
public "isInt"(): boolean
public "isShort"(): boolean
public "isByte"(): boolean
public "createDefaultValue"(): any
get "primitive"(): boolean
get "void"(): boolean
get "character"(): boolean
get "float"(): boolean
get "boolean"(): boolean
get "containedComponentClasses"(): $Set<($Class<(any)>)>
get "double"(): boolean
get "functionalInterface"(): boolean
get "long"(): boolean
get "int"(): boolean
get "short"(): boolean
get "byte"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JSObjectTypeInfo$$Type = ({"fields"?: $List$$Type<($JSOptionalParam$$Type)>}) | ([fields?: $List$$Type<($JSOptionalParam$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JSObjectTypeInfo_ = $JSObjectTypeInfo$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.ScriptTypePredicate" {
import {$List, $List$$Type} from "java.util.List"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ScriptTypePredicate extends $Predicate<($ScriptType)> {

 "test"(arg0: $ScriptType$$Type): boolean
 "test"(arg0: any): boolean
 "getValidTypes"(): $List<($ScriptType)>
 "or"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
 "negate"(): $Predicate<($ScriptType)>
 "and"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>

(arg0: $ScriptType): boolean
get "validTypes"(): $List<($ScriptType)>
}

export namespace $ScriptTypePredicate {
const ALL: $ScriptTypePredicate
const COMMON: $ScriptTypePredicate
const STARTUP_OR_CLIENT: $ScriptTypePredicate
const STARTUP_OR_SERVER: $ScriptTypePredicate
function not<T>(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
function isEqual<T>(arg0: any): $Predicate<($ScriptType)>
const probejs$$marker: never
}
export class $ScriptTypePredicate$$Static implements $ScriptTypePredicate {
static readonly "ALL": $ScriptTypePredicate
static readonly "COMMON": $ScriptTypePredicate
static readonly "STARTUP_OR_CLIENT": $ScriptTypePredicate
static readonly "STARTUP_OR_SERVER": $ScriptTypePredicate


 "test"(arg0: $ScriptType$$Type): boolean
 "test"(arg0: any): boolean
 "getValidTypes"(): $List<($ScriptType)>
 "or"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
 "negate"(): $Predicate<($ScriptType)>
 "and"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
static "not"<T>(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
static "isEqual"<T>(arg0: any): $Predicate<($ScriptType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptTypePredicate$$Type = ((arg0: $ScriptType) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptTypePredicate_ = $ScriptTypePredicate$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemPredicate" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ItemStackSet, $ItemStackSet$$Type} from "dev.latvian.mods.kubejs.item.ItemStackSet"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IngredientSupplierKJS, $IngredientSupplierKJS$$Type} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Set, $Set$$Type} from "java.util.Set"

export interface $ItemPredicate extends $Predicate<($ItemStack)>, $IngredientSupplierKJS {

 "canBeUsedForMatching"(): boolean
 "getDisplayStacks"(): $ItemStackSet
 "asIngredient"(): $Ingredient
 "isWildcard"(): boolean
 "getFirst"(): $ItemStack
 "getStacks"(): $ItemStackSet
 "getStackArray"(): ($ItemStack)[]
 "testItem"(arg0: $Item$$Type): boolean
 "getItemTypes"(): $Set<($Item)>
 "getItemIds"(): $Set<(string)>
 "test"(arg0: $ItemStack$$Type): boolean
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>

(arg0: $ItemStack): boolean
get "displayStacks"(): $ItemStackSet
get "wildcard"(): boolean
get "first"(): $ItemStack
get "stacks"(): $ItemStackSet
get "stackArray"(): ($ItemStack)[]
get "itemTypes"(): $Set<($Item)>
get "itemIds"(): $Set<(string)>
}

export namespace $ItemPredicate {
const TYPE_INFO: $TypeInfo
const NONE: $ItemPredicate
const ALL: $ItemPredicate
function wrap(arg1: any): $ItemPredicate
function not<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
function isEqual<T>(arg0: any): $Predicate<($ItemStack)>
const probejs$$marker: never
}
export class $ItemPredicate$$Static implements $ItemPredicate {
static readonly "TYPE_INFO": $TypeInfo
static readonly "NONE": $ItemPredicate
static readonly "ALL": $ItemPredicate


static "wrap"(arg1: any): $ItemPredicate
 "canBeUsedForMatching"(): boolean
 "getDisplayStacks"(): $ItemStackSet
 "asIngredient"(): $Ingredient
 "isWildcard"(): boolean
 "getFirst"(): $ItemStack
 "getStacks"(): $ItemStackSet
 "getStackArray"(): ($ItemStack)[]
 "testItem"(arg0: $Item$$Type): boolean
 "getItemTypes"(): $Set<($Item)>
 "getItemIds"(): $Set<(string)>
 "test"(arg0: $ItemStack$$Type): boolean
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "not"<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "isEqual"<T>(arg0: any): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPredicate$$Type = ($Ingredient$$Type) | ("*") | ("-") | ((item: $ItemStack) => boolean) | ((arg0: $ItemStack) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPredicate_ = $ItemPredicate$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder" {
import {$ToDoubleFunction, $ToDoubleFunction$$Type} from "java.util.function.ToDoubleFunction"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$NumberProvider, $NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$CropBlockBuilder$ShapeBuilder, $CropBlockBuilder$ShapeBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$ShapeBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$CropBlockBuilder$SurviveCallback, $CropBlockBuilder$SurviveCallback$$Type} from "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$SurviveCallback"

export class $CropBlockBuilder extends $BlockBuilder {
static readonly "CROP_BLOCK_TAGS": ($ResourceLocation)[]
static readonly "CROP_ITEM_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

/**
 * Set the age of the crop. Note that the box will be the same for all ages (A full block size).
 */
public "age"(arg0: integer): this
/**
 * Set the age of the crop and the shape of the crop at that age.
 */
public "age"(arg0: integer, arg1: $Consumer$$Type<($CropBlockBuilder$ShapeBuilder)>): this
public "randomTick"(arg0: $Consumer$$Type<($RandomTickCallbackJS)>): $BlockBuilder
public "noItem"(): $BlockBuilder
/**
 * Add a crop output with a specific amount.
 */
public "crop"(arg0: $Holder$$Type<($Item)>, arg1: $NumberProvider$$Type): this
/**
 * Add a crop output with exactly one output.
 */
public "crop"(arg0: $Holder$$Type<($Item)>): this
/**
 * Remove seed drops from the loot table, does not prevent seed item from creating.
 */
public "noSeeds"(): this
public "survive"(arg0: $CropBlockBuilder$SurviveCallback$$Type): this
public "growTick"(arg0: $ToDoubleFunction$$Type<($RandomTickCallbackJS)>): this
public "bonemeal"(arg0: $ToIntFunction$$Type<($RandomTickCallbackJS)>): this
public "generateLootTable"(): $LootTable
public "farmersCanPlant"(): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$$Type = ($CropBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CropBlockBuilder_ = $CropBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.rhino.type.RecordTypeInfo$Component" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $RecordTypeInfo$Component extends $Record {

constructor(index: integer, name: string, type: $TypeInfo$$Type)

public "index"(): integer
public "name"(): string
public "type"(): $TypeInfo
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecordTypeInfo$Component$$Type = ({"type"?: $TypeInfo$$Type, "index"?: integer, "name"?: string}) | ([type?: $TypeInfo$$Type, index?: integer, name?: string]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecordTypeInfo$Component_ = $RecordTypeInfo$Component$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.ServerPlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$KubeJSInventoryListener, $KubeJSInventoryListener$$Type} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$PlayerKJS, $PlayerKJS$$Type} from "dev.latvian.mods.kubejs.core.PlayerKJS"
import {$Stages, $Stages$$Type} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties, $FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ChestMenuData, $ChestMenuData$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuData"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KubeJSGUI, $KubeJSGUI$$Type} from "dev.latvian.mods.kubejs.gui.KubeJSGUI"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$NotificationToastData, $NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS, $PlayerStatsJS$$Type} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$EntityPotionEffectsJS, $EntityPotionEffectsJS$$Type} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$KGUIActions, $KGUIActions$$Type} from "dev.latvian.mods.kubejs.kgui.action.KGUIActions"
import {$Attribute, $Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$RayTraceResultJS, $RayTraceResultJS$$Type} from "dev.latvian.mods.kubejs.entity.RayTraceResultJS"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export interface $ServerPlayerKJS extends $PlayerKJS {

 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "self"(): $Player
 "kick"(): void
 "kick"(arg0: $Component$$Type): void
 "isOp"(): boolean
 "heal"(): void
 "ban"(arg0: string, arg1: string, arg2: long): void
 "isMiningBlock"(): boolean
 "sendData"(arg0: string, arg1: $CompoundTag$$Type): void
 "getStats"(): $PlayerStatsJS
 "setMouseItem"(arg0: $ItemStack$$Type): void
 "revokeAdvancement"(arg0: $ResourceLocation$$Type): void
 "setSpawnLocation"(arg0: $BlockContainerJS$$Type): void
 "openInventoryGUI"(arg0: $InventoryKJS$$Type, arg1: $Component$$Type): void
 "getSpawnLocation"(): $BlockContainerJS
 "unlockAdvancement"(arg0: $ResourceLocation$$Type): void
 "captureInventory"(arg0: boolean): $Container
 "setCreativeMode"(arg0: boolean): void
 "isAdvancementDone"(arg0: $ResourceLocation$$Type): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "setSelectedSlot"(arg0: integer): void
 "notify"(arg0: $NotificationToastData$$Type): void
 "openChestGUI"(arg0: $Consumer$$Type<($KubeJSGUI)>): void
 "openChestGUI"(arg0: $Component$$Type, arg1: integer, arg2: $Consumer$$Type<($ChestMenuData)>): void
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "spawn"(): void
 "setStatusMessage"(arg0: $Component$$Type): void
 "getStages"(): $Stages
 "getInventory"(): $InventoryKJS
 "addExhaustion"(arg0: float): void
 "getXpLevel"(): integer
 "setSaturation"(arg0: float): void
 "addFood"(arg0: integer, arg1: float): void
 "addXPLevels"(arg0: integer): void
 "giveInHand"(arg0: $ItemStack$$Type): void
 "getFoodLevel"(): integer
 "setFoodLevel"(arg0: integer): void
 "getKgui"(): $KGUIActions
 "getSaturation"(): float
 "getMouseItem"(): $ItemStack
 "setXpLevel"(arg0: integer): void
 "isPlayer"(): boolean
 "getProfile"(): $GameProfile
 "addItemCooldown"(arg0: $Item$$Type, arg1: integer): void
 "getCraftingGrid"(): $InventoryKJS
 "getSelectedSlot"(): integer
 "boostElytraFlight"(): void
 "sendInventoryUpdate"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addXP"(arg0: integer): void
 "setXp"(arg0: integer): void
 "getXp"(): integer
 "give"(arg0: $ItemStack$$Type): void
 "isFake"(): boolean
 "notify"(arg0: $Component$$Type, arg1: $Component$$Type): void
 "setDefaultMovementSpeed"(arg0: double): void
 "setMovementSpeedAddition"(arg0: double): void
 "getDefaultMovementSpeed"(): double
 "swing"(): void
 "swing"(arg0: $InteractionHand$$Type): void
 "foodEaten"(arg0: $ItemStack$$Type, arg1: $FoodProperties$$Type): void
 "getHeldItem"(arg0: $InteractionHand$$Type): $ItemStack
 "isUndead"(): boolean
 "rayTrace"(): $RayTraceResultJS
 "setOffHandItem"(arg0: $ItemStack$$Type): void
 "getEquipment"(arg0: $EquipmentSlot$$Type): $ItemStack
 "setMaxHealth"(arg0: float): void
 "rayTraceEntity"(arg0: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(arg0: $InteractionHand$$Type, arg1: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setEquipment"(arg0: $EquipmentSlot$$Type, arg1: $ItemStack$$Type): void
 "setDefaultMovementSpeedMultiplier"(arg0: double): void
 "setTotalMovementSpeedMultiplier"(arg0: double): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer): void
 "canEntityBeSeen"(arg0: $LivingEntity$$Type): boolean
 "setLegsArmorItem"(arg0: $ItemStack$$Type): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type): void
 "getMainHandItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "setFeetArmorItem"(arg0: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>, arg1: double): void
 "getReachDistance"(): double
 "isHoldingInAnyHand"(arg0: $ItemPredicate$$Type): boolean
 "modifyAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type, arg2: double, arg3: $AttributeModifier$Operation$$Type): void
 "getAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>): double
 "setMainHandItem"(arg0: $ItemStack$$Type): void
 "setChestArmorItem"(arg0: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(arg0: $ItemStack$$Type): void
 "getAttributeTotalValue"(arg0: $Holder$$Type<($Attribute)>): double
 "getChestArmorItem"(): $ItemStack
 "sendData"(arg0: string): void
 "getData"(): $AttachedData<($Player)>
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "getItem"(): $ItemStack
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "getPersistentData"(): $CompoundTag

(): $AttachedData$$Type<($Player$$Type)>
set "activePostShader"(value: $ResourceLocation$$Type)
get "op"(): boolean
get "miningBlock"(): boolean
get "stats"(): $PlayerStatsJS
set "mouseItem"(value: $ItemStack$$Type)
set "spawnLocation"(value: $BlockContainerJS$$Type)
get "spawnLocation"(): $BlockContainerJS
set "creativeMode"(value: boolean)
set "selectedSlot"(value: integer)
get "inventoryChangeListener"(): $KubeJSInventoryListener
set "statusMessage"(value: $Component$$Type)
get "stages"(): $Stages
get "inventory"(): $InventoryKJS
get "xpLevel"(): integer
set "saturation"(value: float)
get "foodLevel"(): integer
set "foodLevel"(value: integer)
get "kgui"(): $KGUIActions
get "saturation"(): float
get "mouseItem"(): $ItemStack
set "xpLevel"(value: integer)
get "player"(): boolean
get "profile"(): $GameProfile
get "craftingGrid"(): $InventoryKJS
get "selectedSlot"(): integer
get "openInventory"(): $AbstractContainerMenu
set "xp"(value: integer)
get "xp"(): integer
get "fake"(): boolean
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
get "defaultMovementSpeed"(): double
get "undead"(): boolean
set "offHandItem"(value: $ItemStack$$Type)
set "maxHealth"(value: float)
get "living"(): boolean
get "offHandItem"(): $ItemStack
set "defaultMovementSpeedMultiplier"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
set "legsArmorItem"(value: $ItemStack$$Type)
get "potionEffects"(): $EntityPotionEffectsJS
get "mainHandItem"(): $ItemStack
get "totalMovementSpeed"(): double
set "feetArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
get "reachDistance"(): double
set "mainHandItem"(value: $ItemStack$$Type)
set "chestArmorItem"(value: $ItemStack$$Type)
get "feetArmorItem"(): $ItemStack
get "headArmorItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "data"(): $AttachedData<($Player)>
set "nbt"(value: $CompoundTag$$Type)
get "nbt"(): $CompoundTag
set "y"(value: double)
set "x"(value: double)
set "z"(value: double)
get "name"(): $Component
get "displayName"(): $Component
get "passengers"(): $EntityArrayList
get "server"(): $MinecraftServer
get "type"(): string
set "position"(value: $BlockContainerJS$$Type)
get "monster"(): boolean
set "motionX"(value: double)
get "level"(): $Level
set "motionY"(value: double)
get "motionX"(): double
get "item"(): $ItemStack
set "motionZ"(value: double)
get "block"(): $BlockContainerJS
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "motionZ"(): double
get "teamId"(): string
get "facing"(): $Direction
get "animal"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "persistentData"(): $CompoundTag
}

export namespace $ServerPlayerKJS {
const probejs$$marker: never
}
export class $ServerPlayerKJS$$Static implements $ServerPlayerKJS {


 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "self"(): $Player
 "kick"(): void
 "kick"(arg0: $Component$$Type): void
 "isOp"(): boolean
 "heal"(): void
 "ban"(arg0: string, arg1: string, arg2: long): void
 "isMiningBlock"(): boolean
 "sendData"(arg0: string, arg1: $CompoundTag$$Type): void
 "getStats"(): $PlayerStatsJS
 "setMouseItem"(arg0: $ItemStack$$Type): void
 "revokeAdvancement"(arg0: $ResourceLocation$$Type): void
 "setSpawnLocation"(arg0: $BlockContainerJS$$Type): void
 "openInventoryGUI"(arg0: $InventoryKJS$$Type, arg1: $Component$$Type): void
 "getSpawnLocation"(): $BlockContainerJS
 "unlockAdvancement"(arg0: $ResourceLocation$$Type): void
 "captureInventory"(arg0: boolean): $Container
 "setCreativeMode"(arg0: boolean): void
 "isAdvancementDone"(arg0: $ResourceLocation$$Type): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "setSelectedSlot"(arg0: integer): void
 "notify"(arg0: $NotificationToastData$$Type): void
 "openChestGUI"(arg0: $Consumer$$Type<($KubeJSGUI)>): void
 "openChestGUI"(arg0: $Component$$Type, arg1: integer, arg2: $Consumer$$Type<($ChestMenuData)>): void
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "spawn"(): void
 "setStatusMessage"(arg0: $Component$$Type): void
 "getStages"(): $Stages
 "getInventory"(): $InventoryKJS
 "addExhaustion"(arg0: float): void
 "getXpLevel"(): integer
 "setSaturation"(arg0: float): void
 "addFood"(arg0: integer, arg1: float): void
 "addXPLevels"(arg0: integer): void
 "giveInHand"(arg0: $ItemStack$$Type): void
 "getFoodLevel"(): integer
 "setFoodLevel"(arg0: integer): void
 "getKgui"(): $KGUIActions
 "getSaturation"(): float
 "getMouseItem"(): $ItemStack
 "setXpLevel"(arg0: integer): void
 "isPlayer"(): boolean
 "getProfile"(): $GameProfile
 "addItemCooldown"(arg0: $Item$$Type, arg1: integer): void
 "getCraftingGrid"(): $InventoryKJS
 "getSelectedSlot"(): integer
 "boostElytraFlight"(): void
 "sendInventoryUpdate"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addXP"(arg0: integer): void
 "setXp"(arg0: integer): void
 "getXp"(): integer
 "give"(arg0: $ItemStack$$Type): void
 "isFake"(): boolean
 "notify"(arg0: $Component$$Type, arg1: $Component$$Type): void
 "setDefaultMovementSpeed"(arg0: double): void
 "setMovementSpeedAddition"(arg0: double): void
 "getDefaultMovementSpeed"(): double
 "swing"(): void
 "swing"(arg0: $InteractionHand$$Type): void
 "foodEaten"(arg0: $ItemStack$$Type, arg1: $FoodProperties$$Type): void
 "getHeldItem"(arg0: $InteractionHand$$Type): $ItemStack
 "isUndead"(): boolean
 "rayTrace"(): $RayTraceResultJS
 "setOffHandItem"(arg0: $ItemStack$$Type): void
 "getEquipment"(arg0: $EquipmentSlot$$Type): $ItemStack
 "setMaxHealth"(arg0: float): void
 "rayTraceEntity"(arg0: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(arg0: $InteractionHand$$Type, arg1: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setEquipment"(arg0: $EquipmentSlot$$Type, arg1: $ItemStack$$Type): void
 "setDefaultMovementSpeedMultiplier"(arg0: double): void
 "setTotalMovementSpeedMultiplier"(arg0: double): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer): void
 "canEntityBeSeen"(arg0: $LivingEntity$$Type): boolean
 "setLegsArmorItem"(arg0: $ItemStack$$Type): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type): void
 "getMainHandItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "setFeetArmorItem"(arg0: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>, arg1: double): void
 "getReachDistance"(): double
 "isHoldingInAnyHand"(arg0: $ItemPredicate$$Type): boolean
 "modifyAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type, arg2: double, arg3: $AttributeModifier$Operation$$Type): void
 "getAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>): double
 "setMainHandItem"(arg0: $ItemStack$$Type): void
 "setChestArmorItem"(arg0: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(arg0: $ItemStack$$Type): void
 "getAttributeTotalValue"(arg0: $Holder$$Type<($Attribute)>): double
 "getChestArmorItem"(): $ItemStack
 "sendData"(arg0: string): void
 "getData"(): $AttachedData<($Player)>
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "getItem"(): $ItemStack
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerPlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerPlayerKJS_ = $ServerPlayerKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.neoforge.NativeEventListeners$Key" {
import {$EventPriority, $EventPriority$$Type} from "net.neoforged.bus.api.EventPriority"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $NativeEventListeners$Key extends $Record {

constructor(eventClass: $Class$$Type<(any)>, priority: $EventPriority$$Type)

public "priority"(): $EventPriority
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "eventClass"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeEventListeners$Key$$Type = ({"priority"?: $EventPriority$$Type, "eventClass"?: $Class$$Type<(never)>}) | ([priority?: $EventPriority$$Type, eventClass?: $Class$$Type<(never)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeEventListeners$Key_ = $NativeEventListeners$Key$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.KMath" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$PoseStack, $PoseStack$$Type} from "com.mojang.blaze3d.vertex.PoseStack"
import {$Vector4f, $Vector4f$$Type} from "org.joml.Vector4f"
import {$Vector3f, $Vector3f$$Type} from "org.joml.Vector3f"
import {$Quaternionf, $Quaternionf$$Type} from "org.joml.Quaternionf"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Matrix4f, $Matrix4f$$Type} from "org.joml.Matrix4f"
import {$Vector3d, $Vector3d$$Type} from "org.joml.Vector3d"
import {$Matrix3f, $Matrix3f$$Type} from "org.joml.Matrix3f"

export interface $KMath {

}

export namespace $KMath {
const E: double
const PI: double
const DEGREES_TO_RADIANS: double
const RADIANS_TO_DEGREES: double
function floor(arg0: double): long
function ceil(arg0: double): long
function clamp(arg0: double, arg1: double, arg2: double): double
function map(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double): double
function v3(arg0: double, arg1: double, arg2: double): $Vec3
function block(arg0: double, arg1: double, arg2: double): $BlockPos
function isPowerOfTwo(arg0: integer): boolean
function poseStack(): $PoseStack
function lerp(arg0: double, arg1: double, arg2: double): double
function approach(arg0: double, arg1: double, arg2: double): double
function rotateIfNecessary(arg0: double, arg1: double, arg2: double): double
function clampedLerp(arg0: double, arg1: double, arg2: double): double
function wrapDegrees(arg0: double): double
function degreesDifference(arg0: double, arg1: double): double
function approachDegrees(arg0: double, arg1: double, arg2: double): double
function rad(arg0: double): double
function v3d(arg0: double, arg1: double, arg2: double): $Vector3d
function m4f(): $Matrix4f
function v4f(arg0: float, arg1: float, arg2: float, arg3: float): $Vector4f
function quaternion(arg0: float, arg1: float, arg2: float, arg3: float): $Quaternionf
function v3f(arg0: float, arg1: float, arg2: float): $Vector3f
function deg(arg0: double): double
function m3f(): $Matrix3f
const probejs$$marker: never
}
export class $KMath$$Static implements $KMath {
static readonly "E": double
static readonly "PI": double
static readonly "DEGREES_TO_RADIANS": double
static readonly "RADIANS_TO_DEGREES": double


static "floor"(arg0: double): long
static "ceil"(arg0: double): long
static "clamp"(arg0: double, arg1: double, arg2: double): double
static "map"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double): double
static "v3"(arg0: double, arg1: double, arg2: double): $Vec3
static "block"(arg0: double, arg1: double, arg2: double): $BlockPos
static "isPowerOfTwo"(arg0: integer): boolean
static "poseStack"(): $PoseStack
static "lerp"(arg0: double, arg1: double, arg2: double): double
static "approach"(arg0: double, arg1: double, arg2: double): double
static "rotateIfNecessary"(arg0: double, arg1: double, arg2: double): double
static "clampedLerp"(arg0: double, arg1: double, arg2: double): double
static "wrapDegrees"(arg0: double): double
static "degreesDifference"(arg0: double, arg1: double): double
static "approachDegrees"(arg0: double, arg1: double, arg2: double): double
static "rad"(arg0: double): double
static "v3d"(arg0: double, arg1: double, arg2: double): $Vector3d
static "m4f"(): $Matrix4f
static "v4f"(arg0: float, arg1: float, arg2: float, arg3: float): $Vector4f
static "quaternion"(arg0: float, arg1: float, arg2: float, arg3: float): $Quaternionf
static "v3f"(arg0: float, arg1: float, arg2: float): $Vector3f
static "deg"(arg0: double): double
static "m3f"(): $Matrix3f
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMath$$Type = ($KMath);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMath_ = $KMath$$Type;
}}
declare module "dev.latvian.mods.kubejs.entity.AfterLivingEntityHurtKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent, $KubeLivingEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$LivingDamageEvent$Post, $LivingDamageEvent$Post$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDamageEvent$Post"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked after an entity is hurt by a damage source.
 */
export class $AfterLivingEntityHurtKubeEvent implements $KubeLivingEntityEvent {

constructor(arg0: $LivingDamageEvent$Post$$Type)

/**
 * The damage source.
 */
public "getSource"(): $DamageSource
/**
 * The entity that was hurt.
 */
public "getEntity"(): $LivingEntity
/**
 * The amount of damage.
 */
public "getDamage"(): float
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "source"(): $DamageSource
get "entity"(): $LivingEntity
get "damage"(): float
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterLivingEntityHurtKubeEvent$$Type = ($AfterLivingEntityHurtKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AfterLivingEntityHurtKubeEvent_ = $AfterLivingEntityHurtKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Chestplate" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder, $ArmorItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ArmorItemBuilder$Chestplate extends $ArmorItemBuilder {
static readonly "CHESTPLATE_TAGS": ($ResourceLocation)[]
readonly "armorType": $ArmorItem$Type
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Chestplate$$Type = ($ArmorItemBuilder$Chestplate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorItemBuilder$Chestplate_ = $ArmorItemBuilder$Chestplate$$Type;
}}
declare module "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$TextAction, $TextAction$$Type} from "dev.latvian.mods.kubejs.text.action.TextAction"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$TooltipRequirements, $TooltipRequirements$$Type} from "dev.latvian.mods.kubejs.text.tooltip.TooltipRequirements"
import {$List, $List$$Type} from "java.util.List"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $ItemTooltipData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemTooltipData)>

constructor(filter: $Optional$$Type<($Ingredient$$Type)>, requirements: $Optional$$Type<($TooltipRequirements$$Type)>, actions: $List$$Type<($TextAction$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "filter"(): $Optional<($Ingredient)>
public "actions"(): $List<($TextAction)>
public "requirements"(): $Optional<($TooltipRequirements)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTooltipData$$Type = ({"filter"?: ($Ingredient$$Type)?, "requirements"?: ($TooltipRequirements$$Type)?, "actions"?: $List$$Type<($TextAction$$Type)>}) | ([filter?: ($Ingredient$$Type)?, requirements?: ($TooltipRequirements$$Type)?, actions?: $List$$Type<($TextAction$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTooltipData_ = $ItemTooltipData$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.ParticleGenerator" {
import {$List, $List$$Type} from "java.util.List"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"

export class $ParticleGenerator {

constructor()

public "textures"(arg0: $List$$Type<(string)>): $ParticleGenerator
public "texture"(arg0: string): $ParticleGenerator
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleGenerator$$Type = ($ParticleGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParticleGenerator_ = $ParticleGenerator$$Type;
}}
declare module "dev.latvian.mods.rhino.JavaMembers$FieldInfo" {
import {$Field, $Field$$Type} from "java.lang.reflect.Field"

export class $JavaMembers$FieldInfo {
readonly "field": $Field
 "name": string

constructor(f: $Field$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaMembers$FieldInfo$$Type = ($JavaMembers$FieldInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaMembers$FieldInfo_ = $JavaMembers$FieldInfo$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Pickaxe" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DiggerItemBuilder, $DiggerItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem, $DiggerItem$$Type} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Pickaxe extends $DiggerItemBuilder {
static readonly "PICKAXE_TAGS": ($ResourceLocation)[]
static readonly "PICKAXE_MODEL": $ResourceLocation
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Pickaxe$$Type = ($DiggerItemBuilder$Pickaxe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DiggerItemBuilder$Pickaxe_ = $DiggerItemBuilder$Pickaxe$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Group" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $ItemData$Group extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData$Group)>

constructor(filter: $Ingredient$$Type, groupId: $ResourceLocation$$Type, description: $Component$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "filter"(): $Ingredient
public "description"(): $Component
public "groupId"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$Group$$Type = ({"filter"?: $Ingredient$$Type, "groupId"?: $ResourceLocation$$Type, "description"?: $Component$$Type}) | ([filter?: $Ingredient$$Type, groupId?: $ResourceLocation$$Type, description?: $Component$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemData$Group_ = $ItemData$Group$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.IconKJS" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$GuiGraphics, $GuiGraphics$$Type} from "net.minecraft.client.gui.GuiGraphics"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Minecraft, $Minecraft$$Type} from "net.minecraft.client.Minecraft"

export interface $IconKJS {

 "draw"(arg0: $Minecraft$$Type, arg1: $GuiGraphics$$Type, arg2: integer, arg3: integer, arg4: integer): void
}

export namespace $IconKJS {
const NONE: $IconKJS
const CODEC: $Codec<($IconKJS)>
const STREAM_CODEC: $StreamCodec<($RegistryFriendlyByteBuf), ($IconKJS)>
const probejs$$marker: never
}
export class $IconKJS$$Static implements $IconKJS {
static readonly "NONE": $IconKJS
static readonly "CODEC": $Codec<($IconKJS)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IconKJS)>


 "draw"(arg0: $Minecraft$$Type, arg1: $GuiGraphics$$Type, arg2: integer, arg3: integer, arg4: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IconKJS$$Type = ($IconKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IconKJS_ = $IconKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.drop.BlockDrops" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$NumberProvider, $NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $BlockDrops extends $Record {
static readonly "EMPTY": $BlockDrops

constructor(items: ($ItemStack$$Type)[], rolls: $NumberProvider$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "items"(): ($ItemStack)[]
public static "createDefault"(arg0: $ItemStack$$Type): $BlockDrops
public "rolls"(): $NumberProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDrops$$Type = ({"items"?: ($ItemStack$$Type)[], "rolls"?: $NumberProvider$$Type}) | ([items?: ($ItemStack$$Type)[], rolls?: $NumberProvider$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockDrops_ = $BlockDrops$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.LevelKJS" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$WithAttachedData, $WithAttachedData$$Type} from "dev.latvian.mods.kubejs.core.WithAttachedData"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Fireworks, $Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$ExplosionJS, $ExplosionJS$$Type} from "dev.latvian.mods.kubejs.level.ExplosionJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$ScriptTypeHolder, $ScriptTypeHolder$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB, $AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export interface $LevelKJS extends $WithAttachedData<($Level)>, $ScriptTypeHolder {

 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "self"(): $Level
 "getName"(): $Component
 "runCommand"(arg0: string): void
 "getBlock"(arg0: integer, arg1: integer, arg2: integer): $BlockContainerJS
 "getBlock"(arg0: $BlockPos$$Type): $BlockContainerJS
 "getBlock"(arg0: $BlockEntity$$Type): $BlockContainerJS
 "getSide"(): $ScriptType
 "createEntityList"(arg0: $Collection$$Type<($Entity$$Type)>): $EntityArrayList
 "createExplosion"(arg0: double, arg1: double, arg2: double): $ExplosionJS
 "getEntitiesWithin"(arg0: $AABB$$Type): $EntityArrayList
 "getEntityByUUID"(arg0: $UUID$$Type): $Entity
 "createEntity"(arg0: $EntityType$$Type<(any)>): $Entity
 "spawnFireworks"(arg0: double, arg1: double, arg2: double, arg3: $Fireworks$$Type, arg4: integer): void
 "spawnParticles"(arg0: $ParticleOptions$$Type, arg1: boolean, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: integer, arg9: double): void
 "getDimension"(): $ResourceLocation
 "getEntities"(): $EntityArrayList
 "isOverworld"(): boolean
 "getPlayers"(): $EntityArrayList
 "getData"(): $AttachedData<($Level)>
 "getDisplayName"(): $Component

(): $AttachedData$$Type<($Level$$Type)>
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "side"(): $ScriptType
get "dimension"(): $ResourceLocation
get "entities"(): $EntityArrayList
get "overworld"(): boolean
get "players"(): $EntityArrayList
get "data"(): $AttachedData<($Level)>
get "displayName"(): $Component
}

export namespace $LevelKJS {
const probejs$$marker: never
}
export class $LevelKJS$$Static implements $LevelKJS {


 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "self"(): $Level
 "getName"(): $Component
 "runCommand"(arg0: string): void
 "getBlock"(arg0: integer, arg1: integer, arg2: integer): $BlockContainerJS
 "getBlock"(arg0: $BlockPos$$Type): $BlockContainerJS
 "getBlock"(arg0: $BlockEntity$$Type): $BlockContainerJS
 "getSide"(): $ScriptType
 "createEntityList"(arg0: $Collection$$Type<($Entity$$Type)>): $EntityArrayList
 "createExplosion"(arg0: double, arg1: double, arg2: double): $ExplosionJS
 "getEntitiesWithin"(arg0: $AABB$$Type): $EntityArrayList
 "getEntityByUUID"(arg0: $UUID$$Type): $Entity
 "createEntity"(arg0: $EntityType$$Type<(any)>): $Entity
 "spawnFireworks"(arg0: double, arg1: double, arg2: double, arg3: $Fireworks$$Type, arg4: integer): void
 "spawnParticles"(arg0: $ParticleOptions$$Type, arg1: boolean, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: integer, arg9: double): void
 "getDimension"(): $ResourceLocation
 "getEntities"(): $EntityArrayList
 "isOverworld"(): boolean
 "getPlayers"(): $EntityArrayList
 "getData"(): $AttachedData<($Level)>
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelKJS$$Type = (() => $AttachedData$$Type<($Level$$Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelKJS_ = $LevelKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.entity.KubeEntityEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubeLevelEvent, $KubeLevelEvent$$Type} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export interface $KubeEntityEvent extends $KubeLevelEvent {

 "getLevel"(): $Level
 "getEntity"(): $Entity
 "getPlayer"(): $Player
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any

(): $Entity$$Type
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}

export namespace $KubeEntityEvent {
const probejs$$marker: never
}
export class $KubeEntityEvent$$Static implements $KubeEntityEvent {


 "getLevel"(): $Level
 "getEntity"(): $Entity
 "getPlayer"(): $Player
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeEntityEvent$$Type = (() => $Entity$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeEntityEvent_ = $KubeEntityEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemEntityInteractedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player right clicks on an entity.
 */
export class $ItemEntityInteractedKubeEvent implements $KubePlayerEvent {

constructor(arg0: $Player$$Type, arg1: $Entity$$Type, arg2: $InteractionHand$$Type, arg3: $ItemStack$$Type)

/**
 * The entity that was interacted with.
 */
public "getTarget"(): $Entity
/**
 * The item that was used to interact with the entity.
 */
public "getItem"(): $ItemStack
/**
 * The player that interacted with the entity.
 */
public "getEntity"(): $Entity
/**
 * The hand that was used to interact with the entity.
 */
public "getHand"(): $InteractionHand
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "target"(): $Entity
get "item"(): $ItemStack
get "entity"(): $Entity
get "hand"(): $InteractionHand
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEntityInteractedKubeEvent$$Type = ($ItemEntityInteractedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemEntityInteractedKubeEvent_ = $ItemEntityInteractedKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder$Key" {
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $RecipeComponentBuilder$Key extends $Record {

constructor(name: string, component: $RecipeComponent$$Type<(any)>, optional: boolean, alwaysWrite: boolean)
constructor(arg0: string, arg1: $RecipeComponent$$Type<(any)>)
constructor(arg0: string, arg1: $RecipeComponent$$Type<(any)>, arg2: boolean)

public "name"(): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "component"(): $RecipeComponent<(any)>
public "optional"(): boolean
public "alwaysWrite"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentBuilder$Key$$Type = ({"component"?: $RecipeComponent$$Type<(never)>, "alwaysWrite"?: boolean, "optional"?: boolean, "name"?: string}) | ([component?: $RecipeComponent$$Type<(never)>, alwaysWrite?: boolean, optional?: boolean, name?: string]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeComponentBuilder$Key_ = $RecipeComponentBuilder$Key$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.FluidKJS" {
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS, $RegistryObjectKJS$$Type} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$FluidLike, $FluidLike$$Type} from "dev.latvian.mods.kubejs.fluid.FluidLike"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export interface $FluidKJS extends $RegistryObjectKJS<($Fluid)>, $FluidLike {

 "isEmpty"(): boolean
 "getFluid"(): $Fluid
 "getAmount"(): integer
 "getRegistry"(): $Registry<($Fluid)>
 "getRegistryId"(): $ResourceKey<($Registry<($Fluid)>)>
 "getId"(): string
 "getKey"(): $ResourceKey<($Fluid)>
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "asHolder"(): $Holder<($Fluid)>
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
 "copy"(arg0: integer): $FluidLike
get "empty"(): boolean
get "fluid"(): $Fluid
get "amount"(): integer
get "registry"(): $Registry<($Fluid)>
get "registryId"(): $ResourceKey<($Registry<($Fluid)>)>
get "id"(): string
get "key"(): $ResourceKey<($Fluid)>
get "mod"(): string
get "idLocation"(): $ResourceLocation
get "tags"(): $Collection<($ResourceLocation)>
}

export namespace $FluidKJS {
function wrap(arg1: any): $ReplacementMatch
const probejs$$marker: never
}
export class $FluidKJS$$Static implements $FluidKJS {


 "isEmpty"(): boolean
 "getFluid"(): $Fluid
 "getAmount"(): integer
 "getRegistry"(): $Registry<($Fluid)>
 "getRegistryId"(): $ResourceKey<($Registry<($Fluid)>)>
 "getId"(): string
 "getKey"(): $ResourceKey<($Fluid)>
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "asHolder"(): $Holder<($Fluid)>
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
 "copy"(arg0: integer): $FluidLike
static "wrap"(arg1: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidKJS$$Type = ($FluidKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidKJS_ = $FluidKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.callbacks.BlockStateMirrorCallbackJS" {
import {$Mirror, $Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$BlockStateModifyCallbackJS, $BlockStateModifyCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.BlockStateModifyCallbackJS"
import {$Rotation, $Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateMirrorCallbackJS extends $BlockStateModifyCallbackJS {

constructor(arg0: $BlockState$$Type, arg1: $Mirror$$Type)

/**
 * Gets the rotation of the direction passed in relative to this mirror
 */
public "getRotation"(arg0: $Direction$$Type): $Rotation
/**
 * Mirrors the direction passed in
 */
public "mirror"(arg0: $Direction$$Type): $Direction
/**
 * Gets the Mirror
 */
public "getMirror"(): $Mirror
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateMirrorCallbackJS$$Type = ($BlockStateMirrorCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateMirrorCallbackJS_ = $BlockStateMirrorCallbackJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.LivingEntityKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties, $FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$EntityPotionEffectsJS, $EntityPotionEffectsJS$$Type} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute, $Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$EntityKJS, $EntityKJS$$Type} from "dev.latvian.mods.kubejs.core.EntityKJS"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$RayTraceResultJS, $RayTraceResultJS$$Type} from "dev.latvian.mods.kubejs.entity.RayTraceResultJS"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export interface $LivingEntityKJS extends $EntityKJS {

 "setDefaultMovementSpeed"(arg0: double): void
 "setMovementSpeedAddition"(arg0: double): void
 "getDefaultMovementSpeed"(): double
 "swing"(): void
 "swing"(arg0: $InteractionHand$$Type): void
 "self"(): $Entity
 "foodEaten"(arg0: $ItemStack$$Type, arg1: $FoodProperties$$Type): void
 "getHeldItem"(arg0: $InteractionHand$$Type): $ItemStack
 "isUndead"(): boolean
 "rayTrace"(): $RayTraceResultJS
 "setOffHandItem"(arg0: $ItemStack$$Type): void
 "getEquipment"(arg0: $EquipmentSlot$$Type): $ItemStack
 "setMaxHealth"(arg0: float): void
 "rayTraceEntity"(arg0: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(arg0: $InteractionHand$$Type, arg1: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setEquipment"(arg0: $EquipmentSlot$$Type, arg1: $ItemStack$$Type): void
 "setDefaultMovementSpeedMultiplier"(arg0: double): void
 "setTotalMovementSpeedMultiplier"(arg0: double): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer): void
 "canEntityBeSeen"(arg0: $LivingEntity$$Type): boolean
 "setLegsArmorItem"(arg0: $ItemStack$$Type): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type): void
 "getMainHandItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "setFeetArmorItem"(arg0: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>, arg1: double): void
 "getReachDistance"(): double
 "isHoldingInAnyHand"(arg0: $ItemPredicate$$Type): boolean
 "modifyAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type, arg2: double, arg3: $AttributeModifier$Operation$$Type): void
 "getAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>): double
 "setMainHandItem"(arg0: $ItemStack$$Type): void
 "setChestArmorItem"(arg0: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(arg0: $ItemStack$$Type): void
 "getAttributeTotalValue"(arg0: $Holder$$Type<($Attribute)>): double
 "getChestArmorItem"(): $ItemStack
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "spawn"(): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isPlayer"(): boolean
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "getProfile"(): $GameProfile
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "getItem"(): $ItemStack
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
get "defaultMovementSpeed"(): double
get "undead"(): boolean
set "offHandItem"(value: $ItemStack$$Type)
set "maxHealth"(value: float)
get "living"(): boolean
get "offHandItem"(): $ItemStack
set "defaultMovementSpeedMultiplier"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
set "legsArmorItem"(value: $ItemStack$$Type)
get "potionEffects"(): $EntityPotionEffectsJS
get "mainHandItem"(): $ItemStack
get "totalMovementSpeed"(): double
set "feetArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
get "reachDistance"(): double
set "mainHandItem"(value: $ItemStack$$Type)
set "chestArmorItem"(value: $ItemStack$$Type)
get "feetArmorItem"(): $ItemStack
get "headArmorItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
set "nbt"(value: $CompoundTag$$Type)
get "nbt"(): $CompoundTag
set "y"(value: double)
set "x"(value: double)
set "z"(value: double)
get "name"(): $Component
get "displayName"(): $Component
get "passengers"(): $EntityArrayList
get "server"(): $MinecraftServer
get "type"(): string
set "position"(value: $BlockContainerJS$$Type)
get "player"(): boolean
get "monster"(): boolean
set "motionX"(value: double)
get "level"(): $Level
get "profile"(): $GameProfile
set "motionY"(value: double)
get "motionX"(): double
get "item"(): $ItemStack
set "motionZ"(value: double)
get "block"(): $BlockContainerJS
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "motionZ"(): double
get "teamId"(): string
get "facing"(): $Direction
get "animal"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export namespace $LivingEntityKJS {
const KJS_PLAYER_CUSTOM_SPEED: $ResourceLocation
const probejs$$marker: never
}
export class $LivingEntityKJS$$Static implements $LivingEntityKJS {
static readonly "KJS_PLAYER_CUSTOM_SPEED": $ResourceLocation


 "setDefaultMovementSpeed"(arg0: double): void
 "setMovementSpeedAddition"(arg0: double): void
 "getDefaultMovementSpeed"(): double
 "swing"(): void
 "swing"(arg0: $InteractionHand$$Type): void
 "self"(): $Entity
 "foodEaten"(arg0: $ItemStack$$Type, arg1: $FoodProperties$$Type): void
 "getHeldItem"(arg0: $InteractionHand$$Type): $ItemStack
 "isUndead"(): boolean
 "rayTrace"(): $RayTraceResultJS
 "setOffHandItem"(arg0: $ItemStack$$Type): void
 "getEquipment"(arg0: $EquipmentSlot$$Type): $ItemStack
 "setMaxHealth"(arg0: float): void
 "rayTraceEntity"(arg0: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(arg0: $InteractionHand$$Type, arg1: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setEquipment"(arg0: $EquipmentSlot$$Type, arg1: $ItemStack$$Type): void
 "setDefaultMovementSpeedMultiplier"(arg0: double): void
 "setTotalMovementSpeedMultiplier"(arg0: double): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer): void
 "canEntityBeSeen"(arg0: $LivingEntity$$Type): boolean
 "setLegsArmorItem"(arg0: $ItemStack$$Type): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type): void
 "getMainHandItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "setFeetArmorItem"(arg0: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>, arg1: double): void
 "getReachDistance"(): double
 "isHoldingInAnyHand"(arg0: $ItemPredicate$$Type): boolean
 "modifyAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type, arg2: double, arg3: $AttributeModifier$Operation$$Type): void
 "getAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>): double
 "setMainHandItem"(arg0: $ItemStack$$Type): void
 "setChestArmorItem"(arg0: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(arg0: $ItemStack$$Type): void
 "getAttributeTotalValue"(arg0: $Holder$$Type<($Attribute)>): double
 "getChestArmorItem"(): $ItemStack
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "spawn"(): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isPlayer"(): boolean
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "getProfile"(): $GameProfile
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "getItem"(): $ItemStack
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityKJS$$Type = ($LivingEntityKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEntityKJS_ = $LivingEntityKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.level.SimpleLevelKubeEvent" {
import {$KubeLevelEvent, $KubeLevelEvent$$Type} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $SimpleLevelKubeEvent implements $KubeLevelEvent {

constructor(arg0: $Level$$Type)

public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleLevelKubeEvent$$Type = ($SimpleLevelKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleLevelKubeEvent_ = $SimpleLevelKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional" {
import {$RecipeSchemaType, $RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"

export interface $RecipeOptional<T> {

 "isDefault"(): boolean
 "getDefaultValue"(arg0: $RecipeSchemaType$$Type): T

(arg0: $RecipeSchemaType): T
get "default"(): boolean
}

export namespace $RecipeOptional {
const DEFAULT: $RecipeOptional<(any)>
const probejs$$marker: never
}
export class $RecipeOptional$$Static<T> implements $RecipeOptional {
static readonly "DEFAULT": $RecipeOptional<(any)>


 "isDefault"(): boolean
 "getDefaultValue"(arg0: $RecipeSchemaType$$Type): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeOptional$$Type<T> = ((arg0: $RecipeSchemaType) => T);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeOptional_<T> = $RecipeOptional$$Type<(T)>;
}}
declare module "dev.latvian.mods.rhino.NativeArray" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$IdScriptableObject, $IdScriptableObject$$Type} from "dev.latvian.mods.rhino.IdScriptableObject"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$IdFunctionObject, $IdFunctionObject$$Type} from "dev.latvian.mods.rhino.IdFunctionObject"
import {$Context, $Context$$Type} from "dev.latvian.mods.rhino.Context"
import {$ListIterator, $ListIterator$$Type} from "java.util.ListIterator"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$DataObject, $DataObject$$Type} from "dev.latvian.mods.rhino.util.DataObject"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"

export class $NativeArray extends $IdScriptableObject implements $List<(any)>, $DataObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(cx: $Context$$Type, lengthArg: long)
constructor(cx: $Context$$Type, array: (any)[])

public "remove"(o: any): boolean
public "remove"(index: integer): any
public "size"(): integer
public "get"(index: long, cx: $Context$$Type): any
public "get"(index: integer): any
public "get"(index: integer, start: $Scriptable$$Type): any
public "put"(index: integer, start: $Scriptable$$Type, value: any): void
public "put"(id: string, start: $Scriptable$$Type, value: any): void
public "toString"(): string
public "getLength"(): long
public "indexOf"(o: any): integer
public "clear"(): void
public "lastIndexOf"(o: any): integer
public "isEmpty"(): boolean
public "add"(o: any): boolean
public "add"(index: integer, element: any): void
public "subList"(fromIndex: integer, toIndex: integer): $List<(any)>
public "toArray"(): (any)[]
public "toArray"(a: (any)[]): (any)[]
public "iterator"(): $Iterator<(any)>
public "contains"(o: any): boolean
public "addAll"(index: integer, c: $Collection$$Type<(any)>): boolean
public "addAll"(c: $Collection$$Type<(any)>): boolean
public "set"(index: integer, element: any): any
public "delete"(index: integer): void
public "getClassName"(): string
public "getAttributes"(index: integer): integer
public "removeAll"(c: $Collection$$Type<(any)>): boolean
public "retainAll"(c: $Collection$$Type<(any)>): boolean
public "listIterator"(): $ListIterator<(any)>
public "listIterator"(start: integer): $ListIterator<(any)>
public "containsAll"(c: $Collection$$Type<(any)>): boolean
public "has"(index: integer, start: $Scriptable$$Type): boolean
public "getIds"(nonEnumerable: boolean, getSymbols: boolean): (any)[]
public "execIdCall"(f: $IdFunctionObject$$Type, cx: $Context$$Type, scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args: (any)[]): any
public "createDataObjectList"<T>(instanceFactory: $Supplier$$Type<(T)>, cx: $Context$$Type): $List<(T)>
public "getIndexIds"(): $List<(integer)>
public "createDataObject"<T>(instanceFactory: $Supplier$$Type<(T)>, cx: $Context$$Type): T
public "isDataObjectList"(): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<E>(arg0: $Collection$$Type<(any)>): $List<(any)>
public "replaceAll"(arg0: $UnaryOperator$$Type<(any)>): void
public static "of"<E>(arg0: any, arg1: any, arg2: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any): $List<(any)>
public static "of"<E>(): $List<(any)>
public static "of"<E>(arg0: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any): $List<(any)>
public static "of"<E>(...arg0: (any)[]): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any): $List<(any)>
public "spliterator"(): $Spliterator<(any)>
public "sort"(arg0: $Comparator$$Type<(any)>): void
public "getFirst"(): any
public "getLast"(): any
public "addFirst"(arg0: any): void
public "addLast"(arg0: any): void
public "removeFirst"(): any
public "removeLast"(): any
public "reversed"(): $SequencedCollection<(any)>
public "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
public "stream"(): $Stream<(any)>
public "removeIf"(arg0: $Predicate$$Type<(any)>): boolean
public "parallelStream"(): $Stream<(any)>
public "forEach"(arg0: $Consumer$$Type<(any)>): void
[Symbol.iterator](): IterableIterator<any>;
[index: number]: any
get "length"(): long
get "empty"(): boolean
get "className"(): string
get "indexIds"(): $List<(integer)>
get "dataObjectList"(): boolean
get "first"(): any
get "last"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeArray$$Type = ($NativeArray);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeArray_ = $NativeArray$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.data.GeneratedDataStage" {
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$Map, $Map$$Type} from "java.util.Map"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$EventTargetType, $EventTargetType$$Type} from "dev.latvian.mods.kubejs.event.EventTargetType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $GeneratedDataStage extends $Enum<($GeneratedDataStage)> implements $StringRepresentable {
static readonly "INTERNAL": $GeneratedDataStage
static readonly "REGISTRIES": $GeneratedDataStage
static readonly "BEFORE_MODS": $GeneratedDataStage
static readonly "AFTER_MODS": $GeneratedDataStage
static readonly "LAST": $GeneratedDataStage
static readonly "FOR_SCRIPTS": ($GeneratedDataStage)[]
static readonly "TARGET": $EventTargetType<($GeneratedDataStage)>
readonly "displayName": string


public static "values"(): ($GeneratedDataStage)[]
public static "valueOf"(arg0: string): $GeneratedDataStage
public "getSerializedName"(): string
public static "forScripts"<T>(arg0: $Function$$Type<($GeneratedDataStage), (T)>): $Map<($GeneratedDataStage), (T)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedDataStage$$Type = (("internal") | ("registries") | ("before_mods") | ("after_mods") | ("last"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratedDataStage_ = $GeneratedDataStage$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Axe" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DiggerItemBuilder, $DiggerItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem, $DiggerItem$$Type} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Axe extends $DiggerItemBuilder {
static readonly "AXE_TAGS": ($ResourceLocation)[]
static readonly "AXE_MODEL": $ResourceLocation
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Axe$$Type = ($DiggerItemBuilder$Axe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DiggerItemBuilder$Axe_ = $DiggerItemBuilder$Axe$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.callbacks.BlockExplodedCallbackJS" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Explosion, $Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$List, $List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockExplodedCallbackJS {

constructor(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type)

public "getCause"(): $Entity
public "getLevel"(): $Level
public "getBlock"(): $BlockContainerJS
public "getRadius"(): float
public "getAffectedPlayers"(): $List<($Player)>
public "getBlockState"(): $BlockState
public "getExplosion"(): $Explosion
public "getIgniter"(): $LivingEntity
get "cause"(): $Entity
get "level"(): $Level
get "block"(): $BlockContainerJS
get "radius"(): float
get "affectedPlayers"(): $List<($Player)>
get "blockState"(): $BlockState
get "explosion"(): $Explosion
get "igniter"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockExplodedCallbackJS$$Type = ($BlockExplodedCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockExplodedCallbackJS_ = $BlockExplodedCallbackJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.component.ComponentFunctions" {
import {$Potion, $Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$ItemAttributeModifiers$Entry, $ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$List, $List$$Type} from "java.util.List"
import {$Rarity, $Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents, $PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Unit, $Unit$$Type} from "net.minecraft.util.Unit"

export interface $ComponentFunctions {

 "setAttributeModifiersWithTooltip"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
 "setUnit"(arg0: $DataComponentType$$Type<($Unit$$Type)>): this
 "setLockCode"(arg0: string): void
 "setCustomData"(arg0: $CompoundTag$$Type): void
 "setRarity"(arg0: $Rarity$$Type): void
 "setCustomName"(arg0: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(arg0: $List$$Type<($Component$$Type)>): void
 "setLore"(arg0: $List$$Type<($Component$$Type)>, arg1: $List$$Type<($Component$$Type)>): void
 "setDyedColor"(arg0: $KubeColor$$Type): void
 "getCustomData"(): $CompoundTag
 "setPotionId"(arg0: $Holder$$Type<($Potion)>): void
 "setEntityData"(arg0: $CompoundTag$$Type): void
 "setProfile"(arg0: $GameProfile$$Type): void
 "setProfile"(arg0: string, arg1: $UUID$$Type): void
 "setBaseColor"(arg0: $DyeColor$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(arg0: $Map$$Type<(string), (string)>): void
 "setDyedColorWithTooltip"(arg0: $KubeColor$$Type): void
 "set"(arg1: $DataComponentType$$Type<(any)>, arg2: any): this
 "set"(arg1: $DataComponentMap$$Type): this
 "patch"(arg1: $DataComponentPatch$$Type): this
 "get"<T>(arg0: $DataComponentType$$Type<(T)>): T
 "remove"(arg0: $DataComponentType$$Type<(any)>): this
 "setPotionContents"(arg0: $PotionContents$$Type): void
 "setGlintOverride"(arg0: boolean): void
 "getComponentString"(): string
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
 "setTooltipHidden"(): void
 "setCustomModelData"(arg0: integer): void
 "resetComponents"(): this
 "getComponentMap"(): $DataComponentMap
 "setAttributeModifiers"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
set "lockCode"(value: string)
set "customData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "customName"(value: $Component$$Type)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "dyedColor"(value: $KubeColor$$Type)
get "customData"(): $CompoundTag
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(string), (string)>)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
set "glintOverride"(value: boolean)
get "componentString"(): string
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
set "customModelData"(value: integer)
get "componentMap"(): $DataComponentMap
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
}

export namespace $ComponentFunctions {
const probejs$$marker: never
}
export class $ComponentFunctions$$Static implements $ComponentFunctions {


 "setAttributeModifiersWithTooltip"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
 "setUnit"(arg0: $DataComponentType$$Type<($Unit$$Type)>): this
 "setLockCode"(arg0: string): void
 "setCustomData"(arg0: $CompoundTag$$Type): void
 "setRarity"(arg0: $Rarity$$Type): void
 "setCustomName"(arg0: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(arg0: $List$$Type<($Component$$Type)>): void
 "setLore"(arg0: $List$$Type<($Component$$Type)>, arg1: $List$$Type<($Component$$Type)>): void
 "setDyedColor"(arg0: $KubeColor$$Type): void
 "getCustomData"(): $CompoundTag
 "setPotionId"(arg0: $Holder$$Type<($Potion)>): void
 "setEntityData"(arg0: $CompoundTag$$Type): void
 "setProfile"(arg0: $GameProfile$$Type): void
 "setProfile"(arg0: string, arg1: $UUID$$Type): void
 "setBaseColor"(arg0: $DyeColor$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(arg0: $Map$$Type<(string), (string)>): void
 "setDyedColorWithTooltip"(arg0: $KubeColor$$Type): void
 "set"(arg1: $DataComponentType$$Type<(any)>, arg2: any): this
 "set"(arg1: $DataComponentMap$$Type): this
 "patch"(arg1: $DataComponentPatch$$Type): this
 "get"<T>(arg0: $DataComponentType$$Type<(T)>): T
 "remove"(arg0: $DataComponentType$$Type<(any)>): this
 "setPotionContents"(arg0: $PotionContents$$Type): void
 "setGlintOverride"(arg0: boolean): void
 "getComponentString"(): string
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
 "setTooltipHidden"(): void
 "setCustomModelData"(arg0: integer): void
 "resetComponents"(): this
 "getComponentMap"(): $DataComponentMap
 "setAttributeModifiers"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentFunctions$$Type = ($ComponentFunctions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentFunctions_ = $ComponentFunctions$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.MenuTypeKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$MenuType, $MenuType$$Type} from "net.minecraft.world.inventory.MenuType"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS, $RegistryObjectKJS$$Type} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export interface $MenuTypeKJS extends $RegistryObjectKJS<($MenuType<(any)>)> {

 "getRegistry"(): $Registry<($MenuType<(any)>)>
 "getRegistryId"(): $ResourceKey<($Registry<($MenuType<(any)>)>)>
 "getId"(): string
 "getKey"(): $ResourceKey<($MenuType<(any)>)>
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "asHolder"(): $Holder<($MenuType<(any)>)>
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
get "registry"(): $Registry<($MenuType<(any)>)>
get "registryId"(): $ResourceKey<($Registry<($MenuType<(any)>)>)>
get "id"(): string
get "key"(): $ResourceKey<($MenuType<(any)>)>
get "mod"(): string
get "idLocation"(): $ResourceLocation
get "tags"(): $Collection<($ResourceLocation)>
}

export namespace $MenuTypeKJS {
const probejs$$marker: never
}
export class $MenuTypeKJS$$Static implements $MenuTypeKJS {


 "getRegistry"(): $Registry<($MenuType<(any)>)>
 "getRegistryId"(): $ResourceKey<($Registry<($MenuType<(any)>)>)>
 "getId"(): string
 "getKey"(): $ResourceKey<($MenuType<(any)>)>
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "asHolder"(): $Holder<($MenuType<(any)>)>
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MenuTypeKJS$$Type = ($MenuTypeKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MenuTypeKJS_ = $MenuTypeKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $ShapedBlockBuilder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type, ...arg1: (string)[])

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedBlockBuilder$$Type = ($ShapedBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapedBlockBuilder_ = $ShapedBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityEventCallback" {
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"

export interface $BlockEntityEventCallback {

 "accept"(arg0: $KubeBlockEntity$$Type, arg1: integer): void

(arg0: $KubeBlockEntity, arg1: integer): void
}

export namespace $BlockEntityEventCallback {
const probejs$$marker: never
}
export class $BlockEntityEventCallback$$Static implements $BlockEntityEventCallback {


 "accept"(arg0: $KubeBlockEntity$$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityEventCallback$$Type = ((arg0: $KubeBlockEntity, arg1: integer) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityEventCallback_ = $BlockEntityEventCallback$$Type;
}}
declare module "dev.latvian.mods.kubejs.event.EventExceptionHandler" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Throwable, $Throwable$$Type} from "java.lang.Throwable"
import {$EventHandlerContainer, $EventHandlerContainer$$Type} from "dev.latvian.mods.kubejs.event.EventHandlerContainer"

export interface $EventExceptionHandler {

 "handle"(arg0: $KubeEvent$$Type, arg1: $EventHandlerContainer$$Type, arg2: $Throwable$$Type): $Throwable

(arg0: $KubeEvent, arg1: $EventHandlerContainer, arg2: $Throwable): $Throwable$$Type
}

export namespace $EventExceptionHandler {
const probejs$$marker: never
}
export class $EventExceptionHandler$$Static implements $EventExceptionHandler {


 "handle"(arg0: $KubeEvent$$Type, arg1: $EventHandlerContainer$$Type, arg2: $Throwable$$Type): $Throwable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventExceptionHandler$$Type = ((arg0: $KubeEvent, arg1: $EventHandlerContainer, arg2: $Throwable) => $Throwable$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventExceptionHandler_ = $EventExceptionHandler$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.ModifyCraftingItemKubeEvent" {
import {$CraftingInput, $CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"

export class $ModifyCraftingItemKubeEvent implements $KubeEvent {
readonly "grid": $RecipeInput
readonly "width": integer
readonly "height": integer
 "item": $ItemStack
readonly "index": integer

constructor(arg0: $RecipeInput$$Type, arg1: integer, arg2: integer, arg3: $ItemStack$$Type, arg4: integer)
constructor(arg0: $CraftingInput$$Type, arg1: $ItemStack$$Type, arg2: integer)

/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifyCraftingItemKubeEvent$$Type = ($ModifyCraftingItemKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModifyCraftingItemKubeEvent_ = $ModifyCraftingItemKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.TagManagerKJS" {
import {$ReloadableServerResourceHolderKJS, $ReloadableServerResourceHolderKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourceHolderKJS"
import {$ReloadableServerResourcesKJS, $ReloadableServerResourcesKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS"

export interface $TagManagerKJS extends $ReloadableServerResourceHolderKJS {

 "kjs$setResources"(arg0: $ReloadableServerResourcesKJS$$Type): void
 "kjs$getResources"(): $ReloadableServerResourcesKJS
}

export namespace $TagManagerKJS {
const probejs$$marker: never
}
export class $TagManagerKJS$$Static implements $TagManagerKJS {


 "kjs$setResources"(arg0: $ReloadableServerResourcesKJS$$Type): void
 "kjs$getResources"(): $ReloadableServerResourcesKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagManagerKJS$$Type = ($TagManagerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagManagerKJS_ = $TagManagerKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.kgui.KGUIType" {
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"

export class $KGUIType extends $Enum<($KGUIType)> implements $StringRepresentable {
static readonly "GUI": $KGUIType
static readonly "HUD": $KGUIType
static readonly "INVENTORY": $KGUIType
static readonly "OVERLAY": $KGUIType
static readonly "VALUES": ($KGUIType)[]
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($KGUIType)>
readonly "gui": boolean
readonly "hud": boolean
readonly "inventory": boolean


public static "values"(): ($KGUIType)[]
public static "valueOf"(arg0: string): $KGUIType
public "getSerializedName"(): string
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KGUIType$$Type = (("gui") | ("hud") | ("inventory") | ("overlay"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KGUIType_ = $KGUIType$$Type;
}}
declare module "dev.latvian.apps.tinyserver.ServerRegistry" {
import {$WSSession, $WSSession$$Type} from "dev.latvian.apps.tinyserver.ws.WSSession"
import {$HTTPMethod, $HTTPMethod$$Type} from "dev.latvian.apps.tinyserver.http.HTTPMethod"
import {$WSSessionFactory, $WSSessionFactory$$Type} from "dev.latvian.apps.tinyserver.ws.WSSessionFactory"
import {$HTTPHandler, $HTTPHandler$$Type} from "dev.latvian.apps.tinyserver.http.HTTPHandler"
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"
import {$HTTPRequest, $HTTPRequest$$Type} from "dev.latvian.apps.tinyserver.http.HTTPRequest"
import {$WSHandler, $WSHandler$$Type} from "dev.latvian.apps.tinyserver.ws.WSHandler"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ServerRegistry<REQ extends $HTTPRequest> {

 "get"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
 "put"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
 "delete"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
 "patch"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
 "ws"<WSS extends $WSSession<(REQ)>>(arg0: string, arg1: $WSSessionFactory$$Type<(REQ), (WSS)>): $WSHandler<(REQ), (WSS)>
 "ws"<WSS extends $WSSession<(REQ)>>(arg0: string): $WSHandler<(REQ), (WSS)>
 "post"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
 "http"(arg0: $HTTPMethod$$Type, arg1: string, arg2: $HTTPHandler$$Type<(REQ)>): void
 "acceptPostTask"(arg0: string, arg1: $Runnable$$Type): void
 "acceptPostString"(arg0: string, arg1: $Consumer$$Type<(string)>): void
}

export namespace $ServerRegistry {
const probejs$$marker: never
}
export class $ServerRegistry$$Static<REQ extends $HTTPRequest> implements $ServerRegistry {


 "get"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
 "put"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
 "delete"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
 "patch"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
 "ws"<WSS extends $WSSession<(REQ)>>(arg0: string, arg1: $WSSessionFactory$$Type<(REQ), (WSS)>): $WSHandler<(REQ), (WSS)>
 "ws"<WSS extends $WSSession<(REQ)>>(arg0: string): $WSHandler<(REQ), (WSS)>
 "post"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
 "http"(arg0: $HTTPMethod$$Type, arg1: string, arg2: $HTTPHandler$$Type<(REQ)>): void
 "acceptPostTask"(arg0: string, arg1: $Runnable$$Type): void
 "acceptPostString"(arg0: string, arg1: $Consumer$$Type<(string)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerRegistry$$Type<REQ> = ($ServerRegistry<(REQ)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerRegistry_<REQ> = $ServerRegistry$$Type<(REQ)>;
}}
declare module "dev.latvian.mods.kubejs.server.tag.TagWrapper" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$List, $List$$Type} from "java.util.List"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$TagKubeEvent, $TagKubeEvent$$Type} from "dev.latvian.mods.kubejs.server.tag.TagKubeEvent"

export class $TagWrapper {
readonly "event": $TagKubeEvent
readonly "id": $ResourceLocation
readonly "entries": $List<($TagLoader$EntryWithSource)>

constructor(arg0: $TagKubeEvent$$Type, arg1: $ResourceLocation$$Type, arg2: $List$$Type<($TagLoader$EntryWithSource$$Type)>)

public "remove"(...arg0: (any)[]): $TagWrapper
public "toString"(): string
public "add"(...arg0: (any)[]): $TagWrapper
public "removeAll"(): $TagWrapper
public "getObjectIds"(): $List<($ResourceLocation)>
get "objectIds"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagWrapper$$Type = ($TagWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagWrapper_ = $TagWrapper$$Type;
}}
declare module "dev.latvian.mods.rhino.util.wrap.TypeWrapperValidator" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"

export interface $TypeWrapperValidator {

 "isValid"(arg0: any, arg1: $TypeInfo$$Type): boolean

(arg0: any, arg1: $TypeInfo): boolean
}

export namespace $TypeWrapperValidator {
const ALWAYS_VALID: $TypeWrapperValidator
const probejs$$marker: never
}
export class $TypeWrapperValidator$$Static implements $TypeWrapperValidator {
static readonly "ALWAYS_VALID": $TypeWrapperValidator


 "isValid"(arg0: any, arg1: $TypeInfo$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeWrapperValidator$$Type = ((arg0: any, arg1: $TypeInfo) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeWrapperValidator_ = $TypeWrapperValidator$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.match.FluidMatch" {
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"

export interface $FluidMatch extends $ReplacementMatch {

 "matches"(arg1: $FluidStack$$Type, arg2: boolean): boolean
 "matches"(arg1: $FluidIngredient$$Type, arg2: boolean): boolean
}

export namespace $FluidMatch {
function wrap(arg1: any): $ReplacementMatch
const probejs$$marker: never
}
export class $FluidMatch$$Static implements $FluidMatch {


 "matches"(arg1: $FluidStack$$Type, arg2: boolean): boolean
 "matches"(arg1: $FluidIngredient$$Type, arg2: boolean): boolean
static "wrap"(arg1: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidMatch$$Type = ($FluidMatch);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidMatch_ = $FluidMatch$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage" {
import {$RecipeComponentFactory, $RecipeComponentFactory$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeComponentFactory"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeSchemaType, $RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$StringReader, $StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$RecipeNamespace, $RecipeNamespace$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$KubeRecipeFactory, $KubeRecipeFactory$$Type} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ResourceManager, $ResourceManager$$Type} from "net.minecraft.server.packs.resources.ResourceManager"

export class $RecipeSchemaStorage {
readonly "recipeTypes": $Map<($ResourceLocation), ($KubeRecipeFactory)>
readonly "namespaces": $Map<(string), ($RecipeNamespace)>
readonly "mappings": $Map<(string), ($ResourceLocation)>
readonly "simpleComponents": $Map<(string), ($RecipeComponent<(any)>)>
readonly "dynamicComponents": $Map<(string), ($RecipeComponentFactory)>
readonly "schemaTypes": $Map<(string), ($RecipeSchemaType)>
 "shapedSchema": $RecipeSchema
 "shapelessSchema": $RecipeSchema
 "specialSchema": $RecipeSchema

constructor()

public "namespace"(arg0: string): $RecipeNamespace
public "getComponent"(arg0: $RegistryAccessContainer$$Type, arg1: string): $RecipeComponent<(any)>
public "readComponent"(arg0: $RegistryAccessContainer$$Type, arg1: $StringReader$$Type): $RecipeComponent<(any)>
public "fireEvents"(arg0: $RegistryAccessContainer$$Type, arg1: $ResourceManager$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaStorage$$Type = ($RecipeSchemaStorage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeSchemaStorage_ = $RecipeSchemaStorage$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemStackKey" {
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemStackKey {
static "EMPTY": $ItemStackKey
readonly "item": $Item
readonly "patch": $DataComponentPatch

constructor(arg0: $Item$$Type, arg1: $DataComponentPatch$$Type)

public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "of"(arg0: $ItemStack$$Type): $ItemStackKey
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackKey$$Type = ($ItemStackKey);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackKey_ = $ItemStackKey$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RemoveCategoriesKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"

export interface $RemoveCategoriesKubeEvent extends $KubeEvent {

 "remove"(arg1: ($ResourceLocation$$Type)[]): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any

(arg1: ($ResourceLocation)[]): void
}

export namespace $RemoveCategoriesKubeEvent {
const probejs$$marker: never
}
export class $RemoveCategoriesKubeEvent$$Static implements $RemoveCategoriesKubeEvent {


 "remove"(arg1: ($ResourceLocation$$Type)[]): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveCategoriesKubeEvent$$Type = ((arg1: ($ResourceLocation)[]) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoveCategoriesKubeEvent_ = $RemoveCategoriesKubeEvent$$Type;
}}
declare module "dev.latvian.mods.rhino.util.wrap.TypeWrapper" {
import {$TypeWrapperValidator, $TypeWrapperValidator$$Type} from "dev.latvian.mods.rhino.util.wrap.TypeWrapperValidator"
import {$TypeWrapperFactory, $TypeWrapperFactory$$Type} from "dev.latvian.mods.rhino.util.wrap.TypeWrapperFactory"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $TypeWrapper<T> extends $Record {

constructor(target: $Class$$Type<(T)>, validator: $TypeWrapperValidator$$Type, factory: $TypeWrapperFactory$$Type<(T)>)

public "equals"(o: any): boolean
public "target"(): $Class<(T)>
public "toString"(): string
public "hashCode"(): integer
public "factory"(): $TypeWrapperFactory<(T)>
public "validator"(): $TypeWrapperValidator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeWrapper$$Type<T> = ({"validator"?: $TypeWrapperValidator$$Type, "factory"?: $TypeWrapperFactory$$Type<(never)>, "target"?: $Class$$Type<(never)>}) | ([validator?: $TypeWrapperValidator$$Type, factory?: $TypeWrapperFactory$$Type<(never)>, target?: $Class$$Type<(never)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeWrapper_<T> = $TypeWrapper$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.core.LocalClientPlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$KubeJSInventoryListener, $KubeJSInventoryListener$$Type} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Stages, $Stages$$Type} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties, $FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$Minecraft, $Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$NotificationToastData, $NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$ClientPlayerKJS, $ClientPlayerKJS$$Type} from "dev.latvian.mods.kubejs.core.ClientPlayerKJS"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS, $PlayerStatsJS$$Type} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$EntityPotionEffectsJS, $EntityPotionEffectsJS$$Type} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$KGUIActions, $KGUIActions$$Type} from "dev.latvian.mods.kubejs.kgui.action.KGUIActions"
import {$Attribute, $Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$RayTraceResultJS, $RayTraceResultJS$$Type} from "dev.latvian.mods.kubejs.entity.RayTraceResultJS"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export interface $LocalClientPlayerKJS extends $ClientPlayerKJS {

 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "self"(): $Entity
 "isMiningBlock"(): boolean
 "sendData"(arg0: string, arg1: $CompoundTag$$Type): void
 "getStats"(): $PlayerStatsJS
 "runCommand"(arg0: string): void
 "notify"(arg0: $NotificationToastData$$Type): void
 "isSelf"(): boolean
 "getMinecraft"(): $Minecraft
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "spawn"(): void
 "setStatusMessage"(arg0: $Component$$Type): void
 "getStages"(): $Stages
 "getInventory"(): $InventoryKJS
 "addExhaustion"(arg0: float): void
 "getXpLevel"(): integer
 "setSaturation"(arg0: float): void
 "addFood"(arg0: integer, arg1: float): void
 "addXPLevels"(arg0: integer): void
 "giveInHand"(arg0: $ItemStack$$Type): void
 "getFoodLevel"(): integer
 "setFoodLevel"(arg0: integer): void
 "getKgui"(): $KGUIActions
 "setMouseItem"(arg0: $ItemStack$$Type): void
 "getSaturation"(): float
 "getMouseItem"(): $ItemStack
 "setXpLevel"(arg0: integer): void
 "isPlayer"(): boolean
 "getProfile"(): $GameProfile
 "addItemCooldown"(arg0: $Item$$Type, arg1: integer): void
 "getCraftingGrid"(): $InventoryKJS
 "setSelectedSlot"(arg0: integer): void
 "getSelectedSlot"(): integer
 "boostElytraFlight"(): void
 "sendInventoryUpdate"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addXP"(arg0: integer): void
 "setXp"(arg0: integer): void
 "getXp"(): integer
 "give"(arg0: $ItemStack$$Type): void
 "isFake"(): boolean
 "notify"(arg0: $Component$$Type, arg1: $Component$$Type): void
 "setDefaultMovementSpeed"(arg0: double): void
 "setMovementSpeedAddition"(arg0: double): void
 "getDefaultMovementSpeed"(): double
 "swing"(): void
 "swing"(arg0: $InteractionHand$$Type): void
 "foodEaten"(arg0: $ItemStack$$Type, arg1: $FoodProperties$$Type): void
 "getHeldItem"(arg0: $InteractionHand$$Type): $ItemStack
 "isUndead"(): boolean
 "rayTrace"(): $RayTraceResultJS
 "setOffHandItem"(arg0: $ItemStack$$Type): void
 "getEquipment"(arg0: $EquipmentSlot$$Type): $ItemStack
 "setMaxHealth"(arg0: float): void
 "rayTraceEntity"(arg0: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(arg0: $InteractionHand$$Type, arg1: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setEquipment"(arg0: $EquipmentSlot$$Type, arg1: $ItemStack$$Type): void
 "setDefaultMovementSpeedMultiplier"(arg0: double): void
 "setTotalMovementSpeedMultiplier"(arg0: double): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer): void
 "canEntityBeSeen"(arg0: $LivingEntity$$Type): boolean
 "setLegsArmorItem"(arg0: $ItemStack$$Type): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type): void
 "getMainHandItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "setFeetArmorItem"(arg0: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>, arg1: double): void
 "getReachDistance"(): double
 "isHoldingInAnyHand"(arg0: $ItemPredicate$$Type): boolean
 "modifyAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type, arg2: double, arg3: $AttributeModifier$Operation$$Type): void
 "getAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>): double
 "setMainHandItem"(arg0: $ItemStack$$Type): void
 "setChestArmorItem"(arg0: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(arg0: $ItemStack$$Type): void
 "getAttributeTotalValue"(arg0: $Holder$$Type<($Attribute)>): double
 "getChestArmorItem"(): $ItemStack
 "sendData"(arg0: string): void
 "getData"(): $AttachedData<($Player)>
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "getItem"(): $ItemStack
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "getPersistentData"(): $CompoundTag

(): $AttachedData$$Type<($Player$$Type)>
set "activePostShader"(value: $ResourceLocation$$Type)
get "miningBlock"(): boolean
get "stats"(): $PlayerStatsJS
get "minecraft"(): $Minecraft
get "inventoryChangeListener"(): $KubeJSInventoryListener
set "statusMessage"(value: $Component$$Type)
get "stages"(): $Stages
get "inventory"(): $InventoryKJS
get "xpLevel"(): integer
set "saturation"(value: float)
get "foodLevel"(): integer
set "foodLevel"(value: integer)
get "kgui"(): $KGUIActions
set "mouseItem"(value: $ItemStack$$Type)
get "saturation"(): float
get "mouseItem"(): $ItemStack
set "xpLevel"(value: integer)
get "player"(): boolean
get "profile"(): $GameProfile
get "craftingGrid"(): $InventoryKJS
set "selectedSlot"(value: integer)
get "selectedSlot"(): integer
get "openInventory"(): $AbstractContainerMenu
set "xp"(value: integer)
get "xp"(): integer
get "fake"(): boolean
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
get "defaultMovementSpeed"(): double
get "undead"(): boolean
set "offHandItem"(value: $ItemStack$$Type)
set "maxHealth"(value: float)
get "living"(): boolean
get "offHandItem"(): $ItemStack
set "defaultMovementSpeedMultiplier"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
set "legsArmorItem"(value: $ItemStack$$Type)
get "potionEffects"(): $EntityPotionEffectsJS
get "mainHandItem"(): $ItemStack
get "totalMovementSpeed"(): double
set "feetArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
get "reachDistance"(): double
set "mainHandItem"(value: $ItemStack$$Type)
set "chestArmorItem"(value: $ItemStack$$Type)
get "feetArmorItem"(): $ItemStack
get "headArmorItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "data"(): $AttachedData<($Player)>
set "nbt"(value: $CompoundTag$$Type)
get "nbt"(): $CompoundTag
set "y"(value: double)
set "x"(value: double)
set "z"(value: double)
get "name"(): $Component
get "displayName"(): $Component
get "passengers"(): $EntityArrayList
get "server"(): $MinecraftServer
get "type"(): string
set "position"(value: $BlockContainerJS$$Type)
get "monster"(): boolean
set "motionX"(value: double)
get "level"(): $Level
set "motionY"(value: double)
get "motionX"(): double
get "item"(): $ItemStack
set "motionZ"(value: double)
get "block"(): $BlockContainerJS
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "motionZ"(): double
get "teamId"(): string
get "facing"(): $Direction
get "animal"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "persistentData"(): $CompoundTag
}

export namespace $LocalClientPlayerKJS {
const probejs$$marker: never
}
export class $LocalClientPlayerKJS$$Static implements $LocalClientPlayerKJS {


 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "self"(): $Entity
 "isMiningBlock"(): boolean
 "sendData"(arg0: string, arg1: $CompoundTag$$Type): void
 "getStats"(): $PlayerStatsJS
 "runCommand"(arg0: string): void
 "notify"(arg0: $NotificationToastData$$Type): void
 "isSelf"(): boolean
 "getMinecraft"(): $Minecraft
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "spawn"(): void
 "setStatusMessage"(arg0: $Component$$Type): void
 "getStages"(): $Stages
 "getInventory"(): $InventoryKJS
 "addExhaustion"(arg0: float): void
 "getXpLevel"(): integer
 "setSaturation"(arg0: float): void
 "addFood"(arg0: integer, arg1: float): void
 "addXPLevels"(arg0: integer): void
 "giveInHand"(arg0: $ItemStack$$Type): void
 "getFoodLevel"(): integer
 "setFoodLevel"(arg0: integer): void
 "getKgui"(): $KGUIActions
 "setMouseItem"(arg0: $ItemStack$$Type): void
 "getSaturation"(): float
 "getMouseItem"(): $ItemStack
 "setXpLevel"(arg0: integer): void
 "isPlayer"(): boolean
 "getProfile"(): $GameProfile
 "addItemCooldown"(arg0: $Item$$Type, arg1: integer): void
 "getCraftingGrid"(): $InventoryKJS
 "setSelectedSlot"(arg0: integer): void
 "getSelectedSlot"(): integer
 "boostElytraFlight"(): void
 "sendInventoryUpdate"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addXP"(arg0: integer): void
 "setXp"(arg0: integer): void
 "getXp"(): integer
 "give"(arg0: $ItemStack$$Type): void
 "isFake"(): boolean
 "notify"(arg0: $Component$$Type, arg1: $Component$$Type): void
 "setDefaultMovementSpeed"(arg0: double): void
 "setMovementSpeedAddition"(arg0: double): void
 "getDefaultMovementSpeed"(): double
 "swing"(): void
 "swing"(arg0: $InteractionHand$$Type): void
 "foodEaten"(arg0: $ItemStack$$Type, arg1: $FoodProperties$$Type): void
 "getHeldItem"(arg0: $InteractionHand$$Type): $ItemStack
 "isUndead"(): boolean
 "rayTrace"(): $RayTraceResultJS
 "setOffHandItem"(arg0: $ItemStack$$Type): void
 "getEquipment"(arg0: $EquipmentSlot$$Type): $ItemStack
 "setMaxHealth"(arg0: float): void
 "rayTraceEntity"(arg0: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(arg0: $InteractionHand$$Type, arg1: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setEquipment"(arg0: $EquipmentSlot$$Type, arg1: $ItemStack$$Type): void
 "setDefaultMovementSpeedMultiplier"(arg0: double): void
 "setTotalMovementSpeedMultiplier"(arg0: double): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer): void
 "canEntityBeSeen"(arg0: $LivingEntity$$Type): boolean
 "setLegsArmorItem"(arg0: $ItemStack$$Type): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type): void
 "getMainHandItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "setFeetArmorItem"(arg0: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>, arg1: double): void
 "getReachDistance"(): double
 "isHoldingInAnyHand"(arg0: $ItemPredicate$$Type): boolean
 "modifyAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type, arg2: double, arg3: $AttributeModifier$Operation$$Type): void
 "getAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>): double
 "setMainHandItem"(arg0: $ItemStack$$Type): void
 "setChestArmorItem"(arg0: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(arg0: $ItemStack$$Type): void
 "getAttributeTotalValue"(arg0: $Holder$$Type<($Attribute)>): double
 "getChestArmorItem"(): $ItemStack
 "sendData"(arg0: string): void
 "getData"(): $AttachedData<($Player)>
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "getItem"(): $ItemStack
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LocalClientPlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LocalClientPlayerKJS_ = $LocalClientPlayerKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.SoundsGenerator" {
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$SoundsGenerator$SoundGen, $SoundsGenerator$SoundGen$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundGen"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $SoundsGenerator {

constructor()

public "toJson"(): $JsonObject
public "addSound"(arg0: string, arg1: $Consumer$$Type<($SoundsGenerator$SoundGen)>, arg2: boolean): void
public "addSound"(arg0: string, arg1: $Consumer$$Type<($SoundsGenerator$SoundGen)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundsGenerator$$Type = ($SoundsGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundsGenerator_ = $SoundsGenerator$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.WithPersistentData" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MessageSenderKJS, $MessageSenderKJS$$Type} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"

export interface $WithPersistentData extends $MessageSenderKJS {

 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}

export namespace $WithPersistentData {
const probejs$$marker: never
}
export class $WithPersistentData$$Static implements $WithPersistentData {


 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithPersistentData$$Type = ($WithPersistentData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WithPersistentData_ = $WithPersistentData$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.ScriptTypeHolder" {
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ScriptTypeHolder {

 "kjs$getScriptType"(): $ScriptType

(): $ScriptType$$Type
}

export namespace $ScriptTypeHolder {
const probejs$$marker: never
}
export class $ScriptTypeHolder$$Static implements $ScriptTypeHolder {


 "kjs$getScriptType"(): $ScriptType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptTypeHolder$$Type = (() => $ScriptType$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptTypeHolder_ = $ScriptTypeHolder$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.BlockModificationKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$BlockModificationKubeEvent$BlockModifications, $BlockModificationKubeEvent$BlockModifications$$Type} from "dev.latvian.mods.kubejs.block.BlockModificationKubeEvent$BlockModifications"
import {$BlockStatePredicate, $BlockStatePredicate$$Type} from "dev.latvian.mods.kubejs.block.state.BlockStatePredicate"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $BlockModificationKubeEvent implements $KubeEvent {

constructor()

/**
 * Modifies blocks that match the given predicate.
 * 
 * **NOTE**: tag predicates are not supported at this time.
 */
public "modify"(arg0: $BlockStatePredicate$$Type, arg1: $Consumer$$Type<($BlockModificationKubeEvent$BlockModifications)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockModificationKubeEvent$$Type = ($BlockModificationKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockModificationKubeEvent_ = $BlockModificationKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider" {
import {$ClientLevel, $ClientLevel$$Type} from "net.minecraft.client.multiplayer.ClientLevel"
import {$ParticleProvider, $ParticleProvider$$Type} from "net.minecraft.client.particle.ParticleProvider"
import {$Particle, $Particle$$Type} from "net.minecraft.client.particle.Particle"
import {$ParticleEngine$SpriteParticleRegistration, $ParticleEngine$SpriteParticleRegistration$$Type} from "net.minecraft.client.particle.ParticleEngine$SpriteParticleRegistration"
import {$SpriteSet, $SpriteSet$$Type} from "net.minecraft.client.particle.SpriteSet"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

export interface $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider<T extends $ParticleOptions> extends $ParticleEngine$SpriteParticleRegistration<(T)> {

 "create"(arg0: T, arg1: $ClientLevel$$Type, arg2: double, arg3: double, arg4: double, arg5: $SpriteSet$$Type, arg6: double, arg7: double, arg8: double): $Particle
 "create"(arg0: $SpriteSet$$Type): $ParticleProvider<(T)>

(arg0: T, arg1: $ClientLevel, arg2: double, arg3: double, arg4: double, arg5: $SpriteSet, arg6: double, arg7: double, arg8: double): $Particle$$Type
}

export namespace $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider {
const probejs$$marker: never
}
export class $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Static<T extends $ParticleOptions> implements $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider {


 "create"(arg0: T, arg1: $ClientLevel$$Type, arg2: double, arg3: double, arg4: double, arg5: $SpriteSet$$Type, arg6: double, arg7: double, arg8: double): $Particle
 "create"(arg0: $SpriteSet$$Type): $ParticleProvider<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Type<T> = ((arg0: T, arg1: $ClientLevel, arg2: double, arg3: double, arg4: double, arg5: $SpriteSet, arg6: double, arg7: double, arg8: double) => $Particle$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider_<T> = $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.util.KubeResourceLocation" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $KubeResourceLocation extends $Record {

constructor(wrapped: $ResourceLocation$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "wrap"(arg0: any): $ResourceLocation
public "wrapped"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeResourceLocation$$Type = ({"wrapped"?: $ResourceLocation$$Type}) | ([wrapped?: $ResourceLocation$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeResourceLocation_ = $KubeResourceLocation$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.JavaWrapper" {
import {$ConsoleJS, $ConsoleJS$$Type} from "dev.latvian.mods.kubejs.script.ConsoleJS"

/**
 * Methods for working with Java classes. Reflection my beloved 
 */
export interface $JavaWrapper {

}

export namespace $JavaWrapper {
function loadClass<T extends ClassPath>(arg1: T): LoadClass<(T)>
function createConsole(arg1: string): $ConsoleJS
function tryLoadClass<T extends ClassPath>(arg1: T): LoadClass<(T)>
const probejs$$marker: never
}
export class $JavaWrapper$$Static implements $JavaWrapper {


/**
 * Loads the specified class, and throws error if class it not found or allowed.
 * The returned object can have public static methods and fields accessed directly from it.
 * Constructors can be used with the new keyword.
 */
static "loadClass"<T extends ClassPath>(arg1: T): LoadClass<(T)>
/**
 * Creates a custom ConsoleJS instance for you to use to, well, log stuff
 */
static "createConsole"(arg1: string): $ConsoleJS
/**
 * Loads the specified class, and returns null if class is not found or allowed.
 * The returned object can have public static methods and fields accessed directly from it.
 * Constructors can be used with the new keyword.
 */
static "tryLoadClass"<T extends ClassPath>(arg1: T): LoadClass<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaWrapper$$Type = ($JavaWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaWrapper_ = $JavaWrapper$$Type;
}}
declare module "dev.latvian.apps.tinyserver.ws.WSHandler" {
import {$WSSession, $WSSession$$Type} from "dev.latvian.apps.tinyserver.ws.WSSession"
import {$Frame, $Frame$$Type} from "dev.latvian.apps.tinyserver.ws.Frame"
import {$Map, $Map$$Type} from "java.util.Map"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$HTTPRequest, $HTTPRequest$$Type} from "dev.latvian.apps.tinyserver.http.HTTPRequest"

export interface $WSHandler<REQ extends $HTTPRequest, WSS extends $WSSession<(REQ)>> {

 "broadcast"(arg0: $Frame$$Type): void
 "sessions"(): $Map<($UUID), (WSS)>
 "broadcastBinary"(arg0: (byte)[]): void
 "broadcastBinary"(arg0: $Supplier$$Type<((byte)[])>): void
 "broadcastText"(arg0: $Supplier$$Type<(string)>): void
 "broadcastText"(arg0: string): void

(): $Map$$Type<($UUID$$Type), (WSS)>
}

export namespace $WSHandler {
function empty<REQ extends $HTTPRequest, WSS extends $WSSession<(REQ)>>(): $WSHandler<(REQ), (WSS)>
const probejs$$marker: never
}
export class $WSHandler$$Static<REQ extends $HTTPRequest, WSS extends $WSSession<(REQ)>> implements $WSHandler {


static "empty"<REQ extends $HTTPRequest, WSS extends $WSSession<(REQ)>>(): $WSHandler<(REQ), (WSS)>
 "broadcast"(arg0: $Frame$$Type): void
 "sessions"(): $Map<($UUID), (WSS)>
 "broadcastBinary"(arg0: (byte)[]): void
 "broadcastBinary"(arg0: $Supplier$$Type<((byte)[])>): void
 "broadcastText"(arg0: $Supplier$$Type<(string)>): void
 "broadcastText"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WSHandler$$Type<REQ, WSS> = (() => $Map$$Type<($UUID$$Type), (WSS)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WSHandler_<REQ, WSS> = $WSHandler$$Type<(REQ), (WSS)>;
}}
declare module "dev.latvian.mods.kubejs.block.BlockModificationKubeEvent$BlockModifications" {
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $BlockModificationKubeEvent$BlockModifications extends $Record {

constructor(block: $Block$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "block"(): $Block
public "setHasCollision"(arg0: boolean): void
public "setDestroySpeed"(arg0: float): void
public "setJumpFactor"(arg0: float): void
public "setSoundType"(arg0: $SoundType$$Type): void
public "setLightEmission"(arg0: integer): void
public "setSpeedFactor"(arg0: float): void
public "setRequiresTool"(arg0: boolean): void
public "setFriction"(arg0: float): void
public "setNameKey"(arg0: string): void
public "setIsRandomlyTicking"(arg0: boolean): void
public "setRandomTickCallback"(arg0: $Consumer$$Type<($RandomTickCallbackJS)>): void
public "setExplosionResistance"(arg0: float): void
set "hasCollision"(value: boolean)
set "destroySpeed"(value: float)
set "jumpFactor"(value: float)
set "soundType"(value: $SoundType$$Type)
set "lightEmission"(value: integer)
set "speedFactor"(value: float)
set "requiresTool"(value: boolean)
set "friction"(value: float)
set "nameKey"(value: string)
set "isRandomlyTicking"(value: boolean)
set "randomTickCallback"(value: $Consumer$$Type<($RandomTickCallbackJS)>)
set "explosionResistance"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockModificationKubeEvent$BlockModifications$$Type = ({"block"?: $Block$$Type}) | ([block?: $Block$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockModificationKubeEvent$BlockModifications_ = $BlockModificationKubeEvent$BlockModifications$$Type;
}}
declare module "dev.latvian.mods.kubejs.mekanism.KubeChemicalBuilder$CleanSlurry" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$KubeChemicalBuilder, $KubeChemicalBuilder$$Type} from "dev.latvian.mods.kubejs.mekanism.KubeChemicalBuilder"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $KubeChemicalBuilder$CleanSlurry extends $KubeChemicalBuilder {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeChemicalBuilder$CleanSlurry$$Type = ($KubeChemicalBuilder$CleanSlurry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeChemicalBuilder$CleanSlurry_ = $KubeChemicalBuilder$CleanSlurry$$Type;
}}
declare module "dev.latvian.mods.kubejs.level.ExplosionKubeEvent$After" {
import {$Explosion, $Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$List, $List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$ExplosionKubeEvent, $ExplosionKubeEvent$$Type} from "dev.latvian.mods.kubejs.level.ExplosionKubeEvent"

/**
 * Invoked right after an explosion happens.
 */
export class $ExplosionKubeEvent$After extends $ExplosionKubeEvent {

constructor(arg0: $Level$$Type, arg1: $Explosion$$Type, arg2: $List$$Type<($Entity$$Type)>)

/**
 * Gets a list of all entities affected by the explosion.
 */
public "getAffectedEntities"(): $EntityArrayList
/**
 * Gets a list of all blocks affected by the explosion.
 */
public "getAffectedBlocks"(): $List<($BlockContainerJS)>
/**
 * Remove all knockback from all affected *players*.
 */
public "removeKnockback"(): void
/**
 * Remove all entities from the list of affected entities.
 */
public "removeAllAffectedEntities"(): void
/**
 * Remove all blocks from the list of affected blocks.
 */
public "removeAllAffectedBlocks"(): void
/**
 * Remove an entity from the list of affected entities.
 */
public "removeAffectedEntity"(arg0: $Entity$$Type): void
/**
 * Remove a block from the list of affected blocks.
 */
public "removeAffectedBlock"(arg0: $BlockContainerJS$$Type): void
get "affectedEntities"(): $EntityArrayList
get "affectedBlocks"(): $List<($BlockContainerJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionKubeEvent$After$$Type = ($ExplosionKubeEvent$After);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionKubeEvent$After_ = $ExplosionKubeEvent$After$$Type;
}}
declare module "dev.latvian.mods.rhino.GeneratedClassLoader" {
import {$Class, $Class$$Type} from "java.lang.Class"

export interface $GeneratedClassLoader {

 "defineClass"(arg0: string, arg1: (byte)[]): $Class<(any)>
 "linkClass"(arg0: $Class$$Type<(any)>): void
}

export namespace $GeneratedClassLoader {
const probejs$$marker: never
}
export class $GeneratedClassLoader$$Static implements $GeneratedClassLoader {


 "defineClass"(arg0: string, arg1: (byte)[]): $Class<(any)>
 "linkClass"(arg0: $Class$$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedClassLoader$$Type = ($GeneratedClassLoader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratedClassLoader_ = $GeneratedClassLoader$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.UtilsWrapper" {
import {$Pattern, $Pattern$$Type} from "java.util.regex.Pattern"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$List, $List$$Type} from "java.util.List"
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Random, $Random$$Type} from "java.util.Random"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Lazy, $Lazy$$Type} from "dev.latvian.mods.kubejs.util.Lazy"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$CountingMap, $CountingMap$$Type} from "dev.latvian.mods.kubejs.util.CountingMap"
import {$Stat, $Stat$$Type} from "net.minecraft.stats.Stat"
import {$CreativeModeTab, $CreativeModeTab$$Type} from "net.minecraft.world.item.CreativeModeTab"
import {$CompletableFuture, $CompletableFuture$$Type} from "java.util.concurrent.CompletableFuture"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"

/**
 * A collection of utilities
 */
export interface $UtilsWrapper {

}

export namespace $UtilsWrapper {
function regex(arg0: any): $Pattern
function regex(arg0: string, arg1: integer): $Pattern
function emptyList<T>(): $List<(T)>
function isWrapped(arg0: any): boolean
function parseInt(arg0: any, arg1: integer): integer
function newMap(): $Map<(any), (any)>
function toTitleCase(arg0: string): string
function toTitleCase(arg0: string, arg1: boolean): string
function parseDouble(arg0: any, arg1: double): double
function emptyMap<K, V>(): $Map<(K), (V)>
function newList(): $List<(any)>
function lazy<T>(arg0: $Supplier$$Type<(T)>): $Lazy<(T)>
function getSystemTime(): long
function newCountingMap(): $CountingMap
function expiringLazy<T>(arg0: $Supplier$$Type<(T)>, arg1: long): $Lazy<(T)>
function getStat(arg0: $ResourceLocation$$Type): $Stat<($ResourceLocation)>
function runAsync(arg0: $Runnable$$Type): $CompletableFuture<(void)>
function getSound(arg0: $ResourceLocation$$Type): $SoundEvent
function supplyAsync(arg0: $Supplier$$Type<(any)>): $CompletableFuture<(any)>
function getRandom(): $RandomSource
function snakeCaseToTitleCase(arg0: string): string
function snakeCaseToCamelCase(arg0: string): string
function newRandom(arg0: long): $RandomSource
function randomOf(arg0: $Random$$Type, arg1: $Collection$$Type<(any)>): any
function findCreativeTab(arg0: $ResourceLocation$$Type): $CreativeModeTab
const probejs$$marker: never
}
export class $UtilsWrapper$$Static implements $UtilsWrapper {


/**
 * Returns a regex pattern of the input
 */
static "regex"(arg0: any): $Pattern
/**
 * Returns a regex pattern of the input with the specified flags
 */
static "regex"(arg0: string, arg1: integer): $Pattern
/**
 * Get an immutable empty list
 */
static "emptyList"<T>(): $List<(T)>
/**
 * Checks if the passed in object is an instance of WrappedJS
 */
static "isWrapped"(arg0: any): boolean
/**
 * Tries to parse the first parameter as an integer, and returns that. The second parameter is returned if parsing fails
 */
static "parseInt"(arg0: any, arg1: integer): integer
/**
 * Returns a new mutable map
 */
static "newMap"(): $Map<(any), (any)>
/**
 * Capitalises the first letter of the string unless it is "a", "an", "the", "of", "on", "in", "and", "or", "but" or "for"
 */
static "toTitleCase"(arg0: string): string
/**
 * Capitalises the first letter of the string. If ignoreSpecial is true, it will also capitalise articles and prepositions
 */
static "toTitleCase"(arg0: string, arg1: boolean): string
/**
 * Tries to parse the first parameter as a double and returns that. The second parameter is returned if parsing fails
 */
static "parseDouble"(arg0: any, arg1: double): double
/**
 * Get an immutable empty map
 */
static "emptyMap"<K, V>(): $Map<(K), (V)>
/**
 * Returns a new mutable list
 */
static "newList"(): $List<(any)>
/**
 * Returns a lazy value with the supplier function as its value factory
 */
static "lazy"<T>(arg0: $Supplier$$Type<(T)>): $Lazy<(T)>
/**
 * Gets the current system time, in milliseconds
 */
static "getSystemTime"(): long
/**
 * Returns a new counting map
 */
static "newCountingMap"(): $CountingMap
/**
 * Returns a lazy value with the supplier function as its value factory, that will expire after the specified number of milliseconds
 */
static "expiringLazy"<T>(arg0: $Supplier$$Type<(T)>, arg1: long): $Lazy<(T)>
/**
 * Returns a Stat of the passed in ResourceLocation.
 * Note that this requires the same ResourceLocation to get the same stat, so should not be used unless you want to make your own stat, and are storing an actual ResourceLocation somewhere to access it.
 */
static "getStat"(arg0: $ResourceLocation$$Type): $Stat<($ResourceLocation)>
/**
 * Runs the provided runnable function in KubeJS' background thread and returns its CompletableFuture
 */
static "runAsync"(arg0: $Runnable$$Type): $CompletableFuture<(void)>
/**
 * Gets a SoundEvent from the id
 */
static "getSound"(arg0: $ResourceLocation$$Type): $SoundEvent
/**
 * Runs the provided supplier function in KubeJS' background thread and returns its CompletableFuture
 */
static "supplyAsync"(arg0: $Supplier$$Type<(any)>): $CompletableFuture<(any)>
/**
 * Get a Random, for generating random numbers. Note this will always return the same Random instance
 */
static "getRandom"(): $RandomSource
/**
 * Returns the provided snake_case_string in Title Case
 */
static "snakeCaseToTitleCase"(arg0: string): string
/**
 * Returns the provided snake_case_string in camelCase
 */
static "snakeCaseToCamelCase"(arg0: string): string
/**
 * Get a new random with the specified seed
 */
static "newRandom"(arg0: long): $RandomSource
/**
 * Gets a random object from the list using the passed in random
 */
static "randomOf"(arg0: $Random$$Type, arg1: $Collection$$Type<(any)>): any
/**
 * Returns the creative tab associated with the id
 */
static "findCreativeTab"(arg0: $ResourceLocation$$Type): $CreativeModeTab
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UtilsWrapper$$Type = ($UtilsWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UtilsWrapper_ = $UtilsWrapper$$Type;
}}
declare module "dev.latvian.mods.rhino.WrappedExecutable" {
import {$Executable, $Executable$$Type} from "java.lang.reflect.Executable"
import {$Type, $Type$$Type} from "java.lang.reflect.Type"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"

export interface $WrappedExecutable {

 "invoke"(arg1: $Scriptable$$Type, arg2: any, arg3: (any)[]): any
 "getReturnType"(): $Class<(any)>
 "isStatic"(): boolean
 "getGenericReturnType"(): $Type
 "unwrap"(): $Executable
 "construct"(scope: $Scriptable$$Type, args: (any)[]): any

(arg1: $Scriptable, arg2: any, arg3: (any)[]): any
get "returnType"(): $Class<(any)>
get "static"(): boolean
get "genericReturnType"(): $Type
}

export namespace $WrappedExecutable {
const probejs$$marker: never
}
export class $WrappedExecutable$$Static implements $WrappedExecutable {


 "invoke"(arg1: $Scriptable$$Type, arg2: any, arg3: (any)[]): any
 "getReturnType"(): $Class<(any)>
 "isStatic"(): boolean
 "getGenericReturnType"(): $Type
 "unwrap"(): $Executable
 "construct"(scope: $Scriptable$$Type, args: (any)[]): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedExecutable$$Type = ((arg1: $Scriptable, arg2: any, arg3: (any)[]) => any);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedExecutable_ = $WrappedExecutable$$Type;
}}
declare module "dev.latvian.mods.kubejs.player.PlayerClonedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player respawns.
 * 
 * The reason of respawn can be either death or returning from the end.
 */
export class $PlayerClonedKubeEvent implements $KubePlayerEvent {

constructor(arg0: $ServerPlayer$$Type, arg1: $ServerPlayer$$Type, arg2: boolean)

/**
 * Gets the player that respawned.
 */
public "getEntity"(): $Entity
/**
 * Gets the player that was before respawn. Note that this entity is already removed from the world.
 */
public "getOldPlayer"(): $ServerPlayer
/**
 * Gets whether the player's data was kept, e.g. when returning from the end.
 */
public "getKeepData"(): boolean
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "entity"(): $Entity
get "oldPlayer"(): $ServerPlayer
get "keepData"(): boolean
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerClonedKubeEvent$$Type = ($PlayerClonedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerClonedKubeEvent_ = $PlayerClonedKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.DataSenderKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"

export interface $DataSenderKJS {

 "sendData"(arg0: string, arg1: $CompoundTag$$Type): void
 "sendData"(arg0: string): void
}

export namespace $DataSenderKJS {
const probejs$$marker: never
}
export class $DataSenderKJS$$Static implements $DataSenderKJS {


 "sendData"(arg0: string, arg1: $CompoundTag$$Type): void
 "sendData"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataSenderKJS$$Type = ($DataSenderKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataSenderKJS_ = $DataSenderKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ItemData$DataComponentSubtypes, $ItemData$DataComponentSubtypes$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$DataComponentSubtypes"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$ItemData$Info, $ItemData$Info$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Info"
import {$ItemData$Group, $ItemData$Group$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Group"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $ItemData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData)>

constructor(addedEntries: $List$$Type<($ItemStack$$Type)>, removedEntries: $List$$Type<($Ingredient$$Type)>, completelyRemovedEntries: $List$$Type<($Ingredient$$Type)>, groupedEntries: $List$$Type<($ItemData$Group$$Type)>, info: $List$$Type<($ItemData$Info$$Type)>, dataComponentSubtypes: $List$$Type<($ItemData$DataComponentSubtypes$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "collect"(): $ItemData
public "info"(): $List<($ItemData$Info)>
public "completelyRemovedEntries"(): $List<($Ingredient)>
public "dataComponentSubtypes"(): $List<($ItemData$DataComponentSubtypes)>
public "addedEntries"(): $List<($ItemStack)>
public "removedEntries"(): $List<($Ingredient)>
public "groupedEntries"(): $List<($ItemData$Group)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$$Type = ({"addedEntries"?: $List$$Type<($ItemStack$$Type)>, "dataComponentSubtypes"?: $List$$Type<($ItemData$DataComponentSubtypes$$Type)>, "removedEntries"?: $List$$Type<($Ingredient$$Type)>, "groupedEntries"?: $List$$Type<($ItemData$Group$$Type)>, "completelyRemovedEntries"?: $List$$Type<($Ingredient$$Type)>, "info"?: $List$$Type<($ItemData$Info$$Type)>}) | ([addedEntries?: $List$$Type<($ItemStack$$Type)>, dataComponentSubtypes?: $List$$Type<($ItemData$DataComponentSubtypes$$Type)>, removedEntries?: $List$$Type<($Ingredient$$Type)>, groupedEntries?: $List$$Type<($ItemData$Group$$Type)>, completelyRemovedEntries?: $List$$Type<($Ingredient$$Type)>, info?: $List$$Type<($ItemData$Info$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemData_ = $ItemData$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.ItemFrameEntityKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$EntityKJS, $EntityKJS$$Type} from "dev.latvian.mods.kubejs.core.EntityKJS"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$RayTraceResultJS, $RayTraceResultJS$$Type} from "dev.latvian.mods.kubejs.entity.RayTraceResultJS"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"

export interface $ItemFrameEntityKJS extends $EntityKJS {

 "self"(): $Entity
 "getItem"(): $ItemStack
 "isFrame"(): boolean
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "spawn"(): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isPlayer"(): boolean
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "getProfile"(): $GameProfile
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "isLiving"(): boolean
 "getScriptType"(): $ScriptType
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
get "item"(): $ItemStack
get "frame"(): boolean
set "nbt"(value: $CompoundTag$$Type)
get "nbt"(): $CompoundTag
set "y"(value: double)
set "x"(value: double)
set "z"(value: double)
get "name"(): $Component
get "displayName"(): $Component
get "passengers"(): $EntityArrayList
get "server"(): $MinecraftServer
get "type"(): string
set "position"(value: $BlockContainerJS$$Type)
get "player"(): boolean
get "monster"(): boolean
set "motionX"(value: double)
get "level"(): $Level
get "profile"(): $GameProfile
set "motionY"(value: double)
get "motionX"(): double
set "motionZ"(value: double)
get "block"(): $BlockContainerJS
get "living"(): boolean
get "scriptType"(): $ScriptType
get "motionY"(): double
get "motionZ"(): double
get "teamId"(): string
get "facing"(): $Direction
get "animal"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export namespace $ItemFrameEntityKJS {
const probejs$$marker: never
}
export class $ItemFrameEntityKJS$$Static implements $ItemFrameEntityKJS {


 "self"(): $Entity
 "getItem"(): $ItemStack
 "isFrame"(): boolean
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "spawn"(): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isPlayer"(): boolean
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "getProfile"(): $GameProfile
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "isLiving"(): boolean
 "getScriptType"(): $ScriptType
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFrameEntityKJS$$Type = ($ItemFrameEntityKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFrameEntityKJS_ = $ItemFrameEntityKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$FluidData$Group, $FluidData$Group$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Group"
import {$FluidData$Info, $FluidData$Info$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Info"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$FluidData$DataComponentSubtypes, $FluidData$DataComponentSubtypes$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$DataComponentSubtypes"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $FluidData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData)>

constructor(addedEntries: $List$$Type<($FluidStack$$Type)>, removedEntries: $List$$Type<($FluidIngredient$$Type)>, completelyRemovedEntries: $List$$Type<($FluidIngredient$$Type)>, groupedEntries: $List$$Type<($FluidData$Group$$Type)>, info: $List$$Type<($FluidData$Info$$Type)>, dataComponentSubtypes: $List$$Type<($FluidData$DataComponentSubtypes$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "collect"(): $FluidData
public "info"(): $List<($FluidData$Info)>
public "completelyRemovedEntries"(): $List<($FluidIngredient)>
public "dataComponentSubtypes"(): $List<($FluidData$DataComponentSubtypes)>
public "addedEntries"(): $List<($FluidStack)>
public "removedEntries"(): $List<($FluidIngredient)>
public "groupedEntries"(): $List<($FluidData$Group)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$$Type = ({"addedEntries"?: $List$$Type<($FluidStack$$Type)>, "dataComponentSubtypes"?: $List$$Type<($FluidData$DataComponentSubtypes$$Type)>, "removedEntries"?: $List$$Type<($FluidIngredient$$Type)>, "groupedEntries"?: $List$$Type<($FluidData$Group$$Type)>, "completelyRemovedEntries"?: $List$$Type<($FluidIngredient$$Type)>, "info"?: $List$$Type<($FluidData$Info$$Type)>}) | ([addedEntries?: $List$$Type<($FluidStack$$Type)>, dataComponentSubtypes?: $List$$Type<($FluidData$DataComponentSubtypes$$Type)>, removedEntries?: $List$$Type<($FluidIngredient$$Type)>, groupedEntries?: $List$$Type<($FluidData$Group$$Type)>, completelyRemovedEntries?: $List$$Type<($FluidIngredient$$Type)>, info?: $List$$Type<($FluidData$Info$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidData_ = $FluidData$$Type;
}}
declare module "dev.latvian.mods.rhino.JavaMembers$MethodInfo" {
import {$Method, $Method$$Type} from "java.lang.reflect.Method"

export class $JavaMembers$MethodInfo {
 "method": $Method
 "name": string
 "hidden": boolean

constructor(m: $Method$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaMembers$MethodInfo$$Type = ($JavaMembers$MethodInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaMembers$MethodInfo_ = $JavaMembers$MethodInfo$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.RotationAxis" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Vector3f, $Vector3f$$Type} from "org.joml.Vector3f"
import {$Quaternionf, $Quaternionf$$Type} from "org.joml.Quaternionf"

export class $RotationAxis extends $Enum<($RotationAxis)> {
static readonly "XN": $RotationAxis
static readonly "XP": $RotationAxis
static readonly "YN": $RotationAxis
static readonly "YP": $RotationAxis
static readonly "ZN": $RotationAxis
static readonly "ZP": $RotationAxis
readonly "vec": $Vector3f


public static "values"(): ($RotationAxis)[]
public static "valueOf"(arg0: string): $RotationAxis
public "rad"(arg0: float): $Quaternionf
public "deg"(arg0: float): $Quaternionf
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotationAxis$$Type = (("xn") | ("xp") | ("yn") | ("yp") | ("zn") | ("zp"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RotationAxis_ = $RotationAxis$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.WindowKJS" {
import {$List, $List$$Type} from "java.util.List"
import {$IoSupplier, $IoSupplier$$Type} from "net.minecraft.server.packs.resources.IoSupplier"
import {$InputStream, $InputStream$$Type} from "java.io.InputStream"

export interface $WindowKJS {

 "kjs$loadIcons"(arg0: $List$$Type<($IoSupplier$$Type<($InputStream$$Type)>)>): $List<($IoSupplier<($InputStream)>)>
}

export namespace $WindowKJS {
const probejs$$marker: never
}
export class $WindowKJS$$Static implements $WindowKJS {


 "kjs$loadIcons"(arg0: $List$$Type<($IoSupplier$$Type<($InputStream$$Type)>)>): $List<($IoSupplier<($InputStream)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindowKJS$$Type = ($WindowKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WindowKJS_ = $WindowKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.FluidStackKJS" {
import {$ComponentFunctions, $ComponentFunctions$$Type} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Potion, $Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$MutableDataComponentHolder, $MutableDataComponentHolder$$Type} from "net.neoforged.neoforge.common.MutableDataComponentHolder"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$ItemAttributeModifiers$Entry, $ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$FluidMatch, $FluidMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.FluidMatch"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$RelativeURL, $RelativeURL$$Type} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Replaceable, $Replaceable$$Type} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$MutableDataComponentHolderFunctions, $MutableDataComponentHolderFunctions$$Type} from "dev.latvian.mods.kubejs.component.MutableDataComponentHolderFunctions"
import {$SpecialEquality, $SpecialEquality$$Type} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$FluidLike, $FluidLike$$Type} from "dev.latvian.mods.kubejs.fluid.FluidLike"
import {$PotionContents, $PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$RegistryObjectKJS, $RegistryObjectKJS$$Type} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$WithCodec, $WithCodec$$Type} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$Rarity, $Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Unit, $Unit$$Type} from "net.minecraft.util.Unit"

export interface $FluidStackKJS extends $Replaceable, $SpecialEquality, $WithCodec, $FluidLike, $FluidMatch, $MutableDataComponentHolderFunctions, $RegistryObjectKJS<($Fluid)> {

 "matches"(arg1: $FluidStack$$Type, arg2: boolean): boolean
 "matches"(arg1: $FluidIngredient$$Type, arg2: boolean): boolean
 "getCodec"(): $Codec<(any)>
 "getId"(): string
 "getKey"(): $ResourceKey<($Fluid)>
 "kjs$self"(): $FluidStack
 "getMod"(): string
 "isEmpty"(): boolean
 "specialEquals"(arg1: any, arg2: boolean): boolean
 "getFluid"(): $Fluid
 "getAmount"(): integer
 "asHolder"(): $Holder<($Fluid)>
 "getIdLocation"(): $ResourceLocation
 "replaceThisWith"(arg1: any): any
 "getRegistry"(): $Registry<($Fluid)>
 "getRegistryId"(): $ResourceKey<($Registry<($Fluid)>)>
 "kjs$getWebIconURL"(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: integer): $RelativeURL
 "copy"(arg0: integer): $FluidLike
 "kjs$equalsIgnoringCount"(arg0: $FluidStack$$Type): boolean
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
 "set"(arg1: $DataComponentMap$$Type): $MutableDataComponentHolderFunctions
 "patch"(arg1: $DataComponentPatch$$Type): $ComponentFunctions
 "getComponentHolder"(): $MutableDataComponentHolder
 "getComponentMap"(): $DataComponentMap
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "getTags"(): $Collection<($ResourceLocation)>
 "setAttributeModifiersWithTooltip"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
 "setUnit"(arg0: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "setLockCode"(arg0: string): void
 "setCustomData"(arg0: $CompoundTag$$Type): void
 "setRarity"(arg0: $Rarity$$Type): void
 "setCustomName"(arg0: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(arg0: $List$$Type<($Component$$Type)>): void
 "setLore"(arg0: $List$$Type<($Component$$Type)>, arg1: $List$$Type<($Component$$Type)>): void
 "setDyedColor"(arg0: $KubeColor$$Type): void
 "getCustomData"(): $CompoundTag
 "setPotionId"(arg0: $Holder$$Type<($Potion)>): void
 "setEntityData"(arg0: $CompoundTag$$Type): void
 "setProfile"(arg0: $GameProfile$$Type): void
 "setProfile"(arg0: string, arg1: $UUID$$Type): void
 "setBaseColor"(arg0: $DyeColor$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(arg0: $Map$$Type<(string), (string)>): void
 "setDyedColorWithTooltip"(arg0: $KubeColor$$Type): void
 "set"(arg1: $DataComponentType$$Type<(any)>, arg2: any): $ComponentFunctions
 "get"<T>(arg0: $DataComponentType$$Type<(T)>): T
 "remove"(arg0: $DataComponentType$$Type<(any)>): $ComponentFunctions
 "setPotionContents"(arg0: $PotionContents$$Type): void
 "setGlintOverride"(arg0: boolean): void
 "getComponentString"(): string
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
 "setTooltipHidden"(): void
 "setCustomModelData"(arg0: integer): void
 "resetComponents"(): $ComponentFunctions
 "setAttributeModifiers"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
get "codec"(): $Codec<(any)>
get "id"(): string
get "key"(): $ResourceKey<($Fluid)>
get "mod"(): string
get "empty"(): boolean
get "fluid"(): $Fluid
get "amount"(): integer
get "idLocation"(): $ResourceLocation
get "registry"(): $Registry<($Fluid)>
get "registryId"(): $ResourceKey<($Registry<($Fluid)>)>
get "componentHolder"(): $MutableDataComponentHolder
get "componentMap"(): $DataComponentMap
get "tags"(): $Collection<($ResourceLocation)>
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
set "lockCode"(value: string)
set "customData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "customName"(value: $Component$$Type)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "dyedColor"(value: $KubeColor$$Type)
get "customData"(): $CompoundTag
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(string), (string)>)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
set "glintOverride"(value: boolean)
get "componentString"(): string
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
set "customModelData"(value: integer)
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
}

export namespace $FluidStackKJS {
function checkSpecialEquality(o: any, o1: any, shallow: boolean): boolean
function wrap(arg1: any): $ReplacementMatch
const probejs$$marker: never
}
export class $FluidStackKJS$$Static implements $FluidStackKJS {


 "matches"(arg1: $FluidStack$$Type, arg2: boolean): boolean
 "matches"(arg1: $FluidIngredient$$Type, arg2: boolean): boolean
 "getCodec"(): $Codec<(any)>
 "getId"(): string
 "getKey"(): $ResourceKey<($Fluid)>
 "kjs$self"(): $FluidStack
 "getMod"(): string
 "isEmpty"(): boolean
 "specialEquals"(arg1: any, arg2: boolean): boolean
 "getFluid"(): $Fluid
 "getAmount"(): integer
 "asHolder"(): $Holder<($Fluid)>
 "getIdLocation"(): $ResourceLocation
 "replaceThisWith"(arg1: any): any
 "getRegistry"(): $Registry<($Fluid)>
 "getRegistryId"(): $ResourceKey<($Registry<($Fluid)>)>
 "kjs$getWebIconURL"(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: integer): $RelativeURL
 "copy"(arg0: integer): $FluidLike
 "kjs$equalsIgnoringCount"(arg0: $FluidStack$$Type): boolean
static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
 "set"(arg1: $DataComponentMap$$Type): $MutableDataComponentHolderFunctions
 "patch"(arg1: $DataComponentPatch$$Type): $ComponentFunctions
 "getComponentHolder"(): $MutableDataComponentHolder
 "getComponentMap"(): $DataComponentMap
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "getTags"(): $Collection<($ResourceLocation)>
static "wrap"(arg1: any): $ReplacementMatch
 "setAttributeModifiersWithTooltip"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
 "setUnit"(arg0: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "setLockCode"(arg0: string): void
 "setCustomData"(arg0: $CompoundTag$$Type): void
 "setRarity"(arg0: $Rarity$$Type): void
 "setCustomName"(arg0: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(arg0: $List$$Type<($Component$$Type)>): void
 "setLore"(arg0: $List$$Type<($Component$$Type)>, arg1: $List$$Type<($Component$$Type)>): void
 "setDyedColor"(arg0: $KubeColor$$Type): void
 "getCustomData"(): $CompoundTag
 "setPotionId"(arg0: $Holder$$Type<($Potion)>): void
 "setEntityData"(arg0: $CompoundTag$$Type): void
 "setProfile"(arg0: $GameProfile$$Type): void
 "setProfile"(arg0: string, arg1: $UUID$$Type): void
 "setBaseColor"(arg0: $DyeColor$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(arg0: $Map$$Type<(string), (string)>): void
 "setDyedColorWithTooltip"(arg0: $KubeColor$$Type): void
 "set"(arg1: $DataComponentType$$Type<(any)>, arg2: any): $ComponentFunctions
 "get"<T>(arg0: $DataComponentType$$Type<(T)>): T
 "remove"(arg0: $DataComponentType$$Type<(any)>): $ComponentFunctions
 "setPotionContents"(arg0: $PotionContents$$Type): void
 "setGlintOverride"(arg0: boolean): void
 "getComponentString"(): string
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
 "setTooltipHidden"(): void
 "setCustomModelData"(arg0: integer): void
 "resetComponents"(): $ComponentFunctions
 "setAttributeModifiers"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidStackKJS$$Type = ($FluidStackKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidStackKJS_ = $FluidStackKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.mixin.RecipeInputMixin" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$List, $List$$Type} from "java.util.List"
import {$SlotFilter, $SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"
import {$RecipeInputKJS, $RecipeInputKJS$$Type} from "dev.latvian.mods.kubejs.core.RecipeInputKJS"

export interface $RecipeInputMixin extends $RecipeInputKJS {

 "find"(arg0: $SlotFilter$$Type): $ItemStack
 "find"(arg0: $SlotFilter$$Type, arg1: integer): $ItemStack
 "self"(): $RecipeInput
 "findAll"(arg0: $SlotFilter$$Type): $List<($ItemStack)>
 "findAll"(): $List<($ItemStack)>
}

export namespace $RecipeInputMixin {
const probejs$$marker: never
}
export class $RecipeInputMixin$$Static implements $RecipeInputMixin {


 "find"(arg0: $SlotFilter$$Type): $ItemStack
 "find"(arg0: $SlotFilter$$Type, arg1: integer): $ItemStack
 "self"(): $RecipeInput
 "findAll"(arg0: $SlotFilter$$Type): $List<($ItemStack)>
 "findAll"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeInputMixin$$Type = ($RecipeInputMixin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeInputMixin_ = $RecipeInputMixin$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecordTypeInfo, $RecordTypeInfo$$Type} from "dev.latvian.mods.rhino.type.RecordTypeInfo"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $ReplacementMatchInfo extends $Record {
static readonly "TYPE_INFO": $RecordTypeInfo
static readonly "NONE": $ReplacementMatchInfo

constructor(match: $ReplacementMatch$$Type, exact: boolean, componentType: $Optional$$Type<($RecipeComponent$$Type<(any)>)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "componentType"(): $Optional<($RecipeComponent<(any)>)>
public static "wrap"(arg1: any, arg2: $TypeInfo$$Type): $ReplacementMatchInfo
public "match"(): $ReplacementMatch
public "exact"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplacementMatchInfo$$Type = ({"componentType"?: ($RecipeComponent$$Type<(never)>)?, "exact"?: boolean, "match"?: $ReplacementMatch$$Type}) | ([componentType?: ($RecipeComponent$$Type<(never)>)?, exact?: boolean, match?: $ReplacementMatch$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReplacementMatchInfo_ = $ReplacementMatchInfo$$Type;
}}
declare module "dev.latvian.mods.kubejs.player.SimplePlayerKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $SimplePlayerKubeEvent implements $KubePlayerEvent {

constructor(arg0: $Player$$Type)

public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimplePlayerKubeEvent$$Type = ($SimplePlayerKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimplePlayerKubeEvent_ = $SimplePlayerKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.registry.ServerRegistryKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$CustomBuilderObject, $CustomBuilderObject$$Type} from "dev.latvian.mods.kubejs.registry.CustomBuilderObject"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"

export class $ServerRegistryKubeEvent<T> implements $KubeEvent {
readonly "registryKey": $ResourceKey<($Registry<(T)>)>
readonly "jsonOps": $DynamicOps<($JsonElement)>
readonly "codec": $Codec<(T)>

constructor(arg0: $ResourceKey$$Type<($Registry<(T)>)>, arg1: $DynamicOps$$Type<($JsonElement$$Type)>, arg2: $Codec$$Type<(T)>, arg3: $List$$Type<($BuilderBase$$Type<(any)>)>)

public "create"(arg1: $ResourceLocation$$Type): $BuilderBase<(T)>
public "create"(arg1: $ResourceLocation$$Type, arg2: string): $BuilderBase<(T)>
public "createFromJson"(arg1: $ResourceLocation$$Type, arg2: $JsonElement$$Type): $CustomBuilderObject
public "createCustom"(arg1: $ResourceLocation$$Type, arg2: $Supplier$$Type<(any)>): $CustomBuilderObject
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerRegistryKubeEvent$$Type<T> = ($ServerRegistryKubeEvent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerRegistryKubeEvent_<T> = $ServerRegistryKubeEvent$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.client.EntityRendererRegistryKubeEvent" {
import {$ClientKubeEvent, $ClientKubeEvent$$Type} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$EntityRenderersEvent$RegisterRenderers, $EntityRenderersEvent$RegisterRenderers$$Type} from "net.neoforged.neoforge.client.event.EntityRenderersEvent$RegisterRenderers"
import {$Minecraft, $Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$EntityRendererProvider, $EntityRendererProvider$$Type} from "net.minecraft.client.renderer.entity.EntityRendererProvider"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $EntityRendererRegistryKubeEvent implements $ClientKubeEvent {

constructor(arg0: $EntityRenderersEvent$RegisterRenderers$$Type)

public "register"(arg0: $EntityType$$Type<(any)>, arg1: $EntityRendererProvider$$Type<(any)>): void
public "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityRendererRegistryKubeEvent$$Type = ($EntityRendererRegistryKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityRendererRegistryKubeEvent_ = $EntityRendererRegistryKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemModelPropertiesKubeEvent" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeStartupEvent, $KubeStartupEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeStartupEvent"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$ClampedItemPropertyFunction, $ClampedItemPropertyFunction$$Type} from "net.minecraft.client.renderer.item.ClampedItemPropertyFunction"

export class $ItemModelPropertiesKubeEvent implements $KubeStartupEvent {

constructor()

/**
 * Register a model property for an item. Model properties are used to change the appearance of an item in the world.
 * 
 * More about model properties: https://minecraft.wiki/w/Tutorials/Models#Item_predicates
 */
public "register"(arg0: $Ingredient$$Type, arg1: $ResourceLocation$$Type, arg2: $ClampedItemPropertyFunction$$Type): void
/**
 * Register a model property for all items.
 */
public "registerAll"(arg0: $ResourceLocation$$Type, arg1: $ClampedItemPropertyFunction$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModelPropertiesKubeEvent$$Type = ($ItemModelPropertiesKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemModelPropertiesKubeEvent_ = $ItemModelPropertiesKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.level.ExplosionJS" {
import {$Level$ExplosionInteraction, $Level$ExplosionInteraction$$Type} from "net.minecraft.world.level.Level$ExplosionInteraction"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$LevelAccessor, $LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $ExplosionJS {
readonly "x": double
readonly "y": double
readonly "z": double

constructor(arg0: $LevelAccessor$$Type, arg1: double, arg2: double, arg3: double)

public "strength"(arg0: float): $ExplosionJS
public "explode"(): void
public "explosionMode"(arg0: $Level$ExplosionInteraction$$Type): $ExplosionJS
public "exploder"(arg0: $Entity$$Type): $ExplosionJS
public "causesFire"(arg0: boolean): $ExplosionJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionJS$$Type = ($ExplosionJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionJS_ = $ExplosionJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.ScriptType" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$KubeJSFileWatcherThread, $KubeJSFileWatcherThread$$Type} from "dev.latvian.mods.kubejs.script.KubeJSFileWatcherThread"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$NativeEventListeners$Key, $NativeEventListeners$Key$$Type} from "dev.latvian.mods.kubejs.neoforge.NativeEventListeners$Key"
import {$Lazy, $Lazy$$Type} from "dev.latvian.mods.kubejs.util.Lazy"
import {$NativeEventListeners, $NativeEventListeners$$Type} from "dev.latvian.mods.kubejs.neoforge.NativeEventListeners"
import {$ScriptTypeHolder, $ScriptTypeHolder$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$ScriptTypePredicate, $ScriptTypePredicate$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$ConsoleJS, $ConsoleJS$$Type} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$ClassFilter, $ClassFilter$$Type} from "dev.latvian.mods.kubejs.plugin.ClassFilter"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptType extends $Enum<($ScriptType)> implements $ScriptTypePredicate, $ScriptTypeHolder {
static readonly "STARTUP": $ScriptType
static readonly "SERVER": $ScriptType
static readonly "CLIENT": $ScriptType
static readonly "VALUES": ($ScriptType)[]
readonly "console": $ConsoleJS
readonly "path": $Path
readonly "nameStrip": string
readonly "classFilter": $Lazy<($ClassFilter)>
readonly "nativeEventListeners": $Map<($NativeEventListeners$Key), ($NativeEventListeners)>
 "fileWatcherThread": $KubeJSFileWatcherThread


public static "values"(): ($ScriptType)[]
public "test"(arg0: any): boolean
public "test"(arg0: $ScriptType$$Type): boolean
public static "valueOf"(arg0: string): $ScriptType
public "negate"(): $ScriptTypePredicate
public "isClient"(): boolean
public "getValidTypes"(): $List<($ScriptType)>
public "kjs$getScriptType"(): $ScriptType
public "getLogFile"(): $Path
public "isServer"(): boolean
public "isStartup"(): boolean
public "or"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
public "and"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
public static "not"<T>(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
public static "isEqual"<T>(arg0: any): $Predicate<($ScriptType)>
get "client"(): boolean
get "validTypes"(): $List<($ScriptType)>
get "logFile"(): $Path
get "server"(): boolean
get "startup"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptType$$Type = (("startup") | ("server") | ("client"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptType_ = $ScriptType$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.SourceLine" {
import {$FriendlyByteBuf, $FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$Record, $Record$$Type} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $SourceLine extends $Record {
static readonly "UNKNOWN": $SourceLine

constructor(source: string, line: integer)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "of"(arg0: string, arg1: integer): $SourceLine
public static "of"(): $SourceLine
public "line"(): integer
public "source"(): string
public static "write"(arg0: $FriendlyByteBuf$$Type, arg1: $SourceLine$$Type): void
public static "read"(arg0: $FriendlyByteBuf$$Type): $SourceLine
public "isUnknown"(): boolean
get "unknown"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SourceLine$$Type = ({"source"?: string, "line"?: integer}) | ([source?: string, line?: integer]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SourceLine_ = $SourceLine$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.ComponentKJS" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$FormattedText, $FormattedText$$Type} from "net.minecraft.network.chat.FormattedText"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$FormattedText$StyledContentConsumer, $FormattedText$StyledContentConsumer$$Type} from "net.minecraft.network.chat.FormattedText$StyledContentConsumer"
import {$Message, $Message$$Type} from "com.mojang.brigadier.Message"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$WrappedJS, $WrappedJS$$Type} from "dev.latvian.mods.kubejs.util.WrappedJS"
import {$ComponentContents, $ComponentContents$$Type} from "net.minecraft.network.chat.ComponentContents"
import {$FormattedText$ContentConsumer, $FormattedText$ContentConsumer$$Type} from "net.minecraft.network.chat.FormattedText$ContentConsumer"
import {$Style, $Style$$Type} from "net.minecraft.network.chat.Style"
import {$WithCodec, $WithCodec$$Type} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$ClickEvent, $ClickEvent$$Type} from "net.minecraft.network.chat.ClickEvent"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$FormattedCharSequence, $FormattedCharSequence$$Type} from "net.minecraft.util.FormattedCharSequence"
import {$URI, $URI$$Type} from "java.net.URI"
import {$MutableComponent, $MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Date, $Date$$Type} from "java.util.Date"
import {$DataSource, $DataSource$$Type} from "net.minecraft.network.chat.contents.DataSource"

export interface $ComponentKJS extends $Component, $WithCodec, $WrappedJS {

 "forEach"(arg0: $Consumer$$Type<($Component)>): void
 "getCodec"(): $Codec<(any)>
 "self"(): $MutableComponent
 "color"(arg0: $KubeColor$$Type): $MutableComponent
 "bold"(): $MutableComponent
 "bold"(arg0: boolean): $MutableComponent
 "italic"(): $MutableComponent
 "italic"(arg0: boolean): $MutableComponent
 "blue"(): $MutableComponent
 "font"(arg0: $ResourceLocation$$Type): $MutableComponent
 "gold"(): $MutableComponent
 "gray"(): $MutableComponent
 "aqua"(): $MutableComponent
 "click"(arg0: $ClickEvent$$Type): $MutableComponent
 "red"(): $MutableComponent
 "yellow"(): $MutableComponent
 "black"(): $MutableComponent
 "green"(): $MutableComponent
 "hover"(arg0: $Component$$Type): $MutableComponent
 "white"(): $MutableComponent
 "clickSuggestCommand"(arg0: string): $MutableComponent
 "clickRunCommand"(arg0: string): $MutableComponent
 "clickChangePage"(arg0: string): $MutableComponent
 "strikethrough"(): $MutableComponent
 "strikethrough"(arg0: boolean): $MutableComponent
 "underlined"(): $MutableComponent
 "underlined"(arg0: boolean): $MutableComponent
 "obfuscated"(arg0: boolean): $MutableComponent
 "obfuscated"(): $MutableComponent
 "asIterable"(): $Iterable<($Component)>
 "clickOpenFile"(arg0: string): $MutableComponent
 "lightPurple"(): $MutableComponent
 "darkBlue"(): $MutableComponent
 "darkGray"(): $MutableComponent
/**
 * 
 * @deprecated
 */
 "rawComponent"(): $MutableComponent
 "hasSiblings"(): boolean
 "darkGreen"(): $MutableComponent
/**
 * 
 * @deprecated
 */
 "rawCopy"(): $MutableComponent
 "darkPurple"(): $MutableComponent
 "clickCopy"(arg0: string): $MutableComponent
/**
 * 
 * @deprecated
 */
 "component"(): $Component
 "insertion"(arg0: string): $MutableComponent
 "darkRed"(): $MutableComponent
 "darkAqua"(): $MutableComponent
 "isEmpty"(): boolean
 "clickOpenUrl"(arg0: string): $MutableComponent
 "hasStyle"(): boolean
 "noColor"(): $MutableComponent
 "contains"(arg0: $Component$$Type): boolean
 "copy"(): $MutableComponent
 "visit"<T>(arg0: $FormattedText$StyledContentConsumer$$Type<(T)>, arg1: $Style$$Type): $Optional<(T)>
 "visit"<T>(arg0: $FormattedText$ContentConsumer$$Type<(T)>): $Optional<(T)>
 "getString"(): string
 "getString"(arg0: integer): string
 "getContents"(): $ComponentContents
 "getStyle"(): $Style
 "tryCollapseToString"(): string
 "plainCopy"(): $MutableComponent
 "toFlatList"(): $List<($Component)>
 "toFlatList"(arg0: $Style$$Type): $List<($Component)>
 "getVisualOrderText"(): $FormattedCharSequence
 "getSiblings"(): $List<($Component)>
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
get "codec"(): $Codec<(any)>
get "string"(): string
get "contents"(): $ComponentContents
get "style"(): $Style
get "visualOrderText"(): $FormattedCharSequence
get "siblings"(): $List<($Component)>
}

export namespace $ComponentKJS {
function empty(): $MutableComponent
function literal(arg0: string): $MutableComponent
function selector(arg0: string, arg1: $Optional$$Type<($Component$$Type)>): $MutableComponent
function score(arg0: string, arg1: string): $MutableComponent
function translatableWithFallback(arg0: string, arg1: string, ...arg2: (any)[]): $MutableComponent
function translatableWithFallback(arg0: string, arg1: string): $MutableComponent
function nbt(arg0: string, arg1: boolean, arg2: $Optional$$Type<($Component$$Type)>, arg3: $DataSource$$Type): $MutableComponent
function keybind(arg0: string): $MutableComponent
function nullToEmpty(arg0: string): $Component
function translatable(arg0: string): $MutableComponent
function translatable(arg0: string, ...arg1: (any)[]): $MutableComponent
function translatableEscape(arg0: string, ...arg1: (any)[]): $MutableComponent
function translationArg(arg0: $URI$$Type): $Component
function translationArg(arg0: $ChunkPos$$Type): $Component
function translationArg(arg0: $ResourceLocation$$Type): $Component
function translationArg(arg0: $Date$$Type): $Component
function translationArg(arg0: $Message$$Type): $Component
function translationArg(arg0: $UUID$$Type): $Component
function of(arg0: string, arg1: $Style$$Type): $FormattedText
function of(arg0: string): $FormattedText
function composite(arg0: $List$$Type<($FormattedText$$Type)>): $FormattedText
function composite(...arg0: ($FormattedText$$Type)[]): $FormattedText
const probejs$$marker: never
}
export class $ComponentKJS$$Static implements $ComponentKJS {


 "forEach"(arg0: $Consumer$$Type<($Component)>): void
 "getCodec"(): $Codec<(any)>
 "self"(): $MutableComponent
 "color"(arg0: $KubeColor$$Type): $MutableComponent
 "bold"(): $MutableComponent
 "bold"(arg0: boolean): $MutableComponent
 "italic"(): $MutableComponent
 "italic"(arg0: boolean): $MutableComponent
 "blue"(): $MutableComponent
 "font"(arg0: $ResourceLocation$$Type): $MutableComponent
 "gold"(): $MutableComponent
 "gray"(): $MutableComponent
 "aqua"(): $MutableComponent
 "click"(arg0: $ClickEvent$$Type): $MutableComponent
 "red"(): $MutableComponent
 "yellow"(): $MutableComponent
 "black"(): $MutableComponent
 "green"(): $MutableComponent
 "hover"(arg0: $Component$$Type): $MutableComponent
 "white"(): $MutableComponent
 "clickSuggestCommand"(arg0: string): $MutableComponent
 "clickRunCommand"(arg0: string): $MutableComponent
 "clickChangePage"(arg0: string): $MutableComponent
 "strikethrough"(): $MutableComponent
 "strikethrough"(arg0: boolean): $MutableComponent
 "underlined"(): $MutableComponent
 "underlined"(arg0: boolean): $MutableComponent
 "obfuscated"(arg0: boolean): $MutableComponent
 "obfuscated"(): $MutableComponent
 "asIterable"(): $Iterable<($Component)>
 "clickOpenFile"(arg0: string): $MutableComponent
 "lightPurple"(): $MutableComponent
 "darkBlue"(): $MutableComponent
 "darkGray"(): $MutableComponent
/**
 * 
 * @deprecated
 */
 "rawComponent"(): $MutableComponent
 "hasSiblings"(): boolean
 "darkGreen"(): $MutableComponent
/**
 * 
 * @deprecated
 */
 "rawCopy"(): $MutableComponent
 "darkPurple"(): $MutableComponent
 "clickCopy"(arg0: string): $MutableComponent
/**
 * 
 * @deprecated
 */
 "component"(): $Component
 "insertion"(arg0: string): $MutableComponent
 "darkRed"(): $MutableComponent
 "darkAqua"(): $MutableComponent
 "isEmpty"(): boolean
 "clickOpenUrl"(arg0: string): $MutableComponent
 "hasStyle"(): boolean
 "noColor"(): $MutableComponent
 "contains"(arg0: $Component$$Type): boolean
static "empty"(): $MutableComponent
 "copy"(): $MutableComponent
static "literal"(arg0: string): $MutableComponent
 "visit"<T>(arg0: $FormattedText$StyledContentConsumer$$Type<(T)>, arg1: $Style$$Type): $Optional<(T)>
 "visit"<T>(arg0: $FormattedText$ContentConsumer$$Type<(T)>): $Optional<(T)>
 "getString"(): string
 "getString"(arg0: integer): string
 "getContents"(): $ComponentContents
static "selector"(arg0: string, arg1: $Optional$$Type<($Component$$Type)>): $MutableComponent
static "score"(arg0: string, arg1: string): $MutableComponent
 "getStyle"(): $Style
 "tryCollapseToString"(): string
static "translatableWithFallback"(arg0: string, arg1: string, ...arg2: (any)[]): $MutableComponent
static "translatableWithFallback"(arg0: string, arg1: string): $MutableComponent
static "nbt"(arg0: string, arg1: boolean, arg2: $Optional$$Type<($Component$$Type)>, arg3: $DataSource$$Type): $MutableComponent
 "plainCopy"(): $MutableComponent
static "keybind"(arg0: string): $MutableComponent
 "toFlatList"(): $List<($Component)>
 "toFlatList"(arg0: $Style$$Type): $List<($Component)>
static "nullToEmpty"(arg0: string): $Component
static "translatable"(arg0: string): $MutableComponent
static "translatable"(arg0: string, ...arg1: (any)[]): $MutableComponent
 "getVisualOrderText"(): $FormattedCharSequence
static "translatableEscape"(arg0: string, ...arg1: (any)[]): $MutableComponent
 "getSiblings"(): $List<($Component)>
static "translationArg"(arg0: $URI$$Type): $Component
static "translationArg"(arg0: $ChunkPos$$Type): $Component
static "translationArg"(arg0: $ResourceLocation$$Type): $Component
static "translationArg"(arg0: $Date$$Type): $Component
static "translationArg"(arg0: $Message$$Type): $Component
static "translationArg"(arg0: $UUID$$Type): $Component
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
static "of"(arg0: string, arg1: $Style$$Type): $FormattedText
static "of"(arg0: string): $FormattedText
static "composite"(arg0: $List$$Type<($FormattedText$$Type)>): $FormattedText
static "composite"(...arg0: ($FormattedText$$Type)[]): $FormattedText
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentKJS$$Type = ($ComponentKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentKJS_ = $ComponentKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.SwordItemBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$HandheldItemBuilder, $HandheldItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.custom.HandheldItemBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $SwordItemBuilder extends $HandheldItemBuilder {
static readonly "SWORD_TAGS": ($ResourceLocation)[]
static readonly "SWORD_MODEL": $ResourceLocation
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SwordItemBuilder$$Type = ($SwordItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SwordItemBuilder_ = $SwordItemBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.HorizontalDirectionalBlockBuilder$WithEntity" {
import {$EntityBlock, $EntityBlock$$Type} from "net.minecraft.world.level.block.EntityBlock"
import {$Map, $Map$$Type} from "java.util.Map"
import {$BlockEntityTicker, $BlockEntityTicker$$Type} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$HorizontalDirectionalBlockBuilder$HorizontalDirectionalBlockJS, $HorizontalDirectionalBlockBuilder$HorizontalDirectionalBlockJS$$Type} from "dev.latvian.mods.kubejs.block.custom.HorizontalDirectionalBlockBuilder$HorizontalDirectionalBlockJS"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$GameEventListener, $GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty, $DirectionProperty$$Type} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HorizontalDirectionalBlockBuilder$WithEntity extends $HorizontalDirectionalBlockBuilder$HorizontalDirectionalBlockJS implements $EntityBlock {
static readonly "FACING": $DirectionProperty
readonly "shapes": $Map<($Direction), ($VoxelShape)>
readonly "blockBuilder": $BlockBuilder
readonly "shape": $VoxelShape
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(arg0: $BlockBuilder$$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HorizontalDirectionalBlockBuilder$WithEntity$$Type = ($HorizontalDirectionalBlockBuilder$WithEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HorizontalDirectionalBlockBuilder$WithEntity_ = $HorizontalDirectionalBlockBuilder$WithEntity$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$HandheldItemBuilder, $HandheldItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.custom.HandheldItemBuilder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem, $DiggerItem$$Type} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder extends $HandheldItemBuilder {
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type, arg1: float, arg2: float, arg3: $BiFunction$$Type<($Tier), ($Item$Properties), ($DiggerItem$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$$Type = ($DiggerItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DiggerItemBuilder_ = $DiggerItemBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.HorizontalDirectionalBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $HorizontalDirectionalBlockBuilder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HorizontalDirectionalBlockBuilder$$Type = ($HorizontalDirectionalBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HorizontalDirectionalBlockBuilder_ = $HorizontalDirectionalBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeTypeFunction, $RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $KubeRecipeFactory extends $Record {
static readonly "DEFAULT": $KubeRecipeFactory

constructor(arg0: $ResourceLocation$$Type, arg1: $Class$$Type<(any)>, arg2: $Supplier$$Type<($KubeRecipe$$Type)>)
constructor(id: $ResourceLocation$$Type, recipeType: $TypeInfo$$Type, factory: $Supplier$$Type<($KubeRecipe$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "factory"(): $Supplier<($KubeRecipe)>
public "id"(): $ResourceLocation
public "create"(arg0: $RecipeTypeFunction$$Type, arg1: $SourceLine$$Type, arg2: boolean): $KubeRecipe
public "recipeType"(): $TypeInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRecipeFactory$$Type = ({"recipeType"?: $TypeInfo$$Type, "factory"?: $Supplier$$Type<($KubeRecipe$$Type)>, "id"?: $ResourceLocation$$Type}) | ([recipeType?: $TypeInfo$$Type, factory?: $Supplier$$Type<($KubeRecipe$$Type)>, id?: $ResourceLocation$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeRecipeFactory_ = $KubeRecipeFactory$$Type;
}}
declare module "dev.latvian.mods.rhino.util.RemappedEnumConstant" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $RemappedEnumConstant {

 "getRemappedEnumConstantName"(): string

(): string
get "remappedEnumConstantName"(): string
}

export namespace $RemappedEnumConstant {
const probejs$$marker: never
}
export class $RemappedEnumConstant$$Static implements $RemappedEnumConstant {


 "getRemappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemappedEnumConstant$$Type = (() => string);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemappedEnumConstant_ = $RemappedEnumConstant$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.HorizontalDirectionalBlockBuilder$HorizontalDirectionalBlockJS" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BasicBlockJS, $BasicBlockJS$$Type} from "dev.latvian.mods.kubejs.block.custom.BasicBlockJS"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$CollisionContext, $CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty, $DirectionProperty$$Type} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HorizontalDirectionalBlockBuilder$HorizontalDirectionalBlockJS extends $BasicBlockJS {
static readonly "FACING": $DirectionProperty
readonly "shapes": $Map<($Direction), ($VoxelShape)>
readonly "blockBuilder": $BlockBuilder
readonly "shape": $VoxelShape
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(arg0: $BlockBuilder$$Type)

/**
 * 
 * @deprecated
 */
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "asHolder"(): $Holder<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HorizontalDirectionalBlockBuilder$HorizontalDirectionalBlockJS$$Type = ($HorizontalDirectionalBlockBuilder$HorizontalDirectionalBlockJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HorizontalDirectionalBlockBuilder$HorizontalDirectionalBlockJS_ = $HorizontalDirectionalBlockBuilder$HorizontalDirectionalBlockJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ItemBuilder, $ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $FluidBlockBuilder extends $BlockBuilder {
readonly "fluidBuilder": $FluidBuilder
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $FluidBuilder$$Type)

public "item"(arg0: $Consumer$$Type<($ItemBuilder)>): $BlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBlockBuilder$$Type = ($FluidBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidBlockBuilder_ = $FluidBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.MinecraftClientKJS" {
import {$ScheduledEvents$Callback, $ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Screen, $Screen$$Type} from "net.minecraft.client.gui.screens.Screen"
import {$ScheduledEvents, $ScheduledEvents$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents"
import {$Minecraft, $Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$TemporalAmount, $TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$KeyMapping, $KeyMapping$$Type} from "net.minecraft.client.KeyMapping"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"
import {$MinecraftEnvironmentKJS, $MinecraftEnvironmentKJS$$Type} from "dev.latvian.mods.kubejs.core.MinecraftEnvironmentKJS"

export interface $MinecraftClientKJS extends $MinecraftEnvironmentKJS {

 "setStatusMessage"(arg0: $Component$$Type): void
 "getCurrentScreen"(): $Screen
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "isKeyMappingDown"(arg0: $KeyMapping$$Type): boolean
 "setCurrentScreen"(arg0: $Screen$$Type): void
 "getCurrentWorldName"(): string
 "tell"(arg0: $Component$$Type): void
 "self"(): $Minecraft
 "getName"(): $Component
 "setTitle"(arg0: string): void
 "isShiftDown"(): boolean
 "getTitle"(): string
 "isKeyDown"(arg0: integer): boolean
 "isCtrlDown"(): boolean
 "runCommand"(arg0: string): void
 "isAltDown"(): boolean
 "scheduleRepeatingInTicks"(arg0: long, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getScheduledEvents"(): $ScheduledEvents
 "scheduleRepeating"(arg0: $TemporalAmount$$Type, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(arg0: long, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "schedule"(arg0: $TemporalAmount$$Type, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getDisplayName"(): $Component

(): $ScheduledEvents$$Type
set "statusMessage"(value: $Component$$Type)
get "currentScreen"(): $Screen
set "activePostShader"(value: $ResourceLocation$$Type)
set "currentScreen"(value: $Screen$$Type)
get "currentWorldName"(): string
get "name"(): $Component
set "title"(value: string)
get "shiftDown"(): boolean
get "title"(): string
get "ctrlDown"(): boolean
get "altDown"(): boolean
get "scheduledEvents"(): $ScheduledEvents
get "displayName"(): $Component
}

export namespace $MinecraftClientKJS {
const probejs$$marker: never
}
export class $MinecraftClientKJS$$Static implements $MinecraftClientKJS {


 "setStatusMessage"(arg0: $Component$$Type): void
 "getCurrentScreen"(): $Screen
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "isKeyMappingDown"(arg0: $KeyMapping$$Type): boolean
 "setCurrentScreen"(arg0: $Screen$$Type): void
 "getCurrentWorldName"(): string
 "tell"(arg0: $Component$$Type): void
 "self"(): $Minecraft
 "getName"(): $Component
 "setTitle"(arg0: string): void
 "isShiftDown"(): boolean
 "getTitle"(): string
 "isKeyDown"(arg0: integer): boolean
 "isCtrlDown"(): boolean
 "runCommand"(arg0: string): void
 "isAltDown"(): boolean
 "scheduleRepeatingInTicks"(arg0: long, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getScheduledEvents"(): $ScheduledEvents
 "scheduleRepeating"(arg0: $TemporalAmount$$Type, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(arg0: long, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "schedule"(arg0: $TemporalAmount$$Type, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftClientKJS$$Type = (() => $ScheduledEvents$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MinecraftClientKJS_ = $MinecraftClientKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.ClientPacketListenerKJS" {
import {$KubeSessionData, $KubeSessionData$$Type} from "dev.latvian.mods.kubejs.client.KubeSessionData"

export interface $ClientPacketListenerKJS {

 "kjs$sessionData"(): $KubeSessionData
}

export namespace $ClientPacketListenerKJS {
const probejs$$marker: never
}
export class $ClientPacketListenerKJS$$Static implements $ClientPacketListenerKJS {


 "kjs$sessionData"(): $KubeSessionData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPacketListenerKJS$$Type = ($ClientPacketListenerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientPacketListenerKJS_ = $ClientPacketListenerKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Boots" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder, $ArmorItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ArmorItemBuilder$Boots extends $ArmorItemBuilder {
static readonly "BOOT_TAGS": ($ResourceLocation)[]
readonly "armorType": $ArmorItem$Type
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Boots$$Type = ($ArmorItemBuilder$Boots);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorItemBuilder$Boots_ = $ArmorItemBuilder$Boots$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentType" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Lazy, $Lazy$$Type} from "dev.latvian.mods.kubejs.util.Lazy"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $BlockEntityAttachmentType extends $Record {
static readonly "ALL": $Lazy<($Map<(string), ($BlockEntityAttachmentType)>)>

constructor(arg0: string, arg1: $Class$$Type<(any)>)
constructor(name: string, typeInfo: $TypeInfo$$Type)

public "name"(): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "typeInfo"(): $TypeInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentType$$Type = ({"name"?: string, "typeInfo"?: $TypeInfo$$Type}) | ([name?: string, typeInfo?: $TypeInfo$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityAttachmentType_ = $BlockEntityAttachmentType$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.RandomTickCallbackJS" {
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $RandomTickCallbackJS {
 "block": $BlockContainerJS
 "random": $RandomSource

constructor(arg0: $BlockContainerJS$$Type, arg1: $RandomSource$$Type)

public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
get "level"(): $Level
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomTickCallbackJS$$Type = ($RandomTickCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RandomTickCallbackJS_ = $RandomTickCallbackJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.misc.MobEffectBuilder$EffectEntityCallback" {
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export interface $MobEffectBuilder$EffectEntityCallback {

 "applyEffectTick"(arg0: $LivingEntity$$Type, arg1: integer): void

(arg0: $LivingEntity, arg1: integer): void
}

export namespace $MobEffectBuilder$EffectEntityCallback {
const probejs$$marker: never
}
export class $MobEffectBuilder$EffectEntityCallback$$Static implements $MobEffectBuilder$EffectEntityCallback {


 "applyEffectTick"(arg0: $LivingEntity$$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectBuilder$EffectEntityCallback$$Type = ((arg0: $LivingEntity, arg1: integer) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobEffectBuilder$EffectEntityCallback_ = $MobEffectBuilder$EffectEntityCallback$$Type;
}}
declare module "dev.latvian.mods.rhino.util.DefaultValueTypeHint" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $DefaultValueTypeHint extends $Enum<($DefaultValueTypeHint)> {
static readonly "STRING": $DefaultValueTypeHint
static readonly "NUMBER": $DefaultValueTypeHint
static readonly "BOOLEAN": $DefaultValueTypeHint
static readonly "FUNCTION": $DefaultValueTypeHint
static readonly "CLASS": $DefaultValueTypeHint


public "toString"(): string
public static "values"(): ($DefaultValueTypeHint)[]
public static "valueOf"(name: string): $DefaultValueTypeHint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultValueTypeHint$$Type = (("string") | ("number") | ("boolean") | ("function") | ("class"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultValueTypeHint_ = $DefaultValueTypeHint$$Type;
}}
declare module "dev.latvian.mods.kubejs.entity.LivingEntityDeathKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent, $KubeLivingEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked before a living entity dies.
 * 
 * **NOTE**: You need to set hp to > 0 besides cancelling the event to prevent the entity from dying.
 */
export class $LivingEntityDeathKubeEvent implements $KubeLivingEntityEvent {

constructor(arg0: $LivingEntity$$Type, arg1: $DamageSource$$Type)

/**
 * The damage source that triggers the death.
 */
public "getSource"(): $DamageSource
/**
 * The entity that dies.
 */
public "getEntity"(): $LivingEntity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "source"(): $DamageSource
get "entity"(): $LivingEntity
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityDeathKubeEvent$$Type = ($LivingEntityDeathKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEntityDeathKubeEvent_ = $LivingEntityDeathKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.RecipeLikeKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeSerializer, $RecipeSerializer$$Type} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$ReplacementMatchInfo, $ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"

export interface $RecipeLikeKJS {

 "hasOutput"(arg1: $ReplacementMatchInfo$$Type): boolean
 "kjs$setGroup"(arg0: string): void
 "replaceInput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "kjs$getSerializer"(): $RecipeSerializer<(any)>
 "kjs$getGroup"(): string
 "kjs$getOrCreateId"(): $ResourceLocation
 "kjs$getSchema"(): $RecipeSchema
 "replaceOutput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "kjs$getMod"(): string
 "kjs$getType"(): $ResourceLocation
 "hasInput"(arg1: $ReplacementMatchInfo$$Type): boolean
}

export namespace $RecipeLikeKJS {
const probejs$$marker: never
}
export class $RecipeLikeKJS$$Static implements $RecipeLikeKJS {


 "hasOutput"(arg1: $ReplacementMatchInfo$$Type): boolean
 "kjs$setGroup"(arg0: string): void
 "replaceInput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "kjs$getSerializer"(): $RecipeSerializer<(any)>
 "kjs$getGroup"(): string
 "kjs$getOrCreateId"(): $ResourceLocation
 "kjs$getSchema"(): $RecipeSchema
 "replaceOutput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "kjs$getMod"(): string
 "kjs$getType"(): $ResourceLocation
 "hasInput"(arg1: $ReplacementMatchInfo$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeLikeKJS$$Type = ($RecipeLikeKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeLikeKJS_ = $RecipeLikeKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.misc.PaintingVariantBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$PaintingVariant, $PaintingVariant$$Type} from "net.minecraft.world.entity.decoration.PaintingVariant"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $PaintingVariantBuilder extends $BuilderBase<($PaintingVariant)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "size"(arg0: integer, arg1: integer): this
public "assetId"(arg0: $ResourceLocation$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PaintingVariantBuilder$$Type = ($PaintingVariantBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PaintingVariantBuilder_ = $PaintingVariantBuilder$$Type;
}}
declare module "dev.latvian.mods.rhino.RhinoException" {
import {$PrintStream, $PrintStream$$Type} from "java.io.PrintStream"
import {$ScriptStackElement, $ScriptStackElement$$Type} from "dev.latvian.mods.rhino.ScriptStackElement"
import {$PrintWriter, $PrintWriter$$Type} from "java.io.PrintWriter"
import {$RuntimeException, $RuntimeException$$Type} from "java.lang.RuntimeException"

export class $RhinoException extends $RuntimeException {


public "printStackTrace"(s: $PrintStream$$Type): void
public "printStackTrace"(s: $PrintWriter$$Type): void
public "lineNumber"(): integer
public "getMessage"(): string
public "details"(): string
public "sourceName"(): string
public "columnNumber"(): integer
public "getScriptStackTrace"(limit: integer, functionName: string): string
public "getScriptStackTrace"(): string
public "getScriptStack"(): ($ScriptStackElement)[]
public "getScriptStack"(limit: integer, hideFunction: string): ($ScriptStackElement)[]
public "lineSource"(): string
public "initSourceName"(sourceName: string): void
public "initLineNumber"(lineNumber: integer): void
public "initLineSource"(lineSource: string): void
public "initColumnNumber"(columnNumber: integer): void
get "message"(): string
get "scriptStackTrace"(): string
get "scriptStack"(): ($ScriptStackElement)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RhinoException$$Type = ($RhinoException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RhinoException_ = $RhinoException$$Type;
}}
declare module "dev.latvian.mods.kubejs.stages.Stages" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Collection, $Collection$$Type} from "java.util.Collection"

export interface $Stages {

 "remove"(arg0: string): boolean
 "clear"(): boolean
 "replace"(arg0: $Collection$$Type<(string)>): void
 "add"(arg0: string): boolean
 "set"(arg0: string, arg1: boolean): boolean
 "sync"(): void
 "getAll"(): $Collection<(string)>
 "has"(arg0: string): boolean
 "getPlayer"(): $Player
 "toggle"(arg0: string): boolean
 "removeNoUpdate"(arg0: string): boolean
 "addNoUpdate"(arg0: string): boolean
get "all"(): $Collection<(string)>
get "player"(): $Player
}

export namespace $Stages {
const probejs$$marker: never
}
export class $Stages$$Static implements $Stages {


 "remove"(arg0: string): boolean
 "clear"(): boolean
 "replace"(arg0: $Collection$$Type<(string)>): void
 "add"(arg0: string): boolean
 "set"(arg0: string, arg1: boolean): boolean
 "sync"(): void
 "getAll"(): $Collection<(string)>
 "has"(arg0: string): boolean
 "getPlayer"(): $Player
 "toggle"(arg0: string): boolean
 "removeNoUpdate"(arg0: string): boolean
 "addNoUpdate"(arg0: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Stages$$Type = ($Stages);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Stages_ = $Stages$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.CountingMap" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Object2LongEntry, $Object2LongEntry$$Type} from "dev.latvian.mods.kubejs.util.Object2LongEntry"
import {$List, $List$$Type} from "java.util.List"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $CountingMap {

constructor()

public "get"(arg0: any): long
public "clear"(): void
public "add"(arg0: any, arg1: long): long
public "set"(arg0: any, arg1: long): long
public "forEach"(arg0: $Consumer$$Type<($Object2LongEntry)>): void
public "getSize"(): integer
public "getEntries"(): $List<($Object2LongEntry)>
public "getKeys"(): $Set<(any)>
public "getValues"(): $Collection<(long)>
public "getTotalCount"(): long
get "size"(): integer
get "entries"(): $List<($Object2LongEntry)>
get "keys"(): $Set<(any)>
get "values"(): $Collection<(long)>
get "totalCount"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CountingMap$$Type = ($CountingMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CountingMap_ = $CountingMap$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$UseCallback" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"

export interface $ItemBuilder$UseCallback {

 "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): boolean

(arg0: $Level, arg1: $Player, arg2: $InteractionHand): boolean
}

export namespace $ItemBuilder$UseCallback {
const probejs$$marker: never
}
export class $ItemBuilder$UseCallback$$Static implements $ItemBuilder$UseCallback {


 "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$UseCallback$$Type = ((arg0: $Level, arg1: $Player, arg2: $InteractionHand) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBuilder$UseCallback_ = $ItemBuilder$UseCallback$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.ScheduledEvents" {
import {$ScheduledEvents$Callback, $ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$LinkedList, $LinkedList$$Type} from "java.util.LinkedList"
import {$AtomicInteger, $AtomicInteger$$Type} from "java.util.concurrent.atomic.AtomicInteger"
import {$TemporalAmount, $TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"

export class $ScheduledEvents {
readonly "factory": $Supplier<($ScheduledEvents$ScheduledEvent)>
readonly "events": $LinkedList<($ScheduledEvents$ScheduledEvent)>
readonly "futureEvents": $LinkedList<($ScheduledEvents$ScheduledEvent)>
readonly "nextId": $AtomicInteger
 "currentMillis": long
 "currentTick": long

constructor(arg0: $Supplier$$Type<($ScheduledEvents$ScheduledEvent$$Type)>)

public "clear"(arg0: integer): void
public "schedule"(arg0: $TemporalAmount$$Type, arg1: boolean, arg2: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
public "schedule"(arg0: long, arg1: boolean, arg2: boolean, arg3: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
public "tickAll"(arg0: long): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$$Type = ($ScheduledEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScheduledEvents_ = $ScheduledEvents$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabIconSupplier" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"

export interface $CreativeTabIconSupplier {

 "getIcon"(): $ItemStack

(): $ItemStack$$Type
get "icon"(): $ItemStack
}

export namespace $CreativeTabIconSupplier {
const DEFAULT: $CreativeTabIconSupplier
const probejs$$marker: never
}
export class $CreativeTabIconSupplier$$Static implements $CreativeTabIconSupplier {
static readonly "DEFAULT": $CreativeTabIconSupplier


 "getIcon"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabIconSupplier$$Type = (() => $ItemStack$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabIconSupplier_ = $CreativeTabIconSupplier$$Type;
}}
declare module "dev.latvian.mods.rhino.IdScriptableObject" {
import {$Context, $Context$$Type} from "dev.latvian.mods.rhino.Context"
import {$ScriptableObject, $ScriptableObject$$Type} from "dev.latvian.mods.rhino.ScriptableObject"
import {$Symbol, $Symbol$$Type} from "dev.latvian.mods.rhino.Symbol"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$IdFunctionCall, $IdFunctionCall$$Type} from "dev.latvian.mods.rhino.IdFunctionCall"
import {$IdFunctionObject, $IdFunctionObject$$Type} from "dev.latvian.mods.rhino.IdFunctionObject"

export class $IdScriptableObject extends $ScriptableObject implements $IdFunctionCall {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(scope: $Scriptable$$Type, prototype: $Scriptable$$Type)
constructor()

public "get"(name: string, start: $Scriptable$$Type): any
public "get"(key: $Symbol$$Type, start: $Scriptable$$Type): any
public "put"(name: string, start: $Scriptable$$Type, value: any): void
public "put"(key: $Symbol$$Type, start: $Scriptable$$Type, value: any): void
public "delete"(name: string): void
public "delete"(key: $Symbol$$Type): void
public "getAttributes"(name: string): integer
public "getAttributes"(key: $Symbol$$Type): integer
public "has"(key: $Symbol$$Type, start: $Scriptable$$Type): boolean
public "has"(name: string, start: $Scriptable$$Type): boolean
public "setAttributes"(name: string, attributes: integer): void
public "initPrototypeMethod"(tag: any, id: integer, propertyName: string, functionName: string, arity: integer, cx: $Context$$Type): $IdFunctionObject
public "initPrototypeMethod"(tag: any, id: integer, key: $Symbol$$Type, functionName: string, arity: integer, cx: $Context$$Type): $IdFunctionObject
public "initPrototypeMethod"(tag: any, id: integer, name: string, arity: integer, cx: $Context$$Type): $IdFunctionObject
public "activatePrototypeMap"(maxPrototypeId: integer): void
public "initPrototypeConstructor"(f: $IdFunctionObject$$Type, cx: $Context$$Type): void
public "execIdCall"(f: $IdFunctionObject$$Type, cx: $Context$$Type, scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args: (any)[]): any
public "exportAsJSClass"(maxPrototypeId: integer, scope: $Scriptable$$Type, sealed: boolean, cx: $Context$$Type): $IdFunctionObject
public "initPrototypeValue"(id: integer, name: string, value: any, attributes: integer): void
public "initPrototypeValue"(id: integer, key: $Symbol$$Type, value: any, attributes: integer): void
public "hasPrototypeMap"(): boolean
public "defineOwnProperty"(key: any, desc: $ScriptableObject$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdScriptableObject$$Type = ($IdScriptableObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdScriptableObject_ = $IdScriptableObject$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockPredicate" {
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"

export interface $BlockPredicate {

 "check"(arg0: $BlockContainerJS$$Type): boolean

(arg0: $BlockContainerJS): boolean
}

export namespace $BlockPredicate {
const probejs$$marker: never
}
export class $BlockPredicate$$Static implements $BlockPredicate {


 "check"(arg0: $BlockContainerJS$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPredicate$$Type = ((arg0: $BlockContainerJS) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPredicate_ = $BlockPredicate$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.OrderedCompoundTag" {
import {$TagType, $TagType$$Type} from "net.minecraft.nbt.TagType"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$DataOutput, $DataOutput$$Type} from "java.io.DataOutput"

export class $OrderedCompoundTag extends $CompoundTag {
readonly "tagMap": $Map<(string), ($Tag)>
static readonly "CODEC": $Codec<($CompoundTag)>
static readonly "TYPE": $TagType<($CompoundTag)>
readonly "tags": $Map<(string), ($Tag)>

constructor(arg0: $Map$$Type<(string), ($Tag$$Type)>)
constructor()

public "write"(arg0: $DataOutput$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrderedCompoundTag$$Type = ($OrderedCompoundTag);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OrderedCompoundTag_ = $OrderedCompoundTag$$Type;
}}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuData" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ChestMenuSlot, $ChestMenuSlot$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuSlot"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$ChestMenuClickEvent$Callback, $ChestMenuClickEvent$Callback$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback"
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$ChestMenuInventoryClickEvent$Callback, $ChestMenuInventoryClickEvent$Callback$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent$Callback"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $ChestMenuData {
readonly "player": $ServerPlayer
 "title": $Component
readonly "rows": integer
readonly "slots": ($ChestMenuSlot)[]
 "anyClicked": $ChestMenuClickEvent$Callback
 "inventoryClicked": $ChestMenuInventoryClickEvent$Callback
 "playerSlots": boolean
 "closed": $Runnable
 "mouseItem": $ItemStack
 "capturedInventory": $Container

constructor(arg0: $ServerPlayer$$Type, arg1: $Component$$Type, arg2: integer)

public "slot"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Consumer$$Type<($ChestMenuSlot)>): void
public "slot"(arg0: integer, arg1: integer, arg2: $Consumer$$Type<($ChestMenuSlot)>): void
public "getSlot"(arg0: integer, arg1: integer): $ChestMenuSlot
public "sync"(): void
public "button"(arg0: integer, arg1: integer, arg2: $ItemStack$$Type, arg3: $Component$$Type, arg4: $ChestMenuClickEvent$Callback$$Type): void
public "handleClick"(arg0: integer, arg1: $ClickType$$Type, arg2: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuData$$Type = ($ChestMenuData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuData_ = $ChestMenuData$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.callbacks.BlockStateModifyPlacementCallbackJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$BlockStateModifyCallbackJS, $BlockStateModifyCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.BlockStateModifyCallbackJS"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"

export class $BlockStateModifyPlacementCallbackJS extends $BlockStateModifyCallbackJS {
readonly "context": $BlockPlaceContext
readonly "minecraftBlock": $Block
 "block": $BlockContainerJS

constructor(arg0: $BlockPlaceContext$$Type, arg1: $Block$$Type)

/**
 * Gets the level
 */
public "getLevel"(): $Level
/**
 * Gets the item being placed
 */
public "getItem"(): $ItemStack
/**
 * Checks if this block is in water
 */
public "isInWater"(): boolean
/**
 * Gets the nearest horizontal direction to where the player is looking. NORTH if there is no player
 */
public "getHorizontalDirection"(): $Direction
/**
 * Returns if the block being placed is replacing the block clicked
 */
public "replacingClickedOnBlock"(): boolean
/**
 * Returns if the block being placed thinks it can be placed here. This is used for replacement checks, like placing blocks in water or tall grass
 */
public "canPlace"(): boolean
/**
 * Get the horizontal rotation of the player
 */
public "getRotation"(): float
/**
 * Gets an array of all directions, ordered by which the player is looking closest to
 */
public "getNearestLookingDirections"(): ($Direction)[]
/**
 * Gets the vertical direction (UP/DOWN) closest to where the player is currently looking
 */
public "getNearestLookingVerticalDirection"(): $Direction
/**
 * Checks if the position clicked has a specified fluid there
 */
public "isClickedPosIn"(arg0: $Fluid$$Type): boolean
/**
 * Checks if the block currently occupying the position this is being placed in is the same block type.
 * Used for things like candles, where multiple can be in the same block-space.
 */
public "isReplacingSelf"(): boolean
/**
 * Gets the clicked block
 */
public "getClickedBlock"(): $BlockContainerJS
/**
 * Gets the direction closes to where the player is currently looking
 */
public "getNearestLookingDirection"(): $Direction
/**
 * Gets the player placing the block, if available
 */
public "getPlayer"(): $Player
/**
 * Returns if the hit posiiton in the block-space is inside the 1x1x1 cube of the block
 */
public "isInside"(): boolean
/**
 * Gets the position in the block-space of where it was clicked
 */
public "getClickLocation"(): $Vec3
/**
 * Gets the clicked position in world
 */
public "getClickedPos"(): $BlockPos
/**
 * Gets the facing direction of the clicked block face
 */
public "getClickedFace"(): $Direction
/**
 * Returns if the player is using the 'secondary' function of this item. Basically checks if they are holding shift
 */
public "isSecondaryUseActive"(): boolean
/**
 * Set this block as waterlogged if it is in water
 */
public "waterlogged"(): $BlockStateModifyPlacementCallbackJS
/**
 * Set if this block is waterlogged or not
 */
public "waterlogged"(arg0: boolean): $BlockStateModifyPlacementCallbackJS
/**
 * Gets the hand that is placing the block
 */
public "getHand"(): $InteractionHand
/**
 * Gets the FluidSate at the clicked position
 */
public "getFluidStateAtClickedPos"(): $FluidState
get "level"(): $Level
get "item"(): $ItemStack
get "inWater"(): boolean
get "horizontalDirection"(): $Direction
get "rotation"(): float
get "nearestLookingDirections"(): ($Direction)[]
get "nearestLookingVerticalDirection"(): $Direction
get "replacingSelf"(): boolean
get "clickedBlock"(): $BlockContainerJS
get "nearestLookingDirection"(): $Direction
get "player"(): $Player
get "inside"(): boolean
get "clickLocation"(): $Vec3
get "clickedPos"(): $BlockPos
get "clickedFace"(): $Direction
get "secondaryUseActive"(): boolean
get "hand"(): $InteractionHand
get "fluidStateAtClickedPos"(): $FluidState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateModifyPlacementCallbackJS$$Type = ($BlockStateModifyPlacementCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateModifyPlacementCallbackJS_ = $BlockStateModifyPlacementCallbackJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.data.VirtualResourcePack" {
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$ExportablePackResources, $ExportablePackResources$$Type} from "dev.latvian.mods.kubejs.script.data.ExportablePackResources"
import {$MetadataSectionSerializer, $MetadataSectionSerializer$$Type} from "net.minecraft.server.packs.metadata.MetadataSectionSerializer"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$KubeResourceGenerator, $KubeResourceGenerator$$Type} from "dev.latvian.mods.kubejs.generator.KubeResourceGenerator"
import {$GeneratedDataStage, $GeneratedDataStage$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedDataStage"
import {$IoSupplier, $IoSupplier$$Type} from "net.minecraft.server.packs.resources.IoSupplier"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PackType, $PackType$$Type} from "net.minecraft.server.packs.PackType"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$PackResources$ResourceOutput, $PackResources$ResourceOutput$$Type} from "net.minecraft.server.packs.PackResources$ResourceOutput"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$InputStream, $InputStream$$Type} from "java.io.InputStream"
import {$AbstractPackResources, $AbstractPackResources$$Type} from "net.minecraft.server.packs.AbstractPackResources"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $VirtualResourcePack extends $AbstractPackResources implements $KubeResourceGenerator, $ExportablePackResources {
readonly "scriptType": $ScriptType
readonly "packType": $PackType
readonly "stage": $GeneratedDataStage
readonly "info": string
readonly "component": $Component

constructor(arg0: $ScriptType$$Type, arg1: $PackType$$Type, arg2: $GeneratedDataStage$$Type)

public "reset"(): void
public "toString"(): string
public "add"(arg0: $GeneratedData$$Type): void
public "getResource"(arg0: $PackType$$Type, arg1: $ResourceLocation$$Type): $IoSupplier<($InputStream)>
public "close"(): void
public "export"(arg0: $Path$$Type): void
public "listResources"(arg0: $PackType$$Type, arg1: string, arg2: string, arg3: $PackResources$ResourceOutput$$Type): void
public "getNamespaces"(arg0: $PackType$$Type): $Set<(string)>
public "getGenerated"(arg0: $ResourceLocation$$Type): $GeneratedData
public "packId"(): string
public "getRootResource"(...arg0: (string)[]): $IoSupplier<($InputStream)>
public "getMetadataSection"<T>(arg0: $MetadataSectionSerializer$$Type<(T)>): T
public "exportPath"(): string
public "text"(arg0: $ResourceLocation$$Type, arg1: string): void
public "json"(arg0: $ResourceLocation$$Type, arg1: $JsonElement$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualResourcePack$$Type = ($VirtualResourcePack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VirtualResourcePack_ = $VirtualResourcePack$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.StairBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $StairBlockBuilder extends $ShapedBlockBuilder {
static readonly "STAIR_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StairBlockBuilder$$Type = ($StairBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StairBlockBuilder_ = $StairBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.level.SpawnerJS" {
import {$Either, $Either$$Type} from "com.mojang.datafixers.util.Either"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $SpawnerJS extends $Record {

constructor(entity: $Entity$$Type, block: $BlockContainerJS$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "of"(arg0: $Either$$Type<($BlockEntity$$Type), ($Entity$$Type)>): $SpawnerJS
public "block"(): $BlockContainerJS
public "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpawnerJS$$Type = ({"entity"?: $Entity$$Type, "block"?: $BlockContainerJS$$Type}) | ([entity?: $Entity$$Type, block?: $BlockContainerJS$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpawnerJS_ = $SpawnerJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.registry.ModelledBuilderBase" {
import {$ModelGenerator, $ModelGenerator$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $ModelledBuilderBase<T> extends $BuilderBase<(T)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

/**
 * Replaces default model with custom generator.
 */
public "modelGenerator"(arg0: $Consumer$$Type<($ModelGenerator)>): this
/**
 * Directly set the texture map.
 */
public "textures"(arg0: $Map$$Type<(string), (string)>): this
/**
 * Sets the texture by given key.
 */
public "texture"(arg0: (string)[], arg1: string): this
/**
 * Sets the texture.
 */
public "texture"(arg0: string): this
/**
 * Sets the parent model.
 */
public "parentModel"(arg0: $ResourceLocation$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelledBuilderBase$$Type<T> = ($ModelledBuilderBase<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelledBuilderBase_<T> = $ModelledBuilderBase$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.script.ScriptFileInfo" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$ScriptPackInfo, $ScriptPackInfo$$Type} from "dev.latvian.mods.kubejs.script.ScriptPackInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptFileInfo {
readonly "pack": $ScriptPackInfo
readonly "path": $Path
readonly "file": string
readonly "id": $ResourceLocation
readonly "location": string

constructor(arg0: $ScriptPackInfo$$Type, arg1: $Path$$Type, arg2: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptFileInfo$$Type = ($ScriptFileInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptFileInfo_ = $ScriptFileInfo$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.entity.FluidTankAttachment$Factory" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockEntityAttachmentFactory, $BlockEntityAttachmentFactory$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentInfo, $BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$List, $List$$Type} from "java.util.List"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$BlockEntityAttachment, $BlockEntityAttachment$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $FluidTankAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory {

constructor(capacity: integer, inputFilter: $Optional$$Type<($FluidIngredient$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "create"(arg0: $BlockEntityAttachmentInfo$$Type, arg1: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "capacity"(): integer
public "getCapabilities"(): $List<($BlockCapability<(any), (any)>)>
public "inputFilter"(): $Optional<($FluidIngredient)>
public "isTicking"(): boolean
get "capabilities"(): $List<($BlockCapability<(any), (any)>)>
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankAttachment$Factory$$Type = ({"capacity"?: integer, "inputFilter"?: ($FluidIngredient$$Type)?}) | ([capacity?: integer, inputFilter?: ($FluidIngredient$$Type)?]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidTankAttachment$Factory_ = $FluidTankAttachment$Factory$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.CarpetBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $CarpetBlockBuilder extends $ShapedBlockBuilder {
static readonly "CARPET_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarpetBlockBuilder$$Type = ($CarpetBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CarpetBlockBuilder_ = $CarpetBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.RandomTickKubeEvent" {
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$KubeLevelEvent, $KubeLevelEvent$$Type} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $RandomTickKubeEvent implements $KubeLevelEvent {
readonly "random": $RandomSource

constructor(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $RandomSource$$Type)

public "getLevel"(): $Level
public "getBlock"(): $BlockContainerJS
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "level"(): $Level
get "block"(): $BlockContainerJS
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomTickKubeEvent$$Type = ($RandomTickKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RandomTickKubeEvent_ = $RandomTickKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.kgui.action.KGUIActions" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$KGUIType, $KGUIType$$Type} from "dev.latvian.mods.kubejs.kgui.KGUIType"

export interface $KGUIActions {

 "update"(arg0: string, arg1: $CompoundTag$$Type): void
 "show"(arg0: $KGUIType$$Type, arg1: string): void
 "show"(arg0: $KGUIType$$Type, arg1: string, arg2: $CompoundTag$$Type): void
 "hide"(arg0: string): void
 "mouseClicked"(arg0: string, arg1: integer, arg2: integer): void
}

export namespace $KGUIActions {
const probejs$$marker: never
}
export class $KGUIActions$$Static implements $KGUIActions {


 "update"(arg0: string, arg1: $CompoundTag$$Type): void
 "show"(arg0: $KGUIType$$Type, arg1: string): void
 "show"(arg0: $KGUIType$$Type, arg1: string, arg2: $CompoundTag$$Type): void
 "hide"(arg0: string): void
 "mouseClicked"(arg0: string, arg1: integer, arg2: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KGUIActions$$Type = ($KGUIActions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KGUIActions_ = $KGUIActions$$Type;
}}
declare module "dev.latvian.mods.rhino.type.RecordTypeInfo$Data" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecordTypeInfo$Component, $RecordTypeInfo$Component$$Type} from "dev.latvian.mods.rhino.type.RecordTypeInfo$Component"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $RecordTypeInfo$Data extends $Record {

constructor(components: ($RecordTypeInfo$Component$$Type)[], componentMap: $Map$$Type<(string), ($RecordTypeInfo$Component$$Type)>, defaultArguments: (any)[])

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "componentMap"(): $Map<(string), ($RecordTypeInfo$Component)>
public "components"(): ($RecordTypeInfo$Component)[]
public "defaultArguments"(): (any)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecordTypeInfo$Data$$Type = ({"components"?: ($RecordTypeInfo$Component$$Type)[], "componentMap"?: $Map$$Type<(string), ($RecordTypeInfo$Component$$Type)>, "defaultArguments"?: (any)[]}) | ([components?: ($RecordTypeInfo$Component$$Type)[], componentMap?: $Map$$Type<(string), ($RecordTypeInfo$Component$$Type)>, defaultArguments?: (any)[]]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecordTypeInfo$Data_ = $RecordTypeInfo$Data$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.BlockTintFunction$Fixed" {
import {$BlockAndTintGetter, $BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$BlockTintFunction, $BlockTintFunction$$Type} from "dev.latvian.mods.kubejs.block.BlockTintFunction"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockTintFunction$Fixed extends $Record implements $BlockTintFunction {

constructor(color: $KubeColor$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "color"(): $KubeColor
public "getColor"(arg0: $BlockState$$Type, arg1: $BlockAndTintGetter$$Type, arg2: $BlockPos$$Type, arg3: integer): $KubeColor
public static "of"(arg1: any): $BlockTintFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTintFunction$Fixed$$Type = ({"color"?: $KubeColor$$Type}) | ([color?: $KubeColor$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTintFunction$Fixed_ = $BlockTintFunction$Fixed$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$AnimalArmor" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder, $ArmorItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$AnimalArmorItem$BodyType, $AnimalArmorItem$BodyType$$Type} from "net.minecraft.world.item.AnimalArmorItem$BodyType"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ArmorItemBuilder$AnimalArmor extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "bodyType"(arg0: $AnimalArmorItem$BodyType$$Type): this
public "overlay"(arg0: boolean): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$AnimalArmor$$Type = ($ArmorItemBuilder$AnimalArmor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorItemBuilder$AnimalArmor_ = $ArmorItemBuilder$AnimalArmor$$Type;
}}
declare module "dev.latvian.mods.kubejs.command.CommandRegistryKubeEvent" {
import {$LiteralArgumentBuilder, $LiteralArgumentBuilder$$Type} from "com.mojang.brigadier.builder.LiteralArgumentBuilder"
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$CommandBuildContext, $CommandBuildContext$$Type} from "net.minecraft.commands.CommandBuildContext"
import {$Commands, $Commands$$Type} from "net.minecraft.commands.Commands"
import {$ArgumentTypeWrappers, $ArgumentTypeWrappers$$Type} from "dev.latvian.mods.kubejs.command.ArgumentTypeWrappers"
import {$CommandDispatcher, $CommandDispatcher$$Type} from "com.mojang.brigadier.CommandDispatcher"
import {$SharedSuggestionProvider, $SharedSuggestionProvider$$Type} from "net.minecraft.commands.SharedSuggestionProvider"
import {$LiteralCommandNode, $LiteralCommandNode$$Type} from "com.mojang.brigadier.tree.LiteralCommandNode"
import {$CommandSourceStack, $CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"
import {$Commands$CommandSelection, $Commands$CommandSelection$$Type} from "net.minecraft.commands.Commands$CommandSelection"

export class $CommandRegistryKubeEvent implements $KubeEvent {
readonly "dispatcher": $CommandDispatcher<($CommandSourceStack)>
readonly "context": $CommandBuildContext
readonly "selection": $Commands$CommandSelection

constructor(arg0: $CommandDispatcher$$Type<($CommandSourceStack$$Type)>, arg1: $CommandBuildContext$$Type, arg2: $Commands$CommandSelection$$Type)

public "register"(arg0: $LiteralArgumentBuilder$$Type<($CommandSourceStack$$Type)>): $LiteralCommandNode<($CommandSourceStack)>
public "getArguments"(): typeof $ArgumentTypeWrappers
public "getRegistry"(): $CommandBuildContext
public "getCommands"(): typeof $Commands
public "isForSinglePlayer"(): boolean
public "isForMultiPlayer"(): boolean
public "getBuiltinSuggestions"(): typeof $SharedSuggestionProvider
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "arguments"(): typeof $ArgumentTypeWrappers
get "registry"(): $CommandBuildContext
get "commands"(): typeof $Commands
get "forSinglePlayer"(): boolean
get "forMultiPlayer"(): boolean
get "builtinSuggestions"(): typeof $SharedSuggestionProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandRegistryKubeEvent$$Type = ($CommandRegistryKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandRegistryKubeEvent_ = $CommandRegistryKubeEvent$$Type;
}}
declare module "dev.latvian.mods.rhino.SymbolScriptable" {
import {$Symbol, $Symbol$$Type} from "dev.latvian.mods.rhino.Symbol"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"

export interface $SymbolScriptable {

 "get"(arg1: $Symbol$$Type, arg2: $Scriptable$$Type): any
 "put"(arg1: $Symbol$$Type, arg2: $Scriptable$$Type, arg3: any): void
 "delete"(arg1: $Symbol$$Type): void
 "has"(arg1: $Symbol$$Type, arg2: $Scriptable$$Type): boolean
}

export namespace $SymbolScriptable {
const probejs$$marker: never
}
export class $SymbolScriptable$$Static implements $SymbolScriptable {


 "get"(arg1: $Symbol$$Type, arg2: $Scriptable$$Type): any
 "put"(arg1: $Symbol$$Type, arg2: $Scriptable$$Type, arg3: any): void
 "delete"(arg1: $Symbol$$Type): void
 "has"(arg1: $Symbol$$Type, arg2: $Scriptable$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SymbolScriptable$$Type = ($SymbolScriptable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SymbolScriptable_ = $SymbolScriptable$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.AABBWrapper" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AABB, $AABB$$Type} from "net.minecraft.world.phys.AABB"

export interface $AABBWrapper {

}

export namespace $AABBWrapper {
const EMPTY: $AABB
const CUBE: $AABB
function wrap(arg0: any): $AABB
function of(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): $AABB
function ofSize(arg0: double, arg1: double, arg2: double): $AABB
function ofSize(arg0: $Vec3$$Type, arg1: double, arg2: double, arg3: double): $AABB
function ofBlock(arg0: $BlockPos$$Type): $AABB
function ofBlocks(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): $AABB
const probejs$$marker: never
}
export class $AABBWrapper$$Static implements $AABBWrapper {
static readonly "EMPTY": $AABB
static readonly "CUBE": $AABB


static "wrap"(arg0: any): $AABB
static "of"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): $AABB
static "ofSize"(arg0: double, arg1: double, arg2: double): $AABB
static "ofSize"(arg0: $Vec3$$Type, arg1: double, arg2: double, arg3: double): $AABB
static "ofBlock"(arg0: $BlockPos$$Type): $AABB
static "ofBlocks"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): $AABB
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AABBWrapper$$Type = ($AABBWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AABBWrapper_ = $AABBWrapper$$Type;
}}
declare module "dev.latvian.apps.tinyserver.HTTPServer" {
import {$WSSession, $WSSession$$Type} from "dev.latvian.apps.tinyserver.ws.WSSession"
import {$HTTPMethod, $HTTPMethod$$Type} from "dev.latvian.apps.tinyserver.http.HTTPMethod"
import {$HTTPResponseBuilder, $HTTPResponseBuilder$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPResponseBuilder"
import {$HTTPHandler, $HTTPHandler$$Type} from "dev.latvian.apps.tinyserver.http.HTTPHandler"
import {$WSSessionFactory, $WSSessionFactory$$Type} from "dev.latvian.apps.tinyserver.ws.WSSessionFactory"
import {$ServerRegistry, $ServerRegistry$$Type} from "dev.latvian.apps.tinyserver.ServerRegistry"
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$Exception, $Exception$$Type} from "java.lang.Exception"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$HTTPRequest, $HTTPRequest$$Type} from "dev.latvian.apps.tinyserver.http.HTTPRequest"
import {$WSHandler, $WSHandler$$Type} from "dev.latvian.apps.tinyserver.ws.WSHandler"

export class $HTTPServer<REQ extends $HTTPRequest> implements $Runnable, $ServerRegistry<(REQ)> {

constructor(arg0: $Supplier$$Type<(REQ)>)

public "run"(): void
public "setDaemon"(arg0: boolean): void
public "start"(): integer
public "stop"(): void
public "ws"<WSS extends $WSSession<(REQ)>>(arg0: string, arg1: $WSSessionFactory$$Type<(REQ), (WSS)>): $WSHandler<(REQ), (WSS)>
public "createBuilder"(arg0: REQ, arg1: $HTTPHandler$$Type<(REQ)>): $HTTPResponseBuilder
public "setPort"(arg0: integer): void
public "setBufferSize"(arg0: integer): void
public "http"(arg0: $HTTPMethod$$Type, arg1: string, arg2: $HTTPHandler$$Type<(REQ)>): void
public "handlePayloadError"(arg0: $HTTPResponseBuilder$$Type, arg1: $Exception$$Type): void
public "setMaxPortShift"(arg0: integer): void
public "setServerName"(arg0: string): void
public "setAddress"(arg0: string): void
public "get"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
public "put"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
public "delete"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
public "patch"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
public "ws"<WSS extends $WSSession<(REQ)>>(arg0: string): $WSHandler<(REQ), (WSS)>
public "post"(arg0: string, arg1: $HTTPHandler$$Type<(REQ)>): void
public "acceptPostTask"(arg0: string, arg1: $Runnable$$Type): void
public "acceptPostString"(arg0: string, arg1: $Consumer$$Type<(string)>): void
set "daemon"(value: boolean)
set "port"(value: integer)
set "bufferSize"(value: integer)
set "maxPortShift"(value: integer)
set "serverName"(value: string)
set "address"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HTTPServer$$Type<REQ> = ($HTTPServer<(REQ)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HTTPServer_<REQ> = $HTTPServer$$Type<(REQ)>;
}}
declare module "dev.latvian.mods.kubejs.core.BlockBehaviourKJS" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $BlockBehaviourKJS {

 "kjs$getTypeData"(): $Map<(string), (any)>
 "kjs$setSoundType"(arg0: $SoundType$$Type): void
 "kjs$setFriction"(arg0: float): void
 "kjs$setSpeedFactor"(arg0: float): void
 "kjs$setJumpFactor"(arg0: float): void
 "kjs$setIsRandomlyTicking"(arg0: boolean): void
 "kjs$setHasCollision"(arg0: boolean): void
 "kjs$setExplosionResistance"(arg0: float): void
 "kjs$setRandomTickCallback"(arg0: $Consumer$$Type<($RandomTickCallbackJS)>): void
}

export namespace $BlockBehaviourKJS {
const probejs$$marker: never
}
export class $BlockBehaviourKJS$$Static implements $BlockBehaviourKJS {


 "kjs$getTypeData"(): $Map<(string), (any)>
 "kjs$setSoundType"(arg0: $SoundType$$Type): void
 "kjs$setFriction"(arg0: float): void
 "kjs$setSpeedFactor"(arg0: float): void
 "kjs$setJumpFactor"(arg0: float): void
 "kjs$setIsRandomlyTicking"(arg0: boolean): void
 "kjs$setHasCollision"(arg0: boolean): void
 "kjs$setExplosionResistance"(arg0: float): void
 "kjs$setRandomTickCallback"(arg0: $Consumer$$Type<($RandomTickCallbackJS)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviourKJS$$Type = ($BlockBehaviourKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBehaviourKJS_ = $BlockBehaviourKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.entity.LivingEntityDropsKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$List, $List$$Type} from "java.util.List"
import {$LivingDropsEvent, $LivingDropsEvent$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDropsEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent, $KubeLivingEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $LivingEntityDropsKubeEvent implements $KubeLivingEntityEvent {
 "eventDrops": $List<($ItemEntity)>

constructor(arg0: $LivingDropsEvent$$Type)

public "getSource"(): $DamageSource
public "getEntity"(): $Entity
public "isRecentlyHit"(): boolean
public "getDrops"(): $List<($ItemEntity)>
public "addDrop"(arg0: $ItemStack$$Type, arg1: float): $ItemEntity
public "addDrop"(arg0: $ItemStack$$Type): $ItemEntity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "source"(): $DamageSource
get "entity"(): $Entity
get "recentlyHit"(): boolean
get "drops"(): $List<($ItemEntity)>
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityDropsKubeEvent$$Type = ($LivingEntityDropsKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEntityDropsKubeEvent_ = $LivingEntityDropsKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.PlatformWrapper" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Set, $Set$$Type} from "java.util.Set"
import {$PlatformWrapper$ModInfo, $PlatformWrapper$ModInfo$$Type} from "dev.latvian.mods.kubejs.script.PlatformWrapper$ModInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $PlatformWrapper {

constructor()

/**
 * 
 * @deprecated
 */
public static "getName"(): string
public static "isLoaded"(arg0: string): boolean
public static "getInfo"(arg0: string): $PlatformWrapper$ModInfo
public static "getMinecraftVersion"(): integer
public static "getList"(): $Set<(string)>
public static "isDevelopmentEnvironment"(): boolean
public static "getMods"(): $Map<(string), ($PlatformWrapper$ModInfo)>
/**
 * 
 * @deprecated
 */
public static "isFabric"(): boolean
public static "getPackMode"(): string
public static "getModVersion"(): string
public static "getMinecraftVersionString"(): string
public static "isClientEnvironment"(): boolean
public static "getCurrentThreadName"(): string
public static "isGeneratingData"(): boolean
public static "getMcVersion"(): string
/**
 * 
 * @deprecated
 */
public static "isForge"(): boolean
public static "setModName"(arg0: string, arg1: string): void
public static "breakpoint"(...arg1: (any)[]): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformWrapper$$Type = ($PlatformWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformWrapper_ = $PlatformWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.entity.RayTraceResultJS" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$HitResult$Type, $HitResult$Type$$Type} from "net.minecraft.world.phys.HitResult$Type"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$HitResult, $HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"

export class $RayTraceResultJS {
readonly "fromEntity": $Entity
readonly "type": $HitResult$Type
readonly "distance": double
 "hit": $Vec3
 "block": $BlockContainerJS
 "facing": $Direction
 "entity": $Entity

constructor(arg0: $Entity$$Type, arg1: $HitResult$$Type, arg2: double)

public "getHitX"(): double
public "getHitZ"(): double
public "getHitY"(): double
get "hitX"(): double
get "hitZ"(): double
get "hitY"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RayTraceResultJS$$Type = ($RayTraceResultJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RayTraceResultJS_ = $RayTraceResultJS$$Type;
}}
declare module "dev.latvian.mods.rhino.EvaluatorException" {
import {$Context, $Context$$Type} from "dev.latvian.mods.rhino.Context"
import {$RhinoException, $RhinoException$$Type} from "dev.latvian.mods.rhino.RhinoException"

export class $EvaluatorException extends $RhinoException {

constructor(cx: $Context$$Type, detail: string)
constructor(cx: $Context$$Type, detail: string, sourceName: string, lineNumber: integer)
constructor(cx: $Context$$Type, detail: string, sourceName: string, lineNumber: integer, lineSource: string, columnNumber: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EvaluatorException$$Type = ($EvaluatorException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EvaluatorException_ = $EvaluatorException$$Type;
}}
declare module "dev.latvian.apps.tinyserver.http.HTTPRequest" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$HTTPServer, $HTTPServer$$Type} from "dev.latvian.apps.tinyserver.HTTPServer"
import {$CompiledPath, $CompiledPath$$Type} from "dev.latvian.apps.tinyserver.CompiledPath"
import {$InputStream, $InputStream$$Type} from "java.io.InputStream"

export class $HTTPRequest {

constructor()

public "init"(arg0: $HTTPServer$$Type<(any)>, arg1: (string)[], arg2: $CompiledPath$$Type, arg3: $Map$$Type<(string), (string)>, arg4: $Map$$Type<(string), (string)>, arg5: $InputStream$$Type): void
public "query"(): $Map<(string), (string)>
public "path"(): (string)[]
public "body"(): string
public "header"(arg0: string): string
public "server"(): $HTTPServer<(any)>
public "headers"(): $Map<(string), (string)>
public "variable"(arg0: string): string
public "bodyStream"(): $InputStream
public "bodyBytes"(): (byte)[]
public "variables"(): $Map<(string), (string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HTTPRequest$$Type = ($HTTPRequest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HTTPRequest_ = $HTTPRequest$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.TinyMap$Entry" {
import {$Record, $Record$$Type} from "java.lang.Record"

export class $TinyMap$Entry<K, V> extends $Record {

constructor(key: K, value: V)

public "value"(): V
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "key"(): K
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TinyMap$Entry$$Type<K, V> = ({"key"?: never, "value"?: never}) | ([key?: never, value?: never]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TinyMap$Entry_<K, V> = $TinyMap$Entry$$Type<(K), (V)>;
}}
declare module "dev.latvian.mods.kubejs.util.WrappedJS" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $WrappedJS {

}

export namespace $WrappedJS {
const probejs$$marker: never
}
export class $WrappedJS$$Static implements $WrappedJS {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedJS$$Type = ($WrappedJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedJS_ = $WrappedJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$CreativeTabCallback, $CreativeTabCallback$$Type} from "dev.latvian.mods.kubejs.item.creativetab.CreativeTabCallback"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CreativeModeTab, $CreativeModeTab$$Type} from "net.minecraft.world.item.CreativeModeTab"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$CreativeModeTab$TabVisibility, $CreativeModeTab$TabVisibility$$Type} from "net.minecraft.world.item.CreativeModeTab$TabVisibility"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export class $CreativeTabKubeEvent implements $KubeEvent {
readonly "tab": $CreativeModeTab
readonly "showRestrictedItems": boolean

constructor(arg0: $CreativeModeTab$$Type, arg1: boolean, arg2: $CreativeTabCallback$$Type)

public "remove"(arg0: $ItemPredicate$$Type): void
public "add"(arg0: ($ItemStack$$Type)[]): void
public "add"(arg0: ($ItemStack$$Type)[], arg1: $CreativeModeTab$TabVisibility$$Type): void
public "setIcon"(arg0: $ItemStack$$Type): void
public "removeFromSearch"(arg0: $ItemPredicate$$Type): void
public "removeFromParent"(arg0: $ItemPredicate$$Type): void
public "addAfter"(arg0: $ItemStack$$Type, arg1: ($ItemStack$$Type)[]): void
public "addAfter"(arg0: $ItemStack$$Type, arg1: ($ItemStack$$Type)[], arg2: $CreativeModeTab$TabVisibility$$Type): void
public "addBefore"(arg0: $ItemStack$$Type, arg1: ($ItemStack$$Type)[], arg2: $CreativeModeTab$TabVisibility$$Type): void
public "addBefore"(arg0: $ItemStack$$Type, arg1: ($ItemStack$$Type)[]): void
public "setDisplayName"(arg0: $Component$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
set "icon"(value: $ItemStack$$Type)
set "displayName"(value: $Component$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabKubeEvent$$Type = ($CreativeTabKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabKubeEvent_ = $CreativeTabKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemCraftedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player crafts an item.
 */
export class $ItemCraftedKubeEvent implements $KubePlayerEvent {

constructor(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Container$$Type)

/**
 * The item that was crafted.
 */
public "getItem"(): $ItemStack
/**
 * The player that crafted the item.
 */
public "getEntity"(): $LivingEntity
/**
 * The inventory that the item was crafted in.
 */
public "getInventory"(): $InventoryKJS
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "item"(): $ItemStack
get "entity"(): $LivingEntity
get "inventory"(): $InventoryKJS
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemCraftedKubeEvent$$Type = ($ItemCraftedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemCraftedKubeEvent_ = $ItemCraftedKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityInfo" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$CustomCapabilityAttachment$Factory, $CustomCapabilityAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.CustomCapabilityAttachment$Factory"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$FluidTankAttachment$Factory, $FluidTankAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.FluidTankAttachment$Factory"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$BlockEntityAttachmentHandler, $BlockEntityAttachmentHandler$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentHandler"
import {$InventoryAttachment$Factory, $InventoryAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.InventoryAttachment$Factory"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Set, $Set$$Type} from "java.util.Set"
import {$EnergyStorageAttachment$Factory, $EnergyStorageAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.EnergyStorageAttachment$Factory"
import {$BlockEntityEventCallback, $BlockEntityEventCallback$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityEventCallback"

export class $BlockEntityInfo implements $BlockEntityAttachmentHandler {

constructor(arg0: $BlockBuilder$$Type)

public "toString"(): string
public "tickOffset"(arg0: integer): void
public "enableSync"(): void
public "eventHandler"(arg0: integer, arg1: $BlockEntityEventCallback$$Type): void
public "initialData"(arg0: $CompoundTag$$Type): void
public "ticking"(): void
public "tickFrequency"(arg0: integer): void
public "clientTicking"(): void
public "serverTicking"(): void
public "rightClickOpensInventory"(arg0: string): void
public "rightClickFillsTank"(arg0: string): void
public "attach"<T extends Attachments>(arg1: string, type: T, arg3: $Set$$Type<($Direction$$Type)>, args: AttachmentMap[T]): void
public "energyStorage"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer, arg3: integer, arg4: integer, arg5: integer): void
public "inventory"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer, arg3: integer): void
public "inventory"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer, arg3: integer, arg4: $ItemPredicate$$Type): void
public "fluidTank"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer, arg3: $FluidIngredient$$Type): void
public "fluidTank"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer): void
public "attachCustomCapability"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: $BlockCapability$$Type<(any), (any)>, arg3: $Supplier$$Type<(any)>): void
}
export type AttachmentMap = {"inventory": $InventoryAttachment$Factory$$Type;
"energy_storage": $EnergyStorageAttachment$Factory$$Type;
"fluid_tank": $FluidTankAttachment$Factory$$Type;
"custom_capability": $CustomCapabilityAttachment$Factory$$Type};
export type Attachments = keyof AttachmentMap;
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityInfo$$Type = ($BlockEntityInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityInfo_ = $BlockEntityInfo$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.AfterRecipesLoadedKubeEvent" {
import {$RecipeManagerKJS, $RecipeManagerKJS$$Type} from "dev.latvian.mods.kubejs.core.RecipeManagerKJS"
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$RecipeFilter, $RecipeFilter$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter"
import {$RecipeLikeKJS, $RecipeLikeKJS$$Type} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $AfterRecipesLoadedKubeEvent implements $KubeEvent {

constructor(arg0: $RecipeManagerKJS$$Type)

public "remove"(arg1: $RecipeFilter$$Type): integer
public "countRecipes"(arg1: $RecipeFilter$$Type): integer
public "forEachRecipe"(arg1: $RecipeFilter$$Type, arg2: $Consumer$$Type<($RecipeLikeKJS)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterRecipesLoadedKubeEvent$$Type = ($AfterRecipesLoadedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AfterRecipesLoadedKubeEvent_ = $AfterRecipesLoadedKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.misc.ParticleTypeBuilder" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ParticleType, $ParticleType$$Type} from "net.minecraft.core.particles.ParticleType"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

export class $ParticleTypeBuilder extends $BuilderBase<($ParticleType<(any)>)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "codec"(arg0: $MapCodec$$Type<($ParticleOptions$$Type)>): this
public "textures"(arg0: $List$$Type<(string)>): this
public "texture"(arg0: string): this
public "overrideLimiter"(arg0: boolean): this
public "streamCodec"(arg0: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), ($ParticleOptions$$Type)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleTypeBuilder$$Type = ($ParticleTypeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParticleTypeBuilder_ = $ParticleTypeBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.ScriptPackInfo" {
import {$ScriptFileInfo, $ScriptFileInfo$$Type} from "dev.latvian.mods.kubejs.script.ScriptFileInfo"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptPackInfo {
readonly "namespace": string
readonly "displayName": $Component
readonly "scripts": $List<($ScriptFileInfo)>
readonly "pathStart": string

constructor(arg0: string, arg1: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptPackInfo$$Type = ($ScriptPackInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptPackInfo_ = $ScriptPackInfo$$Type;
}}
declare module "dev.latvian.mods.kubejs.event.IEventHandler" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $IEventHandler {

 "onEvent"(arg0: $KubeEvent$$Type): any

(arg0: $KubeEvent): any
}

export namespace $IEventHandler {
const probejs$$marker: never
}
export class $IEventHandler$$Static implements $IEventHandler {


 "onEvent"(arg0: $KubeEvent$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEventHandler$$Type = ((arg0: $KubeEvent) => any);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEventHandler_ = $IEventHandler$$Type;
}}
declare module "dev.latvian.mods.rhino.util.SpecialEquality" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $SpecialEquality {

 "specialEquals"(o: any, shallow: boolean): boolean
}

export namespace $SpecialEquality {
function checkSpecialEquality(o: any, o1: any, shallow: boolean): boolean
const probejs$$marker: never
}
export class $SpecialEquality$$Static implements $SpecialEquality {


static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
 "specialEquals"(o: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialEquality$$Type = ($SpecialEquality);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpecialEquality_ = $SpecialEquality$$Type;
}}
declare module "dev.latvian.mods.kubejs.server.CommandKubeEvent" {
import {$ParseResults, $ParseResults$$Type} from "com.mojang.brigadier.ParseResults"
import {$CommandEvent, $CommandEvent$$Type} from "net.neoforged.neoforge.event.CommandEvent"
import {$Throwable, $Throwable$$Type} from "java.lang.Throwable"
import {$ServerKubeEvent, $ServerKubeEvent$$Type} from "dev.latvian.mods.kubejs.server.ServerKubeEvent"
import {$CommandSourceStack, $CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $CommandKubeEvent extends $ServerKubeEvent {
readonly "server": $MinecraftServer

constructor(arg0: $CommandEvent$$Type)

public "getException"(): $Throwable
public "setException"(arg0: $Throwable$$Type): void
public "getInput"(): string
public "setParseResults"(arg0: $ParseResults$$Type<($CommandSourceStack$$Type)>): void
public "getParseResults"(): $ParseResults<($CommandSourceStack)>
public "getCommandName"(): string
get "exception"(): $Throwable
set "exception"(value: $Throwable$$Type)
get "input"(): string
set "parseResults"(value: $ParseResults$$Type<($CommandSourceStack$$Type)>)
get "parseResults"(): $ParseResults<($CommandSourceStack)>
get "commandName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandKubeEvent$$Type = ($CommandKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandKubeEvent_ = $CommandKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.entity.EnergyStorageAttachment$Factory" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockEntityAttachmentFactory, $BlockEntityAttachmentFactory$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentInfo, $BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$List, $List$$Type} from "java.util.List"
import {$BlockEntityAttachment, $BlockEntityAttachment$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $EnergyStorageAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory {

constructor(capacity: integer, maxReceive: $Optional$$Type<(integer)>, maxExtract: $Optional$$Type<(integer)>, autoOutput: $Optional$$Type<(integer)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "create"(arg0: $BlockEntityAttachmentInfo$$Type, arg1: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "capacity"(): integer
public "maxReceive"(): $Optional<(integer)>
public "maxExtract"(): $Optional<(integer)>
public "isTicking"(): boolean
public "getCapabilities"(): $List<($BlockCapability<(any), (any)>)>
public "autoOutput"(): $Optional<(integer)>
get "ticking"(): boolean
get "capabilities"(): $List<($BlockCapability<(any), (any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyStorageAttachment$Factory$$Type = ({"maxExtract"?: (integer)?, "maxReceive"?: (integer)?, "autoOutput"?: (integer)?, "capacity"?: integer}) | ([maxExtract?: (integer)?, maxReceive?: (integer)?, autoOutput?: (integer)?, capacity?: integer]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnergyStorageAttachment$Factory_ = $EnergyStorageAttachment$Factory$$Type;
}}
declare module "dev.latvian.mods.kubejs.player.EntityArrayList" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$ArrayList, $ArrayList$$Type} from "java.util.ArrayList"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MessageSenderKJS, $MessageSenderKJS$$Type} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntitySelector, $EntitySelector$$Type} from "net.minecraft.commands.arguments.selector.EntitySelector"
import {$DataSenderKJS, $DataSenderKJS$$Type} from "dev.latvian.mods.kubejs.core.DataSenderKJS"

export class $EntityArrayList extends $ArrayList<($Entity)> implements $MessageSenderKJS, $DataSenderKJS {
readonly "level": $Level

constructor(arg0: $Level$$Type, arg1: integer)
constructor(arg0: $Level$$Type, arg1: $Iterable$$Type<($Entity$$Type)>)

public "filter"(arg0: $List$$Type<($Predicate$$Type<($Entity$$Type)>)>): $EntityArrayList
public "getFirst"(): any
public "playSound"(arg0: $SoundEvent$$Type): void
public "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
public "kill"(): void
public "setStatusMessage"(arg0: $Component$$Type): void
public "setActivePostShader"(arg0: $ResourceLocation$$Type): void
public "runCommandSilent"(arg0: string): void
public "tell"(arg0: $Component$$Type): void
public "sendData"(arg0: string, arg1: $CompoundTag$$Type): void
public "getName"(): $Component
public "getDisplayName"(): $Component
public "runCommand"(arg0: string): void
public "filterSelector"(arg0: $EntitySelector$$Type): $EntityArrayList
public "addAllIterable"(arg0: $Iterable$$Type<($Entity$$Type)>): void
public "sendData"(arg0: string): void
public static "copyOf"<E>(arg0: $Collection$$Type<(E)>): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public "reversed"(): $SequencedCollection<(any)>
public "containsAll"(arg0: $Collection$$Type<(any)>): boolean
get "first"(): any
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityArrayList$$Type = ($EntityArrayList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityArrayList_ = $EntityArrayList$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.BasicBlockJS" {
import {$BlockHitResult, $BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Mirror, $Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$$Type} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Explosion, $Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$IdMapper, $IdMapper$$Type} from "net.minecraft.core.IdMapper"
import {$CollisionContext, $CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$StateDefinition, $StateDefinition$$Type} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation, $Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor, $LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $BasicBlockJS extends $Block implements $SimpleWaterloggedBlock {
readonly "blockBuilder": $BlockBuilder
readonly "shape": $VoxelShape
static readonly "CODEC": $MapCodec<($Block)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
readonly "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "hasCollision": boolean
 "explosionResistance": float
 "soundType": $SoundType
 "friction": float
 "speedFactor": float
 "jumpFactor": float
readonly "dynamicShape": boolean
 "drops": $ResourceKey<($LootTable)>

constructor(arg0: $BlockBuilder$$Type)

public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "stepOn"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Entity$$Type): void
public "useItemOn"(arg0: $ItemStack$$Type, arg1: $BlockState$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type, arg5: $InteractionHand$$Type, arg6: $BlockHitResult$$Type): $ItemInteractionResult
/**
 * 
 * @deprecated
 */
public "randomTick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
/**
 * 
 * @deprecated
 */
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "skipRendering"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public "wasExploded"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type): void
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "isRandomlyTicking"(arg0: $BlockState$$Type): boolean
/**
 * 
 * @deprecated
 */
public "getShadeBrightness"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): float
/**
 * 
 * @deprecated
 */
public "getVisualShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
/**
 * 
 * @deprecated
 */
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "getPickupSound"(): $Optional<($SoundEvent)>
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getBlockBuilder"(): $BlockBuilder
public "propagatesSkylightDown"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "canBeReplaced"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): boolean
public "asHolder"(): $Holder<(any)>
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
get "pickupSound"(): $Optional<($SoundEvent)>
get "blockBuilder"(): $BlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicBlockJS$$Type = ($BasicBlockJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicBlockJS_ = $BasicBlockJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.CategoryData" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $CategoryData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($CategoryData)>

constructor(arg0: $ResourceLocation$$Type)
constructor(category: $ResourceLocation$$Type, removedRecipes: $List$$Type<($ResourceLocation$$Type)>)

public "lock"(): $CategoryData
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "category"(): $ResourceLocation
public "removedRecipes"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CategoryData$$Type = ({"removedRecipes"?: $List$$Type<($ResourceLocation$$Type)>, "category"?: $ResourceLocation$$Type}) | ([removedRecipes?: $List$$Type<($ResourceLocation$$Type)>, category?: $ResourceLocation$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CategoryData_ = $CategoryData$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.AtlasSpriteRegistryKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $AtlasSpriteRegistryKubeEvent implements $KubeEvent {

constructor(arg0: $Consumer$$Type<($ResourceLocation)>)

public "register"(arg0: $ResourceLocation$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AtlasSpriteRegistryKubeEvent$$Type = ($AtlasSpriteRegistryKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AtlasSpriteRegistryKubeEvent_ = $AtlasSpriteRegistryKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent" {
import {$TinyMap, $TinyMap$$Type} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$RecipeComponentFactory, $RecipeComponentFactory$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeComponentFactory"
import {$RecipeComponentBuilder$Key, $RecipeComponentBuilder$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder$Key"
import {$ComponentRole, $ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$PairRecipeComponent, $PairRecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.PairRecipeComponent"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo, $ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$UniqueIdBuilder, $UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentValue, $RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$Either, $Either$$Type} from "com.mojang.datafixers.util.Either"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $EitherRecipeComponent<H, L> extends $Record implements $RecipeComponent<($Either<(H), (L)>)> {
static readonly "FACTORY": $RecipeComponentFactory

constructor(high: $RecipeComponent$$Type<(H)>, low: $RecipeComponent$$Type<(L)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "wrap"(arg1: $KubeRecipe$$Type, arg2: any): $Either<(H), (L)>
public "isEmpty"(arg0: $Either$$Type<(H), (L)>): boolean
public "isEmpty"(arg0: any): boolean
public "replace"(arg1: $KubeRecipe$$Type, arg2: any, arg3: $ReplacementMatchInfo$$Type, arg4: any): any
public "replace"(arg1: $KubeRecipe$$Type, arg2: $Either$$Type<(H), (L)>, arg3: $ReplacementMatchInfo$$Type, arg4: any): $Either<(H), (L)>
public "matches"(arg1: $KubeRecipe$$Type, arg2: any, arg3: $ReplacementMatchInfo$$Type): boolean
public "matches"(arg1: $KubeRecipe$$Type, arg2: $Either$$Type<(H), (L)>, arg3: $ReplacementMatchInfo$$Type): boolean
public "validate"(arg0: $Either$$Type<(H), (L)>): void
public "validate"(arg0: any): void
public "typeInfo"(): $TypeInfo
public "high"(): $RecipeComponent<(H)>
public "low"(): $RecipeComponent<(L)>
public "codec"(): $Codec<($Either<(H), (L)>)>
public "buildUniqueId"(arg0: $UniqueIdBuilder$$Type, arg1: $Either$$Type<(H), (L)>): void
public "buildUniqueId"(arg0: $UniqueIdBuilder$$Type, arg1: any): void
public static "builder"(arg0: $List$$Type<($RecipeComponentBuilder$Key$$Type)>): $RecipeComponentBuilder
public static "builder"(...arg0: ($RecipeComponentBuilder$Key$$Type)[]): $RecipeComponentBuilder
public "key"(arg0: string, arg1: $ComponentRole$$Type): $RecipeKey<($Either<(H), (L)>)>
public "asList"(): $RecipeComponent<($List<($Either<(H), (L)>)>)>
public "or"<O>(arg0: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<($Either<(H), (L)>), (O)>
public "and"<O>(arg0: $RecipeComponent$$Type<(O)>): $PairRecipeComponent<($Either<(H), (L)>), (O)>
public "asMap"<K>(arg0: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($Either<(H), (L)>)>)>
public "inputKey"(arg0: string): $RecipeKey<($Either<(H), (L)>)>
public "outputKey"(arg0: string): $RecipeKey<($Either<(H), (L)>)>
public "orSelf"(): $RecipeComponent<($Either<(H), (L)>)>
public "withCodec"(arg0: $Codec$$Type<($Either$$Type<(H), (L)>)>): $RecipeComponent<($Either<(H), (L)>)>
public "otherKey"(arg0: string): $RecipeKey<($Either<(H), (L)>)>
public "asConditionalListOrSelf"(): $RecipeComponent<($List<($Either<(H), (L)>)>)>
public "writeToJson"(arg0: $KubeRecipe$$Type, arg1: $RecipeComponentValue$$Type<($Either$$Type<(H), (L)>)>, arg2: $JsonObject$$Type): void
public "readFromJson"(arg0: $KubeRecipe$$Type, arg1: $RecipeComponentValue$$Type<($Either$$Type<(H), (L)>)>, arg2: $JsonObject$$Type): void
public "asConditionalList"(): $RecipeComponent<($List<($Either<(H), (L)>)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($Either<(H), (L)>)>)>
public "hasPriority"(arg1: $KubeRecipe$$Type, arg2: any): boolean
public "asListOrSelf"(): $RecipeComponent<($List<($Either<(H), (L)>)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EitherRecipeComponent$$Type<H, L> = ({"low"?: $RecipeComponent$$Type<(never)>, "high"?: $RecipeComponent$$Type<(never)>}) | ([low?: $RecipeComponent$$Type<(never)>, high?: $RecipeComponent$$Type<(never)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EitherRecipeComponent_<H, L> = $EitherRecipeComponent$$Type<(H), (L)>;
}}
declare module "dev.latvian.apps.tinyserver.http.response.HTTPResponse" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$HTTPResponseBuilder, $HTTPResponseBuilder$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPResponseBuilder"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$ResponseContent, $ResponseContent$$Type} from "dev.latvian.apps.tinyserver.content.ResponseContent"

export interface $HTTPResponse {

 "build"(arg0: $HTTPResponseBuilder$$Type): void
 "text"(arg0: string): $HTTPResponse
 "text"(arg0: $Iterable$$Type<(string)>): $HTTPResponse
 "header"(arg0: string, arg1: string): $HTTPResponse
 "content"(arg0: (byte)[], arg1: string): $HTTPResponse
 "content"(arg0: $ResponseContent$$Type): $HTTPResponse
 "content"(arg0: $Path$$Type, arg1: string): $HTTPResponse
 "content"(arg0: $Path$$Type): $HTTPResponse
 "json"(arg0: string): $HTTPResponse
 "noCache"(): $HTTPResponse
 "publicCache"(arg0: integer): $HTTPResponse
 "privateCache"(arg0: integer): $HTTPResponse

(arg0: $HTTPResponseBuilder): void
}

export namespace $HTTPResponse {
function created(): $HTTPResponse
function ok(): $HTTPResponse
function redirect(arg0: string): $HTTPResponse
function noContent(): $HTTPResponse
function redirectTemporary(arg0: string): $HTTPResponse
function movedPermanently(arg0: string): $HTTPResponse
function accepted(): $HTTPResponse
function redirectPermanently(arg0: string): $HTTPResponse
const probejs$$marker: never
}
export class $HTTPResponse$$Static implements $HTTPResponse {


static "created"(): $HTTPResponse
 "build"(arg0: $HTTPResponseBuilder$$Type): void
 "text"(arg0: string): $HTTPResponse
 "text"(arg0: $Iterable$$Type<(string)>): $HTTPResponse
static "ok"(): $HTTPResponse
 "header"(arg0: string, arg1: string): $HTTPResponse
 "content"(arg0: (byte)[], arg1: string): $HTTPResponse
 "content"(arg0: $ResponseContent$$Type): $HTTPResponse
 "content"(arg0: $Path$$Type, arg1: string): $HTTPResponse
 "content"(arg0: $Path$$Type): $HTTPResponse
static "redirect"(arg0: string): $HTTPResponse
 "json"(arg0: string): $HTTPResponse
static "noContent"(): $HTTPResponse
 "noCache"(): $HTTPResponse
static "redirectTemporary"(arg0: string): $HTTPResponse
 "publicCache"(arg0: integer): $HTTPResponse
static "movedPermanently"(arg0: string): $HTTPResponse
 "privateCache"(arg0: integer): $HTTPResponse
static "accepted"(): $HTTPResponse
static "redirectPermanently"(arg0: string): $HTTPResponse
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HTTPResponse$$Type = ((arg0: $HTTPResponseBuilder) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HTTPResponse_ = $HTTPResponse$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.BlockStateKJS" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$RelativeURL, $RelativeURL$$Type} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$Replaceable, $Replaceable$$Type} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$RegistryObjectKJS, $RegistryObjectKJS$$Type} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockStateKJS extends $RegistryObjectKJS<($Block)>, $Replaceable {

 "getId"(): string
 "getKey"(): $ResourceKey<($Block)>
 "asHolder"(): $Holder<($Block)>
 "replaceThisWith"(arg1: any): any
 "getRegistry"(): $Registry<($Block)>
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getWebIconURL"(arg0: integer): $RelativeURL
 "setDestroySpeed"(arg0: float): void
 "setRequiresTool"(arg0: boolean): void
 "setLightEmission"(arg0: integer): void
 "randomTickOverride"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): boolean
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
get "id"(): string
get "key"(): $ResourceKey<($Block)>
get "registry"(): $Registry<($Block)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
set "destroySpeed"(value: float)
set "requiresTool"(value: boolean)
set "lightEmission"(value: integer)
get "mod"(): string
get "idLocation"(): $ResourceLocation
get "tags"(): $Collection<($ResourceLocation)>
}

export namespace $BlockStateKJS {
const probejs$$marker: never
}
export class $BlockStateKJS$$Static implements $BlockStateKJS {


 "getId"(): string
 "getKey"(): $ResourceKey<($Block)>
 "asHolder"(): $Holder<($Block)>
 "replaceThisWith"(arg1: any): any
 "getRegistry"(): $Registry<($Block)>
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getWebIconURL"(arg0: integer): $RelativeURL
 "setDestroySpeed"(arg0: float): void
 "setRequiresTool"(arg0: boolean): void
 "setLightEmission"(arg0: integer): void
 "randomTickOverride"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): boolean
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateKJS$$Type = ($BlockStateKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateKJS_ = $BlockStateKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.level.BlockContainerJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Fireworks, $Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$ExplosionJS, $ExplosionJS$$Type} from "dev.latvian.mods.kubejs.level.ExplosionJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$SpecialEquality, $SpecialEquality$$Type} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockContainerJS implements $SpecialEquality {
readonly "minecraftLevel": $Level

constructor(arg0: $Level$$Type, arg1: $BlockPos$$Type)
constructor(arg0: $BlockEntity$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "offset"(arg0: integer, arg1: integer, arg2: integer): $BlockContainerJS
public "offset"(arg0: $Direction$$Type): $BlockContainerJS
public "offset"(arg0: $Direction$$Type, arg1: integer): $BlockContainerJS
public "set"(arg0: $Block$$Type, arg1: $Map$$Type<(any), (any)>): void
public "set"(arg0: $Block$$Type): void
public "set"(arg0: $Block$$Type, arg1: $Map$$Type<(any), (any)>, arg2: integer): void
public "getProperties"(): $Map<(string), (string)>
public "getId"(): $ResourceLocation
public "clearCache"(): void
public "getLevel"(): $Level
public "getItem"(): $ItemStack
public "getDimension"(): $ResourceLocation
public "getEntity"(): $BlockEntity
public "getY"(): integer
public "spawnLightning"(): void
public "spawnLightning"(arg0: boolean): void
public "spawnLightning"(arg0: boolean, arg1: $ServerPlayer$$Type): void
public "getZ"(): integer
public "getX"(): integer
public "hasTag"(arg0: $ResourceLocation$$Type): boolean
public "getTags"(): $Collection<($ResourceLocation)>
public "createEntity"(arg0: $EntityType$$Type<(any)>): $Entity
public "getLight"(): integer
public "getEntityId"(): string
public "getBlockState"(): $BlockState
public "getInventory"(): $InventoryKJS
public "getInventory"(arg0: $Direction$$Type): $InventoryKJS
public "specialEquals"(arg1: any, arg2: boolean): boolean
public "getEntityData"(): $CompoundTag
public "getDrops"(arg0: $Entity$$Type, arg1: $ItemStack$$Type): $List<($ItemStack)>
public "getDrops"(): $List<($ItemStack)>
public "getPos"(): $BlockPos
public "canSeeSkyFromBelowWater"(): boolean
public "setBlockState"(arg0: $BlockState$$Type, arg1: integer): void
public "setEntityData"(arg0: $CompoundTag$$Type): void
public "getSouth"(): $BlockContainerJS
public "getWest"(): $BlockContainerJS
public "getEast"(): $BlockContainerJS
public "popItem"(arg0: $ItemStack$$Type): void
public "getUp"(): $BlockContainerJS
public "getNorth"(): $BlockContainerJS
public "getDown"(): $BlockContainerJS
public "getBiomeId"(): $ResourceLocation
public "spawnFireworks"(arg0: $Fireworks$$Type, arg1: integer): void
public "getPlayersInRadius"(arg0: double): $EntityArrayList
public "getPlayersInRadius"(): $EntityArrayList
public "createExplosion"(): $ExplosionJS
public "getBlockLight"(): integer
public "getCanSeeSky"(): boolean
public "getTypeData"(): $Map<(string), (any)>
public "popItemFromFace"(arg0: $ItemStack$$Type, arg1: $Direction$$Type): void
public "mergeEntityData"(arg0: $CompoundTag$$Type): void
public "getSkyLight"(): integer
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
get "properties"(): $Map<(string), (string)>
get "id"(): $ResourceLocation
get "level"(): $Level
get "item"(): $ItemStack
get "dimension"(): $ResourceLocation
get "entity"(): $BlockEntity
get "y"(): integer
get "z"(): integer
get "x"(): integer
get "tags"(): $Collection<($ResourceLocation)>
get "light"(): integer
get "entityId"(): string
get "blockState"(): $BlockState
get "inventory"(): $InventoryKJS
get "entityData"(): $CompoundTag
get "drops"(): $List<($ItemStack)>
get "pos"(): $BlockPos
set "entityData"(value: $CompoundTag$$Type)
get "south"(): $BlockContainerJS
get "west"(): $BlockContainerJS
get "east"(): $BlockContainerJS
get "up"(): $BlockContainerJS
get "north"(): $BlockContainerJS
get "down"(): $BlockContainerJS
get "biomeId"(): $ResourceLocation
get "playersInRadius"(): $EntityArrayList
get "blockLight"(): integer
get "canSeeSky"(): boolean
get "typeData"(): $Map<(string), (any)>
get "skyLight"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockContainerJS$$Type = ($BlockContainerJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockContainerJS_ = $BlockContainerJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.mekanism.MekanismChemicalWrapper" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ChemicalIngredient, $ChemicalIngredient$$Type} from "mekanism.api.recipes.ingredients.chemical.ChemicalIngredient"
import {$ChemicalStackIngredient, $ChemicalStackIngredient$$Type} from "mekanism.api.recipes.ingredients.ChemicalStackIngredient"
import {$ChemicalStack, $ChemicalStack$$Type} from "mekanism.api.chemical.ChemicalStack"
import {$StringReader, $StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$Chemical, $Chemical$$Type} from "mekanism.api.chemical.Chemical"
import {$List, $List$$Type} from "java.util.List"

export interface $MekanismChemicalWrapper {

}

export namespace $MekanismChemicalWrapper {
const CHEMICAL_TYPE_INFO: $TypeInfo
const CHEMICAL_STACK_TYPE_INFO: $TypeInfo
const CHEMICAL_INGREDIENT_TYPE_INFO: $TypeInfo
const CHEMICAL_STACK_INGREDIENT_TYPE_INFO: $TypeInfo
function stack(arg0: $Chemical$$Type, arg1: long): $ChemicalStack
function of(arg0: any): $Chemical
function read(arg0: $StringReader$$Type): $Chemical
function readStack(arg0: $StringReader$$Type): $ChemicalStack
function readIngredient(arg0: $StringReader$$Type): $ChemicalIngredient
function ingredientOf(arg0: any): $ChemicalIngredient
function stackOf(arg0: any): $ChemicalStack
function ingredientStack(arg0: $ChemicalIngredient$$Type, arg1: long): $ChemicalStackIngredient
function ingredientExcept(arg0: $ChemicalIngredient$$Type, arg1: $ChemicalIngredient$$Type): $ChemicalIngredient
function ingredientIntersection(arg0: $List$$Type<($ChemicalIngredient$$Type)>): $ChemicalIngredient
function readStackIngredient(arg0: $StringReader$$Type): $ChemicalStackIngredient
const probejs$$marker: never
}
export class $MekanismChemicalWrapper$$Static implements $MekanismChemicalWrapper {
static readonly "CHEMICAL_TYPE_INFO": $TypeInfo
static readonly "CHEMICAL_STACK_TYPE_INFO": $TypeInfo
static readonly "CHEMICAL_INGREDIENT_TYPE_INFO": $TypeInfo
static readonly "CHEMICAL_STACK_INGREDIENT_TYPE_INFO": $TypeInfo


static "stack"(arg0: $Chemical$$Type, arg1: long): $ChemicalStack
static "of"(arg0: any): $Chemical
static "read"(arg0: $StringReader$$Type): $Chemical
static "readStack"(arg0: $StringReader$$Type): $ChemicalStack
static "readIngredient"(arg0: $StringReader$$Type): $ChemicalIngredient
static "ingredientOf"(arg0: any): $ChemicalIngredient
static "stackOf"(arg0: any): $ChemicalStack
static "ingredientStack"(arg0: $ChemicalIngredient$$Type, arg1: long): $ChemicalStackIngredient
static "ingredientExcept"(arg0: $ChemicalIngredient$$Type, arg1: $ChemicalIngredient$$Type): $ChemicalIngredient
static "ingredientIntersection"(arg0: $List$$Type<($ChemicalIngredient$$Type)>): $ChemicalIngredient
static "readStackIngredient"(arg0: $StringReader$$Type): $ChemicalStackIngredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MekanismChemicalWrapper$$Type = ($MekanismChemicalWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MekanismChemicalWrapper_ = $MekanismChemicalWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.FenceGateBlockBuilder" {
import {$WoodType, $WoodType$$Type} from "net.minecraft.world.level.block.state.properties.WoodType"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $FenceGateBlockBuilder extends $ShapedBlockBuilder {
static readonly "FENCE_GATE_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "behaviour"(arg0: $WoodType$$Type): this
public "behaviour"(arg0: string): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FenceGateBlockBuilder$$Type = ($FenceGateBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FenceGateBlockBuilder_ = $FenceGateBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent" {
import {$LocalPlayer, $LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$ClientKubeEvent, $ClientKubeEvent$$Type} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Minecraft, $Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $ClientPlayerKubeEvent implements $KubePlayerEvent, $ClientKubeEvent {

constructor(arg0: $LocalPlayer$$Type)

public "getEntity"(): $Entity
public "getPlayer"(): $LocalPlayer
public "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
get "entity"(): $Entity
get "player"(): $LocalPlayer
get "client"(): $Minecraft
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerKubeEvent$$Type = ($ClientPlayerKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientPlayerKubeEvent_ = $ClientPlayerKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.CreativeModeTabKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $CreativeModeTabKJS {

 "kjs$setDisplayName"(arg0: $Component$$Type): void
 "kjs$setIcon"(arg0: $ItemStack$$Type): void
}

export namespace $CreativeModeTabKJS {
const probejs$$marker: never
}
export class $CreativeModeTabKJS$$Static implements $CreativeModeTabKJS {


 "kjs$setDisplayName"(arg0: $Component$$Type): void
 "kjs$setIcon"(arg0: $ItemStack$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeModeTabKJS$$Type = ($CreativeModeTabKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeModeTabKJS_ = $CreativeModeTabKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.callbacks.EntitySteppedOnBlockCallbackJS" {
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EntitySteppedOnBlockCallbackJS {

constructor(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type)

/**
 * Returns the BlockState
 */
public "getState"(): $BlockState
/**
 * Returns the level
 */
public "getLevel"(): $Level
/**
 * Returns the entity
 */
public "getEntity"(): $Entity
/**
 * Returns the block
 */
public "getBlock"(): $BlockContainerJS
/**
 * Returns if the entity is suppressing bouncing (for players this is true if the player is crouching)
 */
public "isSuppressingBounce"(): boolean
/**
 * Returns the block's position
 */
public "getPos"(): $BlockPos
get "state"(): $BlockState
get "level"(): $Level
get "entity"(): $Entity
get "block"(): $BlockContainerJS
get "suppressingBounce"(): boolean
get "pos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySteppedOnBlockCallbackJS$$Type = ($EntitySteppedOnBlockCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntitySteppedOnBlockCallbackJS_ = $EntitySteppedOnBlockCallbackJS$$Type;
}}
declare module "dev.latvian.mods.rhino.IdFunctionCall" {
import {$Context, $Context$$Type} from "dev.latvian.mods.rhino.Context"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$IdFunctionObject, $IdFunctionObject$$Type} from "dev.latvian.mods.rhino.IdFunctionObject"

export interface $IdFunctionCall {

 "execIdCall"(arg0: $IdFunctionObject$$Type, arg1: $Context$$Type, arg2: $Scriptable$$Type, arg3: $Scriptable$$Type, arg4: (any)[]): any

(arg0: $IdFunctionObject, arg1: $Context, arg2: $Scriptable, arg3: $Scriptable, arg4: (any)[]): any
}

export namespace $IdFunctionCall {
const probejs$$marker: never
}
export class $IdFunctionCall$$Static implements $IdFunctionCall {


 "execIdCall"(arg0: $IdFunctionObject$$Type, arg1: $Context$$Type, arg2: $Scriptable$$Type, arg3: $Scriptable$$Type, arg4: (any)[]): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdFunctionCall$$Type = ((arg0: $IdFunctionObject, arg1: $Context, arg2: $Scriptable, arg3: $Scriptable, arg4: (any)[]) => any);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdFunctionCall_ = $IdFunctionCall$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.DetectorBlockKubeEvent" {
import {$KubeLevelEvent, $KubeLevelEvent$$Type} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a detector block registered in KubeJS receives a block update.
 * 
 * `Powered`/`Unpowered` event will be fired when the detector block is powered/unpowered.
 */
export class $DetectorBlockKubeEvent implements $KubeLevelEvent {

constructor(arg0: string, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: boolean)

/**
 * The level where the detector block is located.
 */
public "getLevel"(): $Level
/**
 * The detector block.
 */
public "getBlock"(): $BlockContainerJS
/**
 * If the detector block is powered.
 */
public "isPowered"(): boolean
/**
 * The id of the detector block when it was registered.
 */
public "getDetectorId"(): string
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "level"(): $Level
get "block"(): $BlockContainerJS
get "powered"(): boolean
get "detectorId"(): string
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DetectorBlockKubeEvent$$Type = ($DetectorBlockKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DetectorBlockKubeEvent_ = $DetectorBlockKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.DebugInfoKubeEvent" {
import {$LocalPlayer, $LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$List, $List$$Type} from "java.util.List"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ClientPlayerKubeEvent, $ClientPlayerKubeEvent$$Type} from "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent"

/**
 * Invoked when the debug info is rendered.
 */
export class $DebugInfoKubeEvent extends $ClientPlayerKubeEvent {

constructor(arg0: $LocalPlayer$$Type, arg1: $List$$Type<(string)>)

/**
 * The lines of debug info. Mutating this list will change the debug info.
 */
public "getLines"(): $List<(string)>
/**
 * Whether the debug info should be rendered.
 */
public "getShowDebug"(): boolean
public "getEntity"(): $Entity
get "lines"(): $List<(string)>
get "showDebug"(): boolean
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DebugInfoKubeEvent$$Type = ($DebugInfoKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DebugInfoKubeEvent_ = $DebugInfoKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.event.EventTargetType$Transformer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $EventTargetType$Transformer {

 "transform"(arg0: any): any

(arg0: any): any
}

export namespace $EventTargetType$Transformer {
const IDENTITY: $EventTargetType$Transformer
const probejs$$marker: never
}
export class $EventTargetType$Transformer$$Static implements $EventTargetType$Transformer {
static readonly "IDENTITY": $EventTargetType$Transformer


 "transform"(arg0: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventTargetType$Transformer$$Type = ((arg0: any) => any);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventTargetType$Transformer_ = $EventTargetType$Transformer$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RemoveEntriesKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $RemoveEntriesKubeEvent<E, F> extends $KubeEvent {

 "remove"(arg1: F): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any

(arg1: F): void
}

export namespace $RemoveEntriesKubeEvent {
const probejs$$marker: never
}
export class $RemoveEntriesKubeEvent$$Static<E, F> implements $RemoveEntriesKubeEvent {


 "remove"(arg1: F): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveEntriesKubeEvent$$Type<E, F> = ((arg1: any) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoveEntriesKubeEvent_<E, F> = $RemoveEntriesKubeEvent$$Type<(E), (F)>;
}}
declare module "dev.latvian.mods.rhino.type.TypeStringContext" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"
import {$ClassTypeInfo, $ClassTypeInfo$$Type} from "dev.latvian.mods.rhino.type.ClassTypeInfo"

export interface $TypeStringContext {

 "toString"(info: $TypeInfo$$Type): string
 "append"(sb: $StringBuilder$$Type, type: $TypeInfo$$Type): void
 "appendSpace"(sb: $StringBuilder$$Type): void
 "appendClassName"(sb: $StringBuilder$$Type, type: $ClassTypeInfo$$Type): void
}

export namespace $TypeStringContext {
const DEFAULT: $TypeStringContext
const probejs$$marker: never
}
export class $TypeStringContext$$Static implements $TypeStringContext {
static readonly "DEFAULT": $TypeStringContext


 "toString"(info: $TypeInfo$$Type): string
 "append"(sb: $StringBuilder$$Type, type: $TypeInfo$$Type): void
 "appendSpace"(sb: $StringBuilder$$Type): void
 "appendClassName"(sb: $StringBuilder$$Type, type: $ClassTypeInfo$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeStringContext$$Type = ($TypeStringContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeStringContext_ = $TypeStringContext$$Type;
}}
declare module "dev.latvian.mods.kubejs.event.EventResult$Type" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$EventExit, $EventExit$$Type} from "dev.latvian.mods.kubejs.event.EventExit"
import {$EventResult, $EventResult$$Type} from "dev.latvian.mods.kubejs.event.EventResult"

export class $EventResult$Type extends $Enum<($EventResult$Type)> {
static readonly "ERROR": $EventResult$Type
static readonly "PASS": $EventResult$Type
static readonly "INTERRUPT_DEFAULT": $EventResult$Type
static readonly "INTERRUPT_FALSE": $EventResult$Type
static readonly "INTERRUPT_TRUE": $EventResult$Type
readonly "defaultResult": $EventResult
readonly "defaultExit": $EventExit


public "exit"(arg0: any): $EventExit
public static "values"(): ($EventResult$Type)[]
public static "valueOf"(arg0: string): $EventResult$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventResult$Type$$Type = (("error") | ("pass") | ("interrupt_default") | ("interrupt_false") | ("interrupt_true"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventResult$Type_ = $EventResult$Type$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch" {
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"

export interface $ReplacementMatch {

}

export namespace $ReplacementMatch {
const NONE: $ReplacementMatch
function wrap(arg1: any): $ReplacementMatch
const probejs$$marker: never
}
export class $ReplacementMatch$$Static implements $ReplacementMatch {
static readonly "NONE": $ReplacementMatch


static "wrap"(arg1: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplacementMatch$$Type = ($Ingredient$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReplacementMatch_ = $ReplacementMatch$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemTintFunction, $ItemTintFunction$$Type} from "dev.latvian.mods.kubejs.item.ItemTintFunction"
import {$JukeboxSong, $JukeboxSong$$Type} from "net.minecraft.world.item.JukeboxSong"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$ItemBuilder$ReleaseUsingCallback, $ItemBuilder$ReleaseUsingCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$ReleaseUsingCallback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$ItemBuilder$HurtEnemyContext, $ItemBuilder$HurtEnemyContext$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$HurtEnemyContext"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$FoodBuilder, $FoodBuilder$$Type} from "dev.latvian.mods.kubejs.item.FoodBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ItemBuilder$FinishUsingCallback, $ItemBuilder$FinishUsingCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$FinishUsingCallback"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$TickDuration, $TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$ItemBuilder$NameCallback, $ItemBuilder$NameCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$NameCallback"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$ToIntBiFunction, $ToIntBiFunction$$Type} from "java.util.function.ToIntBiFunction"
import {$ModelledBuilderBase, $ModelledBuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.ModelledBuilderBase"
import {$Rarity, $Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$UseAnim, $UseAnim$$Type} from "net.minecraft.world.item.UseAnim"
import {$ItemBuilder$UseCallback, $ItemBuilder$UseCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$UseCallback"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"

export class $ItemBuilder extends $ModelledBuilderBase<($Item)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

/**
 * Sets the item's name dynamically.
 */
public "name"(arg0: $ItemBuilder$NameCallback$$Type): this
/**
 * 
 * @deprecated
 */
public "group"(arg0: string): this
public "component"<T>(arg0: $DataComponentType$$Type<(T)>, arg1: T): this
/**
 * Determines if player will start using the item.
 * 
 * For example, when eating food, returning true will make the player start eating the food.
 */
public "use"(arg0: $ItemBuilder$UseCallback$$Type): this
/**
 * Colorizes item's texture of the given index. Useful for coloring items, like GT ores ore dusts.
 */
public "color"(arg0: $ItemTintFunction$$Type): this
/**
 * Colorizes item's texture of the given index. Index is used when you have multiple layers, e.g. a crushed ore (of rock + ore).
 */
public "color"(arg0: integer, arg1: $ItemTintFunction$$Type): this
/**
 * Sets the item's max stack size. Default is 64.
 */
public "maxStackSize"(arg0: integer): this
/**
 * Sets the item's container item, e.g. a bucket for a milk bucket.
 */
public "containerItem"(arg0: $ResourceLocation$$Type): this
public "transformObject"(arg0: $Item$$Type): $Item
/**
 * Makes the item not stackable, equivalent to setting the item's max stack size to 1.
 */
public "unstackable"(): this
/**
 * Determines the animation of the item when used, e.g. eating food.
 */
public "useAnimation"(arg0: $UseAnim$$Type): this
public "disableRepair"(): this
/**
 * Determines the color of the item's durability bar. Defaulted to vanilla behavior.
 */
public "barColor"(arg0: $Function$$Type<($ItemStack), ($KubeColor$$Type)>): this
/**
 * Set the food nutrition and saturation of the item.
 */
public "food"(arg0: integer, arg1: float): this
/**
 * Set the food properties of the item.
 */
public "food"(arg0: $Consumer$$Type<($FoodBuilder)>): this
/**
 * Makes the item glow like enchanted, even if it's not enchanted.
 */
public "glow"(arg0: boolean): this
/**
 * Adds a tooltip to the item.
 */
public "tooltip"(arg0: $Component$$Type): this
/**
 * Determines the width of the item's durability bar. Defaulted to vanilla behavior.
 * 
 * The function should return a value between 0 and 13 (max width of the bar).
 */
public "barWidth"(arg0: $ToIntFunction$$Type<($ItemStack)>): this
/**
 * The duration when the item is used.
 * 
 * For example, when eating food, this is the time it takes to eat the food.
 * This can change the eating speed, or be used for other things (like making a custom bow).
 */
public "useDuration"(arg0: $ToIntBiFunction$$Type<($ItemStack), ($LivingEntity)>): this
/**
 * When players did not finish using the item but released the right mouse button halfway through.
 * 
 * An example is the bow, where the arrow is shot when the player releases the right mouse button.
 * 
 * To ensure the bow won't finish using, Minecraft sets the `useDuration` to a very high number (1h).
 */
public "releaseUsing"(arg0: $ItemBuilder$ReleaseUsingCallback$$Type): this
/**
 * Makes the item fire resistant like netherite tools (or not).
 */
public "fireResistant"(arg0: boolean): this
/**
 * Makes the item fire resistant like netherite tools.
 */
public "fireResistant"(): this
public "jukeboxPlayable"(arg0: $ResourceKey$$Type<($JukeboxSong)>, arg1: boolean): this
public "jukeboxPlayable"(arg0: $ResourceKey$$Type<($JukeboxSong)>): this
/**
 * When players finish using the item.
 * 
 * This is called only when `useDuration` ticks have passed.
 * 
 * For example, when eating food, this is called when the player has finished eating the food, so hunger is restored.
 */
public "finishUsing"(arg0: $ItemBuilder$FinishUsingCallback$$Type): this
/**
 * Sets the item's burn time. Default is 0 (Not a fuel).
 */
public "burnTime"(arg0: $TickDuration$$Type): this
/**
 * Sets the item's max damage. Default is 0 (No durability).
 */
public "maxDamage"(arg0: integer): this
/**
 * Adds subtypes to the item. The function should return a collection of item stacks, each with a different subtype.
 * 
 * Each subtype will appear as a separate item in JEI and the creative inventory.
 */
public "subtypes"(arg0: $Function$$Type<($ItemStack), ($Collection$$Type<($ItemStack$$Type)>)>): this
/**
 * Gets called when the item is used to hurt an entity.
 * 
 * For example, when using a sword to hit a mob, this is called.
 */
public "hurtEnemy"(arg0: $Predicate$$Type<($ItemBuilder$HurtEnemyContext)>): this
/**
 * Sets the item's rarity.
 */
public "rarity"(arg0: $Rarity$$Type): this
public "createItemProperties"(): $Item$Properties
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$$Type = ($ItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBuilder_ = $ItemBuilder$$Type;
}}
declare module "dev.latvian.mods.rhino.util.ArrayValueProvider" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$NativeArray, $NativeArray$$Type} from "dev.latvian.mods.rhino.NativeArray"
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$List, $List$$Type} from "java.util.List"

export interface $ArrayValueProvider {

 "getLength"(): integer
 "createList"(target: $TypeInfo$$Type): any
 "createArray"(target: $TypeInfo$$Type): any
 "createSet"(target: $TypeInfo$$Type): any
 "getArrayValue"(arg1: integer): any
 "getErrorSource"(): any
get "length"(): integer
get "errorSource"(): any
}

export namespace $ArrayValueProvider {
const EMPTY: $ArrayValueProvider
function fromIterable(iterable: $Iterable$$Type<(any)>): $ArrayValueProvider
function fromNativeArray(array: $NativeArray$$Type): $ArrayValueProvider
function fromJavaList(list: $List$$Type<(any)>, errorSource: any): $ArrayValueProvider
const probejs$$marker: never
}
export class $ArrayValueProvider$$Static implements $ArrayValueProvider {
static readonly "EMPTY": $ArrayValueProvider


 "getLength"(): integer
 "createList"(target: $TypeInfo$$Type): any
static "fromIterable"(iterable: $Iterable$$Type<(any)>): $ArrayValueProvider
static "fromNativeArray"(array: $NativeArray$$Type): $ArrayValueProvider
static "fromJavaList"(list: $List$$Type<(any)>, errorSource: any): $ArrayValueProvider
 "createArray"(target: $TypeInfo$$Type): any
 "createSet"(target: $TypeInfo$$Type): any
 "getArrayValue"(arg1: integer): any
 "getErrorSource"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayValueProvider$$Type = ($ArrayValueProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayValueProvider_ = $ArrayValueProvider$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.callbacks.AfterEntityFallenOnBlockCallbackJS" {
import {$EntitySteppedOnBlockCallbackJS, $EntitySteppedOnBlockCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.EntitySteppedOnBlockCallbackJS"
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"

export class $AfterEntityFallenOnBlockCallbackJS extends $EntitySteppedOnBlockCallbackJS {

constructor(arg0: $BlockGetter$$Type, arg1: $Entity$$Type)

/**
 * Sets the entity's velocity
 */
public "setVelocity"(arg0: float, arg1: float, arg2: float): void
/**
 * Sets the entity's velocity
 */
public "setVelocity"(arg0: $Vec3$$Type): void
/**
 * Bounce the entity upwards by bounciness * their fall velocity.
 * Do not make bounciness negative, as that is a recipe for a long and laggy trip to the void
 */
public "bounce"(arg0: float): void
/**
 * Returns the Vec3 of the entity's velocity. Use .x, .y and .z to get the respective components of that
 */
public "getVelocity"(): $Vec3
set "velocity"(value: $Vec3$$Type)
get "velocity"(): $Vec3
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterEntityFallenOnBlockCallbackJS$$Type = ($AfterEntityFallenOnBlockCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AfterEntityFallenOnBlockCallbackJS_ = $AfterEntityFallenOnBlockCallbackJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeSchemaFunction, $RecipeSchemaFunction$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaFunction"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$KubeRecipeFactory, $KubeRecipeFactory$$Type} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction, $RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$RecipeConstructor, $RecipeConstructor$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeConstructor"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$RecipeOptional, $RecipeOptional$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Int2ObjectMap, $Int2ObjectMap$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectMap"

export class $RecipeSchema {
static readonly "DEFAULT_UNIQUE_ID_FUNCTION": $Function<($KubeRecipe), (string)>
 "recipeFactory": $KubeRecipeFactory
readonly "keys": $List<($RecipeKey<(any)>)>
readonly "includedKeys": $List<($RecipeKey<(any)>)>
readonly "keyOverrides": $Map<($RecipeKey<(any)>), ($RecipeOptional<(any)>)>
readonly "functions": $Map<(string), ($RecipeSchemaFunction)>

constructor(arg0: $Map$$Type<($RecipeKey$$Type<(any)>), ($RecipeOptional$$Type<(any)>)>, arg1: $List$$Type<($RecipeKey$$Type<(any)>)>)
constructor(...arg0: ($RecipeKey$$Type<(any)>)[])

public "isHidden"(): boolean
public "getKey"<T>(arg0: string): $RecipeKey<(T)>
public "factory"(arg0: $KubeRecipeFactory$$Type): $RecipeSchema
public "constructor"(arg0: $RecipeConstructor$$Type): $RecipeSchema
public "addConstructor"(...arg0: ($RecipeKey$$Type<(any)>)[]): $RecipeSchema
public "constructors"(): $Int2ObjectMap<($RecipeConstructor)>
public "function"(arg0: string, arg1: $RecipeSchemaFunction$$Type): $RecipeSchema
public "deserialize"(arg0: $SourceLine$$Type, arg1: $RecipeTypeFunction$$Type, arg2: $ResourceLocation$$Type, arg3: $JsonObject$$Type): $KubeRecipe
public "outputCount"(): integer
public "uniqueId"(arg0: $RecipeKey$$Type<(any)>): $RecipeSchema
public "uniqueIds"(): $List<($RecipeKey<(any)>)>
public "uniqueIds"(arg0: $SequencedCollection$$Type<($RecipeKey$$Type<(any)>)>): $RecipeSchema
public "inputCount"(): integer
public "typeOverride"(arg0: $ResourceLocation$$Type): $RecipeSchema
public "setOpFunction"<T>(arg0: string, arg1: $RecipeKey$$Type<(T)>, arg2: T): $RecipeSchema
public "buildUniqueId"(arg0: $KubeRecipe$$Type): string
public "constructorsGenerated"(): boolean
public "addToListOpFunction"<T>(arg0: string, arg1: $RecipeKey$$Type<($List$$Type<(T)>)>): $RecipeSchema
public "minRequiredArguments"(): integer
get "hidden"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchema$$Type = ($RecipeSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeSchema_ = $RecipeSchema$$Type;
}}
declare module "dev.latvian.mods.kubejs.player.PlayerRespawnedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player respawns.
 * 
 * The reason of respawn can be either death or returning from the end.
 */
export class $PlayerRespawnedKubeEvent implements $KubePlayerEvent {

constructor(arg0: $ServerPlayer$$Type, arg1: boolean)

/**
 * Gets the player that respawned.
 */
public "getEntity"(): $Player
public "isEndConquered"(): boolean
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "entity"(): $Player
get "endConquered"(): boolean
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerRespawnedKubeEvent$$Type = ($PlayerRespawnedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerRespawnedKubeEvent_ = $PlayerRespawnedKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.PressurePlateBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$BlockSetType, $BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $PressurePlateBlockBuilder extends $ShapedBlockBuilder {
static readonly "PRESSURE_PLATE_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "behaviour"(arg0: $BlockSetType$$Type): this
public "behaviour"(arg0: string): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressurePlateBlockBuilder$$Type = ($PressurePlateBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PressurePlateBlockBuilder_ = $PressurePlateBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.text.action.TextActionBuilder" {
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export class $TextActionBuilder {

constructor()

public "insert"(arg0: integer, arg1: $List$$Type<($Component$$Type)>): void
public "clear"(): void
public "add"(arg0: $List$$Type<($Component$$Type)>): void
public "dynamic"(arg0: string): void
public "removeLine"(arg0: integer): void
public "removeText"(arg0: $Component$$Type): void
public "removeExactText"(arg0: $Component$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextActionBuilder$$Type = ($TextActionBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextActionBuilder_ = $TextActionBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.server.tag.PreTagWrapper" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$List, $List$$Type} from "java.util.List"
import {$PreTagKubeEvent, $PreTagKubeEvent$$Type} from "dev.latvian.mods.kubejs.server.tag.PreTagKubeEvent"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$TagWrapper, $TagWrapper$$Type} from "dev.latvian.mods.kubejs.server.tag.TagWrapper"
import {$TagKubeEvent, $TagKubeEvent$$Type} from "dev.latvian.mods.kubejs.server.tag.TagKubeEvent"

export class $PreTagWrapper extends $TagWrapper {
readonly "preEvent": $PreTagKubeEvent
readonly "id": $ResourceLocation
readonly "event": $TagKubeEvent
readonly "entries": $List<($TagLoader$EntryWithSource)>

constructor(arg0: $PreTagKubeEvent$$Type, arg1: $ResourceLocation$$Type)

public "remove"(...arg0: (any)[]): $TagWrapper
public "add"(...arg0: (any)[]): $TagWrapper
public "removeAll"(): $TagWrapper
public "getObjectIds"(): $List<($ResourceLocation)>
get "objectIds"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PreTagWrapper$$Type = ($PreTagWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PreTagWrapper_ = $PreTagWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.misc.SoundEventBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$SoundsGenerator$SoundGen, $SoundsGenerator$SoundGen$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundGen"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $SoundEventBuilder extends $BuilderBase<($SoundEvent)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "sounds"(arg0: $Consumer$$Type<($SoundsGenerator$SoundGen)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundEventBuilder$$Type = ($SoundEventBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundEventBuilder_ = $SoundEventBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemModificationKubeEvent$ItemModifications" {
import {$ComponentFunctions, $ComponentFunctions$$Type} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$Potion, $Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$ItemAttributeModifiers$Entry, $ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$List, $List$$Type} from "java.util.List"
import {$FireworkExplosion, $FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties, $FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$MutableToolTier, $MutableToolTier$$Type} from "dev.latvian.mods.kubejs.item.MutableToolTier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents, $PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$TickDuration, $TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Instrument, $Instrument$$Type} from "net.minecraft.world.item.Instrument"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Rarity, $Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Tool, $Tool$$Type} from "net.minecraft.world.item.component.Tool"
import {$Fireworks, $Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$ItemComponentFunctions, $ItemComponentFunctions$$Type} from "dev.latvian.mods.kubejs.component.ItemComponentFunctions"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$Unit, $Unit$$Type} from "net.minecraft.util.Unit"

export class $ItemModificationKubeEvent$ItemModifications extends $Record implements $ItemComponentFunctions {

constructor(item: $Item$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "item"(): $Item
public "disableRepair"(): void
public "setNameKey"(arg0: string): void
public "getComponentMap"(): $DataComponentMap
public "setBurnTime"(arg0: $TickDuration$$Type): void
public "setCraftingRemainder"(arg0: $Item$$Type): void
public "setTier"(arg0: $Consumer$$Type<($MutableToolTier)>): void
public "setItemName"(arg0: $Component$$Type): void
public "setDamage"(arg0: integer): void
public "setMaxDamage"(arg0: integer): void
public "setFireworks"(arg0: $Fireworks$$Type): void
public "setTool"(arg0: $Tool$$Type): void
public "setFood"(arg0: $FoodProperties$$Type): void
public "setFood"(arg0: integer, arg1: float): void
public "setRepairCost"(arg0: integer): void
public "setInstrument"(arg0: $Holder$$Type<($Instrument)>): void
public "setUnbreakable"(): void
public "setUnbreakableWithTooltip"(): void
public "setMaxStackSize"(arg0: integer): void
public "setFireworkExplosion"(arg0: $FireworkExplosion$$Type): void
public "setChargedProjectiles"(arg0: $List$$Type<($ItemStack$$Type)>): void
public "setBlockEntityData"(arg0: $CompoundTag$$Type): void
public "setBucketEntityData"(arg0: $CompoundTag$$Type): void
public "setNoteBlockSound"(arg0: $ResourceLocation$$Type): void
public "setMapItemColor"(arg0: $KubeColor$$Type): void
public "setFireResistant"(): void
public "setBundleContents"(arg0: $List$$Type<($ItemStack$$Type)>): void
public "setAttributeModifiersWithTooltip"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
public "setUnit"(arg0: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
public "setLockCode"(arg0: string): void
public "setCustomData"(arg0: $CompoundTag$$Type): void
public "setRarity"(arg0: $Rarity$$Type): void
public "setCustomName"(arg0: $Component$$Type): void
public "getCustomName"(): $Component
public "setLore"(arg0: $List$$Type<($Component$$Type)>): void
public "setLore"(arg0: $List$$Type<($Component$$Type)>, arg1: $List$$Type<($Component$$Type)>): void
public "setDyedColor"(arg0: $KubeColor$$Type): void
public "getCustomData"(): $CompoundTag
public "setPotionId"(arg0: $Holder$$Type<($Potion)>): void
public "setEntityData"(arg0: $CompoundTag$$Type): void
public "setProfile"(arg0: $GameProfile$$Type): void
public "setProfile"(arg0: string, arg1: $UUID$$Type): void
public "setBaseColor"(arg0: $DyeColor$$Type): void
public "setAdditionalTooltipHidden"(): void
public "setBlockStateProperties"(arg0: $Map$$Type<(string), (string)>): void
public "setDyedColorWithTooltip"(arg0: $KubeColor$$Type): void
public "set"(arg1: $DataComponentType$$Type<(any)>, arg2: any): $ComponentFunctions
public "set"(arg1: $DataComponentMap$$Type): $ComponentFunctions
public "patch"(arg1: $DataComponentPatch$$Type): $ComponentFunctions
public "get"<T>(arg0: $DataComponentType$$Type<(T)>): T
public "remove"(arg0: $DataComponentType$$Type<(any)>): $ComponentFunctions
public "setPotionContents"(arg0: $PotionContents$$Type): void
public "setGlintOverride"(arg0: boolean): void
public "getComponentString"(): string
public "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
public "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
public "setTooltipHidden"(): void
public "setCustomModelData"(arg0: integer): void
public "resetComponents"(): $ComponentFunctions
public "setAttributeModifiers"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
set "nameKey"(value: string)
get "componentMap"(): $DataComponentMap
set "burnTime"(value: $TickDuration$$Type)
set "craftingRemainder"(value: $Item$$Type)
set "tier"(value: $Consumer$$Type<($MutableToolTier)>)
set "itemName"(value: $Component$$Type)
set "damage"(value: integer)
set "maxDamage"(value: integer)
set "fireworks"(value: $Fireworks$$Type)
set "tool"(value: $Tool$$Type)
set "food"(value: $FoodProperties$$Type)
set "repairCost"(value: integer)
set "instrument"(value: $Holder$$Type<($Instrument)>)
set "maxStackSize"(value: integer)
set "fireworkExplosion"(value: $FireworkExplosion$$Type)
set "chargedProjectiles"(value: $List$$Type<($ItemStack$$Type)>)
set "blockEntityData"(value: $CompoundTag$$Type)
set "bucketEntityData"(value: $CompoundTag$$Type)
set "noteBlockSound"(value: $ResourceLocation$$Type)
set "mapItemColor"(value: $KubeColor$$Type)
set "bundleContents"(value: $List$$Type<($ItemStack$$Type)>)
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
set "lockCode"(value: string)
set "customData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "customName"(value: $Component$$Type)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "dyedColor"(value: $KubeColor$$Type)
get "customData"(): $CompoundTag
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(string), (string)>)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
set "glintOverride"(value: boolean)
get "componentString"(): string
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
set "customModelData"(value: integer)
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModificationKubeEvent$ItemModifications$$Type = ({"item"?: $Item$$Type}) | ([item?: $Item$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemModificationKubeEvent$ItemModifications_ = $ItemModificationKubeEvent$ItemModifications$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.data.ExportablePackResources" {
import {$PackLocationInfo, $PackLocationInfo$$Type} from "net.minecraft.server.packs.PackLocationInfo"
import {$KnownPack, $KnownPack$$Type} from "net.minecraft.server.packs.repository.KnownPack"
import {$MetadataSectionSerializer, $MetadataSectionSerializer$$Type} from "net.minecraft.server.packs.metadata.MetadataSectionSerializer"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$PackResources, $PackResources$$Type} from "net.minecraft.server.packs.PackResources"
import {$IoSupplier, $IoSupplier$$Type} from "net.minecraft.server.packs.resources.IoSupplier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PackType, $PackType$$Type} from "net.minecraft.server.packs.PackType"
import {$PackResources$ResourceOutput, $PackResources$ResourceOutput$$Type} from "net.minecraft.server.packs.PackResources$ResourceOutput"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$InputStream, $InputStream$$Type} from "java.io.InputStream"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ExportablePackResources extends $PackResources {

 "export"(arg0: $Path$$Type): void
 "exportPath"(): string
 "getResource"(arg0: $PackType$$Type, arg1: $ResourceLocation$$Type): $IoSupplier<($InputStream)>
 "location"(): $PackLocationInfo
 "close"(): void
 "listResources"(arg0: $PackType$$Type, arg1: string, arg2: string, arg3: $PackResources$ResourceOutput$$Type): void
 "getNamespaces"(arg0: $PackType$$Type): $Set<(string)>
 "packId"(): string
 "getRootResource"(...arg0: (string)[]): $IoSupplier<($InputStream)>
 "getMetadataSection"<T>(arg0: $MetadataSectionSerializer$$Type<(T)>): T
 "knownPackInfo"(): $Optional<($KnownPack)>
 "isHidden"(): boolean
get "hidden"(): boolean
}

export namespace $ExportablePackResources {
const probejs$$marker: never
}
export class $ExportablePackResources$$Static implements $ExportablePackResources {


 "export"(arg0: $Path$$Type): void
 "exportPath"(): string
 "getResource"(arg0: $PackType$$Type, arg1: $ResourceLocation$$Type): $IoSupplier<($InputStream)>
 "location"(): $PackLocationInfo
 "close"(): void
 "listResources"(arg0: $PackType$$Type, arg1: string, arg2: string, arg3: $PackResources$ResourceOutput$$Type): void
 "getNamespaces"(arg0: $PackType$$Type): $Set<(string)>
 "packId"(): string
 "getRootResource"(...arg0: (string)[]): $IoSupplier<($InputStream)>
 "getMetadataSection"<T>(arg0: $MetadataSectionSerializer$$Type<(T)>): T
 "knownPackInfo"(): $Optional<($KnownPack)>
 "isHidden"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExportablePackResources$$Type = ($ExportablePackResources);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExportablePackResources_ = $ExportablePackResources$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.InventoryKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$List, $List$$Type} from "java.util.List"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"

export interface $InventoryKJS {

 "asContainer"(): $Container
 "getStackInSlot"(arg0: integer): $ItemStack
 "getSlots"(): integer
 "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
 "getHeight"(): integer
 "setChanged"(): void
 "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
 "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
 "insertItem"(arg0: $ItemStack$$Type, arg1: boolean): $ItemStack
 "getAllItems"(): $List<($ItemStack)>
 "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
 "getSlotLimit"(arg0: integer): integer
 "isMutable"(): boolean
 "countNonEmpty"(): integer
 "countNonEmpty"(arg0: $ItemPredicate$$Type): integer
 "getWidth"(): integer
 "isEmpty"(): boolean
 "getBlock"(arg0: $Level$$Type): $BlockContainerJS
 "find"(): integer
 "find"(arg0: $ItemPredicate$$Type): integer
 "clear"(arg0: $ItemPredicate$$Type): void
 "clear"(): void
 "count"(arg0: $ItemPredicate$$Type): integer
 "count"(): integer
get "slots"(): integer
get "height"(): integer
get "allItems"(): $List<($ItemStack)>
get "mutable"(): boolean
get "width"(): integer
get "empty"(): boolean
}

export namespace $InventoryKJS {
const probejs$$marker: never
}
export class $InventoryKJS$$Static implements $InventoryKJS {


 "asContainer"(): $Container
 "getStackInSlot"(arg0: integer): $ItemStack
 "getSlots"(): integer
 "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
 "getHeight"(): integer
 "setChanged"(): void
 "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
 "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
 "insertItem"(arg0: $ItemStack$$Type, arg1: boolean): $ItemStack
 "getAllItems"(): $List<($ItemStack)>
 "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
 "getSlotLimit"(arg0: integer): integer
 "isMutable"(): boolean
 "countNonEmpty"(): integer
 "countNonEmpty"(arg0: $ItemPredicate$$Type): integer
 "getWidth"(): integer
 "isEmpty"(): boolean
 "getBlock"(arg0: $Level$$Type): $BlockContainerJS
 "find"(): integer
 "find"(arg0: $ItemPredicate$$Type): integer
 "clear"(arg0: $ItemPredicate$$Type): void
 "clear"(): void
 "count"(arg0: $ItemPredicate$$Type): integer
 "count"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryKJS$$Type = ($InventoryKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryKJS_ = $InventoryKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.NotificationToastData" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Duration, $Duration$$Type} from "java.time.Duration"
import {$IconKJS, $IconKJS$$Type} from "dev.latvian.mods.kubejs.util.IconKJS"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $NotificationToastData extends $Record {
static readonly "DEFAULT_DURATION": $Duration
static readonly "DEFAULT_BORDER_COLOR": $KubeColor
static readonly "DEFAULT_BACKGROUND_COLOR": $KubeColor
static readonly "CODEC": $MapCodec<($NotificationToastData)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($NotificationToastData)>

constructor(duration: $Duration$$Type, text: $Component$$Type, icon: $IconKJS$$Type, iconSize: integer, outlineColor: $KubeColor$$Type, borderColor: $KubeColor$$Type, backgroundColor: $KubeColor$$Type, textShadow: boolean)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "duration"(): $Duration
public "text"(): $Component
public "icon"(): $IconKJS
public "outlineColor"(): $KubeColor
public "show"(): void
public static "ofTitle"(arg0: $Component$$Type, arg1: $Component$$Type): $NotificationToastData
public "backgroundColor"(): $KubeColor
public "borderColor"(): $KubeColor
public "iconSize"(): integer
public "textShadow"(): boolean
public static "ofText"(arg0: $Component$$Type): $NotificationToastData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotificationToastData$$Type = ({"icon"?: $IconKJS$$Type, "iconSize"?: integer, "text"?: $Component$$Type, "textShadow"?: boolean, "outlineColor"?: $KubeColor$$Type, "duration"?: $Duration$$Type, "backgroundColor"?: $KubeColor$$Type, "borderColor"?: $KubeColor$$Type}) | ([icon?: $IconKJS$$Type, iconSize?: integer, text?: $Component$$Type, textShadow?: boolean, outlineColor?: $KubeColor$$Type, duration?: $Duration$$Type, backgroundColor?: $KubeColor$$Type, borderColor?: $KubeColor$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotificationToastData_ = $NotificationToastData$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.WithCodec" {
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$JsonSerializable, $JsonSerializable$$Type} from "dev.latvian.mods.kubejs.util.JsonSerializable"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$NBTSerializable, $NBTSerializable$$Type} from "dev.latvian.mods.kubejs.util.NBTSerializable"

export interface $WithCodec extends $NBTSerializable, $JsonSerializable {

 "getCodec"(): $Codec<(any)>
 "toJson"(): $JsonElement
 "toNBT"(): $Tag

(): $Codec$$Type<(any)>
get "codec"(): $Codec<(any)>
}

export namespace $WithCodec {
const probejs$$marker: never
}
export class $WithCodec$$Static implements $WithCodec {


 "getCodec"(): $Codec<(any)>
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithCodec$$Type = (() => $Codec$$Type<(any)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WithCodec_ = $WithCodec$$Type;
}}
declare module "dev.latvian.mods.kubejs.neoforge.NativeEventWrapper" {
import {$EventPriority, $EventPriority$$Type} from "net.neoforged.bus.api.EventPriority"
import {$Event, $Event$$Type} from "net.neoforged.bus.api.Event"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $NativeEventWrapper {

}

export namespace $NativeEventWrapper {
function onEvent<T extends typeof $Event<(unknown)>>(arg1: T, arg2: (event: InstanceType<(T)>) => void): void
function onEvent<T extends typeof $Event<(unknown)>>(arg1: T, arg2: (event: InstanceType<(T)>) => void, arg3: $Consumer$$Type<($Event)>): void
const probejs$$marker: never
}
export class $NativeEventWrapper$$Static implements $NativeEventWrapper {


static "onEvent"<T extends typeof $Event<(unknown)>>(arg1: T, arg2: (event: InstanceType<(T)>) => void): void
static "onEvent"<T extends typeof $Event<(unknown)>>(arg1: T, arg2: (event: InstanceType<(T)>) => void, arg3: $Consumer$$Type<($Event)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeEventWrapper$$Type = ($NativeEventWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeEventWrapper_ = $NativeEventWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ItemBuilder, $ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $FluidBucketItemBuilder extends $ItemBuilder {
readonly "fluidBuilder": $FluidBuilder
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $FluidBuilder$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBucketItemBuilder$$Type = ($FluidBucketItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidBucketItemBuilder_ = $FluidBucketItemBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.RecipeManagerKJS" {
import {$ReloadableServerResourceHolderKJS, $ReloadableServerResourceHolderKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourceHolderKJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeHolder, $RecipeHolder$$Type} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$ReloadableServerResourcesKJS, $ReloadableServerResourcesKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS"

export interface $RecipeManagerKJS extends $ReloadableServerResourceHolderKJS {

 "kjs$getRecipeIdMap"(): $Map<($ResourceLocation), ($RecipeHolder<(any)>)>
 "kjs$replaceRecipes"(arg0: $Map$$Type<($ResourceLocation$$Type), ($RecipeHolder$$Type<(any)>)>): void
 "kjs$setResources"(arg0: $ReloadableServerResourcesKJS$$Type): void
 "kjs$getResources"(): $ReloadableServerResourcesKJS
}

export namespace $RecipeManagerKJS {
const probejs$$marker: never
}
export class $RecipeManagerKJS$$Static implements $RecipeManagerKJS {


 "kjs$getRecipeIdMap"(): $Map<($ResourceLocation), ($RecipeHolder<(any)>)>
 "kjs$replaceRecipes"(arg0: $Map$$Type<($ResourceLocation$$Type), ($RecipeHolder$$Type<(any)>)>): void
 "kjs$setResources"(arg0: $ReloadableServerResourcesKJS$$Type): void
 "kjs$getResources"(): $ReloadableServerResourcesKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeManagerKJS$$Type = ($RecipeManagerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeManagerKJS_ = $RecipeManagerKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator$Face" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"

export class $ModelGenerator$Face {
readonly "side": $Direction

constructor(arg0: $Direction$$Type)

public "uv"(arg0: double, arg1: double, arg2: double, arg3: double): $ModelGenerator$Face
public "tex"(arg0: string): $ModelGenerator$Face
public "toJson"(): $JsonObject
public "cull"(): $ModelGenerator$Face
public "cull"(arg0: $Direction$$Type): $ModelGenerator$Face
public "tintindex"(arg0: integer): $ModelGenerator$Face
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Face$$Type = ($ModelGenerator$Face);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelGenerator$Face_ = $ModelGenerator$Face$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.AttachedData" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$HashMap, $HashMap$$Type} from "java.util.HashMap"

export class $AttachedData<T> extends $HashMap<(string), (any)> {

constructor(arg0: T)

public "add"(arg0: string, arg1: any): void
public "getParent"(): T
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
get "parent"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedData$$Type<T> = ($AttachedData<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttachedData_<T> = $AttachedData$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.client.MenuScreenRegistryKubeEvent" {
import {$ClientKubeEvent, $ClientKubeEvent$$Type} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$MenuType, $MenuType$$Type} from "net.minecraft.world.inventory.MenuType"
import {$Minecraft, $Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$RegisterMenuScreensEvent, $RegisterMenuScreensEvent$$Type} from "net.neoforged.neoforge.client.event.RegisterMenuScreensEvent"
import {$MenuScreens$ScreenConstructor, $MenuScreens$ScreenConstructor$$Type} from "net.minecraft.client.gui.screens.MenuScreens$ScreenConstructor"

export class $MenuScreenRegistryKubeEvent implements $ClientKubeEvent {

constructor(arg0: $RegisterMenuScreensEvent$$Type)

public "register"(arg0: $MenuType$$Type<(any)>, arg1: $MenuScreens$ScreenConstructor$$Type<(any), (any)>): void
public "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MenuScreenRegistryKubeEvent$$Type = ($MenuScreenRegistryKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MenuScreenRegistryKubeEvent_ = $MenuScreenRegistryKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemClickedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$RayTraceResultJS, $RayTraceResultJS$$Type} from "dev.latvian.mods.kubejs.entity.RayTraceResultJS"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player right clicks with an item **without targeting anything**.
 * 
 * Not to be confused with `BlockEvents.rightClick` or `ItemEvents.entityInteracted`.
 */
export class $ItemClickedKubeEvent implements $KubePlayerEvent {

constructor(arg0: $Player$$Type, arg1: $InteractionHand$$Type, arg2: $ItemStack$$Type)

/**
 * The ray trace result of the click.
 */
public "getTarget"(): $RayTraceResultJS
/**
 * The item that was clicked with.
 */
public "getItem"(): $ItemStack
/**
 * The player that clicked with the item.
 */
public "getEntity"(): $LivingEntity
/**
 * The hand that the item was clicked with.
 */
public "getHand"(): $InteractionHand
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "target"(): $RayTraceResultJS
get "item"(): $ItemStack
get "entity"(): $LivingEntity
get "hand"(): $InteractionHand
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemClickedKubeEvent$$Type = ($ItemClickedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemClickedKubeEvent_ = $ItemClickedKubeEvent$$Type;
}}
declare module "dev.latvian.apps.tinyserver.CompiledPath" {
import {$CompiledPath$Part, $CompiledPath$Part$$Type} from "dev.latvian.apps.tinyserver.CompiledPath$Part"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $CompiledPath extends $Record {
static readonly "EMPTY": $CompiledPath

constructor(parts: ($CompiledPath$Part$$Type)[], variables: integer, wildcard: boolean)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "matches"(arg0: (string)[]): (string)[]
public static "compile"(arg0: string): $CompiledPath
public "parts"(): ($CompiledPath$Part)[]
public "wildcard"(): boolean
public "variables"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompiledPath$$Type = ({"variables"?: integer, "wildcard"?: boolean, "parts"?: ($CompiledPath$Part$$Type)[]}) | ([variables?: integer, wildcard?: boolean, parts?: ($CompiledPath$Part$$Type)[]]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompiledPath_ = $CompiledPath$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.RecipeHolderKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeHolder, $RecipeHolder$$Type} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$Recipe, $Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"
import {$RecipeLikeKJS, $RecipeLikeKJS$$Type} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RecipeSerializer, $RecipeSerializer$$Type} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$ReplacementMatchInfo, $ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"

export interface $RecipeHolderKJS extends $RecipeLikeKJS {

 "hasOutput"(arg1: $ReplacementMatchInfo$$Type): boolean
 "setGroup"(arg0: string): void
 "replaceInput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "getGroup"(): string
 "getOrCreateId"(): $ResourceLocation
 "getRecipe"(): $Recipe<(any)>
 "getSchema"(): $RecipeSchema
 "replaceOutput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "self"(): $RecipeHolder<(any)>
 "getType"(): $ResourceLocation
 "hasInput"(arg1: $ReplacementMatchInfo$$Type): boolean
 "kjs$getMod"(): string
set "group"(value: string)
get "serializer"(): $RecipeSerializer<(any)>
get "group"(): string
get "orCreateId"(): $ResourceLocation
get "recipe"(): $Recipe<(any)>
get "schema"(): $RecipeSchema
get "type"(): $ResourceLocation
}

export namespace $RecipeHolderKJS {
const probejs$$marker: never
}
export class $RecipeHolderKJS$$Static implements $RecipeHolderKJS {


 "hasOutput"(arg1: $ReplacementMatchInfo$$Type): boolean
 "setGroup"(arg0: string): void
 "replaceInput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "getGroup"(): string
 "getOrCreateId"(): $ResourceLocation
 "getRecipe"(): $Recipe<(any)>
 "getSchema"(): $RecipeSchema
 "replaceOutput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "self"(): $RecipeHolder<(any)>
 "getType"(): $ResourceLocation
 "hasInput"(arg1: $ReplacementMatchInfo$$Type): boolean
 "kjs$getMod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeHolderKJS$$Type = ($RecipeHolderKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeHolderKJS_ = $RecipeHolderKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.BlockPlacedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BlockEvent$EntityPlaceEvent, $BlockEvent$EntityPlaceEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$EntityPlaceEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$KubeEntityEvent, $KubeEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a block is placed.
 */
export class $BlockPlacedKubeEvent implements $KubeEntityEvent {

constructor(arg0: $BlockEvent$EntityPlaceEvent$$Type)

/**
 * The level of the block that was placed.
 */
public "getLevel"(): $Level
/**
 * The entity that placed the block. Can be `null`, e.g. when a block is placed by a dispenser.
 */
public "getEntity"(): $Entity
/**
 * The block that is placed.
 */
public "getBlock"(): $BlockContainerJS
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "level"(): $Level
get "entity"(): $Entity
get "block"(): $BlockContainerJS
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPlacedKubeEvent$$Type = ($BlockPlacedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPlacedKubeEvent_ = $BlockPlacedKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.mekanism.KubeChemicalBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Chemical, $Chemical$$Type} from "mekanism.api.chemical.Chemical"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ChemicalAttribute, $ChemicalAttribute$$Type} from "mekanism.api.chemical.attribute.ChemicalAttribute"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $KubeChemicalBuilder extends $BuilderBase<($Chemical)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "with"(arg0: $ChemicalAttribute$$Type): this
public "tint"(arg0: $KubeColor$$Type): this
public "fuel"(arg0: integer, arg1: long): this
public "heatedCoolant"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double): this
public "gaseous"(): this
public "radiation"(arg0: double): this
public "ore"(arg0: $TagKey$$Type<($Item)>): this
public "cooledCoolant"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeChemicalBuilder$$Type = ($KubeChemicalBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeChemicalBuilder_ = $KubeChemicalBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.level.KubeLevelEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export interface $KubeLevelEvent extends $KubeEvent {

 "getLevel"(): $Level
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any

(): $Level$$Type
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}

export namespace $KubeLevelEvent {
const probejs$$marker: never
}
export class $KubeLevelEvent$$Static implements $KubeLevelEvent {


 "getLevel"(): $Level
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeLevelEvent$$Type = (() => $Level$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeLevelEvent_ = $KubeLevelEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.entity.AttributeBuilder" {
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$AttributeBuilder$Range, $AttributeBuilder$Range$$Type} from "dev.latvian.mods.kubejs.entity.AttributeBuilder$Range"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$MobCategory, $MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$Attribute$Sentiment, $Attribute$Sentiment$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute$Sentiment"
import {$Either, $Either$$Type} from "com.mojang.datafixers.util.Either"
import {$Attribute, $Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $AttributeBuilder extends $BuilderBase<($Attribute)> {
readonly "predicateList": $List<($Predicate<($EntityType<(any)>)>)>
 "defaultValue": $Either<($AttributeBuilder$Range), (boolean)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "range"(arg0: double, arg1: double, arg2: double): this
public "transformObject"(arg0: $Attribute$$Type): $Attribute
public "bool"(arg0: boolean): this
public "sentiment"(arg0: $Attribute$Sentiment$$Type): this
public "syncable"(arg0: boolean): this
public "negativeSentiment"(): this
public "attachToCategory"(arg0: $MobCategory$$Type): this
public "attachToPlayers"(): this
public "attachToMonsters"(): this
public "neutralSentiment"(): this
public "attachTo"(arg0: $Predicate$$Type<($EntityType<(any)>)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeBuilder$$Type = ($AttributeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttributeBuilder_ = $AttributeBuilder$$Type;
}}
declare module "dev.latvian.mods.rhino.type.JSFixedArrayTypeInfo" {
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$List, $List$$Type} from "java.util.List"
import {$TypeStringContext, $TypeStringContext$$Type} from "dev.latvian.mods.rhino.type.TypeStringContext"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Type, $Type$$Type} from "java.lang.reflect.Type"
import {$JSOptionalParam, $JSOptionalParam$$Type} from "dev.latvian.mods.rhino.type.JSOptionalParam"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$RecordTypeInfo$Component, $RecordTypeInfo$Component$$Type} from "dev.latvian.mods.rhino.type.RecordTypeInfo$Component"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $JSFixedArrayTypeInfo extends $Record implements $TypeInfo {

constructor(types: $List$$Type<($JSOptionalParam$$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "append"(ctx: $TypeStringContext$$Type, sb: $StringBuilder$$Type): void
public "hashCode"(): integer
public "types"(): $List<($JSOptionalParam)>
public "asClass"(): $Class<(any)>
public "collectContainedComponentClasses"(classes: $Collection$$Type<($Class$$Type<(any)>)>): void
public "signature"(): string
public "isPrimitive"(): boolean
public "newArray"(length: integer): any
public "componentType"(): $TypeInfo
public static "of"(type: $Type$$Type): $TypeInfo
public static "of"(c: $Class$$Type<(any)>): $TypeInfo
public "enumConstants"(): $List<(any)>
public "param"(index: integer): $TypeInfo
public "isVoid"(): boolean
public "is"(info: $TypeInfo$$Type): boolean
public "or"(info: $TypeInfo$$Type): $TypeInfo
public "isCharacter"(): boolean
public "isFloat"(): boolean
public "asArray"(): $TypeInfo
public "isBoolean"(): boolean
public "recordComponents"(): $Map<(string), ($RecordTypeInfo$Component)>
public static "ofArray"(array: ($Type$$Type)[]): ($TypeInfo)[]
public "getContainedComponentClasses"(): $Set<($Class<(any)>)>
public "withParams"(...params: ($TypeInfo$$Type)[]): $TypeInfo
public "isDouble"(): boolean
public "isFunctionalInterface"(): boolean
public "shouldConvert"(): boolean
public "isLong"(): boolean
public "isInt"(): boolean
public "isShort"(): boolean
public "isByte"(): boolean
public "createDefaultValue"(): any
get "primitive"(): boolean
get "void"(): boolean
get "character"(): boolean
get "float"(): boolean
get "boolean"(): boolean
get "containedComponentClasses"(): $Set<($Class<(any)>)>
get "double"(): boolean
get "functionalInterface"(): boolean
get "long"(): boolean
get "int"(): boolean
get "short"(): boolean
get "byte"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JSFixedArrayTypeInfo$$Type = ({"types"?: $List$$Type<($JSOptionalParam$$Type)>}) | ([types?: $List$$Type<($JSOptionalParam$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JSFixedArrayTypeInfo_ = $JSFixedArrayTypeInfo$$Type;
}}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickHandler" {
import {$ChestMenuClickEvent, $ChestMenuClickEvent$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent"
import {$ChestMenuClickEvent$Callback, $ChestMenuClickEvent$Callback$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $ChestMenuClickHandler extends $Record {

constructor(type: $ClickType$$Type, button: integer, callback: $ChestMenuClickEvent$Callback$$Type, autoHandle: boolean)

public "type"(): $ClickType
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(arg0: $ChestMenuClickEvent$$Type): boolean
public "button"(): integer
public "callback"(): $ChestMenuClickEvent$Callback
public "autoHandle"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickHandler$$Type = ({"callback"?: $ChestMenuClickEvent$Callback$$Type, "autoHandle"?: boolean, "button"?: integer, "type"?: $ClickType$$Type}) | ([callback?: $ChestMenuClickEvent$Callback$$Type, autoHandle?: boolean, button?: integer, type?: $ClickType$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuClickHandler_ = $ChestMenuClickHandler$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.FenceBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $FenceBlockBuilder extends $ShapedBlockBuilder {
static readonly "FENCE_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FenceBlockBuilder$$Type = ($FenceBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FenceBlockBuilder_ = $FenceBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder" {
import {$Pattern, $Pattern$$Type} from "java.util.regex.Pattern"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $UniqueIdBuilder extends $Record {
static readonly "NON_W_PATTERN": $Pattern
static readonly "MULTIPLE_UNDERSCORES_PATTERN": $Pattern

constructor(builder: $StringBuilder$$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "append"(arg0: string): void
public "append"(arg0: $ResourceLocation$$Type): void
public "hashCode"(): integer
public "builder"(): $StringBuilder
public "build"(): string
public "appendSeparator"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UniqueIdBuilder$$Type = ({"builder"?: $StringBuilder$$Type}) | ([builder?: $StringBuilder$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UniqueIdBuilder_ = $UniqueIdBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.player.KubePlayerEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent, $KubeLivingEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export interface $KubePlayerEvent extends $KubeLivingEntityEvent {

 "getEntity"(): $Entity
 "getPlayer"(): $Player
 "getLevel"(): $Level
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}

export namespace $KubePlayerEvent {
const probejs$$marker: never
}
export class $KubePlayerEvent$$Static implements $KubePlayerEvent {


 "getEntity"(): $Entity
 "getPlayer"(): $Player
 "getLevel"(): $Level
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubePlayerEvent$$Type = ($KubePlayerEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubePlayerEvent_ = $KubePlayerEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.component.ComponentValueMap" {
import {$Reference2ObjectOpenHashMap, $Reference2ObjectOpenHashMap$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"

export class $ComponentValueMap extends $Reference2ObjectOpenHashMap<($RecipeKey<(any)>), (any)> {

constructor(arg0: integer)

public "getValue"<T>(arg1: $KubeRecipe$$Type, arg2: $RecipeKey$$Type<(T)>): T
public "reference2ObjectEntrySet"(): $ObjectSet<(any)>
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentValueMap$$Type = ($ComponentValueMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentValueMap_ = $ComponentValueMap$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.HandheldItemBuilder" {
import {$MutableToolTier, $MutableToolTier$$Type} from "dev.latvian.mods.kubejs.item.MutableToolTier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ItemBuilder, $ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $HandheldItemBuilder extends $ItemBuilder {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type, arg1: float, arg2: float)

/**
 * Sets the attack speed of the tool.
 */
public "speed"(arg0: float): this
public "tier"(arg0: $Tier$$Type): this
/**
 * Modifies the tool tier.
 */
public "modifyTier"(arg0: $Consumer$$Type<($MutableToolTier)>): this
/**
 * Sets the base attack speed of the tool. Different tools have different baselines.
 * 
 * For example, a sword has a baseline of -2.4, while an axe has a baseline of -3.1.
 * 
 * The actual speed is the sum of the baseline and the speed from tier + 4 (bare hand).
 */
public "speedBaseline"(arg0: float): this
/**
 * Sets the attack damage bonus of the tool.
 */
public "attackDamageBonus"(arg0: float): this
/**
 * Sets the base attack damage of the tool. Different tools have different baselines.
 * 
 * For example, a sword has a baseline of 3, while an axe has a baseline of 6.
 * 
 * The actual damage is the sum of the baseline and the attackDamageBonus from tier.
 */
public "attackDamageBaseline"(arg0: float): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandheldItemBuilder$$Type = ($HandheldItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandheldItemBuilder_ = $HandheldItemBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.BlockKJS" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$BlockBuilderProvider, $BlockBuilderProvider$$Type} from "dev.latvian.mods.kubejs.core.BlockBuilderProvider"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Replaceable, $Replaceable$$Type} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS, $RegistryObjectKJS$$Type} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockKJS extends $BlockBuilderProvider, $RegistryObjectKJS<($Block)>, $Replaceable {

 "setNameKey"(arg0: string): void
 "replaceThisWith"(arg1: any): any
 "getBlockStates"(): $List<($BlockState)>
 "getRegistry"(): $Registry<($Block)>
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "setDestroySpeed"(arg0: float): void
 "setRequiresTool"(arg0: boolean): void
 "setBlockBuilder"(arg0: $BlockBuilder$$Type): void
 "setLightEmission"(arg0: integer): void
 "getBlockBuilder"(): $BlockBuilder
 "getId"(): string
 "getKey"(): $ResourceKey<($Block)>
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "asHolder"(): $Holder<($Block)>
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
set "nameKey"(value: string)
get "blockStates"(): $List<($BlockState)>
get "registry"(): $Registry<($Block)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
set "destroySpeed"(value: float)
set "requiresTool"(value: boolean)
set "blockBuilder"(value: $BlockBuilder$$Type)
set "lightEmission"(value: integer)
get "blockBuilder"(): $BlockBuilder
get "id"(): string
get "key"(): $ResourceKey<($Block)>
get "mod"(): string
get "idLocation"(): $ResourceLocation
get "tags"(): $Collection<($ResourceLocation)>
}

export namespace $BlockKJS {
const probejs$$marker: never
}
export class $BlockKJS$$Static implements $BlockKJS {


 "setNameKey"(arg0: string): void
 "replaceThisWith"(arg1: any): any
 "getBlockStates"(): $List<($BlockState)>
 "getRegistry"(): $Registry<($Block)>
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "setDestroySpeed"(arg0: float): void
 "setRequiresTool"(arg0: boolean): void
 "setBlockBuilder"(arg0: $BlockBuilder$$Type): void
 "setLightEmission"(arg0: integer): void
 "getBlockBuilder"(): $BlockBuilder
 "getId"(): string
 "getKey"(): $ResourceKey<($Block)>
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "asHolder"(): $Holder<($Block)>
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockKJS$$Type = ($BlockKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockKJS_ = $BlockKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$DataComponentSubtypes" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $ItemData$DataComponentSubtypes extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData$DataComponentSubtypes)>

constructor(filter: $Ingredient$$Type, components: $List$$Type<($DataComponentType$$Type<(any)>)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "filter"(): $Ingredient
public "components"(): $List<($DataComponentType<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$DataComponentSubtypes$$Type = ({"filter"?: $Ingredient$$Type, "components"?: $List$$Type<($DataComponentType$$Type<(never)>)>}) | ([filter?: $Ingredient$$Type, components?: $List$$Type<($DataComponentType$$Type<(never)>)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemData$DataComponentSubtypes_ = $ItemData$DataComponentSubtypes$$Type;
}}
declare module "dev.latvian.mods.rhino.Function" {
import {$MemberType, $MemberType$$Type} from "dev.latvian.mods.rhino.MemberType"
import {$Callable, $Callable$$Type} from "dev.latvian.mods.rhino.Callable"
import {$DefaultValueTypeHint, $DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $Function extends $Scriptable, $Callable {

 "call"(arg1: $Scriptable$$Type, arg2: $Scriptable$$Type, arg3: (any)[]): any
 "construct"(arg1: $Scriptable$$Type, arg2: (any)[]): $Scriptable
 "get"(arg1: integer, arg2: $Scriptable$$Type): any
 "get"(arg1: string, arg2: $Scriptable$$Type): any
 "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
 "put"(arg1: string, arg2: $Scriptable$$Type, arg3: any): void
 "delete"(arg1: string): void
 "delete"(arg1: integer): void
 "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
 "getClassName"(): string
 "has"(arg1: string, arg2: $Scriptable$$Type): boolean
 "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
 "getTypeOf"(): $MemberType
 "getAllIds"(): (any)[]
 "getIds"(): (any)[]
 "getParentScope"(): $Scriptable
 "getPrototype"(): $Scriptable
 "hasInstance"(arg1: $Scriptable$$Type): boolean
 "setPrototype"(arg0: $Scriptable$$Type): void
 "setParentScope"(arg0: $Scriptable$$Type): void
 "enumerationIteratorHasNext"(currentId: $Consumer$$Type<(any)>): boolean
 "enumerationIteratorNext"(currentId: $Consumer$$Type<(any)>): boolean
get "className"(): string
get "typeOf"(): $MemberType
get "allIds"(): (any)[]
get "ids"(): (any)[]
get "parentScope"(): $Scriptable
get "prototype"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
set "parentScope"(value: $Scriptable$$Type)
}

export namespace $Function {
const probejs$$marker: never
}
export class $Function$$Static implements $Function {


 "call"(arg1: $Scriptable$$Type, arg2: $Scriptable$$Type, arg3: (any)[]): any
 "construct"(arg1: $Scriptable$$Type, arg2: (any)[]): $Scriptable
 "get"(arg1: integer, arg2: $Scriptable$$Type): any
 "get"(arg1: string, arg2: $Scriptable$$Type): any
 "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
 "put"(arg1: string, arg2: $Scriptable$$Type, arg3: any): void
 "delete"(arg1: string): void
 "delete"(arg1: integer): void
 "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
 "getClassName"(): string
 "has"(arg1: string, arg2: $Scriptable$$Type): boolean
 "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
 "getTypeOf"(): $MemberType
 "getAllIds"(): (any)[]
 "getIds"(): (any)[]
 "getParentScope"(): $Scriptable
 "getPrototype"(): $Scriptable
 "hasInstance"(arg1: $Scriptable$$Type): boolean
 "setPrototype"(arg0: $Scriptable$$Type): void
 "setParentScope"(arg0: $Scriptable$$Type): void
 "enumerationIteratorHasNext"(currentId: $Consumer$$Type<(any)>): boolean
 "enumerationIteratorNext"(currentId: $Consumer$$Type<(any)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function$$Type = ($Function);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function_ = $Function$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.SubtypeInterpreter" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $SubtypeInterpreter {

 "apply"(arg0: any): any

(arg0: any): any
}

export namespace $SubtypeInterpreter {
const probejs$$marker: never
}
export class $SubtypeInterpreter$$Static implements $SubtypeInterpreter {


 "apply"(arg0: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SubtypeInterpreter$$Type = ((arg0: any) => any);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SubtypeInterpreter_ = $SubtypeInterpreter$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.MinecraftServerKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$WithAttachedData, $WithAttachedData$$Type} from "dev.latvian.mods.kubejs.core.WithAttachedData"
import {$AdvancementNode, $AdvancementNode$$Type} from "net.minecraft.advancements.AdvancementNode"
import {$ScheduledEvents, $ScheduledEvents$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$WithPersistentData, $WithPersistentData$$Type} from "dev.latvian.mods.kubejs.core.WithPersistentData"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$PlayerSelector, $PlayerSelector$$Type} from "dev.latvian.mods.kubejs.core.PlayerSelector"
import {$MinecraftEnvironmentKJS, $MinecraftEnvironmentKJS$$Type} from "dev.latvian.mods.kubejs.core.MinecraftEnvironmentKJS"
import {$ScheduledEvents$Callback, $ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$TemporalAmount, $TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"
import {$DataSenderKJS, $DataSenderKJS$$Type} from "dev.latvian.mods.kubejs.core.DataSenderKJS"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"

export interface $MinecraftServerKJS extends $WithAttachedData<($MinecraftServer)>, $WithPersistentData, $DataSenderKJS, $MinecraftEnvironmentKJS {

 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "self"(): $MinecraftServer
 "sendData"(arg0: string, arg1: $CompoundTag$$Type): void
 "getName"(): $Component
 "runCommand"(arg0: string): void
 "getLevel"(arg0: $ResourceLocation$$Type): $ServerLevel
 "restoreInventories"(): $Map<($UUID), ($Map<(integer), ($ItemStack)>)>
 "getEntities"(): $EntityArrayList
 "getPlayers"(): $EntityArrayList
 "getPlayer"(arg0: $PlayerSelector$$Type): $ServerPlayer
 "getAdvancement"(arg0: $ResourceLocation$$Type): $AdvancementNode
 "getOverworld"(): $ServerLevel
 "getData"(): $AttachedData<($MinecraftServer)>
 "getPersistentData"(): $CompoundTag
 "sendData"(arg0: string): void
 "scheduleRepeatingInTicks"(arg0: long, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getScheduledEvents"(): $ScheduledEvents
 "scheduleRepeating"(arg0: $TemporalAmount$$Type, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(arg0: long, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "schedule"(arg0: $TemporalAmount$$Type, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getDisplayName"(): $Component
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "entities"(): $EntityArrayList
get "players"(): $EntityArrayList
get "overworld"(): $ServerLevel
get "data"(): $AttachedData<($MinecraftServer)>
get "persistentData"(): $CompoundTag
get "scheduledEvents"(): $ScheduledEvents
get "displayName"(): $Component
}

export namespace $MinecraftServerKJS {
const probejs$$marker: never
}
export class $MinecraftServerKJS$$Static implements $MinecraftServerKJS {


 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "self"(): $MinecraftServer
 "sendData"(arg0: string, arg1: $CompoundTag$$Type): void
 "getName"(): $Component
 "runCommand"(arg0: string): void
 "getLevel"(arg0: $ResourceLocation$$Type): $ServerLevel
 "restoreInventories"(): $Map<($UUID), ($Map<(integer), ($ItemStack)>)>
 "getEntities"(): $EntityArrayList
 "getPlayers"(): $EntityArrayList
 "getPlayer"(arg0: $PlayerSelector$$Type): $ServerPlayer
 "getAdvancement"(arg0: $ResourceLocation$$Type): $AdvancementNode
 "getOverworld"(): $ServerLevel
 "getData"(): $AttachedData<($MinecraftServer)>
 "getPersistentData"(): $CompoundTag
 "sendData"(arg0: string): void
 "scheduleRepeatingInTicks"(arg0: long, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getScheduledEvents"(): $ScheduledEvents
 "scheduleRepeating"(arg0: $TemporalAmount$$Type, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(arg0: long, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "schedule"(arg0: $TemporalAmount$$Type, arg1: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftServerKJS$$Type = ($MinecraftServerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MinecraftServerKJS_ = $MinecraftServerKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.SizedIngredientWrapper" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$SizedIngredient, $SizedIngredient$$Type} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * Various SizedIngredient related helper methods
 */
export interface $SizedIngredientWrapper {

}

export namespace $SizedIngredientWrapper {
const TYPE_INFO: $TypeInfo
const empty: $SizedIngredient
const all: $SizedIngredient
function of(arg0: $SizedIngredient$$Type): $SizedIngredient
function of(arg0: $Ingredient$$Type, arg1: integer): $SizedIngredient
function ofTag(arg0: $TagKey$$Type<($Item)>, arg1: integer): $SizedIngredient
const probejs$$marker: never
}
export class $SizedIngredientWrapper$$Static implements $SizedIngredientWrapper {
static readonly "TYPE_INFO": $TypeInfo
/**
 * A completely empty ingredient that will only match air
 */
static readonly "empty": $SizedIngredient
/**
 * An ingredient that matches everything
 */
static readonly "all": $SizedIngredient


/**
 * Returns a sized ingredient of the input
 */
static "of"(arg0: $SizedIngredient$$Type): $SizedIngredient
/**
 * Returns a sized ingredient of the input
 */
static "of"(arg0: $Ingredient$$Type, arg1: integer): $SizedIngredient
static "ofTag"(arg0: $TagKey$$Type<($Item)>, arg1: integer): $SizedIngredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SizedIngredientWrapper$$Type = ($SizedIngredientWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SizedIngredientWrapper_ = $SizedIngredientWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.entity.AttributeBuilder$Range" {
import {$Record, $Record$$Type} from "java.lang.Record"

export class $AttributeBuilder$Range extends $Record {

constructor(defaultValue: double, min: double, max: double)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "min"(): double
public "max"(): double
public "defaultValue"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeBuilder$Range$$Type = ({"defaultValue"?: double, "min"?: double, "max"?: double}) | ([defaultValue?: double, min?: double, max?: double]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttributeBuilder$Range_ = $AttributeBuilder$Range$$Type;
}}
declare module "dev.latvian.mods.kubejs.mekanism.KubeChemicalBuilder$InfuseType" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$KubeChemicalBuilder, $KubeChemicalBuilder$$Type} from "dev.latvian.mods.kubejs.mekanism.KubeChemicalBuilder"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $KubeChemicalBuilder$InfuseType extends $KubeChemicalBuilder {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeChemicalBuilder$InfuseType$$Type = ($KubeChemicalBuilder$InfuseType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeChemicalBuilder$InfuseType_ = $KubeChemicalBuilder$InfuseType$$Type;
}}
declare module "dev.latvian.mods.rhino.type.RecordTypeInfo" {
import {$JSFixedArrayTypeInfo, $JSFixedArrayTypeInfo$$Type} from "dev.latvian.mods.rhino.type.JSFixedArrayTypeInfo"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$JSObjectTypeInfo, $JSObjectTypeInfo$$Type} from "dev.latvian.mods.rhino.type.JSObjectTypeInfo"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Type, $Type$$Type} from "java.lang.reflect.Type"
import {$TypeWrapperFactory, $TypeWrapperFactory$$Type} from "dev.latvian.mods.rhino.util.wrap.TypeWrapperFactory"
import {$ClassTypeInfo, $ClassTypeInfo$$Type} from "dev.latvian.mods.rhino.type.ClassTypeInfo"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Constructor, $Constructor$$Type} from "java.lang.reflect.Constructor"
import {$RecordTypeInfo$Component, $RecordTypeInfo$Component$$Type} from "dev.latvian.mods.rhino.type.RecordTypeInfo$Component"
import {$RecordTypeInfo$Data, $RecordTypeInfo$Data$$Type} from "dev.latvian.mods.rhino.type.RecordTypeInfo$Data"

export class $RecordTypeInfo extends $ClassTypeInfo implements $TypeWrapperFactory<(any)> {


public "wrap"(from: any, target: $TypeInfo$$Type): any
public "getConstructor"(): $Constructor<(any)>
public "getData"(): $RecordTypeInfo$Data
public "createInstance"(...objects: (any)[]): any
public "createInstance"(map: $Map$$Type<(any), (any)>): any
public "recordComponents"(): $Map<(string), ($RecordTypeInfo$Component)>
public static "setGlobalDefaultValue"<T>(type: $Class$$Type<(T)>, value: T): void
public "createCombinedType"(...preference: ($TypeInfo$$Type)[]): $TypeInfo
public "getObjectTypeInfo"(): $JSObjectTypeInfo
public "getArrayTypeInfo"(): $JSFixedArrayTypeInfo
public static "of"(type: $Type$$Type): $TypeInfo
public static "of"(c: $Class$$Type<(any)>): $TypeInfo
public static "ofArray"(array: ($Type$$Type)[]): ($TypeInfo)[]
get "constructor"(): $Constructor<(any)>
get "data"(): $RecordTypeInfo$Data
get "objectTypeInfo"(): $JSObjectTypeInfo
get "arrayTypeInfo"(): $JSFixedArrayTypeInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecordTypeInfo$$Type = ($RecordTypeInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecordTypeInfo_ = $RecordTypeInfo$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.KubeAnimatedParticle" {
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$TextureAtlasSprite, $TextureAtlasSprite$$Type} from "net.minecraft.client.renderer.texture.TextureAtlasSprite"
import {$ClientLevel, $ClientLevel$$Type} from "net.minecraft.client.multiplayer.ClientLevel"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$SimpleAnimatedParticle, $SimpleAnimatedParticle$$Type} from "net.minecraft.client.particle.SimpleAnimatedParticle"
import {$SpriteSet, $SpriteSet$$Type} from "net.minecraft.client.particle.SpriteSet"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $KubeAnimatedParticle extends $SimpleAnimatedParticle {
readonly "sprites": $SpriteSet
 "sprite": $TextureAtlasSprite
 "quadSize": float
readonly "level": $ClientLevel
 "xo": double
 "yo": double
 "zo": double
 "x": double
 "y": double
 "z": double
 "xd": double
 "yd": double
 "zd": double
 "onGround": boolean
 "hasPhysics": boolean
 "removed": boolean
 "bbWidth": float
 "bbHeight": float
readonly "random": $RandomSource
 "age": integer
 "lifetime": integer
 "gravity": float
 "rCol": float
 "gCol": float
 "bCol": float
 "alpha": float
 "roll": float
 "oRoll": float
 "friction": float
 "speedUpWhenYMotionIsBlocked": boolean

constructor(arg0: $ClientLevel$$Type, arg1: double, arg2: double, arg3: double, arg4: $SpriteSet$$Type)

public "tick"(): void
public "setColor"(arg0: $KubeColor$$Type, arg1: boolean): void
public "setColor"(arg0: $KubeColor$$Type): void
public "getLevel"(): $ClientLevel
public "onTick"(arg0: $Consumer$$Type<($KubeAnimatedParticle)>): void
public "getY"(): double
public "getZ"(): double
public "getX"(): double
public "setGravity"(arg0: float): void
public "setSpeed"(arg0: $Vec3$$Type): void
public "getRandom"(): $RandomSource
public "getSpriteSet"(): $SpriteSet
public "setLightColor"(arg0: $Float2IntFunction$$Type): void
/**
 * Sets teh friction of the particle, the particle's motion is multiplied by this value every tick
 */
public "setFriction"(arg0: float): void
public "setPhysicality"(arg0: boolean): void
public "getLightColor"(arg0: float): integer
public "setFasterWhenYMotionBlocked"(arg0: boolean): void
public "getXSpeed"(): double
public "getYSpeed"(): double
public "getZSpeed"(): double
set "color"(value: $KubeColor$$Type)
get "level"(): $ClientLevel
get "y"(): double
get "z"(): double
get "x"(): double
set "gravity"(value: float)
set "speed"(value: $Vec3$$Type)
get "random"(): $RandomSource
get "spriteSet"(): $SpriteSet
set "lightColor"(value: $Float2IntFunction$$Type)
set "friction"(value: float)
set "physicality"(value: boolean)
set "fasterWhenYMotionBlocked"(value: boolean)
get "xSpeed"(): double
get "ySpeed"(): double
get "zSpeed"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeAnimatedParticle$$Type = ($KubeAnimatedParticle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeAnimatedParticle_ = $KubeAnimatedParticle$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Leggings" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder, $ArmorItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ArmorItemBuilder$Leggings extends $ArmorItemBuilder {
static readonly "LEGGING_TAGS": ($ResourceLocation)[]
readonly "armorType": $ArmorItem$Type
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Leggings$$Type = ($ArmorItemBuilder$Leggings);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorItemBuilder$Leggings_ = $ArmorItemBuilder$Leggings$$Type;
}}
declare module "dev.latvian.mods.rhino.util.ToStringJS" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ToStringJS {

 "toStringJS"(): string
}

export namespace $ToStringJS {
function toStringJS(o: any): string
const probejs$$marker: never
}
export class $ToStringJS$$Static implements $ToStringJS {


static "toStringJS"(o: any): string
 "toStringJS"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToStringJS$$Type = ($ToStringJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ToStringJS_ = $ToStringJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.generator.KubeResourceGenerator" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"

export interface $KubeResourceGenerator extends $KubeEvent {

 "add"(arg0: $GeneratedData$$Type): void
 "text"(arg0: $ResourceLocation$$Type, arg1: string): void
 "json"(arg0: $ResourceLocation$$Type, arg1: $JsonElement$$Type): void
 "getGenerated"(arg0: $ResourceLocation$$Type): $GeneratedData
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}

export namespace $KubeResourceGenerator {
const probejs$$marker: never
}
export class $KubeResourceGenerator$$Static implements $KubeResourceGenerator {


 "add"(arg0: $GeneratedData$$Type): void
 "text"(arg0: $ResourceLocation$$Type, arg1: string): void
 "json"(arg0: $ResourceLocation$$Type, arg1: $JsonElement$$Type): void
 "getGenerated"(arg0: $ResourceLocation$$Type): $GeneratedData
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeResourceGenerator$$Type = ($KubeResourceGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeResourceGenerator_ = $KubeResourceGenerator$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.ScriptPack" {
import {$List, $List$$Type} from "java.util.List"
import {$ScriptFile, $ScriptFile$$Type} from "dev.latvian.mods.kubejs.script.ScriptFile"
import {$ScriptPackInfo, $ScriptPackInfo$$Type} from "dev.latvian.mods.kubejs.script.ScriptPackInfo"
import {$ScriptManager, $ScriptManager$$Type} from "dev.latvian.mods.kubejs.script.ScriptManager"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptPack {
readonly "manager": $ScriptManager
readonly "info": $ScriptPackInfo
readonly "scripts": $List<($ScriptFile)>

constructor(arg0: $ScriptManager$$Type, arg1: $ScriptPackInfo$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptPack$$Type = ($ScriptPack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptPack_ = $ScriptPack$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.PlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$WithAttachedData, $WithAttachedData$$Type} from "dev.latvian.mods.kubejs.core.WithAttachedData"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$KubeJSInventoryListener, $KubeJSInventoryListener$$Type} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Stages, $Stages$$Type} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties, $FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$NotificationToastData, $NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS, $PlayerStatsJS$$Type} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$LivingEntityKJS, $LivingEntityKJS$$Type} from "dev.latvian.mods.kubejs.core.LivingEntityKJS"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$EntityPotionEffectsJS, $EntityPotionEffectsJS$$Type} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$KGUIActions, $KGUIActions$$Type} from "dev.latvian.mods.kubejs.kgui.action.KGUIActions"
import {$Attribute, $Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$RayTraceResultJS, $RayTraceResultJS$$Type} from "dev.latvian.mods.kubejs.entity.RayTraceResultJS"
import {$DataSenderKJS, $DataSenderKJS$$Type} from "dev.latvian.mods.kubejs.core.DataSenderKJS"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export interface $PlayerKJS extends $LivingEntityKJS, $DataSenderKJS, $WithAttachedData<($Player)> {

 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "spawn"(): void
 "setStatusMessage"(arg0: $Component$$Type): void
 "self"(): $LivingEntity
 "getStages"(): $Stages
 "getInventory"(): $InventoryKJS
 "isMiningBlock"(): boolean
 "addExhaustion"(arg0: float): void
 "getXpLevel"(): integer
 "setSaturation"(arg0: float): void
 "addFood"(arg0: integer, arg1: float): void
 "addXPLevels"(arg0: integer): void
 "giveInHand"(arg0: $ItemStack$$Type): void
 "getFoodLevel"(): integer
 "setFoodLevel"(arg0: integer): void
 "getStats"(): $PlayerStatsJS
 "getKgui"(): $KGUIActions
 "setMouseItem"(arg0: $ItemStack$$Type): void
 "getSaturation"(): float
 "getMouseItem"(): $ItemStack
 "setXpLevel"(arg0: integer): void
 "isPlayer"(): boolean
 "getProfile"(): $GameProfile
 "addItemCooldown"(arg0: $Item$$Type, arg1: integer): void
 "getCraftingGrid"(): $InventoryKJS
 "setSelectedSlot"(arg0: integer): void
 "getSelectedSlot"(): integer
 "boostElytraFlight"(): void
 "sendInventoryUpdate"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addXP"(arg0: integer): void
 "setXp"(arg0: integer): void
 "getXp"(): integer
 "give"(arg0: $ItemStack$$Type): void
 "isFake"(): boolean
 "notify"(arg0: $Component$$Type, arg1: $Component$$Type): void
 "notify"(arg0: $NotificationToastData$$Type): void
 "setDefaultMovementSpeed"(arg0: double): void
 "setMovementSpeedAddition"(arg0: double): void
 "getDefaultMovementSpeed"(): double
 "swing"(): void
 "swing"(arg0: $InteractionHand$$Type): void
 "foodEaten"(arg0: $ItemStack$$Type, arg1: $FoodProperties$$Type): void
 "getHeldItem"(arg0: $InteractionHand$$Type): $ItemStack
 "isUndead"(): boolean
 "rayTrace"(): $RayTraceResultJS
 "setOffHandItem"(arg0: $ItemStack$$Type): void
 "getEquipment"(arg0: $EquipmentSlot$$Type): $ItemStack
 "setMaxHealth"(arg0: float): void
 "rayTraceEntity"(arg0: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(arg0: $InteractionHand$$Type, arg1: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setEquipment"(arg0: $EquipmentSlot$$Type, arg1: $ItemStack$$Type): void
 "setDefaultMovementSpeedMultiplier"(arg0: double): void
 "setTotalMovementSpeedMultiplier"(arg0: double): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer): void
 "canEntityBeSeen"(arg0: $LivingEntity$$Type): boolean
 "setLegsArmorItem"(arg0: $ItemStack$$Type): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type): void
 "getMainHandItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "setFeetArmorItem"(arg0: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>, arg1: double): void
 "getReachDistance"(): double
 "isHoldingInAnyHand"(arg0: $ItemPredicate$$Type): boolean
 "modifyAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type, arg2: double, arg3: $AttributeModifier$Operation$$Type): void
 "getAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>): double
 "setMainHandItem"(arg0: $ItemStack$$Type): void
 "setChestArmorItem"(arg0: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(arg0: $ItemStack$$Type): void
 "getAttributeTotalValue"(arg0: $Holder$$Type<($Attribute)>): double
 "getChestArmorItem"(): $ItemStack
 "sendData"(arg0: string, arg1: $CompoundTag$$Type): void
 "sendData"(arg0: string): void
 "getData"(): $AttachedData<($Player)>
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "getItem"(): $ItemStack
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "getPersistentData"(): $CompoundTag

(): $AttachedData$$Type<($Player$$Type)>
get "inventoryChangeListener"(): $KubeJSInventoryListener
set "statusMessage"(value: $Component$$Type)
get "stages"(): $Stages
get "inventory"(): $InventoryKJS
get "miningBlock"(): boolean
get "xpLevel"(): integer
set "saturation"(value: float)
get "foodLevel"(): integer
set "foodLevel"(value: integer)
get "stats"(): $PlayerStatsJS
get "kgui"(): $KGUIActions
set "mouseItem"(value: $ItemStack$$Type)
get "saturation"(): float
get "mouseItem"(): $ItemStack
set "xpLevel"(value: integer)
get "player"(): boolean
get "profile"(): $GameProfile
get "craftingGrid"(): $InventoryKJS
set "selectedSlot"(value: integer)
get "selectedSlot"(): integer
get "openInventory"(): $AbstractContainerMenu
set "xp"(value: integer)
get "xp"(): integer
get "fake"(): boolean
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
get "defaultMovementSpeed"(): double
get "undead"(): boolean
set "offHandItem"(value: $ItemStack$$Type)
set "maxHealth"(value: float)
get "living"(): boolean
get "offHandItem"(): $ItemStack
set "defaultMovementSpeedMultiplier"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
set "legsArmorItem"(value: $ItemStack$$Type)
get "potionEffects"(): $EntityPotionEffectsJS
get "mainHandItem"(): $ItemStack
get "totalMovementSpeed"(): double
set "feetArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
get "reachDistance"(): double
set "mainHandItem"(value: $ItemStack$$Type)
set "chestArmorItem"(value: $ItemStack$$Type)
get "feetArmorItem"(): $ItemStack
get "headArmorItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "data"(): $AttachedData<($Player)>
set "nbt"(value: $CompoundTag$$Type)
get "nbt"(): $CompoundTag
set "y"(value: double)
set "x"(value: double)
set "z"(value: double)
get "name"(): $Component
get "displayName"(): $Component
get "passengers"(): $EntityArrayList
get "server"(): $MinecraftServer
get "type"(): string
set "position"(value: $BlockContainerJS$$Type)
get "monster"(): boolean
set "motionX"(value: double)
get "level"(): $Level
set "motionY"(value: double)
get "motionX"(): double
get "item"(): $ItemStack
set "motionZ"(value: double)
get "block"(): $BlockContainerJS
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "motionZ"(): double
get "teamId"(): string
get "facing"(): $Direction
get "animal"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
set "activePostShader"(value: $ResourceLocation$$Type)
get "persistentData"(): $CompoundTag
}

export namespace $PlayerKJS {
const probejs$$marker: never
}
export class $PlayerKJS$$Static implements $PlayerKJS {


 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "spawn"(): void
 "setStatusMessage"(arg0: $Component$$Type): void
 "self"(): $LivingEntity
 "getStages"(): $Stages
 "getInventory"(): $InventoryKJS
 "isMiningBlock"(): boolean
 "addExhaustion"(arg0: float): void
 "getXpLevel"(): integer
 "setSaturation"(arg0: float): void
 "addFood"(arg0: integer, arg1: float): void
 "addXPLevels"(arg0: integer): void
 "giveInHand"(arg0: $ItemStack$$Type): void
 "getFoodLevel"(): integer
 "setFoodLevel"(arg0: integer): void
 "getStats"(): $PlayerStatsJS
 "getKgui"(): $KGUIActions
 "setMouseItem"(arg0: $ItemStack$$Type): void
 "getSaturation"(): float
 "getMouseItem"(): $ItemStack
 "setXpLevel"(arg0: integer): void
 "isPlayer"(): boolean
 "getProfile"(): $GameProfile
 "addItemCooldown"(arg0: $Item$$Type, arg1: integer): void
 "getCraftingGrid"(): $InventoryKJS
 "setSelectedSlot"(arg0: integer): void
 "getSelectedSlot"(): integer
 "boostElytraFlight"(): void
 "sendInventoryUpdate"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addXP"(arg0: integer): void
 "setXp"(arg0: integer): void
 "getXp"(): integer
 "give"(arg0: $ItemStack$$Type): void
 "isFake"(): boolean
 "notify"(arg0: $Component$$Type, arg1: $Component$$Type): void
 "notify"(arg0: $NotificationToastData$$Type): void
 "setDefaultMovementSpeed"(arg0: double): void
 "setMovementSpeedAddition"(arg0: double): void
 "getDefaultMovementSpeed"(): double
 "swing"(): void
 "swing"(arg0: $InteractionHand$$Type): void
 "foodEaten"(arg0: $ItemStack$$Type, arg1: $FoodProperties$$Type): void
 "getHeldItem"(arg0: $InteractionHand$$Type): $ItemStack
 "isUndead"(): boolean
 "rayTrace"(): $RayTraceResultJS
 "setOffHandItem"(arg0: $ItemStack$$Type): void
 "getEquipment"(arg0: $EquipmentSlot$$Type): $ItemStack
 "setMaxHealth"(arg0: float): void
 "rayTraceEntity"(arg0: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(arg0: $InteractionHand$$Type, arg1: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setEquipment"(arg0: $EquipmentSlot$$Type, arg1: $ItemStack$$Type): void
 "setDefaultMovementSpeedMultiplier"(arg0: double): void
 "setTotalMovementSpeedMultiplier"(arg0: double): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer): void
 "canEntityBeSeen"(arg0: $LivingEntity$$Type): boolean
 "setLegsArmorItem"(arg0: $ItemStack$$Type): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type): void
 "getMainHandItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "setFeetArmorItem"(arg0: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>, arg1: double): void
 "getReachDistance"(): double
 "isHoldingInAnyHand"(arg0: $ItemPredicate$$Type): boolean
 "modifyAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type, arg2: double, arg3: $AttributeModifier$Operation$$Type): void
 "getAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>): double
 "setMainHandItem"(arg0: $ItemStack$$Type): void
 "setChestArmorItem"(arg0: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(arg0: $ItemStack$$Type): void
 "getAttributeTotalValue"(arg0: $Holder$$Type<($Attribute)>): double
 "getChestArmorItem"(): $ItemStack
 "sendData"(arg0: string, arg1: $CompoundTag$$Type): void
 "sendData"(arg0: string): void
 "getData"(): $AttachedData<($Player)>
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "getItem"(): $ItemStack
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerKJS_ = $PlayerKJS$$Type;
}}
declare module "dev.latvian.mods.rhino.Context" {
import {$ContextFactory, $ContextFactory$$Type} from "dev.latvian.mods.rhino.ContextFactory"
import {$Reader, $Reader$$Type} from "java.io.Reader"
import {$ErrorReporter, $ErrorReporter$$Type} from "dev.latvian.mods.rhino.ErrorReporter"
import {$EvaluatorException, $EvaluatorException$$Type} from "dev.latvian.mods.rhino.EvaluatorException"
import {$Field, $Field$$Type} from "java.lang.reflect.Field"
import {$Method, $Method$$Type} from "java.lang.reflect.Method"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Script, $Script$$Type} from "dev.latvian.mods.rhino.Script"
import {$Callable, $Callable$$Type} from "dev.latvian.mods.rhino.Callable"
import {$ScriptableObject, $ScriptableObject$$Type} from "dev.latvian.mods.rhino.ScriptableObject"
import {$ArrayValueProvider, $ArrayValueProvider$$Type} from "dev.latvian.mods.rhino.util.ArrayValueProvider"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Throwable, $Throwable$$Type} from "java.lang.Throwable"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$ClassLoader, $ClassLoader$$Type} from "java.lang.ClassLoader"
import {$ClassVisibilityContext, $ClassVisibilityContext$$Type} from "dev.latvian.mods.rhino.util.ClassVisibilityContext"
import {$RegExp, $RegExp$$Type} from "dev.latvian.mods.rhino.regexp.RegExp"
import {$RuntimeException, $RuntimeException$$Type} from "java.lang.RuntimeException"
import {$GeneratedClassLoader, $GeneratedClassLoader$$Type} from "dev.latvian.mods.rhino.GeneratedClassLoader"

export class $Context {
static readonly "CONVERSION_EXACT": integer
static readonly "CONVERSION_TRIVIAL": integer
static readonly "CONVERSION_NONE": integer
static readonly "JSTYPE_UNDEFINED": integer
static readonly "JSTYPE_NULL": integer
static readonly "JSTYPE_BOOLEAN": integer
static readonly "JSTYPE_NUMBER": integer
static readonly "JSTYPE_STRING": integer
static readonly "JSTYPE_JAVA_CLASS": integer
static readonly "JSTYPE_JAVA_OBJECT": integer
static readonly "JSTYPE_JAVA_ARRAY": integer
static readonly "JSTYPE_OBJECT": integer
readonly "factory": $ContextFactory
readonly "lock": any
 "generateObserverCount": boolean

constructor(factory: $ContextFactory$$Type)

public "newArray"(scope: $Scriptable$$Type, elements: (any)[]): $Scriptable
public "newArray"(scope: $Scriptable$$Type, length: integer): $Scriptable
public "wrap"(scope: $Scriptable$$Type, obj: any, target: $TypeInfo$$Type): any
public "wrap"(scope: $Scriptable$$Type, obj: any): any
public "canConvert"(from: any, target: $TypeInfo$$Type): boolean
public "getImplementationVersion"(): string
public static "reportError"(message: string, lineno: integer, lineSource: string, lineOffset: integer, sourceName: string): void
public static "reportError"(message: string): void
public "createClassLoader"(parent: $ClassLoader$$Type): $GeneratedClassLoader
public "listOf"(from: any, target: $TypeInfo$$Type): any
public "setOf"(from: any, target: $TypeInfo$$Type): any
public "arrayOf"(from: any, target: $TypeInfo$$Type): any
public "getMaximumInterpreterStackDepth"(): integer
public "setInstructionObserverThreshold"(threshold: integer): void
public "internalConversionWeightLast"(fromObj: any, target: $TypeInfo$$Type): integer
public "getInstructionObserverThreshold"(): integer
public static "getSourcePositionFromStack"(linep: (integer)[]): string
public static "reportRuntimeError0"(messageId: string, cx: $Context$$Type): $EvaluatorException
public static "reportRuntimeError1"(messageId: string, arg1: any, cx: $Context$$Type): $EvaluatorException
public static "reportRuntimeError2"(messageId: string, arg1: any, arg2: any, cx: $Context$$Type): $EvaluatorException
public static "reportRuntimeError3"(messageId: string, arg1: any, arg2: any, arg3: any, cx: $Context$$Type): $EvaluatorException
public static "reportRuntimeError4"(messageId: string, arg1: any, arg2: any, arg3: any, arg4: any, cx: $Context$$Type): $EvaluatorException
public static "throwAsScriptRuntimeEx"(e: $Throwable$$Type, cx: $Context$$Type): $RuntimeException
public "initStandardObjects"(scope: $ScriptableObject$$Type): $Scriptable
public "initStandardObjects"(): $ScriptableObject
public "initStandardObjects"(scope: $ScriptableObject$$Type, sealed: boolean): $ScriptableObject
public "initSafeStandardObjects"(): $ScriptableObject
public "initSafeStandardObjects"(scope: $ScriptableObject$$Type, sealed: boolean): $ScriptableObject
public "initSafeStandardObjects"(scope: $ScriptableObject$$Type): $Scriptable
public "setApplicationClassLoader"(loader: $ClassLoader$$Type): void
public "defaultObjectToSource"(scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args: (any)[]): string
public "internalConversionWeight"(fromObj: any, target: $TypeInfo$$Type): integer
public "lastStoredScriptable"(): $Scriptable
public "reportConversionError"(value: any, type: $TypeInfo$$Type): any
public "newClassSerialNumber"(): integer
public "setGenerateObserverCount"(generateObserverCount: boolean): void
public "createInterfaceAdapter"(type: $TypeInfo$$Type, so: $ScriptableObject$$Type): any
public "getApplicationClassLoader"(): $ClassLoader
public "arrayValueProviderOf"(value: any): $ArrayValueProvider
public "getConversionWeight"(from: any, target: $TypeInfo$$Type): integer
public "putThreadLocal"(key: any, value: any): void
public "evaluateReader"(scope: $Scriptable$$Type, arg1: $Reader$$Type, sourceName: string, lineno: integer, securityDomain: any): any
public "isStrictMode"(): boolean
public "getErrorReporter"(): $ErrorReporter
public static "getUndefinedValue"(): any
public "compileReader"(arg0: $Reader$$Type, sourceName: string, lineno: integer, securityDomain: any): $Script
public static "reportWarning"(message: string, sourceName: string, lineno: integer, lineSource: string, lineOffset: integer): void
public static "reportWarning"(message: string, cx: $Context$$Type): void
public "compileString"(source: string, sourceName: string, lineno: integer, securityDomain: any): $Script
public static "reportRuntimeError"(message: string, sourceName: string, lineno: integer, lineSource: string, lineOffset: integer): $EvaluatorException
public static "reportRuntimeError"(message: string, cx: $Context$$Type): $EvaluatorException
public "removeThreadLocal"(key: any): void
public "visibleToScripts"(fullClassName: string, type: $ClassVisibilityContext$$Type): boolean
public "wrapAsJavaObject"(scope: $Scriptable$$Type, javaObject: any, target: $TypeInfo$$Type): $Scriptable
public "getThreadLocal"(key: any): any
public "evaluateString"(scope: $Scriptable$$Type, source: string, sourceName: string, lineno: integer, securityDomain: any): any
public "insertContextArg"(args: (any)[]): (any)[]
public "getMappedMethod"(from: $Class$$Type<(any)>, method: $Method$$Type): string
public static "getSizeRank"(aType: $TypeInfo$$Type): integer
public "hasTopCallScope"(): boolean
public "getMappedField"(from: $Class$$Type<(any)>, field: $Field$$Type): string
public "getTopCallOrThrow"(): $Scriptable
public "getUnmappedClass"(from: string): string
public "getMappedClass"(from: $Class$$Type<(any)>): string
public "getTopCallScope"(): $Scriptable
public "storeScriptable"(value: $Scriptable$$Type): void
public "wrapJavaClass"(scope: $Scriptable$$Type, javaClass: $Class$$Type<(any)>): $Scriptable
public "wrapNewObject"(scope: $Scriptable$$Type, obj: any, objType: $TypeInfo$$Type): $Scriptable
public "getRegExp"(): $RegExp
public "newObject"(scope: $Scriptable$$Type): $Scriptable
public "newObject"(scope: $Scriptable$$Type, constructorName: string, args: (any)[]): $Scriptable
public "newObject"(scope: $Scriptable$$Type, constructorName: string): $Scriptable
public "addToScope"(scope: $Scriptable$$Type, name: string, value: any): void
public "javaToJS"(value: any, scope: $Scriptable$$Type): any
public "javaToJS"(value: any, scope: $Scriptable$$Type, target: $TypeInfo$$Type): any
public "mapOf"(from: any, kTarget: $TypeInfo$$Type, vTarget: $TypeInfo$$Type): any
public "doTopCall"(scope: $Scriptable$$Type, callable: $Callable$$Type, thisObj: $Scriptable$$Type, args: (any)[], isTopLevelStrict: boolean): any
public "setTopCall"(scope: $Scriptable$$Type): void
public "callSync"(callable: $Callable$$Type, scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args: (any)[]): any
public "jsToJava"(from: any, target: $TypeInfo$$Type): any
get "implementationVersion"(): string
get "maximumInterpreterStackDepth"(): integer
set "instructionObserverThreshold"(value: integer)
get "instructionObserverThreshold"(): integer
set "applicationClassLoader"(value: $ClassLoader$$Type)
set "generateObserverCount"(value: boolean)
get "applicationClassLoader"(): $ClassLoader
get "strictMode"(): boolean
get "errorReporter"(): $ErrorReporter
get "topCallOrThrow"(): $Scriptable
get "topCallScope"(): $Scriptable
get "regExp"(): $RegExp
set "topCall"(value: $Scriptable$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Context$$Type = ($Context);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Context_ = $Context$$Type;
}}
declare module "dev.latvian.mods.rhino.IdEnumerationIterator" {
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $IdEnumerationIterator {

 "enumerationIteratorHasNext"(arg1: $Consumer$$Type<(any)>): boolean
 "enumerationIteratorNext"(arg1: $Consumer$$Type<(any)>): boolean
}

export namespace $IdEnumerationIterator {
const probejs$$marker: never
}
export class $IdEnumerationIterator$$Static implements $IdEnumerationIterator {


 "enumerationIteratorHasNext"(arg1: $Consumer$$Type<(any)>): boolean
 "enumerationIteratorNext"(arg1: $Consumer$$Type<(any)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdEnumerationIterator$$Type = ($IdEnumerationIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdEnumerationIterator_ = $IdEnumerationIterator$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.EntityKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$WithPersistentData, $WithPersistentData$$Type} from "dev.latvian.mods.kubejs.core.WithPersistentData"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MessageSenderKJS, $MessageSenderKJS$$Type} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$ScriptTypeHolder, $ScriptTypeHolder$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$RayTraceResultJS, $RayTraceResultJS$$Type} from "dev.latvian.mods.kubejs.entity.RayTraceResultJS"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"

export interface $EntityKJS extends $WithPersistentData, $MessageSenderKJS, $ScriptTypeHolder {

 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "spawn"(): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "self"(): $Entity
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isPlayer"(): boolean
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "getProfile"(): $GameProfile
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "getItem"(): $ItemStack
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "isLiving"(): boolean
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
set "nbt"(value: $CompoundTag$$Type)
get "nbt"(): $CompoundTag
set "y"(value: double)
set "x"(value: double)
set "z"(value: double)
get "name"(): $Component
get "displayName"(): $Component
get "passengers"(): $EntityArrayList
get "server"(): $MinecraftServer
get "type"(): string
set "position"(value: $BlockContainerJS$$Type)
get "player"(): boolean
get "monster"(): boolean
set "motionX"(value: double)
get "level"(): $Level
get "profile"(): $GameProfile
set "motionY"(value: double)
get "motionX"(): double
get "item"(): $ItemStack
set "motionZ"(value: double)
get "block"(): $BlockContainerJS
get "living"(): boolean
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "motionZ"(): double
get "teamId"(): string
get "facing"(): $Direction
get "animal"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export namespace $EntityKJS {
const probejs$$marker: never
}
export class $EntityKJS$$Static implements $EntityKJS {


 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "spawn"(): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "self"(): $Entity
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isPlayer"(): boolean
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "getProfile"(): $GameProfile
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "getItem"(): $ItemStack
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "isLiving"(): boolean
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityKJS$$Type = ($EntityKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityKJS_ = $EntityKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemTintFunction" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"

export interface $ItemTintFunction {

 "getColor"(arg0: $ItemStack$$Type, arg1: integer): $KubeColor

(arg0: $ItemStack, arg1: integer): $KubeColor$$Type
}

export namespace $ItemTintFunction {
const TYPE_INFO: $TypeInfo
const BLOCK: $ItemTintFunction
const POTION: $ItemTintFunction
const MAP: $ItemTintFunction
const DISPLAY_COLOR_NBT: $ItemTintFunction
function of(arg1: any): $ItemTintFunction
const probejs$$marker: never
}
export class $ItemTintFunction$$Static implements $ItemTintFunction {
static readonly "TYPE_INFO": $TypeInfo
static readonly "BLOCK": $ItemTintFunction
static readonly "POTION": $ItemTintFunction
static readonly "MAP": $ItemTintFunction
static readonly "DISPLAY_COLOR_NBT": $ItemTintFunction


static "of"(arg1: any): $ItemTintFunction
 "getColor"(arg0: $ItemStack$$Type, arg1: integer): $KubeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTintFunction$$Type = (($ItemTintFunction$$Type)[]) | (string) | ((stack: $ItemStack, index: integer) => void) | ((arg0: $ItemStack, arg1: integer) => $KubeColor$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTintFunction_ = $ItemTintFunction$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.special.ShapelessKubeJSRecipe" {
import {$CraftingInput, $CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IngredientActionHolder, $IngredientActionHolder$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$ShapelessRecipe, $ShapelessRecipe$$Type} from "net.minecraft.world.item.crafting.ShapelessRecipe"
import {$KubeJSCraftingRecipe, $KubeJSCraftingRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.special.KubeJSCraftingRecipe"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$RecipeSerializer, $RecipeSerializer$$Type} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $ShapelessKubeJSRecipe extends $ShapelessRecipe implements $KubeJSCraftingRecipe {
readonly "group": string
readonly "result": $ItemStack
readonly "ingredients": $NonNullList<($Ingredient)>

constructor(arg0: $ShapelessRecipe$$Type, arg1: $List$$Type<($IngredientActionHolder$$Type)>, arg2: string, arg3: string)

public "getRemainingItems"(arg0: $CraftingInput$$Type): $NonNullList<($ItemStack)>
public "getRemainingItems"(arg0: $RecipeInput$$Type): $NonNullList<(any)>
public "assemble"(arg0: $RecipeInput$$Type, arg1: $HolderLookup$Provider$$Type): $ItemStack
public "assemble"(arg0: $CraftingInput$$Type, arg1: $HolderLookup$Provider$$Type): $ItemStack
public "getSerializer"(): $RecipeSerializer<(any)>
public "kjs$getStage"(): string
public "kjs$getModifyResult"(): string
public "kjs$getIngredientActions"(): $List<($IngredientActionHolder)>
public "kjs$assemble"(arg0: $CraftingInput$$Type, arg1: $HolderLookup$Provider$$Type): $ItemStack
public "kjs$getRemainingItems"(arg0: $CraftingInput$$Type): $NonNullList<($ItemStack)>
get "serializer"(): $RecipeSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapelessKubeJSRecipe$$Type = ($ShapelessKubeJSRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapelessKubeJSRecipe_ = $ShapelessKubeJSRecipe$$Type;
}}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent" {
import {$Slot, $Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"

export class $ChestMenuInventoryClickEvent {
readonly "type": $ClickType
readonly "button": integer

constructor(arg0: $Slot$$Type, arg1: $ClickType$$Type, arg2: integer)

public "getIndex"(): integer
public "getItem"(): $ItemStack
public "setItem"(arg0: $ItemStack$$Type): void
get "index"(): integer
get "item"(): $ItemStack
set "item"(value: $ItemStack$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuInventoryClickEvent$$Type = ($ChestMenuInventoryClickEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuInventoryClickEvent_ = $ChestMenuInventoryClickEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.BlockRenderType" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $BlockRenderType extends $Enum<($BlockRenderType)> {
static readonly "SOLID": $BlockRenderType
static readonly "CUTOUT": $BlockRenderType
static readonly "CUTOUT_MIPPED": $BlockRenderType
static readonly "TRANSLUCENT": $BlockRenderType


public static "values"(): ($BlockRenderType)[]
public static "valueOf"(arg0: string): $BlockRenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRenderType$$Type = (("solid") | ("cutout") | ("cutout_mipped") | ("translucent"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockRenderType_ = $BlockRenderType$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.CachedItemTagLookup" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List, $List$$Type} from "java.util.List"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$CachedTagLookup, $CachedTagLookup$$Type} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup"

export class $CachedItemTagLookup extends $CachedTagLookup<($Item)> {
readonly "registry": $Registry<(T)>
readonly "originalMap": $Map<($ResourceLocation), ($List<($TagLoader$EntryWithSource)>)>

constructor(arg0: $Registry$$Type<($Item$$Type)>, arg1: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>)

public "isEmpty"(arg0: $TagKey$$Type<($Item)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedItemTagLookup$$Type = ($CachedItemTagLookup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedItemTagLookup_ = $CachedItemTagLookup$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction" {
import {$CraftingInput, $CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IngredientActionHolder, $IngredientActionHolder$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$IngredientActionType, $IngredientActionType$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionType"

export interface $IngredientAction {

 "transform"(arg0: $ItemStack$$Type, arg1: integer, arg2: $CraftingInput$$Type): $ItemStack
 "getType"(): $IngredientActionType<(any)>
get "type"(): $IngredientActionType<(any)>
}

export namespace $IngredientAction {
const CODEC: $Codec<($IngredientAction)>
const STREAM_CODEC: $StreamCodec<($RegistryFriendlyByteBuf), ($IngredientAction)>
function getRemaining(arg0: $CraftingInput$$Type, arg1: integer, arg2: $List$$Type<($IngredientActionHolder$$Type)>): $ItemStack
const probejs$$marker: never
}
export class $IngredientAction$$Static implements $IngredientAction {
static readonly "CODEC": $Codec<($IngredientAction)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IngredientAction)>


 "transform"(arg0: $ItemStack$$Type, arg1: integer, arg2: $CraftingInput$$Type): $ItemStack
 "getType"(): $IngredientActionType<(any)>
static "getRemaining"(arg0: $CraftingInput$$Type, arg1: integer, arg2: $List$$Type<($IngredientActionHolder$$Type)>): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientAction$$Type = ($IngredientAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientAction_ = $IngredientAction$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.ParticleOptionsWrapper" {
import {$DustParticleOptions, $DustParticleOptions$$Type} from "net.minecraft.core.particles.DustParticleOptions"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

export interface $ParticleOptionsWrapper {

}

export namespace $ParticleOptionsWrapper {
const ERROR: $DustParticleOptions
function wrap(arg0: $RegistryAccessContainer$$Type, arg1: any): $ParticleOptions
function create(arg0: $ParticleOptions$$Type): $ParticleOptions
const probejs$$marker: never
}
export class $ParticleOptionsWrapper$$Static implements $ParticleOptionsWrapper {
static readonly "ERROR": $DustParticleOptions


static "wrap"(arg0: $RegistryAccessContainer$$Type, arg1: any): $ParticleOptions
static "create"(arg0: $ParticleOptions$$Type): $ParticleOptions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleOptionsWrapper$$Type = ($ParticleOptionsWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParticleOptionsWrapper_ = $ParticleOptionsWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.EntityTypeKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS, $RegistryObjectKJS$$Type} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export interface $EntityTypeKJS extends $RegistryObjectKJS<($EntityType<(any)>)> {

 "getRegistry"(): $Registry<($EntityType<(any)>)>
 "getRegistryId"(): $ResourceKey<($Registry<($EntityType<(any)>)>)>
 "getId"(): string
 "getKey"(): $ResourceKey<($EntityType<(any)>)>
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "asHolder"(): $Holder<($EntityType<(any)>)>
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
get "registry"(): $Registry<($EntityType<(any)>)>
get "registryId"(): $ResourceKey<($Registry<($EntityType<(any)>)>)>
get "id"(): string
get "key"(): $ResourceKey<($EntityType<(any)>)>
get "mod"(): string
get "idLocation"(): $ResourceLocation
get "tags"(): $Collection<($ResourceLocation)>
}

export namespace $EntityTypeKJS {
const probejs$$marker: never
}
export class $EntityTypeKJS$$Static implements $EntityTypeKJS {


 "getRegistry"(): $Registry<($EntityType<(any)>)>
 "getRegistryId"(): $ResourceKey<($Registry<($EntityType<(any)>)>)>
 "getId"(): string
 "getKey"(): $ResourceKey<($EntityType<(any)>)>
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "asHolder"(): $Holder<($EntityType<(any)>)>
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTypeKJS$$Type = ($EntityTypeKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityTypeKJS_ = $EntityTypeKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockEntityAttachment {

 "deserialize"(arg0: $HolderLookup$Provider$$Type, arg1: $Tag$$Type): void
 "getCapability"<CAP, SRC>(arg0: $BlockCapability$$Type<(CAP), (SRC)>): CAP
 "serverTick"(): void
 "serialize"(arg0: $HolderLookup$Provider$$Type): $Tag
 "onRemove"(arg0: $ServerLevel$$Type, arg1: $KubeBlockEntity$$Type, arg2: $BlockState$$Type): void
 "getWrappedObject"(): any
get "wrappedObject"(): any
}

export namespace $BlockEntityAttachment {
const probejs$$marker: never
}
export class $BlockEntityAttachment$$Static implements $BlockEntityAttachment {


 "deserialize"(arg0: $HolderLookup$Provider$$Type, arg1: $Tag$$Type): void
 "getCapability"<CAP, SRC>(arg0: $BlockCapability$$Type<(CAP), (SRC)>): CAP
 "serverTick"(): void
 "serialize"(arg0: $HolderLookup$Provider$$Type): $Tag
 "onRemove"(arg0: $ServerLevel$$Type, arg1: $KubeBlockEntity$$Type, arg2: $BlockState$$Type): void
 "getWrappedObject"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachment$$Type = ($BlockEntityAttachment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityAttachment_ = $BlockEntityAttachment$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.LangKubeEvent$Key" {
import {$Record, $Record$$Type} from "java.lang.Record"

export class $LangKubeEvent$Key extends $Record {

constructor(namespace: string, lang: string, key: string)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "key"(): string
public "lang"(): string
public "namespace"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LangKubeEvent$Key$$Type = ({"lang"?: string, "namespace"?: string, "key"?: string}) | ([lang?: string, namespace?: string, key?: string]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LangKubeEvent$Key_ = $LangKubeEvent$Key$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$MultipartBlockStateGenerator$Part, $MultipartBlockStateGenerator$Part$$Type} from "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator$Part"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $MultipartBlockStateGenerator {

constructor()

public "part"(arg0: string, arg1: $ResourceLocation$$Type): void
public "part"(arg0: string, arg1: $Consumer$$Type<($MultipartBlockStateGenerator$Part)>): void
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartBlockStateGenerator$$Type = ($MultipartBlockStateGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultipartBlockStateGenerator_ = $MultipartBlockStateGenerator$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.ColorWrapper" {
import {$ColorRGBA, $ColorRGBA$$Type} from "net.minecraft.util.ColorRGBA"
import {$Map, $Map$$Type} from "java.util.Map"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$TextColor, $TextColor$$Type} from "net.minecraft.network.chat.TextColor"
import {$ChatFormatting, $ChatFormatting$$Type} from "net.minecraft.ChatFormatting"

export interface $ColorWrapper {

}

export namespace $ColorWrapper {
const MAP: $Map<(string), ($KubeColor)>
const TEXT: $Map<(string), ($ChatFormatting)>
const DYE: $Map<(string), ($DyeColor)>
const NONE: $KubeColor
const BLACK: $KubeColor
const DARK_BLUE: $KubeColor
const DARK_GREEN: $KubeColor
const DARK_AQUA: $KubeColor
const DARK_RED: $KubeColor
const DARK_PURPLE: $KubeColor
const GOLD: $KubeColor
const GRAY: $KubeColor
const DARK_GRAY: $KubeColor
const BLUE: $KubeColor
const GREEN: $KubeColor
const AQUA: $KubeColor
const RED: $KubeColor
const LIGHT_PURPLE: $KubeColor
const YELLOW: $KubeColor
const WHITE: $KubeColor
const WHITE_DYE: $KubeColor
const ORANGE_DYE: $KubeColor
const MAGENTA_DYE: $KubeColor
const LIGHT_BLUE_DYE: $KubeColor
const YELLOW_DYE: $KubeColor
const LIME_DYE: $KubeColor
const PINK_DYE: $KubeColor
const GRAY_DYE: $KubeColor
const LIGHT_GRAY_DYE: $KubeColor
const CYAN_DYE: $KubeColor
const PURPLE_DYE: $KubeColor
const BLUE_DYE: $KubeColor
const BROWN_DYE: $KubeColor
const GREEN_DYE: $KubeColor
const RED_DYE: $KubeColor
const BLACK_DYE: $KubeColor
function of(arg0: any): $KubeColor
function textColorOf(arg0: any): $TextColor
function colorRGBAOf(arg0: any): $ColorRGBA
function createMapped(arg0: any, ...arg1: (string)[]): $KubeColor
function rgba(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $KubeColor
const probejs$$marker: never
}
export class $ColorWrapper$$Static implements $ColorWrapper {
static readonly "MAP": $Map<(string), ($KubeColor)>
static readonly "TEXT": $Map<(string), ($ChatFormatting)>
static readonly "DYE": $Map<(string), ($DyeColor)>
static readonly "NONE": $KubeColor
static readonly "BLACK": $KubeColor
static readonly "DARK_BLUE": $KubeColor
static readonly "DARK_GREEN": $KubeColor
static readonly "DARK_AQUA": $KubeColor
static readonly "DARK_RED": $KubeColor
static readonly "DARK_PURPLE": $KubeColor
static readonly "GOLD": $KubeColor
static readonly "GRAY": $KubeColor
static readonly "DARK_GRAY": $KubeColor
static readonly "BLUE": $KubeColor
static readonly "GREEN": $KubeColor
static readonly "AQUA": $KubeColor
static readonly "RED": $KubeColor
static readonly "LIGHT_PURPLE": $KubeColor
static readonly "YELLOW": $KubeColor
static readonly "WHITE": $KubeColor
static readonly "WHITE_DYE": $KubeColor
static readonly "ORANGE_DYE": $KubeColor
static readonly "MAGENTA_DYE": $KubeColor
static readonly "LIGHT_BLUE_DYE": $KubeColor
static readonly "YELLOW_DYE": $KubeColor
static readonly "LIME_DYE": $KubeColor
static readonly "PINK_DYE": $KubeColor
static readonly "GRAY_DYE": $KubeColor
static readonly "LIGHT_GRAY_DYE": $KubeColor
static readonly "CYAN_DYE": $KubeColor
static readonly "PURPLE_DYE": $KubeColor
static readonly "BLUE_DYE": $KubeColor
static readonly "BROWN_DYE": $KubeColor
static readonly "GREEN_DYE": $KubeColor
static readonly "RED_DYE": $KubeColor
static readonly "BLACK_DYE": $KubeColor


static "of"(arg0: any): $KubeColor
static "textColorOf"(arg0: any): $TextColor
static "colorRGBAOf"(arg0: any): $ColorRGBA
static "createMapped"(arg0: any, ...arg1: (string)[]): $KubeColor
static "rgba"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $KubeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColorWrapper$$Type = ($ColorWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ColorWrapper_ = $ColorWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.event.EventGroup" {
import {$EventHandler, $EventHandler$$Type} from "dev.latvian.mods.kubejs.event.EventHandler"
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ScriptTypePredicate, $ScriptTypePredicate$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$Class, $Class$$Type} from "java.lang.Class"

export class $EventGroup {
readonly "name": string


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "add"(arg0: string, arg1: $ScriptTypePredicate$$Type, arg2: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public static "of"(arg0: string): $EventGroup
public "common"(arg0: string, arg1: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public "getHandlers"(): $Map<(string), ($EventHandler)>
public "server"(arg0: string, arg1: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public "startup"(arg0: string, arg1: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public "client"(arg0: string, arg1: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
get "handlers"(): $Map<(string), ($EventHandler)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventGroup$$Type = ($EventGroup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventGroup_ = $EventGroup$$Type;
}}
declare module "dev.latvian.mods.rhino.util.ClassVisibilityContext" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $ClassVisibilityContext extends $Enum<($ClassVisibilityContext)> {
static readonly "UNKNOWN": $ClassVisibilityContext
static readonly "MEMBER": $ClassVisibilityContext
static readonly "CLASS_IN_PACKAGE": $ClassVisibilityContext
static readonly "ARGUMENT": $ClassVisibilityContext
static readonly "EXCEPTION": $ClassVisibilityContext


public static "values"(): ($ClassVisibilityContext)[]
public static "valueOf"(name: string): $ClassVisibilityContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassVisibilityContext$$Type = (("unknown") | ("member") | ("class_in_package") | ("argument") | ("exception"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassVisibilityContext_ = $ClassVisibilityContext$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.callbacks.EntityFallenOnBlockCallbackJS" {
import {$EntitySteppedOnBlockCallbackJS, $EntitySteppedOnBlockCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.EntitySteppedOnBlockCallbackJS"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EntityFallenOnBlockCallbackJS extends $EntitySteppedOnBlockCallbackJS {

constructor(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: float)

/**
 * Get the height the entity has fallen
 */
public "getFallHeight"(): float
/**
 * Applies fall damage to the entity as if they had fallen from the provided height, and multiplies it by the provided multiplier.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(arg0: float, arg1: float): boolean
/**
 * Damages the entity using the provided damage source, using the fall height and multiplier to calculate the damage amount.
 * Note this does not force the damage, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(arg0: float, arg1: float, arg2: $DamageSource$$Type): boolean
/**
 * Applies fall damage to the entity, multiplier by the multiplier.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(arg0: float): boolean
/**
 * Applies default fall damage to the entity.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(): boolean
get "fallHeight"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityFallenOnBlockCallbackJS$$Type = ($EntityFallenOnBlockCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityFallenOnBlockCallbackJS_ = $EntityFallenOnBlockCallbackJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.data.VirtualDataPack" {
import {$KubeDataGenerator, $KubeDataGenerator$$Type} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$PackType, $PackType$$Type} from "net.minecraft.server.packs.PackType"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$GeneratedDataStage, $GeneratedDataStage$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedDataStage"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$VirtualResourcePack, $VirtualResourcePack$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualResourcePack"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $VirtualDataPack extends $VirtualResourcePack implements $KubeDataGenerator {
readonly "scriptType": $ScriptType
readonly "packType": $PackType
readonly "stage": $GeneratedDataStage
readonly "info": string
readonly "component": $Component

constructor(arg0: $GeneratedDataStage$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualDataPack$$Type = ($VirtualDataPack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VirtualDataPack_ = $VirtualDataPack$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.entity.InventoryAttachment$Factory" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockEntityAttachmentFactory, $BlockEntityAttachmentFactory$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentInfo, $BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$List, $List$$Type} from "java.util.List"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$BlockEntityAttachment, $BlockEntityAttachment$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $InventoryAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory {

constructor(width: integer, height: integer, inputFilter: $Optional$$Type<($ItemPredicate$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "create"(arg0: $BlockEntityAttachmentInfo$$Type, arg1: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "width"(): integer
public "height"(): integer
public "getCapabilities"(): $List<($BlockCapability<(any), (any)>)>
public "inputFilter"(): $Optional<($ItemPredicate)>
public "isTicking"(): boolean
get "capabilities"(): $List<($BlockCapability<(any), (any)>)>
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryAttachment$Factory$$Type = ({"width"?: integer, "height"?: integer, "inputFilter"?: ($ItemPredicate$$Type)?}) | ([width?: integer, height?: integer, inputFilter?: ($ItemPredicate$$Type)?]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryAttachment$Factory_ = $InventoryAttachment$Factory$$Type;
}}
declare module "dev.latvian.mods.kubejs.web.KJSWSSession" {
import {$WSSession, $WSSession$$Type} from "dev.latvian.apps.tinyserver.ws.WSSession"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$SessionInfo, $SessionInfo$$Type} from "dev.latvian.mods.kubejs.web.SessionInfo"
import {$KJSHTTPRequest, $KJSHTTPRequest$$Type} from "dev.latvian.mods.kubejs.web.KJSHTTPRequest"

export class $KJSWSSession extends $WSSession<($KJSHTTPRequest)> {
 "info": $SessionInfo

constructor()

public "onTextMessage"(arg0: string): void
public "onEvent"(arg0: string, arg1: $JsonElement$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KJSWSSession$$Type = ($KJSWSSession);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KJSWSSession_ = $KJSWSSession$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.DoorBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$BlockSetType, $BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $DoorBlockBuilder extends $ShapedBlockBuilder {
static readonly "TRAPDOOR_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "behaviour"(arg0: $BlockSetType$$Type): this
public "generateLootTable"(): $LootTable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoorBlockBuilder$$Type = ($DoorBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoorBlockBuilder_ = $DoorBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.rhino.Symbol" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Symbol {

}

export namespace $Symbol {
const probejs$$marker: never
}
export class $Symbol$$Static implements $Symbol {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Symbol$$Type = ($Symbol);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Symbol_ = $Symbol$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.DetectorBlock$Builder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $DetectorBlock$Builder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "detectorId"(arg0: string): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DetectorBlock$Builder$$Type = ($DetectorBlock$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DetectorBlock$Builder_ = $DetectorBlock$Builder$$Type;
}}
declare module "dev.latvian.mods.rhino.IdFunctionObject" {
import {$Context, $Context$$Type} from "dev.latvian.mods.rhino.Context"
import {$BaseFunction, $BaseFunction$$Type} from "dev.latvian.mods.rhino.BaseFunction"
import {$DefaultValueTypeHint, $DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$RuntimeException, $RuntimeException$$Type} from "java.lang.RuntimeException"
import {$IdFunctionCall, $IdFunctionCall$$Type} from "dev.latvian.mods.rhino.IdFunctionCall"

export class $IdFunctionObject extends $BaseFunction {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(idcall: $IdFunctionCall$$Type, tag: any, id: integer, name: string, arity: integer, scope: $Scriptable$$Type)
constructor(idcall: $IdFunctionCall$$Type, tag: any, id: integer, arity: integer)

public "getLength"(): integer
public "call"(scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args: (any)[]): any
public "createObject"(scope: $Scriptable$$Type): $Scriptable
public "getTag"(): any
public "unknown"(): $RuntimeException
public "exportAsScopeProperty"(): void
public "methodId"(): integer
public "initFunction"(name: string, scope: $Scriptable$$Type): void
public "markAsConstructor"(prototypeProperty: $Scriptable$$Type): void
public "hasTag"(tag: any): boolean
public "getFunctionName"(): string
public "getPrototype"(): $Scriptable
public "getArity"(): integer
public "addAsProperty"(target: $Scriptable$$Type, cx: $Context$$Type): void
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "getAllIds"(): (any)[]
public "getIds"(): (any)[]
public "getParentScope"(): $Scriptable
public "setPrototype"(arg0: $Scriptable$$Type): void
public "setParentScope"(arg0: $Scriptable$$Type): void
get "length"(): integer
get "tag"(): any
get "functionName"(): string
get "prototype"(): $Scriptable
get "arity"(): integer
get "allIds"(): (any)[]
get "ids"(): (any)[]
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
set "parentScope"(value: $Scriptable$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdFunctionObject$$Type = ($IdFunctionObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdFunctionObject_ = $IdFunctionObject$$Type;
}}
declare module "dev.latvian.apps.tinyserver.http.response.HTTPStatus" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$HTTPResponse, $HTTPResponse$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPResponse"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$StatusCode, $StatusCode$$Type} from "dev.latvian.apps.tinyserver.StatusCode"
import {$HTTPResponseBuilder, $HTTPResponseBuilder$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPResponseBuilder"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$ResponseContent, $ResponseContent$$Type} from "dev.latvian.apps.tinyserver.content.ResponseContent"

export class $HTTPStatus extends $Enum<($HTTPStatus)> implements $HTTPResponse {
static readonly "CONTINUE": $HTTPStatus
static readonly "SWITCHING_PROTOCOLS": $HTTPStatus
static readonly "OK": $HTTPStatus
static readonly "CREATED": $HTTPStatus
static readonly "ACCEPTED": $HTTPStatus
static readonly "NOT_AUTHORITATIVE_INFORMATION": $HTTPStatus
static readonly "NO_CONTENT": $HTTPStatus
static readonly "RESET_CONTENT": $HTTPStatus
static readonly "PARTIAL_CONTENT": $HTTPStatus
static readonly "MULTIPLE_CHOICES": $HTTPStatus
static readonly "MOVED_PERMANENTLY": $HTTPStatus
static readonly "FOUND": $HTTPStatus
static readonly "SEE_OTHER": $HTTPStatus
static readonly "NOT_MODIFIED": $HTTPStatus
static readonly "USE_PROXY": $HTTPStatus
static readonly "TEMPORARY_REDIRECT": $HTTPStatus
static readonly "PERMANENT_REDIRECT": $HTTPStatus
static readonly "BAD_REQUEST": $HTTPStatus
static readonly "UNAUTHORIZED": $HTTPStatus
static readonly "PAYMENT_REQUIRED": $HTTPStatus
static readonly "FORBIDDEN": $HTTPStatus
static readonly "NOT_FOUND": $HTTPStatus
static readonly "METHOD_NOT_ALLOWED": $HTTPStatus
static readonly "NOT_ACCEPTABLE": $HTTPStatus
static readonly "PROXY_AUTHENTICATION_REQUIRED": $HTTPStatus
static readonly "REQUEST_TIMEOUT": $HTTPStatus
static readonly "CONFLICT": $HTTPStatus
static readonly "GONE": $HTTPStatus
static readonly "LENGTH_REQUIRED": $HTTPStatus
static readonly "PRECONDITION_FAILED": $HTTPStatus
static readonly "CONTENT_TOO_LARGE": $HTTPStatus
static readonly "URI_TOO_LONG": $HTTPStatus
static readonly "UNSUPPORTED_MEDIA_TYPE": $HTTPStatus
static readonly "RANGE_NOT_SATISFIABLE": $HTTPStatus
static readonly "EXPECTATION_FAILED": $HTTPStatus
static readonly "MISDIRECTED_REQUEST": $HTTPStatus
static readonly "UNPROCESSABLE_CONTENT": $HTTPStatus
static readonly "UPGRADE_REQUIRED": $HTTPStatus
static readonly "INTERNAL_ERROR": $HTTPStatus
static readonly "NOT_IMPLEMENTED": $HTTPStatus
static readonly "BAD_GATEWAY": $HTTPStatus
static readonly "SERVICE_UNAVAILABLE": $HTTPStatus
static readonly "GATEWAY_TIMEOUT": $HTTPStatus
static readonly "HTTP_VERSION_NOT_SUPPORTED": $HTTPStatus
readonly "statusCode": $StatusCode
readonly "responseBytes": (byte)[]


public static "values"(): ($HTTPStatus)[]
public static "valueOf"(arg0: string): $HTTPStatus
public "build"(arg0: $HTTPResponseBuilder$$Type): void
public static "created"(): $HTTPResponse
public "text"(arg0: string): $HTTPResponse
public "text"(arg0: $Iterable$$Type<(string)>): $HTTPResponse
public static "ok"(): $HTTPResponse
public "header"(arg0: string, arg1: string): $HTTPResponse
public "content"(arg0: (byte)[], arg1: string): $HTTPResponse
public "content"(arg0: $ResponseContent$$Type): $HTTPResponse
public "content"(arg0: $Path$$Type, arg1: string): $HTTPResponse
public "content"(arg0: $Path$$Type): $HTTPResponse
public static "redirect"(arg0: string): $HTTPResponse
public "json"(arg0: string): $HTTPResponse
public static "noContent"(): $HTTPResponse
public "noCache"(): $HTTPResponse
public static "redirectTemporary"(arg0: string): $HTTPResponse
public "publicCache"(arg0: integer): $HTTPResponse
public static "movedPermanently"(arg0: string): $HTTPResponse
public "privateCache"(arg0: integer): $HTTPResponse
public static "accepted"(): $HTTPResponse
public static "redirectPermanently"(arg0: string): $HTTPResponse
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HTTPStatus$$Type = (("continue") | ("switching_protocols") | ("ok") | ("created") | ("accepted") | ("not_authoritative_information") | ("no_content") | ("reset_content") | ("partial_content") | ("multiple_choices") | ("moved_permanently") | ("found") | ("see_other") | ("not_modified") | ("use_proxy") | ("temporary_redirect") | ("permanent_redirect") | ("bad_request") | ("unauthorized") | ("payment_required") | ("forbidden") | ("not_found") | ("method_not_allowed") | ("not_acceptable") | ("proxy_authentication_required") | ("request_timeout") | ("conflict") | ("gone") | ("length_required") | ("precondition_failed") | ("content_too_large") | ("uri_too_long") | ("unsupported_media_type") | ("range_not_satisfiable") | ("expectation_failed") | ("misdirected_request") | ("unprocessable_content") | ("upgrade_required") | ("internal_error") | ("not_implemented") | ("bad_gateway") | ("service_unavailable") | ("gateway_timeout") | ("http_version_not_supported"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HTTPStatus_ = $HTTPStatus$$Type;
}}
declare module "dev.latvian.apps.tinyserver.CompiledPath$Part" {
import {$Record, $Record$$Type} from "java.lang.Record"

export class $CompiledPath$Part extends $Record {

constructor(name: string, variable: boolean)

public "name"(): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "matches"(arg0: string): boolean
public "variable"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompiledPath$Part$$Type = ({"name"?: string, "variable"?: boolean}) | ([name?: string, variable?: boolean]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompiledPath$Part_ = $CompiledPath$Part$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.callbacks.CanBeReplacedCallbackJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CanBeReplacedCallbackJS {

constructor(arg0: $BlockPlaceContext$$Type, arg1: $BlockState$$Type)

public "getLevel"(): $Level
public "getItem"(): $ItemStack
public "getHorizontalDirection"(): $Direction
public "getRotation"(): float
public "getNearestLookingDirections"(): ($Direction)[]
public "getNearestLookingVerticalDirection"(): $Direction
public "isClickedPosIn"(arg0: $Fluid$$Type): boolean
public "getClickedBlock"(): $BlockContainerJS
public "getNearestLookingDirection"(): $Direction
public "getPlayer"(): $Player
public "isInside"(): boolean
public "getClickLocation"(): $Vec3
public "getClickedPos"(): $BlockPos
public "getClickedFace"(): $Direction
public "isSecondaryUseActive"(): boolean
public "getHand"(): $InteractionHand
public "canBeReplaced"(): boolean
public "getFluidStateAtClickedPos"(): $FluidState
get "level"(): $Level
get "item"(): $ItemStack
get "horizontalDirection"(): $Direction
get "rotation"(): float
get "nearestLookingDirections"(): ($Direction)[]
get "nearestLookingVerticalDirection"(): $Direction
get "clickedBlock"(): $BlockContainerJS
get "nearestLookingDirection"(): $Direction
get "player"(): $Player
get "inside"(): boolean
get "clickLocation"(): $Vec3
get "clickedPos"(): $BlockPos
get "clickedFace"(): $Direction
get "secondaryUseActive"(): boolean
get "hand"(): $InteractionHand
get "fluidStateAtClickedPos"(): $FluidState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CanBeReplacedCallbackJS$$Type = ($CanBeReplacedCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CanBeReplacedCallbackJS_ = $CanBeReplacedCallbackJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"

export interface $ScheduledEvents$Callback {

 "onCallback"(arg0: $ScheduledEvents$ScheduledEvent$$Type): void

(arg0: $ScheduledEvents$ScheduledEvent): void
}

export namespace $ScheduledEvents$Callback {
const TYPE_INFO: $TypeInfo
const probejs$$marker: never
}
export class $ScheduledEvents$Callback$$Static implements $ScheduledEvents$Callback {
static readonly "TYPE_INFO": $TypeInfo


 "onCallback"(arg0: $ScheduledEvents$ScheduledEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$Callback$$Type = ((arg0: $ScheduledEvents$ScheduledEvent) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScheduledEvents$Callback_ = $ScheduledEvents$Callback$$Type;
}}
declare module "dev.latvian.mods.kubejs.neoforge.NativeEventListeners" {
import {$List, $List$$Type} from "java.util.List"
import {$Event, $Event$$Type} from "net.neoforged.bus.api.Event"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $NativeEventListeners implements $Consumer<($Event)> {
readonly "listeners": $List<($Consumer<($Event)>)>

constructor()

public "accept"(arg0: $Event$$Type): void
public "accept"(arg0: any): void
public "andThen"(arg0: $Consumer$$Type<($Event)>): $Consumer<($Event)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeEventListeners$$Type = ($NativeEventListeners);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeEventListeners_ = $NativeEventListeners$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponent" {
import {$TinyMap, $TinyMap$$Type} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$RecipeComponentBuilder$Key, $RecipeComponentBuilder$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder$Key"
import {$ComponentRole, $ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$PairRecipeComponent, $PairRecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.PairRecipeComponent"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo, $ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$EitherRecipeComponent, $EitherRecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$UniqueIdBuilder, $UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentValue, $RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"

export interface $RecipeComponent<T> {

 "wrap"(arg1: $KubeRecipe$$Type, arg2: any): T
 "isEmpty"(arg0: T): boolean
 "replace"(arg1: $KubeRecipe$$Type, arg2: T, arg3: $ReplacementMatchInfo$$Type, arg4: any): T
 "matches"(arg1: $KubeRecipe$$Type, arg2: T, arg3: $ReplacementMatchInfo$$Type): boolean
 "validate"(arg0: T): void
 "typeInfo"(): $TypeInfo
 "key"(arg0: string, arg1: $ComponentRole$$Type): $RecipeKey<(T)>
 "asList"(): $RecipeComponent<($List<(T)>)>
 "or"<O>(arg0: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<(T), (O)>
 "and"<O>(arg0: $RecipeComponent$$Type<(O)>): $PairRecipeComponent<(T), (O)>
 "asMap"<K>(arg0: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), (T)>)>
 "codec"(): $Codec<(T)>
 "inputKey"(arg0: string): $RecipeKey<(T)>
 "outputKey"(arg0: string): $RecipeKey<(T)>
 "orSelf"(): $RecipeComponent<(T)>
 "withCodec"(arg0: $Codec$$Type<(T)>): $RecipeComponent<(T)>
 "otherKey"(arg0: string): $RecipeKey<(T)>
 "asConditionalListOrSelf"(): $RecipeComponent<($List<(T)>)>
 "writeToJson"(arg0: $KubeRecipe$$Type, arg1: $RecipeComponentValue$$Type<(T)>, arg2: $JsonObject$$Type): void
 "readFromJson"(arg0: $KubeRecipe$$Type, arg1: $RecipeComponentValue$$Type<(T)>, arg2: $JsonObject$$Type): void
 "asConditionalList"(): $RecipeComponent<($List<(T)>)>
 "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (T)>)>
 "hasPriority"(arg1: $KubeRecipe$$Type, arg2: any): boolean
 "buildUniqueId"(arg0: $UniqueIdBuilder$$Type, arg1: T): void
 "asListOrSelf"(): $RecipeComponent<($List<(T)>)>
}

export namespace $RecipeComponent {
function builder(arg0: $List$$Type<($RecipeComponentBuilder$Key$$Type)>): $RecipeComponentBuilder
function builder(...arg0: ($RecipeComponentBuilder$Key$$Type)[]): $RecipeComponentBuilder
const probejs$$marker: never
}
export class $RecipeComponent$$Static<T> implements $RecipeComponent {


 "wrap"(arg1: $KubeRecipe$$Type, arg2: any): T
 "isEmpty"(arg0: T): boolean
 "replace"(arg1: $KubeRecipe$$Type, arg2: T, arg3: $ReplacementMatchInfo$$Type, arg4: any): T
 "matches"(arg1: $KubeRecipe$$Type, arg2: T, arg3: $ReplacementMatchInfo$$Type): boolean
static "builder"(arg0: $List$$Type<($RecipeComponentBuilder$Key$$Type)>): $RecipeComponentBuilder
static "builder"(...arg0: ($RecipeComponentBuilder$Key$$Type)[]): $RecipeComponentBuilder
 "validate"(arg0: T): void
 "typeInfo"(): $TypeInfo
 "key"(arg0: string, arg1: $ComponentRole$$Type): $RecipeKey<(T)>
 "asList"(): $RecipeComponent<($List<(T)>)>
 "or"<O>(arg0: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<(T), (O)>
 "and"<O>(arg0: $RecipeComponent$$Type<(O)>): $PairRecipeComponent<(T), (O)>
 "asMap"<K>(arg0: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), (T)>)>
 "codec"(): $Codec<(T)>
 "inputKey"(arg0: string): $RecipeKey<(T)>
 "outputKey"(arg0: string): $RecipeKey<(T)>
 "orSelf"(): $RecipeComponent<(T)>
 "withCodec"(arg0: $Codec$$Type<(T)>): $RecipeComponent<(T)>
 "otherKey"(arg0: string): $RecipeKey<(T)>
 "asConditionalListOrSelf"(): $RecipeComponent<($List<(T)>)>
 "writeToJson"(arg0: $KubeRecipe$$Type, arg1: $RecipeComponentValue$$Type<(T)>, arg2: $JsonObject$$Type): void
 "readFromJson"(arg0: $KubeRecipe$$Type, arg1: $RecipeComponentValue$$Type<(T)>, arg2: $JsonObject$$Type): void
 "asConditionalList"(): $RecipeComponent<($List<(T)>)>
 "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (T)>)>
 "hasPriority"(arg1: $KubeRecipe$$Type, arg2: any): boolean
 "buildUniqueId"(arg0: $UniqueIdBuilder$$Type, arg1: T): void
 "asListOrSelf"(): $RecipeComponent<($List<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponent$$Type<T> = ($RecipeComponent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeComponent_<T> = $RecipeComponent$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.core.ClientLevelKJS" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Fireworks, $Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$SpriteSet, $SpriteSet$$Type} from "net.minecraft.client.particle.SpriteSet"
import {$ExplosionJS, $ExplosionJS$$Type} from "dev.latvian.mods.kubejs.level.ExplosionJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$LevelKJS, $LevelKJS$$Type} from "dev.latvian.mods.kubejs.core.LevelKJS"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB, $AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$KubeAnimatedParticle, $KubeAnimatedParticle$$Type} from "dev.latvian.mods.kubejs.client.KubeAnimatedParticle"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export interface $ClientLevelKJS extends $LevelKJS {

 "self"(): $Level
 "getSide"(): $ScriptType
 "spawnParticles"(arg0: $ParticleOptions$$Type, arg1: boolean, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: integer, arg9: double): void
 "getEntities"(): $EntityArrayList
 "kubeParticle"(arg0: double, arg1: double, arg2: double, arg3: $SpriteSet$$Type): $KubeAnimatedParticle
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(arg0: string): void
 "getBlock"(arg0: integer, arg1: integer, arg2: integer): $BlockContainerJS
 "getBlock"(arg0: $BlockPos$$Type): $BlockContainerJS
 "getBlock"(arg0: $BlockEntity$$Type): $BlockContainerJS
 "createEntityList"(arg0: $Collection$$Type<($Entity$$Type)>): $EntityArrayList
 "createExplosion"(arg0: double, arg1: double, arg2: double): $ExplosionJS
 "getEntitiesWithin"(arg0: $AABB$$Type): $EntityArrayList
 "getEntityByUUID"(arg0: $UUID$$Type): $Entity
 "createEntity"(arg0: $EntityType$$Type<(any)>): $Entity
 "spawnFireworks"(arg0: double, arg1: double, arg2: double, arg3: $Fireworks$$Type, arg4: integer): void
 "getDimension"(): $ResourceLocation
 "isOverworld"(): boolean
 "getPlayers"(): $EntityArrayList
 "getData"(): $AttachedData<($Level)>
 "getDisplayName"(): $Component

(): $AttachedData$$Type<($Level$$Type)>
get "side"(): $ScriptType
get "entities"(): $EntityArrayList
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "dimension"(): $ResourceLocation
get "overworld"(): boolean
get "players"(): $EntityArrayList
get "data"(): $AttachedData<($Level)>
get "displayName"(): $Component
}

export namespace $ClientLevelKJS {
const probejs$$marker: never
}
export class $ClientLevelKJS$$Static implements $ClientLevelKJS {


 "self"(): $Level
 "getSide"(): $ScriptType
 "spawnParticles"(arg0: $ParticleOptions$$Type, arg1: boolean, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: integer, arg9: double): void
 "getEntities"(): $EntityArrayList
 "kubeParticle"(arg0: double, arg1: double, arg2: double, arg3: $SpriteSet$$Type): $KubeAnimatedParticle
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(arg0: string): void
 "getBlock"(arg0: integer, arg1: integer, arg2: integer): $BlockContainerJS
 "getBlock"(arg0: $BlockPos$$Type): $BlockContainerJS
 "getBlock"(arg0: $BlockEntity$$Type): $BlockContainerJS
 "createEntityList"(arg0: $Collection$$Type<($Entity$$Type)>): $EntityArrayList
 "createExplosion"(arg0: double, arg1: double, arg2: double): $ExplosionJS
 "getEntitiesWithin"(arg0: $AABB$$Type): $EntityArrayList
 "getEntityByUUID"(arg0: $UUID$$Type): $Entity
 "createEntity"(arg0: $EntityType$$Type<(any)>): $Entity
 "spawnFireworks"(arg0: double, arg1: double, arg2: double, arg3: $Fireworks$$Type, arg4: integer): void
 "getDimension"(): $ResourceLocation
 "isOverworld"(): boolean
 "getPlayers"(): $EntityArrayList
 "getData"(): $AttachedData<($Level)>
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientLevelKJS$$Type = (() => $AttachedData$$Type<($Level$$Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientLevelKJS_ = $ClientLevelKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.ItemKJS" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ItemStackKey, $ItemStackKey$$Type} from "dev.latvian.mods.kubejs.item.ItemStackKey"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$IngredientSupplierKJS, $IngredientSupplierKJS$$Type} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ItemBuilder, $ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS, $RegistryObjectKJS$$Type} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"

export interface $ItemKJS extends $IngredientSupplierKJS, $RegistryObjectKJS<($Item)> {

 "getItem"(): $Item
 "getItemBuilder"(): $ItemBuilder
 "setItemBuilder"(arg0: $ItemBuilder$$Type): void
 "setCanRepair"(arg0: boolean): void
 "setNameKey"(arg0: string): void
 "getTypeData"(): $Map<(string), (any)>
 "getRegistry"(): $Registry<($Item)>
 "getRegistryId"(): $ResourceKey<($Registry<($Item)>)>
 "getTypeItemStackKey"(): $ItemStackKey
 "setCraftingRemainder"(arg0: $Item$$Type): void
 "kjs$asIngredient"(): $Ingredient
 "getId"(): string
 "getKey"(): $ResourceKey<($Item)>
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "asHolder"(): $Holder<($Item)>
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
get "item"(): $Item
get "itemBuilder"(): $ItemBuilder
set "itemBuilder"(value: $ItemBuilder$$Type)
set "canRepair"(value: boolean)
set "nameKey"(value: string)
get "typeData"(): $Map<(string), (any)>
get "registry"(): $Registry<($Item)>
get "registryId"(): $ResourceKey<($Registry<($Item)>)>
get "typeItemStackKey"(): $ItemStackKey
set "craftingRemainder"(value: $Item$$Type)
get "id"(): string
get "key"(): $ResourceKey<($Item)>
get "mod"(): string
get "idLocation"(): $ResourceLocation
get "tags"(): $Collection<($ResourceLocation)>
}

export namespace $ItemKJS {
const probejs$$marker: never
}
export class $ItemKJS$$Static implements $ItemKJS {


 "getItem"(): $Item
 "getItemBuilder"(): $ItemBuilder
 "setItemBuilder"(arg0: $ItemBuilder$$Type): void
 "setCanRepair"(arg0: boolean): void
 "setNameKey"(arg0: string): void
 "getTypeData"(): $Map<(string), (any)>
 "getRegistry"(): $Registry<($Item)>
 "getRegistryId"(): $ResourceKey<($Registry<($Item)>)>
 "getTypeItemStackKey"(): $ItemStackKey
 "setCraftingRemainder"(arg0: $Item$$Type): void
 "kjs$asIngredient"(): $Ingredient
 "getId"(): string
 "getKey"(): $ResourceKey<($Item)>
 "getMod"(): string
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "asHolder"(): $Holder<($Item)>
 "getIdLocation"(): $ResourceLocation
 "getTags"(): $Collection<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemKJS$$Type = ($ItemKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemKJS_ = $ItemKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.player.InventoryKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player opens or closes a container.
 */
export class $InventoryKubeEvent implements $KubePlayerEvent {

constructor(arg0: $Player$$Type, arg1: $AbstractContainerMenu$$Type)

/**
 * Gets the player that opened or closed the container.
 */
public "getEntity"(): $LivingEntity
/**
 * Gets the container that was opened or closed.
 */
public "getInventoryContainer"(): $AbstractContainerMenu
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "entity"(): $LivingEntity
get "inventoryContainer"(): $AbstractContainerMenu
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryKubeEvent$$Type = ($InventoryKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryKubeEvent_ = $InventoryKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicateDataCheck" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"

export interface $BlockEntityPredicateDataCheck {

 "checkData"(arg0: $CompoundTag$$Type): boolean

(arg0: $CompoundTag): boolean
}

export namespace $BlockEntityPredicateDataCheck {
const probejs$$marker: never
}
export class $BlockEntityPredicateDataCheck$$Static implements $BlockEntityPredicateDataCheck {


 "checkData"(arg0: $CompoundTag$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityPredicateDataCheck$$Type = ((arg0: $CompoundTag) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityPredicateDataCheck_ = $BlockEntityPredicateDataCheck$$Type;
}}
declare module "dev.latvian.mods.kubejs.gui.KubeJSGUI" {
import {$FriendlyByteBuf, $FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SimpleContainer, $SimpleContainer$$Type} from "net.minecraft.world.SimpleContainer"

export class $KubeJSGUI {
static readonly "EMPTY_CONTAINER": $SimpleContainer
 "width": integer
 "height": integer
 "title": $Component
 "inventoryLabelX": integer
 "inventoryLabelY": integer
 "inventory": $InventoryKJS
 "inventoryWidth": integer
 "inventoryHeight": integer
 "playerSlotsX": integer
 "playerSlotsY": integer

constructor()
constructor(arg0: $FriendlyByteBuf$$Type)

public "write"(arg0: $FriendlyByteBuf$$Type): void
public "setInventory"(arg0: $InventoryKJS$$Type): void
set "inventory"(value: $InventoryKJS$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSGUI$$Type = ($KubeJSGUI);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSGUI_ = $KubeJSGUI$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.entity.CustomCapabilityAttachment$Factory" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockEntityAttachmentFactory, $BlockEntityAttachmentFactory$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentInfo, $BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$List, $List$$Type} from "java.util.List"
import {$BlockEntityAttachment, $BlockEntityAttachment$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $CustomCapabilityAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory {

constructor(type: $BlockCapability$$Type<(any), (any)>, dataFactory: $Supplier$$Type<(any)>)

public "type"(): $BlockCapability<(any), (any)>
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "create"(arg0: $BlockEntityAttachmentInfo$$Type, arg1: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "getCapabilities"(): $List<($BlockCapability<(any), (any)>)>
public "dataFactory"(): $Supplier<(any)>
public "isTicking"(): boolean
get "capabilities"(): $List<($BlockCapability<(any), (any)>)>
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomCapabilityAttachment$Factory$$Type = ({"dataFactory"?: $Supplier$$Type<(never)>, "type"?: $BlockCapability$$Type<(never), (never)>}) | ([dataFactory?: $Supplier$$Type<(never)>, type?: $BlockCapability$$Type<(never), (never)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomCapabilityAttachment$Factory_ = $CustomCapabilityAttachment$Factory$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.BlockTintFunction" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$BlockAndTintGetter, $BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockTintFunction$Fixed, $BlockTintFunction$Fixed$$Type} from "dev.latvian.mods.kubejs.block.BlockTintFunction$Fixed"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockTintFunction {

 "getColor"(arg0: $BlockState$$Type, arg1: $BlockAndTintGetter$$Type, arg2: $BlockPos$$Type, arg3: integer): $KubeColor

(arg0: $BlockState, arg1: $BlockAndTintGetter, arg2: $BlockPos, arg3: integer): $KubeColor$$Type
}

export namespace $BlockTintFunction {
const TYPE_INFO: $TypeInfo
const GRASS: $BlockTintFunction
const DEFAULT_FOLIAGE_COLOR: $KubeColor
const FOLIAGE: $BlockTintFunction
const EVERGREEN_FOLIAGE: $BlockTintFunction$Fixed
const BIRCH_FOLIAGE: $BlockTintFunction$Fixed
const MANGROVE_FOLIAGE: $BlockTintFunction$Fixed
const WATER: $BlockTintFunction
const REDSTONE_COLORS: ($KubeColor)[]
const REDSTONE: $BlockTintFunction
function of(arg1: any): $BlockTintFunction
const probejs$$marker: never
}
export class $BlockTintFunction$$Static implements $BlockTintFunction {
static readonly "TYPE_INFO": $TypeInfo
static readonly "GRASS": $BlockTintFunction
static readonly "DEFAULT_FOLIAGE_COLOR": $KubeColor
static readonly "FOLIAGE": $BlockTintFunction
static readonly "EVERGREEN_FOLIAGE": $BlockTintFunction$Fixed
static readonly "BIRCH_FOLIAGE": $BlockTintFunction$Fixed
static readonly "MANGROVE_FOLIAGE": $BlockTintFunction$Fixed
static readonly "WATER": $BlockTintFunction
static readonly "REDSTONE_COLORS": ($KubeColor)[]
static readonly "REDSTONE": $BlockTintFunction


static "of"(arg1: any): $BlockTintFunction
 "getColor"(arg0: $BlockState$$Type, arg1: $BlockAndTintGetter$$Type, arg2: $BlockPos$$Type, arg3: integer): $KubeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTintFunction$$Type = (($BlockTintFunction$$Type)[]) | (string) | ((state: $BlockState, level: $BlockAndTintGetter, pos: $BlockPos, index: integer) => $KubeColor$$Type) | ((arg0: $BlockState, arg1: $BlockAndTintGetter, arg2: $BlockPos, arg3: integer) => $KubeColor$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTintFunction_ = $BlockTintFunction$$Type;
}}
declare module "dev.latvian.mods.rhino.regexp.RegExp" {
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"

export class $RegExp {
static readonly "RA_MATCH": integer
static readonly "RA_REPLACE": integer
static readonly "RA_SEARCH": integer

constructor()

public "action"(scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args: (any)[], actionType: integer): any
public "isRegExp"(obj: $Scriptable$$Type): boolean
public "wrapRegExp"(scope: $Scriptable$$Type, compiled: any): $Scriptable
public "js_split"(scope: $Scriptable$$Type, target: string, args: (any)[]): any
public "compileRegExp"(source: string, flags: string): any
public "find_split"(scope: $Scriptable$$Type, target: string, separator: string, reObj: $Scriptable$$Type, ip: (integer)[], matchlen: (integer)[], matched: (boolean)[], parensp: ((string)[])[]): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegExp$$Type = ($RegExp);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegExp_ = $RegExp$$Type;
}}
declare module "dev.latvian.mods.rhino.util.wrap.DirectTypeWrapperFactory" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$TypeWrapperFactory, $TypeWrapperFactory$$Type} from "dev.latvian.mods.rhino.util.wrap.TypeWrapperFactory"

export interface $DirectTypeWrapperFactory<T> extends $TypeWrapperFactory<(T)> {

 "wrap"(arg0: any): T
 "wrap"(from: any, target: $TypeInfo$$Type): T

(arg0: any): T
}

export namespace $DirectTypeWrapperFactory {
const probejs$$marker: never
}
export class $DirectTypeWrapperFactory$$Static<T> implements $DirectTypeWrapperFactory {


 "wrap"(arg0: any): T
 "wrap"(from: any, target: $TypeInfo$$Type): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectTypeWrapperFactory$$Type<T> = ((arg0: any) => T);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DirectTypeWrapperFactory_<T> = $DirectTypeWrapperFactory$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.misc.PotionBuilder" {
import {$MobEffectInstance, $MobEffectInstance$$Type} from "net.minecraft.world.effect.MobEffectInstance"
import {$Potion, $Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$MobEffect, $MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $PotionBuilder extends $BuilderBase<($Potion)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "addEffect"(arg0: $MobEffectInstance$$Type): this
public "effect"(arg0: $Holder$$Type<($MobEffect)>, arg1: integer, arg2: integer, arg3: boolean, arg4: boolean, arg5: boolean): this
public "effect"(arg0: $Holder$$Type<($MobEffect)>, arg1: integer, arg2: integer, arg3: boolean, arg4: boolean, arg5: boolean, arg6: $MobEffectInstance$$Type): this
public "effect"(arg0: $Holder$$Type<($MobEffect)>, arg1: integer, arg2: integer): this
public "effect"(arg0: $Holder$$Type<($MobEffect)>, arg1: integer, arg2: integer, arg3: boolean, arg4: boolean): this
public "effect"(arg0: $Holder$$Type<($MobEffect)>, arg1: integer): this
public "effect"(arg0: $Holder$$Type<($MobEffect)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionBuilder$$Type = ($PotionBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PotionBuilder_ = $PotionBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ModifyItemTooltipsKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$TooltipRequirements, $TooltipRequirements$$Type} from "dev.latvian.mods.kubejs.text.tooltip.TooltipRequirements"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$ItemTooltipData, $ItemTooltipData$$Type} from "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData"
import {$TextActionBuilder, $TextActionBuilder$$Type} from "dev.latvian.mods.kubejs.text.action.TextActionBuilder"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $ModifyItemTooltipsKubeEvent implements $KubeEvent {

constructor(arg0: $Consumer$$Type<($ItemTooltipData)>)

public "add"(arg0: $Ingredient$$Type, arg1: $TooltipRequirements$$Type, arg2: $List$$Type<($Component$$Type)>): void
public "add"(arg0: $Ingredient$$Type, arg1: $List$$Type<($Component$$Type)>): void
public "modify"(arg0: $Ingredient$$Type, arg1: $Consumer$$Type<($TextActionBuilder)>): void
public "modify"(arg0: $Ingredient$$Type, arg1: $TooltipRequirements$$Type, arg2: $Consumer$$Type<($TextActionBuilder)>): void
public "modifyAll"(arg0: $TooltipRequirements$$Type, arg1: $Consumer$$Type<($TextActionBuilder)>): void
public "modifyAll"(arg0: $Consumer$$Type<($TextActionBuilder)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifyItemTooltipsKubeEvent$$Type = ($ModifyItemTooltipsKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModifyItemTooltipsKubeEvent_ = $ModifyItemTooltipsKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS" {
import {$MobEffectInstance, $MobEffectInstance$$Type} from "net.minecraft.world.effect.MobEffectInstance"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$MobEffect, $MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"

export class $EntityPotionEffectsJS {

constructor(arg0: $LivingEntity$$Type)

public "clear"(): void
public "add"(arg0: $Holder$$Type<($MobEffect)>, arg1: integer, arg2: integer): void
public "add"(arg0: $Holder$$Type<($MobEffect)>, arg1: integer): void
public "add"(arg0: $Holder$$Type<($MobEffect)>): void
public "add"(arg0: $Holder$$Type<($MobEffect)>, arg1: integer, arg2: integer, arg3: boolean, arg4: boolean): void
public "isActive"(arg0: $Holder$$Type<($MobEffect)>): boolean
public "getMap"(): $Map<($Holder<($MobEffect)>), ($MobEffectInstance)>
public "getDuration"(arg0: $Holder$$Type<($MobEffect)>): integer
public "isApplicable"(arg0: $MobEffectInstance$$Type): boolean
public "getActive"(): $Collection<($MobEffectInstance)>
public "getActive"(arg0: $Holder$$Type<($MobEffect)>): $MobEffectInstance
get "map"(): $Map<($Holder<($MobEffect)>), ($MobEffectInstance)>
get "active"(): $Collection<($MobEffectInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityPotionEffectsJS$$Type = ($EntityPotionEffectsJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityPotionEffectsJS_ = $EntityPotionEffectsJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.web.RelativeURL" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $RelativeURL extends $Record {

constructor(arg0: string)
constructor(path: string, query: $Map$$Type<(string), (string)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "query"(): $Map<(string), (string)>
public "path"(): string
public "fullString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RelativeURL$$Type = ({"query"?: $Map$$Type<(string), (string)>, "path"?: string}) | ([query?: $Map$$Type<(string), (string)>, path?: string]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RelativeURL_ = $RelativeURL$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentHandler" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Set, $Set$$Type} from "java.util.Set"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"

export interface $BlockEntityAttachmentHandler {

 "attach"(arg1: string, arg2: string, arg3: $Set$$Type<($Direction$$Type)>, arg4: any): void
 "energyStorage"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer, arg3: integer, arg4: integer, arg5: integer): void
 "inventory"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer, arg3: integer): void
 "inventory"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer, arg3: integer, arg4: $ItemPredicate$$Type): void
 "fluidTank"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer, arg3: $FluidIngredient$$Type): void
 "fluidTank"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer): void
 "attachCustomCapability"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: $BlockCapability$$Type<(any), (any)>, arg3: $Supplier$$Type<(any)>): void
}

export namespace $BlockEntityAttachmentHandler {
const probejs$$marker: never
}
export class $BlockEntityAttachmentHandler$$Static implements $BlockEntityAttachmentHandler {


 "attach"(arg1: string, arg2: string, arg3: $Set$$Type<($Direction$$Type)>, arg4: any): void
 "energyStorage"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer, arg3: integer, arg4: integer, arg5: integer): void
 "inventory"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer, arg3: integer): void
 "inventory"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer, arg3: integer, arg4: $ItemPredicate$$Type): void
 "fluidTank"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer, arg3: $FluidIngredient$$Type): void
 "fluidTank"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: integer): void
 "attachCustomCapability"(arg0: string, arg1: $Set$$Type<($Direction$$Type)>, arg2: $BlockCapability$$Type<(any), (any)>, arg3: $Supplier$$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentHandler$$Type = ($BlockEntityAttachmentHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityAttachmentHandler_ = $BlockEntityAttachmentHandler$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.special.ShapedKubeJSRecipe" {
import {$CraftingInput, $CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IngredientActionHolder, $IngredientActionHolder$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder"
import {$List, $List$$Type} from "java.util.List"
import {$CraftingBookCategory, $CraftingBookCategory$$Type} from "net.minecraft.world.item.crafting.CraftingBookCategory"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ShapedRecipePattern, $ShapedRecipePattern$$Type} from "net.minecraft.world.item.crafting.ShapedRecipePattern"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$ShapedRecipe, $ShapedRecipe$$Type} from "net.minecraft.world.item.crafting.ShapedRecipe"
import {$KubeJSCraftingRecipe, $KubeJSCraftingRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.special.KubeJSCraftingRecipe"
import {$RecipeSerializer, $RecipeSerializer$$Type} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $ShapedKubeJSRecipe extends $ShapedRecipe implements $KubeJSCraftingRecipe {
readonly "pattern": $ShapedRecipePattern
readonly "result": $ItemStack
readonly "group": string

constructor(arg0: string, arg1: $CraftingBookCategory$$Type, arg2: $ShapedRecipePattern$$Type, arg3: $ItemStack$$Type, arg4: boolean, arg5: boolean, arg6: $List$$Type<($IngredientActionHolder$$Type)>, arg7: string, arg8: string)

public "getRemainingItems"(arg0: $CraftingInput$$Type): $NonNullList<($ItemStack)>
public "getRemainingItems"(arg0: $RecipeInput$$Type): $NonNullList<(any)>
public "assemble"(arg0: $RecipeInput$$Type, arg1: $HolderLookup$Provider$$Type): $ItemStack
public "assemble"(arg0: $CraftingInput$$Type, arg1: $HolderLookup$Provider$$Type): $ItemStack
public "getSerializer"(): $RecipeSerializer<(any)>
public "kjs$getMirror"(): boolean
public "kjs$getStage"(): string
public "kjs$getModifyResult"(): string
public "kjs$getIngredientActions"(): $List<($IngredientActionHolder)>
public "kjs$assemble"(arg0: $CraftingInput$$Type, arg1: $HolderLookup$Provider$$Type): $ItemStack
public "kjs$getRemainingItems"(arg0: $CraftingInput$$Type): $NonNullList<($ItemStack)>
get "serializer"(): $RecipeSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedKubeJSRecipe$$Type = ($ShapedKubeJSRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapedKubeJSRecipe_ = $ShapedKubeJSRecipe$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.ReloadableServerResourceHolderKJS" {
import {$ReloadableServerResourcesKJS, $ReloadableServerResourcesKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS"

export interface $ReloadableServerResourceHolderKJS {

 "kjs$setResources"(arg0: $ReloadableServerResourcesKJS$$Type): void
 "kjs$getResources"(): $ReloadableServerResourcesKJS
}

export namespace $ReloadableServerResourceHolderKJS {
const probejs$$marker: never
}
export class $ReloadableServerResourceHolderKJS$$Static implements $ReloadableServerResourceHolderKJS {


 "kjs$setResources"(arg0: $ReloadableServerResourcesKJS$$Type): void
 "kjs$getResources"(): $ReloadableServerResourcesKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReloadableServerResourceHolderKJS$$Type = ($ReloadableServerResourceHolderKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReloadableServerResourceHolderKJS_ = $ReloadableServerResourceHolderKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.CompostableRecipesKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemLike, $ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Object2FloatMap, $Object2FloatMap$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatMap"

export class $CompostableRecipesKubeEvent implements $KubeEvent {
static "originalMap": $Object2FloatMap<($ItemLike)>

constructor()

public "remove"(arg0: $ItemPredicate$$Type): void
public "add"(arg0: $ItemPredicate$$Type, arg1: float): void
public "removeAll"(): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompostableRecipesKubeEvent$$Type = ($CompostableRecipesKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompostableRecipesKubeEvent_ = $CompostableRecipesKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.player.PlayerStatsJS" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Stat, $Stat$$Type} from "net.minecraft.stats.Stat"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$StatsCounter, $StatsCounter$$Type} from "net.minecraft.stats.StatsCounter"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $PlayerStatsJS {
readonly "player": $Player

constructor(arg0: $Player$$Type, arg1: $StatsCounter$$Type)

public "get"(arg0: $Stat$$Type<(any)>): integer
public "add"(arg0: $Stat$$Type<(any)>, arg1: integer): void
public "set"(arg0: $Stat$$Type<(any)>, arg1: integer): void
public "getJumps"(): integer
public "getDeaths"(): integer
public "getKilled"(arg0: $EntityType$$Type<(any)>): integer
public static "statOf"(arg0: any): $Stat<(any)>
public "getDamageResisted"(): integer
public "getTimeSinceRest"(): integer
public "getAnimalsBred"(): integer
public "getSprintDistance"(): integer
public "getItemsUsed"(arg0: $Item$$Type): integer
public "getDamageAbsorbed"(): integer
public "getTimeSinceDeath"(): integer
public "getMobKills"(): integer
public "getItemsBroken"(arg0: $Item$$Type): integer
public "getItemsPickedUp"(arg0: $Item$$Type): integer
public "getItemsCrafted"(arg0: $Item$$Type): integer
public "getItemsDropped"(arg0: $Item$$Type): integer
public "getWalkDistance"(): integer
public "getBlocksMined"(arg0: $Block$$Type): integer
public "getSwimDistance"(): integer
public "getPlayTime"(): integer
public "getCrouchDistance"(): integer
public "getDamageTaken"(): integer
public "getFishCaught"(): integer
public "getKilledBy"(arg0: $EntityType$$Type<(any)>): integer
public "getDamageDealt"(): integer
public "getTimeCrouchTime"(): integer
public "getPlayerKills"(): integer
public "getDamageDealt_absorbed"(): integer
public "getDamageDealt_resisted"(): integer
public "getDamageBlocked_by_shield"(): integer
get "jumps"(): integer
get "deaths"(): integer
get "damageResisted"(): integer
get "timeSinceRest"(): integer
get "animalsBred"(): integer
get "sprintDistance"(): integer
get "damageAbsorbed"(): integer
get "timeSinceDeath"(): integer
get "mobKills"(): integer
get "walkDistance"(): integer
get "swimDistance"(): integer
get "playTime"(): integer
get "crouchDistance"(): integer
get "damageTaken"(): integer
get "fishCaught"(): integer
get "damageDealt"(): integer
get "timeCrouchTime"(): integer
get "playerKills"(): integer
get "damageDealt_absorbed"(): integer
get "damageDealt_resisted"(): integer
get "damageBlocked_by_shield"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerStatsJS$$Type = ($PlayerStatsJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerStatsJS_ = $PlayerStatsJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder" {
import {$TinyMap, $TinyMap$$Type} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$RecipeComponentBuilder$Key, $RecipeComponentBuilder$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder$Key"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ComponentRole, $ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$PairRecipeComponent, $PairRecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.PairRecipeComponent"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$RecipeComponentBuilder$Value, $RecipeComponentBuilder$Value$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder$Value"
import {$ReplacementMatchInfo, $ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$EitherRecipeComponent, $EitherRecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$UniqueIdBuilder, $UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentValue, $RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$Set, $Set$$Type} from "java.util.Set"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $RecipeComponentBuilder implements $RecipeComponent<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)> {
readonly "keys": $List<($RecipeComponentBuilder$Key)>

constructor(arg0: $List$$Type<($RecipeComponentBuilder$Key$$Type)>)

public "toString"(): string
public "isEmpty"(arg0: $Map$$Type<($RecipeComponentBuilder$Key$$Type), ($RecipeComponentBuilder$Value$$Type)>): boolean
public "isEmpty"(arg0: any): boolean
public "replace"(arg1: $KubeRecipe$$Type, arg2: $Map$$Type<($RecipeComponentBuilder$Key$$Type), ($RecipeComponentBuilder$Value$$Type)>, arg3: $ReplacementMatchInfo$$Type, arg4: any): $Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>
public "replace"(arg1: $KubeRecipe$$Type, arg2: any, arg3: $ReplacementMatchInfo$$Type, arg4: any): any
public "matches"(arg1: $KubeRecipe$$Type, arg2: $Map$$Type<($RecipeComponentBuilder$Key$$Type), ($RecipeComponentBuilder$Value$$Type)>, arg3: $ReplacementMatchInfo$$Type): boolean
public "matches"(arg1: $KubeRecipe$$Type, arg2: any, arg3: $ReplacementMatchInfo$$Type): boolean
public "validate"(arg0: any): void
public "validate"(arg0: $Map$$Type<($RecipeComponentBuilder$Key$$Type), ($RecipeComponentBuilder$Value$$Type)>): void
public "typeInfo"(): $TypeInfo
public "codec"(): $Codec<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>
public "mapCodec"(): $MapCodec<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>
public "createCopy"(): $RecipeComponentBuilder
public "hasPriority"(arg0: $Predicate$$Type<($Set<(string)>)>): $RecipeComponentBuilder
public "hasPriority"(arg1: $KubeRecipe$$Type, arg2: any): boolean
public "buildUniqueId"(arg0: $UniqueIdBuilder$$Type, arg1: $Map$$Type<($RecipeComponentBuilder$Key$$Type), ($RecipeComponentBuilder$Value$$Type)>): void
public "buildUniqueId"(arg0: $UniqueIdBuilder$$Type, arg1: any): void
public "wrap"(arg1: $KubeRecipe$$Type, arg2: any): $Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>
public static "builder"(arg0: $List$$Type<($RecipeComponentBuilder$Key$$Type)>): $RecipeComponentBuilder
public static "builder"(...arg0: ($RecipeComponentBuilder$Key$$Type)[]): $RecipeComponentBuilder
public "key"(arg0: string, arg1: $ComponentRole$$Type): $RecipeKey<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>
public "asList"(): $RecipeComponent<($List<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>)>
public "or"<O>(arg0: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>), (O)>
public "and"<O>(arg0: $RecipeComponent$$Type<(O)>): $PairRecipeComponent<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>), (O)>
public "asMap"<K>(arg0: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>)>
public "inputKey"(arg0: string): $RecipeKey<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>
public "outputKey"(arg0: string): $RecipeKey<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>
public "orSelf"(): $RecipeComponent<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>
public "withCodec"(arg0: $Codec$$Type<($Map$$Type<($RecipeComponentBuilder$Key$$Type), ($RecipeComponentBuilder$Value$$Type)>)>): $RecipeComponent<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>
public "otherKey"(arg0: string): $RecipeKey<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>
public "asConditionalListOrSelf"(): $RecipeComponent<($List<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>)>
public "writeToJson"(arg0: $KubeRecipe$$Type, arg1: $RecipeComponentValue$$Type<($Map$$Type<($RecipeComponentBuilder$Key$$Type), ($RecipeComponentBuilder$Value$$Type)>)>, arg2: $JsonObject$$Type): void
public "readFromJson"(arg0: $KubeRecipe$$Type, arg1: $RecipeComponentValue$$Type<($Map$$Type<($RecipeComponentBuilder$Key$$Type), ($RecipeComponentBuilder$Value$$Type)>)>, arg2: $JsonObject$$Type): void
public "asConditionalList"(): $RecipeComponent<($List<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>)>
public "asListOrSelf"(): $RecipeComponent<($List<($Map<($RecipeComponentBuilder$Key), ($RecipeComponentBuilder$Value)>)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentBuilder$$Type = ($RecipeComponentBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeComponentBuilder_ = $RecipeComponentBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.AddEntriesKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $AddEntriesKubeEvent<E, F> extends $KubeEvent {

 "add"(arg1: E): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any

(arg1: E): void
}

export namespace $AddEntriesKubeEvent {
const probejs$$marker: never
}
export class $AddEntriesKubeEvent$$Static<E, F> implements $AddEntriesKubeEvent {


 "add"(arg1: E): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddEntriesKubeEvent$$Type<E, F> = ((arg1: (any)[]) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AddEntriesKubeEvent_<E, F> = $AddEntriesKubeEvent$$Type<(E), (F)>;
}}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$FinishUsingCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export interface $ItemBuilder$FinishUsingCallback {

 "finishUsingItem"(arg0: $ItemStack$$Type, arg1: $Level$$Type, arg2: $LivingEntity$$Type): $ItemStack

(arg0: $ItemStack, arg1: $Level, arg2: $LivingEntity): $ItemStack$$Type
}

export namespace $ItemBuilder$FinishUsingCallback {
const probejs$$marker: never
}
export class $ItemBuilder$FinishUsingCallback$$Static implements $ItemBuilder$FinishUsingCallback {


 "finishUsingItem"(arg0: $ItemStack$$Type, arg1: $Level$$Type, arg2: $LivingEntity$$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$FinishUsingCallback$$Type = ((arg0: $ItemStack, arg1: $Level, arg2: $LivingEntity) => $ItemStack$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBuilder$FinishUsingCallback_ = $ItemBuilder$FinishUsingCallback$$Type;
}}
declare module "dev.latvian.mods.kubejs.component.ItemComponentFunctions" {
import {$ComponentFunctions, $ComponentFunctions$$Type} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$Potion, $Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$ItemAttributeModifiers$Entry, $ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$List, $List$$Type} from "java.util.List"
import {$FireworkExplosion, $FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties, $FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents, $PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Instrument, $Instrument$$Type} from "net.minecraft.world.item.Instrument"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Rarity, $Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Tool, $Tool$$Type} from "net.minecraft.world.item.component.Tool"
import {$Fireworks, $Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Unit, $Unit$$Type} from "net.minecraft.util.Unit"

export interface $ItemComponentFunctions extends $ComponentFunctions {

 "setItemName"(arg0: $Component$$Type): void
 "setDamage"(arg0: integer): void
 "setMaxDamage"(arg0: integer): void
 "setFireworks"(arg0: $Fireworks$$Type): void
 "setTool"(arg0: $Tool$$Type): void
 "setFood"(arg0: $FoodProperties$$Type): void
 "setFood"(arg0: integer, arg1: float): void
 "setRepairCost"(arg0: integer): void
 "setInstrument"(arg0: $Holder$$Type<($Instrument)>): void
 "setUnbreakable"(): void
 "setUnbreakableWithTooltip"(): void
 "setMaxStackSize"(arg0: integer): void
 "setFireworkExplosion"(arg0: $FireworkExplosion$$Type): void
 "setChargedProjectiles"(arg0: $List$$Type<($ItemStack$$Type)>): void
 "setBlockEntityData"(arg0: $CompoundTag$$Type): void
 "setBucketEntityData"(arg0: $CompoundTag$$Type): void
 "setNoteBlockSound"(arg0: $ResourceLocation$$Type): void
 "setMapItemColor"(arg0: $KubeColor$$Type): void
 "setFireResistant"(): void
 "setBundleContents"(arg0: $List$$Type<($ItemStack$$Type)>): void
 "setAttributeModifiersWithTooltip"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
 "setUnit"(arg0: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "setLockCode"(arg0: string): void
 "setCustomData"(arg0: $CompoundTag$$Type): void
 "setRarity"(arg0: $Rarity$$Type): void
 "setCustomName"(arg0: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(arg0: $List$$Type<($Component$$Type)>): void
 "setLore"(arg0: $List$$Type<($Component$$Type)>, arg1: $List$$Type<($Component$$Type)>): void
 "setDyedColor"(arg0: $KubeColor$$Type): void
 "getCustomData"(): $CompoundTag
 "setPotionId"(arg0: $Holder$$Type<($Potion)>): void
 "setEntityData"(arg0: $CompoundTag$$Type): void
 "setProfile"(arg0: $GameProfile$$Type): void
 "setProfile"(arg0: string, arg1: $UUID$$Type): void
 "setBaseColor"(arg0: $DyeColor$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(arg0: $Map$$Type<(string), (string)>): void
 "setDyedColorWithTooltip"(arg0: $KubeColor$$Type): void
 "set"(arg1: $DataComponentType$$Type<(any)>, arg2: any): $ComponentFunctions
 "set"(arg1: $DataComponentMap$$Type): $ComponentFunctions
 "patch"(arg1: $DataComponentPatch$$Type): $ComponentFunctions
 "get"<T>(arg0: $DataComponentType$$Type<(T)>): T
 "remove"(arg0: $DataComponentType$$Type<(any)>): $ComponentFunctions
 "setPotionContents"(arg0: $PotionContents$$Type): void
 "setGlintOverride"(arg0: boolean): void
 "getComponentString"(): string
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
 "setTooltipHidden"(): void
 "setCustomModelData"(arg0: integer): void
 "resetComponents"(): $ComponentFunctions
 "getComponentMap"(): $DataComponentMap
 "setAttributeModifiers"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
set "itemName"(value: $Component$$Type)
set "damage"(value: integer)
set "maxDamage"(value: integer)
set "fireworks"(value: $Fireworks$$Type)
set "tool"(value: $Tool$$Type)
set "food"(value: $FoodProperties$$Type)
set "repairCost"(value: integer)
set "instrument"(value: $Holder$$Type<($Instrument)>)
set "maxStackSize"(value: integer)
set "fireworkExplosion"(value: $FireworkExplosion$$Type)
set "chargedProjectiles"(value: $List$$Type<($ItemStack$$Type)>)
set "blockEntityData"(value: $CompoundTag$$Type)
set "bucketEntityData"(value: $CompoundTag$$Type)
set "noteBlockSound"(value: $ResourceLocation$$Type)
set "mapItemColor"(value: $KubeColor$$Type)
set "bundleContents"(value: $List$$Type<($ItemStack$$Type)>)
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
set "lockCode"(value: string)
set "customData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "customName"(value: $Component$$Type)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "dyedColor"(value: $KubeColor$$Type)
get "customData"(): $CompoundTag
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(string), (string)>)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
set "glintOverride"(value: boolean)
get "componentString"(): string
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
set "customModelData"(value: integer)
get "componentMap"(): $DataComponentMap
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
}

export namespace $ItemComponentFunctions {
const probejs$$marker: never
}
export class $ItemComponentFunctions$$Static implements $ItemComponentFunctions {


 "setItemName"(arg0: $Component$$Type): void
 "setDamage"(arg0: integer): void
 "setMaxDamage"(arg0: integer): void
 "setFireworks"(arg0: $Fireworks$$Type): void
 "setTool"(arg0: $Tool$$Type): void
 "setFood"(arg0: $FoodProperties$$Type): void
 "setFood"(arg0: integer, arg1: float): void
 "setRepairCost"(arg0: integer): void
 "setInstrument"(arg0: $Holder$$Type<($Instrument)>): void
 "setUnbreakable"(): void
 "setUnbreakableWithTooltip"(): void
 "setMaxStackSize"(arg0: integer): void
 "setFireworkExplosion"(arg0: $FireworkExplosion$$Type): void
 "setChargedProjectiles"(arg0: $List$$Type<($ItemStack$$Type)>): void
 "setBlockEntityData"(arg0: $CompoundTag$$Type): void
 "setBucketEntityData"(arg0: $CompoundTag$$Type): void
 "setNoteBlockSound"(arg0: $ResourceLocation$$Type): void
 "setMapItemColor"(arg0: $KubeColor$$Type): void
 "setFireResistant"(): void
 "setBundleContents"(arg0: $List$$Type<($ItemStack$$Type)>): void
 "setAttributeModifiersWithTooltip"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
 "setUnit"(arg0: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "setLockCode"(arg0: string): void
 "setCustomData"(arg0: $CompoundTag$$Type): void
 "setRarity"(arg0: $Rarity$$Type): void
 "setCustomName"(arg0: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(arg0: $List$$Type<($Component$$Type)>): void
 "setLore"(arg0: $List$$Type<($Component$$Type)>, arg1: $List$$Type<($Component$$Type)>): void
 "setDyedColor"(arg0: $KubeColor$$Type): void
 "getCustomData"(): $CompoundTag
 "setPotionId"(arg0: $Holder$$Type<($Potion)>): void
 "setEntityData"(arg0: $CompoundTag$$Type): void
 "setProfile"(arg0: $GameProfile$$Type): void
 "setProfile"(arg0: string, arg1: $UUID$$Type): void
 "setBaseColor"(arg0: $DyeColor$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(arg0: $Map$$Type<(string), (string)>): void
 "setDyedColorWithTooltip"(arg0: $KubeColor$$Type): void
 "set"(arg1: $DataComponentType$$Type<(any)>, arg2: any): $ComponentFunctions
 "set"(arg1: $DataComponentMap$$Type): $ComponentFunctions
 "patch"(arg1: $DataComponentPatch$$Type): $ComponentFunctions
 "get"<T>(arg0: $DataComponentType$$Type<(T)>): T
 "remove"(arg0: $DataComponentType$$Type<(any)>): $ComponentFunctions
 "setPotionContents"(arg0: $PotionContents$$Type): void
 "setGlintOverride"(arg0: boolean): void
 "getComponentString"(): string
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
 "setTooltipHidden"(): void
 "setCustomModelData"(arg0: integer): void
 "resetComponents"(): $ComponentFunctions
 "getComponentMap"(): $DataComponentMap
 "setAttributeModifiers"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemComponentFunctions$$Type = ($ItemComponentFunctions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemComponentFunctions_ = $ItemComponentFunctions$$Type;
}}
declare module "dev.latvian.mods.rhino.type.JSOptionalParam" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"
import {$TypeStringContext, $TypeStringContext$$Type} from "dev.latvian.mods.rhino.type.TypeStringContext"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $JSOptionalParam extends $Record {

constructor(name: string, type: $TypeInfo$$Type)
constructor(name: string, type: $TypeInfo$$Type, optional: boolean)

public "name"(): string
public "type"(): $TypeInfo
public "equals"(o: any): boolean
public "toString"(): string
public "append"(ctx: $TypeStringContext$$Type, sb: $StringBuilder$$Type): void
public "hashCode"(): integer
public "optional"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JSOptionalParam$$Type = ({"optional"?: boolean, "type"?: $TypeInfo$$Type, "name"?: string}) | ([optional?: boolean, type?: $TypeInfo$$Type, name?: string]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JSOptionalParam_ = $JSOptionalParam$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.ItemStackKJS" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Potion, $Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$RelativeURL, $RelativeURL$$Type} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ItemEnchantments, $ItemEnchantments$$Type} from "net.minecraft.world.item.enchantment.ItemEnchantments"
import {$SpecialEquality, $SpecialEquality$$Type} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$RegistryObjectKJS, $RegistryObjectKJS$$Type} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$ItemMatch, $ItemMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ItemMatch"
import {$Rarity, $Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Fireworks, $Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$ItemComponentFunctions, $ItemComponentFunctions$$Type} from "dev.latvian.mods.kubejs.component.ItemComponentFunctions"
import {$ItemLike, $ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Unit, $Unit$$Type} from "net.minecraft.util.Unit"
import {$ComponentFunctions, $ComponentFunctions$$Type} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$ItemAttributeModifiers$Entry, $ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$FireworkExplosion, $FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Replaceable, $Replaceable$$Type} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$FoodProperties, $FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ToStringJS, $ToStringJS$$Type} from "dev.latvian.mods.rhino.util.ToStringJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents, $PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Instrument, $Instrument$$Type} from "net.minecraft.world.item.Instrument"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$WithCodec, $WithCodec$$Type} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Tool, $Tool$$Type} from "net.minecraft.world.item.component.Tool"
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Enchantment, $Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$IngredientSupplierKJS, $IngredientSupplierKJS$$Type} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"

export interface $ItemStackKJS extends $SpecialEquality, $WithCodec, $IngredientSupplierKJS, $ToStringJS, $Replaceable, $ItemComponentFunctions, $ItemMatch, $RegistryObjectKJS<($Item)> {

 "matches"(arg1: $Ingredient$$Type, arg2: boolean): boolean
 "matches"(arg1: $ItemLike$$Type, arg2: boolean): boolean
 "matches"(arg1: $ItemStack$$Type, arg2: boolean): boolean
 "getCodec"(): $Codec<($ItemStack)>
 "getId"(): string
 "asIngredient"(): $Ingredient
 "withCount"(arg0: integer): this
 "toItemString0"(arg0: $DynamicOps$$Type<($Tag$$Type)>): string
 "getKey"(): $ResourceKey<($Item)>
 "self"(): $ItemStack
 "withLore"(arg0: ($Component$$Type)[], arg1: ($Component$$Type)[]): this
 "withLore"(arg0: ($Component$$Type)[]): this
 "areItemsEqual"(arg0: $ItemStack$$Type): boolean
 "hasEnchantment"(arg0: $Holder$$Type<($Enchantment)>, arg1: integer): boolean
 "enchant"(arg0: $Holder$$Type<($Enchantment)>, arg1: integer): this
 "enchant"(arg0: $ItemEnchantments$$Type): this
 "withCustomName"(arg0: $Component$$Type): this
 "toItemString"(): string
 "getMod"(): string
 "specialEquals"(arg1: any, arg2: boolean): boolean
 "getBlock"(): $Block
 "toStringJS"(): string
 "asHolder"(): $Holder<($Item)>
 "getIdLocation"(): $ResourceLocation
 "replaceThisWith"(arg1: any): any
 "getTypeData"(): $Map<(string), (any)>
 "getRegistry"(): $Registry<($Item)>
 "getRegistryId"(): $ResourceKey<($Registry<($Item)>)>
 "getWebIconURL"(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: integer): $RelativeURL
 "getComponentString"(): string
 "getHarvestSpeed"(arg0: $BlockContainerJS$$Type): float
 "getHarvestSpeed"(): float
 "areComponentsEqual"(arg0: $ItemStack$$Type): boolean
 "equalsIgnoringCount"(arg0: $ItemStack$$Type): boolean
 "getEnchantments"(): $ItemEnchantments
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
 "setItemName"(arg0: $Component$$Type): void
 "setDamage"(arg0: integer): void
 "setMaxDamage"(arg0: integer): void
 "setFireworks"(arg0: $Fireworks$$Type): void
 "setTool"(arg0: $Tool$$Type): void
 "setFood"(arg0: $FoodProperties$$Type): void
 "setFood"(arg0: integer, arg1: float): void
 "setRepairCost"(arg0: integer): void
 "setInstrument"(arg0: $Holder$$Type<($Instrument)>): void
 "setUnbreakable"(): void
 "setUnbreakableWithTooltip"(): void
 "setMaxStackSize"(arg0: integer): void
 "setFireworkExplosion"(arg0: $FireworkExplosion$$Type): void
 "setChargedProjectiles"(arg0: $List$$Type<($ItemStack$$Type)>): void
 "setBlockEntityData"(arg0: $CompoundTag$$Type): void
 "setBucketEntityData"(arg0: $CompoundTag$$Type): void
 "setNoteBlockSound"(arg0: $ResourceLocation$$Type): void
 "setMapItemColor"(arg0: $KubeColor$$Type): void
 "setFireResistant"(): void
 "setBundleContents"(arg0: $List$$Type<($ItemStack$$Type)>): void
 "matchesAny"(arg1: $Iterable$$Type<($ItemLike$$Type)>, arg2: boolean): boolean
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "getTags"(): $Collection<($ResourceLocation)>
 "setAttributeModifiersWithTooltip"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
 "setUnit"(arg0: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "setLockCode"(arg0: string): void
 "setCustomData"(arg0: $CompoundTag$$Type): void
 "setRarity"(arg0: $Rarity$$Type): void
 "setCustomName"(arg0: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(arg0: $List$$Type<($Component$$Type)>): void
 "setLore"(arg0: $List$$Type<($Component$$Type)>, arg1: $List$$Type<($Component$$Type)>): void
 "setDyedColor"(arg0: $KubeColor$$Type): void
 "getCustomData"(): $CompoundTag
 "setPotionId"(arg0: $Holder$$Type<($Potion)>): void
 "setEntityData"(arg0: $CompoundTag$$Type): void
 "setProfile"(arg0: $GameProfile$$Type): void
 "setProfile"(arg0: string, arg1: $UUID$$Type): void
 "setBaseColor"(arg0: $DyeColor$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(arg0: $Map$$Type<(string), (string)>): void
 "setDyedColorWithTooltip"(arg0: $KubeColor$$Type): void
 "set"(arg1: $DataComponentType$$Type<(any)>, arg2: any): $ComponentFunctions
 "set"(arg1: $DataComponentMap$$Type): $ComponentFunctions
 "patch"(arg1: $DataComponentPatch$$Type): $ComponentFunctions
 "get"<T>(arg0: $DataComponentType$$Type<(T)>): T
 "remove"(arg0: $DataComponentType$$Type<(any)>): $ComponentFunctions
 "setPotionContents"(arg0: $PotionContents$$Type): void
 "setGlintOverride"(arg0: boolean): void
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
 "setTooltipHidden"(): void
 "setCustomModelData"(arg0: integer): void
 "resetComponents"(): $ComponentFunctions
 "getComponentMap"(): $DataComponentMap
 "setAttributeModifiers"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
get "codec"(): $Codec<($ItemStack)>
get "id"(): string
get "key"(): $ResourceKey<($Item)>
get "mod"(): string
get "block"(): $Block
get "idLocation"(): $ResourceLocation
get "typeData"(): $Map<(string), (any)>
get "registry"(): $Registry<($Item)>
get "registryId"(): $ResourceKey<($Registry<($Item)>)>
get "componentString"(): string
get "harvestSpeed"(): float
get "enchantments"(): $ItemEnchantments
set "itemName"(value: $Component$$Type)
set "damage"(value: integer)
set "maxDamage"(value: integer)
set "fireworks"(value: $Fireworks$$Type)
set "tool"(value: $Tool$$Type)
set "food"(value: $FoodProperties$$Type)
set "repairCost"(value: integer)
set "instrument"(value: $Holder$$Type<($Instrument)>)
set "maxStackSize"(value: integer)
set "fireworkExplosion"(value: $FireworkExplosion$$Type)
set "chargedProjectiles"(value: $List$$Type<($ItemStack$$Type)>)
set "blockEntityData"(value: $CompoundTag$$Type)
set "bucketEntityData"(value: $CompoundTag$$Type)
set "noteBlockSound"(value: $ResourceLocation$$Type)
set "mapItemColor"(value: $KubeColor$$Type)
set "bundleContents"(value: $List$$Type<($ItemStack$$Type)>)
get "tags"(): $Collection<($ResourceLocation)>
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
set "lockCode"(value: string)
set "customData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "customName"(value: $Component$$Type)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "dyedColor"(value: $KubeColor$$Type)
get "customData"(): $CompoundTag
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(string), (string)>)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
set "glintOverride"(value: boolean)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
set "customModelData"(value: integer)
get "componentMap"(): $DataComponentMap
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
}

export namespace $ItemStackKJS {
function checkSpecialEquality(o: any, o1: any, shallow: boolean): boolean
function toStringJS(o: any): string
function wrap(arg1: any): $ReplacementMatch
const probejs$$marker: never
}
export class $ItemStackKJS$$Static implements $ItemStackKJS {


 "matches"(arg1: $Ingredient$$Type, arg2: boolean): boolean
 "matches"(arg1: $ItemLike$$Type, arg2: boolean): boolean
 "matches"(arg1: $ItemStack$$Type, arg2: boolean): boolean
 "getCodec"(): $Codec<($ItemStack)>
 "getId"(): string
 "asIngredient"(): $Ingredient
 "withCount"(arg0: integer): this
 "toItemString0"(arg0: $DynamicOps$$Type<($Tag$$Type)>): string
 "getKey"(): $ResourceKey<($Item)>
 "self"(): $ItemStack
 "withLore"(arg0: ($Component$$Type)[], arg1: ($Component$$Type)[]): this
 "withLore"(arg0: ($Component$$Type)[]): this
 "areItemsEqual"(arg0: $ItemStack$$Type): boolean
 "hasEnchantment"(arg0: $Holder$$Type<($Enchantment)>, arg1: integer): boolean
 "enchant"(arg0: $Holder$$Type<($Enchantment)>, arg1: integer): this
 "enchant"(arg0: $ItemEnchantments$$Type): this
 "withCustomName"(arg0: $Component$$Type): this
 "toItemString"(): string
 "getMod"(): string
 "specialEquals"(arg1: any, arg2: boolean): boolean
 "getBlock"(): $Block
 "toStringJS"(): string
 "asHolder"(): $Holder<($Item)>
 "getIdLocation"(): $ResourceLocation
 "replaceThisWith"(arg1: any): any
 "getTypeData"(): $Map<(string), (any)>
 "getRegistry"(): $Registry<($Item)>
 "getRegistryId"(): $ResourceKey<($Registry<($Item)>)>
 "getWebIconURL"(arg0: $DynamicOps$$Type<($Tag$$Type)>, arg1: integer): $RelativeURL
 "getComponentString"(): string
 "getHarvestSpeed"(arg0: $BlockContainerJS$$Type): float
 "getHarvestSpeed"(): float
 "areComponentsEqual"(arg0: $ItemStack$$Type): boolean
 "equalsIgnoringCount"(arg0: $ItemStack$$Type): boolean
 "getEnchantments"(): $ItemEnchantments
static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
static "toStringJS"(o: any): string
 "setItemName"(arg0: $Component$$Type): void
 "setDamage"(arg0: integer): void
 "setMaxDamage"(arg0: integer): void
 "setFireworks"(arg0: $Fireworks$$Type): void
 "setTool"(arg0: $Tool$$Type): void
 "setFood"(arg0: $FoodProperties$$Type): void
 "setFood"(arg0: integer, arg1: float): void
 "setRepairCost"(arg0: integer): void
 "setInstrument"(arg0: $Holder$$Type<($Instrument)>): void
 "setUnbreakable"(): void
 "setUnbreakableWithTooltip"(): void
 "setMaxStackSize"(arg0: integer): void
 "setFireworkExplosion"(arg0: $FireworkExplosion$$Type): void
 "setChargedProjectiles"(arg0: $List$$Type<($ItemStack$$Type)>): void
 "setBlockEntityData"(arg0: $CompoundTag$$Type): void
 "setBucketEntityData"(arg0: $CompoundTag$$Type): void
 "setNoteBlockSound"(arg0: $ResourceLocation$$Type): void
 "setMapItemColor"(arg0: $KubeColor$$Type): void
 "setFireResistant"(): void
 "setBundleContents"(arg0: $List$$Type<($ItemStack$$Type)>): void
 "matchesAny"(arg1: $Iterable$$Type<($ItemLike$$Type)>, arg2: boolean): boolean
 "hasTag"(arg0: $ResourceLocation$$Type): boolean
 "getTags"(): $Collection<($ResourceLocation)>
 "setAttributeModifiersWithTooltip"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
 "setUnit"(arg0: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "setLockCode"(arg0: string): void
 "setCustomData"(arg0: $CompoundTag$$Type): void
 "setRarity"(arg0: $Rarity$$Type): void
 "setCustomName"(arg0: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(arg0: $List$$Type<($Component$$Type)>): void
 "setLore"(arg0: $List$$Type<($Component$$Type)>, arg1: $List$$Type<($Component$$Type)>): void
 "setDyedColor"(arg0: $KubeColor$$Type): void
 "getCustomData"(): $CompoundTag
 "setPotionId"(arg0: $Holder$$Type<($Potion)>): void
 "setEntityData"(arg0: $CompoundTag$$Type): void
 "setProfile"(arg0: $GameProfile$$Type): void
 "setProfile"(arg0: string, arg1: $UUID$$Type): void
 "setBaseColor"(arg0: $DyeColor$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(arg0: $Map$$Type<(string), (string)>): void
 "setDyedColorWithTooltip"(arg0: $KubeColor$$Type): void
 "set"(arg1: $DataComponentType$$Type<(any)>, arg2: any): $ComponentFunctions
 "set"(arg1: $DataComponentMap$$Type): $ComponentFunctions
 "patch"(arg1: $DataComponentPatch$$Type): $ComponentFunctions
 "get"<T>(arg0: $DataComponentType$$Type<(T)>): T
 "remove"(arg0: $DataComponentType$$Type<(any)>): $ComponentFunctions
 "setPotionContents"(arg0: $PotionContents$$Type): void
 "setGlintOverride"(arg0: boolean): void
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
 "setTooltipHidden"(): void
 "setCustomModelData"(arg0: integer): void
 "resetComponents"(): $ComponentFunctions
 "getComponentMap"(): $DataComponentMap
 "setAttributeModifiers"(arg0: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
static "wrap"(arg1: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackKJS$$Type = ($ItemStackKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackKJS_ = $ItemStackKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundInstance" {
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"

export class $SoundsGenerator$SoundInstance {

constructor(arg0: string)

public "stream"(): $SoundsGenerator$SoundInstance
public "stream"(arg0: boolean): $SoundsGenerator$SoundInstance
public "weight"(arg0: integer): $SoundsGenerator$SoundInstance
public "volume"(arg0: float): $SoundsGenerator$SoundInstance
public "pitch"(arg0: float): $SoundsGenerator$SoundInstance
public "toJson"(): $JsonElement
public "preload"(arg0: boolean): $SoundsGenerator$SoundInstance
public "preload"(): $SoundsGenerator$SoundInstance
public "asReferenceToEvent"(): $SoundsGenerator$SoundInstance
public "attenuationDistance"(arg0: integer): $SoundsGenerator$SoundInstance
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundsGenerator$SoundInstance$$Type = ($SoundsGenerator$SoundInstance);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundsGenerator$SoundInstance_ = $SoundsGenerator$SoundInstance$$Type;
}}
declare module "dev.latvian.mods.kubejs.misc.CustomStatBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $CustomStatBuilder extends $BuilderBase<($ResourceLocation)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomStatBuilder$$Type = ($CustomStatBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomStatBuilder_ = $CustomStatBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.ServerLevelKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$WithPersistentData, $WithPersistentData$$Type} from "dev.latvian.mods.kubejs.core.WithPersistentData"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Fireworks, $Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$ExplosionJS, $ExplosionJS$$Type} from "dev.latvian.mods.kubejs.level.ExplosionJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$LevelKJS, $LevelKJS$$Type} from "dev.latvian.mods.kubejs.core.LevelKJS"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB, $AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export interface $ServerLevelKJS extends $LevelKJS, $WithPersistentData {

 "spawnLightning"(arg0: double, arg1: double, arg2: double, arg3: boolean): void
 "spawnLightning"(arg0: double, arg1: double, arg2: double, arg3: boolean, arg4: $ServerPlayer$$Type): void
 "setTime"(arg0: long): void
 "self"(): $Level
 "getSide"(): $ScriptType
 "spawnParticles"(arg0: $ParticleOptions$$Type, arg1: boolean, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: integer, arg9: double): void
 "getEntities"(): $EntityArrayList
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(arg0: string): void
 "getBlock"(arg0: integer, arg1: integer, arg2: integer): $BlockContainerJS
 "getBlock"(arg0: $BlockPos$$Type): $BlockContainerJS
 "getBlock"(arg0: $BlockEntity$$Type): $BlockContainerJS
 "createEntityList"(arg0: $Collection$$Type<($Entity$$Type)>): $EntityArrayList
 "createExplosion"(arg0: double, arg1: double, arg2: double): $ExplosionJS
 "getEntitiesWithin"(arg0: $AABB$$Type): $EntityArrayList
 "getEntityByUUID"(arg0: $UUID$$Type): $Entity
 "createEntity"(arg0: $EntityType$$Type<(any)>): $Entity
 "spawnFireworks"(arg0: double, arg1: double, arg2: double, arg3: $Fireworks$$Type, arg4: integer): void
 "getDimension"(): $ResourceLocation
 "isOverworld"(): boolean
 "getPlayers"(): $EntityArrayList
 "getPersistentData"(): $CompoundTag
 "getData"(): $AttachedData<($Level)>
 "getDisplayName"(): $Component

(): $AttachedData$$Type<($Level$$Type)>
set "time"(value: long)
get "side"(): $ScriptType
get "entities"(): $EntityArrayList
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "dimension"(): $ResourceLocation
get "overworld"(): boolean
get "players"(): $EntityArrayList
get "persistentData"(): $CompoundTag
get "data"(): $AttachedData<($Level)>
get "displayName"(): $Component
}

export namespace $ServerLevelKJS {
const probejs$$marker: never
}
export class $ServerLevelKJS$$Static implements $ServerLevelKJS {


 "spawnLightning"(arg0: double, arg1: double, arg2: double, arg3: boolean): void
 "spawnLightning"(arg0: double, arg1: double, arg2: double, arg3: boolean, arg4: $ServerPlayer$$Type): void
 "setTime"(arg0: long): void
 "self"(): $Level
 "getSide"(): $ScriptType
 "spawnParticles"(arg0: $ParticleOptions$$Type, arg1: boolean, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: integer, arg9: double): void
 "getEntities"(): $EntityArrayList
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(arg0: string): void
 "getBlock"(arg0: integer, arg1: integer, arg2: integer): $BlockContainerJS
 "getBlock"(arg0: $BlockPos$$Type): $BlockContainerJS
 "getBlock"(arg0: $BlockEntity$$Type): $BlockContainerJS
 "createEntityList"(arg0: $Collection$$Type<($Entity$$Type)>): $EntityArrayList
 "createExplosion"(arg0: double, arg1: double, arg2: double): $ExplosionJS
 "getEntitiesWithin"(arg0: $AABB$$Type): $EntityArrayList
 "getEntityByUUID"(arg0: $UUID$$Type): $Entity
 "createEntity"(arg0: $EntityType$$Type<(any)>): $Entity
 "spawnFireworks"(arg0: double, arg1: double, arg2: double, arg3: $Fireworks$$Type, arg4: integer): void
 "getDimension"(): $ResourceLocation
 "isOverworld"(): boolean
 "getPlayers"(): $EntityArrayList
 "getPersistentData"(): $CompoundTag
 "getData"(): $AttachedData<($Level)>
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerLevelKJS$$Type = (() => $AttachedData$$Type<($Level$$Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerLevelKJS_ = $ServerLevelKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.event.EventHandlerContainer" {
import {$EventHandler, $EventHandler$$Type} from "dev.latvian.mods.kubejs.event.EventHandler"
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ConsoleJS, $ConsoleJS$$Type} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$IEventHandler, $IEventHandler$$Type} from "dev.latvian.mods.kubejs.event.IEventHandler"
import {$EventResult, $EventResult$$Type} from "dev.latvian.mods.kubejs.event.EventResult"

export class $EventHandlerContainer {
readonly "target": any
readonly "handler": $IEventHandler
readonly "source": string
readonly "line": integer

constructor(arg0: any, arg1: $IEventHandler$$Type, arg2: string, arg3: integer)

public "toString"(): string
public static "isEmpty"(arg0: ($EventHandlerContainer$$Type)[]): boolean
public "add"(arg0: any, arg1: $IEventHandler$$Type, arg2: string, arg3: integer): void
public "handle"(arg0: $ConsoleJS$$Type, arg1: $EventHandler$$Type, arg2: $KubeEvent$$Type): $EventResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventHandlerContainer$$Type = ($EventHandlerContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventHandlerContainer_ = $EventHandlerContainer$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.Tristate" {
import {$Keyable, $Keyable$$Type} from "com.mojang.serialization.Keyable"
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$StringRepresentable$EnumCodec, $StringRepresentable$EnumCodec$$Type} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BooleanSupplier, $BooleanSupplier$$Type} from "java.util.function.BooleanSupplier"
import {$StringRepresentable, $StringRepresentable$$Type} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"

export class $Tristate extends $Enum<($Tristate)> implements $StringRepresentable {
static readonly "FALSE": $Tristate
static readonly "TRUE": $Tristate
static readonly "DEFAULT": $Tristate
static readonly "VALUES": ($Tristate)[]
static readonly "CODEC": $Codec<($Tristate)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($Tristate)>


public static "values"(): ($Tristate)[]
public "test"(arg0: boolean): boolean
public "test"(arg0: $BooleanSupplier$$Type): boolean
public static "valueOf"(arg0: string): $Tristate
public static "wrap"(arg0: any): $Tristate
public "getSerializedName"(): string
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): string
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(string), (string)>): $Function<(string), (T)>
public static "fromEnumWithMapping"<E extends ($Enum<(E)>) & ($StringRepresentable)>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(string), (string)>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): string
get "remappedEnumConstantName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Tristate$$Type = (("false") | ("true") | ("default"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Tristate_ = $Tristate$$Type;
}}
declare module "dev.latvian.mods.rhino.type.TypeInfoBase" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Map, $Map$$Type} from "java.util.Map"
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Type, $Type$$Type} from "java.lang.reflect.Type"
import {$List, $List$$Type} from "java.util.List"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$RecordTypeInfo$Component, $RecordTypeInfo$Component$$Type} from "dev.latvian.mods.rhino.type.RecordTypeInfo$Component"
import {$TypeStringContext, $TypeStringContext$$Type} from "dev.latvian.mods.rhino.type.TypeStringContext"

export class $TypeInfoBase implements $TypeInfo {

constructor()

public "newArray"(length: integer): any
public "asArray"(): $TypeInfo
public "signature"(): string
public "append"(ctx: $TypeStringContext$$Type, sb: $StringBuilder$$Type): void
public "isPrimitive"(): boolean
public "componentType"(): $TypeInfo
public static "of"(type: $Type$$Type): $TypeInfo
public static "of"(c: $Class$$Type<(any)>): $TypeInfo
public "enumConstants"(): $List<(any)>
public "param"(index: integer): $TypeInfo
public "isVoid"(): boolean
public "is"(info: $TypeInfo$$Type): boolean
public "or"(info: $TypeInfo$$Type): $TypeInfo
public "isCharacter"(): boolean
public "isFloat"(): boolean
public "isBoolean"(): boolean
public "recordComponents"(): $Map<(string), ($RecordTypeInfo$Component)>
public "asClass"(): $Class<(any)>
public static "ofArray"(array: ($Type$$Type)[]): ($TypeInfo)[]
public "getContainedComponentClasses"(): $Set<($Class<(any)>)>
public "collectContainedComponentClasses"(classes: $Collection$$Type<($Class$$Type<(any)>)>): void
public "withParams"(...params: ($TypeInfo$$Type)[]): $TypeInfo
public "isDouble"(): boolean
public "isFunctionalInterface"(): boolean
public "shouldConvert"(): boolean
public "isLong"(): boolean
public "isInt"(): boolean
public "isShort"(): boolean
public "isByte"(): boolean
public "createDefaultValue"(): any
get "primitive"(): boolean
get "void"(): boolean
get "character"(): boolean
get "float"(): boolean
get "boolean"(): boolean
get "containedComponentClasses"(): $Set<($Class<(any)>)>
get "double"(): boolean
get "functionalInterface"(): boolean
get "long"(): boolean
get "int"(): boolean
get "short"(): boolean
get "byte"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeInfoBase$$Type = ($TypeInfoBase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeInfoBase_ = $TypeInfoBase$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.TrapdoorBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$BlockSetType, $BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $TrapdoorBlockBuilder extends $ShapedBlockBuilder {
static readonly "TRAPDOOR_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "behaviour"(arg0: $BlockSetType$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrapdoorBlockBuilder$$Type = ($TrapdoorBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TrapdoorBlockBuilder_ = $TrapdoorBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$BlockEntityTicker, $BlockEntityTicker$$Type} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$BlockEntityInfo, $BlockEntityInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityInfo"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ClientGamePacketListener, $ClientGamePacketListener$$Type} from "net.minecraft.network.protocol.game.ClientGamePacketListener"
import {$Packet, $Packet$$Type} from "net.minecraft.network.protocol.Packet"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $KubeBlockEntity extends $BlockEntity {
static readonly "TICKER": $BlockEntityTicker<($KubeBlockEntity)>
readonly "info": $BlockEntityInfo
readonly "blockKey": $ResourceKey<($Block)>
readonly "x": integer
readonly "y": integer
readonly "z": integer
 "tick": integer
 "cycle": integer
 "data": $CompoundTag
readonly "attachments": $Map<(string), (any)>
 "placerId": $UUID
 "level": $Level
readonly "worldPosition": $BlockPos
 "remove": boolean
static readonly "ATTACHMENTS_NBT_KEY": string

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityInfo$$Type)

public "save"(): void
public "sync"(): void
public "setLevel"(arg0: $Level$$Type): void
public "getBlock"(): $BlockContainerJS
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "triggerEvent"(arg0: integer, arg1: integer): boolean
public "getPlacer"(): $Entity
public "sendEvent"(arg0: integer, arg1: integer): void
set "level"(value: $Level$$Type)
get "block"(): $BlockContainerJS
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
get "placer"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeBlockEntity$$Type = ($KubeBlockEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeBlockEntity_ = $KubeBlockEntity$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$ReleaseUsingCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export interface $ItemBuilder$ReleaseUsingCallback {

 "releaseUsing"(arg0: $ItemStack$$Type, arg1: $Level$$Type, arg2: $LivingEntity$$Type, arg3: integer): void

(arg0: $ItemStack, arg1: $Level, arg2: $LivingEntity, arg3: integer): void
}

export namespace $ItemBuilder$ReleaseUsingCallback {
const probejs$$marker: never
}
export class $ItemBuilder$ReleaseUsingCallback$$Static implements $ItemBuilder$ReleaseUsingCallback {


 "releaseUsing"(arg0: $ItemStack$$Type, arg1: $Level$$Type, arg2: $LivingEntity$$Type, arg3: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$ReleaseUsingCallback$$Type = ((arg0: $ItemStack, arg1: $Level, arg2: $LivingEntity, arg3: integer) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBuilder$ReleaseUsingCallback_ = $ItemBuilder$ReleaseUsingCallback$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory" {
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockEntityAttachmentInfo, $BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$List, $List$$Type} from "java.util.List"
import {$BlockEntityAttachment, $BlockEntityAttachment$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"

export interface $BlockEntityAttachmentFactory {

 "create"(arg0: $BlockEntityAttachmentInfo$$Type, arg1: $KubeBlockEntity$$Type): $BlockEntityAttachment
 "isTicking"(): boolean
 "getCapabilities"(): $List<($BlockCapability<(any), (any)>)>

(arg0: $BlockEntityAttachmentInfo, arg1: $KubeBlockEntity): $BlockEntityAttachment$$Type
get "ticking"(): boolean
get "capabilities"(): $List<($BlockCapability<(any), (any)>)>
}

export namespace $BlockEntityAttachmentFactory {
const probejs$$marker: never
}
export class $BlockEntityAttachmentFactory$$Static implements $BlockEntityAttachmentFactory {


 "create"(arg0: $BlockEntityAttachmentInfo$$Type, arg1: $KubeBlockEntity$$Type): $BlockEntityAttachment
 "isTicking"(): boolean
 "getCapabilities"(): $List<($BlockCapability<(any), (any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentFactory$$Type = ((arg0: $BlockEntityAttachmentInfo, arg1: $KubeBlockEntity) => $BlockEntityAttachment$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityAttachmentFactory_ = $BlockEntityAttachmentFactory$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.TinyMap" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$TinyMap$Entry, $TinyMap$Entry$$Type} from "dev.latvian.mods.kubejs.util.TinyMap$Entry"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $TinyMap<K, V> extends $Record {

constructor(entries: ($TinyMap$Entry$$Type<(K), (V)>)[])
constructor(arg0: $TinyMap$$Type<(K), (V)>)
constructor(arg0: $Collection$$Type<($TinyMap$Entry$$Type<(K), (V)>)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "toMap"(): $Map<(K), (V)>
public "entries"(): ($TinyMap$Entry<(K), (V)>)[]
public static "ofMap"<K, V>(arg0: $Map$$Type<(K), (V)>): $TinyMap<(K), (V)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TinyMap$$Type<K, V> = ({"entries"?: ($TinyMap$Entry$$Type<(never), (never)>)[]}) | ([entries?: ($TinyMap$Entry$$Type<(never), (never)>)[]]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TinyMap_<K, V> = $TinyMap$$Type<(K), (V)>;
}}
declare module "dev.latvian.mods.kubejs.text.tooltip.TooltipRequirements" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Tristate, $Tristate$$Type} from "dev.latvian.mods.kubejs.util.Tristate"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $TooltipRequirements extends $Record {
static readonly "DEFAULT": $TooltipRequirements
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($TooltipRequirements)>

constructor(shift: $Tristate$$Type, ctrl: $Tristate$$Type, alt: $Tristate$$Type, advanced: $Tristate$$Type, creative: $Tristate$$Type, stages: $Map$$Type<(string), ($Tristate$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "shift"(): $Tristate
public "alt"(): $Tristate
public "advanced"(): $Tristate
public "creative"(): $Tristate
public "stages"(): $Map<(string), ($Tristate)>
public "ctrl"(): $Tristate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipRequirements$$Type = ({"creative"?: $Tristate$$Type, "alt"?: $Tristate$$Type, "ctrl"?: $Tristate$$Type, "stages"?: $Map$$Type<(string), ($Tristate$$Type)>, "advanced"?: $Tristate$$Type, "shift"?: $Tristate$$Type}) | ([creative?: $Tristate$$Type, alt?: $Tristate$$Type, ctrl?: $Tristate$$Type, stages?: $Map$$Type<(string), ($Tristate$$Type)>, advanced?: $Tristate$$Type, shift?: $Tristate$$Type]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipRequirements_ = $TooltipRequirements$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS" {
import {$TagManager, $TagManager$$Type} from "net.minecraft.tags.TagManager"
import {$ServerScriptManager, $ServerScriptManager$$Type} from "dev.latvian.mods.kubejs.server.ServerScriptManager"

export interface $ReloadableServerResourcesKJS {

 "kjs$getTagManager"(): $TagManager
 "kjs$getServerScriptManager"(): $ServerScriptManager
}

export namespace $ReloadableServerResourcesKJS {
const probejs$$marker: never
}
export class $ReloadableServerResourcesKJS$$Static implements $ReloadableServerResourcesKJS {


 "kjs$getTagManager"(): $TagManager
 "kjs$getServerScriptManager"(): $ServerScriptManager
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReloadableServerResourcesKJS$$Type = ($ReloadableServerResourcesKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReloadableServerResourcesKJS_ = $ReloadableServerResourcesKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.Object2LongEntry" {
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Object2LongMap$Entry, $Object2LongMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongMap$Entry"

export class $Object2LongEntry implements $Comparable<($Object2LongEntry)> {
readonly "key": any
readonly "value": long

constructor(arg0: any, arg1: long)
constructor(arg0: $Object2LongMap$Entry$$Type<(any)>)

public "compareTo"(arg0: any): integer
public "compareTo"(arg0: $Object2LongEntry$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2LongEntry$$Type = ($Object2LongEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2LongEntry_ = $Object2LongEntry$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo" {
import {$BlockEntityAttachmentFactory, $BlockEntityAttachmentFactory$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentType, $BlockEntityAttachmentType$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentType"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$EnumSet, $EnumSet$$Type} from "java.util.EnumSet"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $BlockEntityAttachmentInfo extends $Record {

constructor(id: string, type: $BlockEntityAttachmentType$$Type, index: integer, directions: $EnumSet$$Type<($Direction$$Type)>, factory: $BlockEntityAttachmentFactory$$Type)

public "index"(): integer
public "type"(): $BlockEntityAttachmentType
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "factory"(): $BlockEntityAttachmentFactory
public "id"(): string
public "directions"(): $EnumSet<($Direction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentInfo$$Type = ({"index"?: integer, "factory"?: $BlockEntityAttachmentFactory$$Type, "directions"?: $EnumSet$$Type<($Direction$$Type)>, "type"?: $BlockEntityAttachmentType$$Type, "id"?: string}) | ([index?: integer, factory?: $BlockEntityAttachmentFactory$$Type, directions?: $EnumSet$$Type<($Direction$$Type)>, type?: $BlockEntityAttachmentType$$Type, id?: string]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityAttachmentInfo_ = $BlockEntityAttachmentInfo$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabContentSupplier" {
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"

export interface $CreativeTabContentSupplier {

 "getContent"(arg0: boolean): $ItemPredicate

(arg0: boolean): $ItemPredicate$$Type
}

export namespace $CreativeTabContentSupplier {
const DEFAULT: $CreativeTabContentSupplier
const probejs$$marker: never
}
export class $CreativeTabContentSupplier$$Static implements $CreativeTabContentSupplier {
static readonly "DEFAULT": $CreativeTabContentSupplier


 "getContent"(arg0: boolean): $ItemPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabContentSupplier$$Type = ((arg0: boolean) => $ItemPredicate$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabContentSupplier_ = $CreativeTabContentSupplier$$Type;
}}
declare module "dev.latvian.mods.kubejs.command.ArgumentTypeWrapper" {
import {$CommandContext, $CommandContext$$Type} from "com.mojang.brigadier.context.CommandContext"
import {$ArgumentType, $ArgumentType$$Type} from "com.mojang.brigadier.arguments.ArgumentType"
import {$CommandRegistryKubeEvent, $CommandRegistryKubeEvent$$Type} from "dev.latvian.mods.kubejs.command.CommandRegistryKubeEvent"
import {$CommandSourceStack, $CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"

export interface $ArgumentTypeWrapper {

 "create"(arg0: $CommandRegistryKubeEvent$$Type): $ArgumentType<(any)>
 "getResult"(arg0: $CommandContext$$Type<($CommandSourceStack$$Type)>, arg1: string): any
}

export namespace $ArgumentTypeWrapper {
const probejs$$marker: never
}
export class $ArgumentTypeWrapper$$Static implements $ArgumentTypeWrapper {


 "create"(arg0: $CommandRegistryKubeEvent$$Type): $ArgumentType<(any)>
 "getResult"(arg0: $CommandContext$$Type<($CommandSourceStack$$Type)>, arg1: string): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArgumentTypeWrapper$$Type = ($ArgumentTypeWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArgumentTypeWrapper_ = $ArgumentTypeWrapper$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$CreativeModeTab, $CreativeModeTab$$Type} from "net.minecraft.world.item.CreativeModeTab"
import {$CreativeTabContentSupplier, $CreativeTabContentSupplier$$Type} from "dev.latvian.mods.kubejs.item.creativetab.CreativeTabContentSupplier"
import {$CreativeTabIconSupplier, $CreativeTabIconSupplier$$Type} from "dev.latvian.mods.kubejs.item.creativetab.CreativeTabIconSupplier"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $CreativeTabBuilder extends $BuilderBase<($CreativeModeTab)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "content"(arg0: $CreativeTabContentSupplier$$Type): this
public "icon"(arg0: $CreativeTabIconSupplier$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabBuilder$$Type = ($CreativeTabBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabBuilder_ = $CreativeTabBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.state.BlockStatePredicate" {
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration$TargetBlockState"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Set, $Set$$Type} from "java.util.Set"
import {$RuleTest, $RuleTest$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockStatePredicate extends $Predicate<($BlockState)>, $ReplacementMatch {

 "test"(arg0: $BlockState$$Type): boolean
 "test"(arg0: any): boolean
 "check"(arg0: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>): boolean
 "getBlockStates"(): $Collection<($BlockState)>
 "getBlocks"(): $Collection<($Block)>
 "getBlockIds"(): $Set<($ResourceLocation)>
 "testBlock"(arg0: $Block$$Type): boolean
 "asRuleTest"(): $RuleTest
 "or"(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
 "negate"(): $Predicate<($BlockState)>
 "and"(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>

(arg0: $BlockState): boolean
get "blockStates"(): $Collection<($BlockState)>
get "blocks"(): $Collection<($Block)>
get "blockIds"(): $Set<($ResourceLocation)>
}

export namespace $BlockStatePredicate {
function of(arg0: $RegistryAccessContainer$$Type, arg1: any): $BlockStatePredicate
function fromString(arg0: $RegistryAccessContainer$$Type, arg1: string): $BlockStatePredicate
function ruleTestOf(arg1: any): $RuleTest
function not<T>(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
function isEqual<T>(arg0: any): $Predicate<($BlockState)>
function wrap(arg1: any): $ReplacementMatch
const probejs$$marker: never
}
export class $BlockStatePredicate$$Static implements $BlockStatePredicate {


 "test"(arg0: $BlockState$$Type): boolean
 "test"(arg0: any): boolean
static "of"(arg0: $RegistryAccessContainer$$Type, arg1: any): $BlockStatePredicate
 "check"(arg0: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>): boolean
static "fromString"(arg0: $RegistryAccessContainer$$Type, arg1: string): $BlockStatePredicate
 "getBlockStates"(): $Collection<($BlockState)>
 "getBlocks"(): $Collection<($Block)>
 "getBlockIds"(): $Set<($ResourceLocation)>
static "ruleTestOf"(arg1: any): $RuleTest
 "testBlock"(arg0: $Block$$Type): boolean
 "asRuleTest"(): $RuleTest
 "or"(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
 "negate"(): $Predicate<($BlockState)>
 "and"(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
static "not"<T>(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
static "isEqual"<T>(arg0: any): $Predicate<($BlockState)>
static "wrap"(arg1: any): $ReplacementMatch
}
export type BlockStatePredicateObject = {"or"?: $BlockStatePredicate$$Type, "not"?: $BlockStatePredicate$$Type};
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStatePredicate$$Type = (($BlockStatePredicate$$Type)[]) | (BlockStatePredicateObject) | ($Block$$Type) | (Special.BlockTag) | (RegExp) | ("*") | ("-") | ((arg0: $BlockState) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStatePredicate_ = $BlockStatePredicate$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Shovel" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DiggerItemBuilder, $DiggerItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem, $DiggerItem$$Type} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Shovel extends $DiggerItemBuilder {
static readonly "SHOVEL_TAGS": ($ResourceLocation)[]
static readonly "SHOVEL_MODEL": $ResourceLocation
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Shovel$$Type = ($DiggerItemBuilder$Shovel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DiggerItemBuilder$Shovel_ = $DiggerItemBuilder$Shovel$$Type;
}}
declare module "dev.latvian.mods.kubejs.mekanism.KubeChemicalBuilder$DirtySlurry" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$KubeChemicalBuilder, $KubeChemicalBuilder$$Type} from "dev.latvian.mods.kubejs.mekanism.KubeChemicalBuilder"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $KubeChemicalBuilder$DirtySlurry extends $KubeChemicalBuilder {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeChemicalBuilder$DirtySlurry$$Type = ($KubeChemicalBuilder$DirtySlurry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeChemicalBuilder$DirtySlurry_ = $KubeChemicalBuilder$DirtySlurry$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeConstructor" {
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeSchemaType, $RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ComponentValueMap, $ComponentValueMap$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentValueMap"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction, $RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$RecipeOptional, $RecipeOptional$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $RecipeConstructor {
readonly "keys": $List<($RecipeKey<(any)>)>

constructor(arg0: $List$$Type<($RecipeKey$$Type<(any)>)>)
constructor(...arg0: ($RecipeKey$$Type<(any)>)[])

public "toString"(): string
public "override"<T>(arg0: $RecipeKey$$Type<(T)>, arg1: $RecipeOptional$$Type<(T)>): $RecipeConstructor
public "create"(arg1: $SourceLine$$Type, arg2: $RecipeTypeFunction$$Type, arg3: $RecipeSchemaType$$Type, arg4: $ComponentValueMap$$Type): $KubeRecipe
public "overrides"(arg0: $Map$$Type<($RecipeKey$$Type<(any)>), ($RecipeOptional$$Type<(any)>)>): $RecipeConstructor
public "setValues"(arg1: $KubeRecipe$$Type, arg2: $RecipeSchemaType$$Type, arg3: $ComponentValueMap$$Type): void
public "toJson"(arg0: $RecipeSchemaType$$Type, arg1: $DynamicOps$$Type<($JsonElement$$Type)>): $JsonObject
public "overrideValue"<T>(arg0: $RecipeKey$$Type<(T)>, arg1: T): $RecipeConstructor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeConstructor$$Type = ($RecipeConstructor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeConstructor_ = $RecipeConstructor$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemDestroyedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$PlayerDestroyItemEvent, $PlayerDestroyItemEvent$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerDestroyItemEvent"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $ItemDestroyedKubeEvent implements $KubePlayerEvent {

constructor(arg0: $PlayerDestroyItemEvent$$Type)

public "getItem"(): $ItemStack
public "getEntity"(): $Entity
public "getHand"(): $InteractionHand
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "item"(): $ItemStack
get "entity"(): $Entity
get "hand"(): $InteractionHand
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDestroyedKubeEvent$$Type = ($ItemDestroyedKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDestroyedKubeEvent_ = $ItemDestroyedKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.ScriptManager" {
import {$ScriptPack, $ScriptPack$$Type} from "dev.latvian.mods.kubejs.script.ScriptPack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$KubeJSContextFactory, $KubeJSContextFactory$$Type} from "dev.latvian.mods.kubejs.script.KubeJSContextFactory"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptManager {
readonly "scriptType": $ScriptType
readonly "packs": $Map<(string), ($ScriptPack)>
 "contextFactory": $KubeJSContextFactory
 "canListenEvents": boolean

constructor(arg0: $ScriptType$$Type)

public "unload"(): void
public "reload"(): void
public "getRegistries"(): $RegistryAccessContainer
public "loadAdditional"(): void
public "isClassAllowed"(arg0: string): boolean
public "loadPackFromDirectory"(arg0: $Path$$Type, arg1: string, arg2: boolean): void
public "loadFromDirectory"(): void
public "collectScripts"(arg0: $ScriptPack$$Type, arg1: $Path$$Type, arg2: string): void
get "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptManager$$Type = ($ScriptManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptManager_ = $ScriptManager$$Type;
}}
declare module "dev.latvian.mods.kubejs.server.BasicCommandKubeEvent" {
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$KubeEntityEvent, $KubeEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $BasicCommandKubeEvent implements $KubeEntityEvent {
readonly "id": string
readonly "input": string

constructor(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: $BlockPos$$Type, arg3: string, arg4: string)

public "getId"(): string
public "getLevel"(): $Level
public "getEntity"(): $Entity
public "getBlock"(): $BlockContainerJS
public "getPlayer"(): $ServerPlayer
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "id"(): string
get "level"(): $Level
get "entity"(): $Entity
get "block"(): $BlockContainerJS
get "player"(): $ServerPlayer
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicCommandKubeEvent$$Type = ($BasicCommandKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicCommandKubeEvent_ = $BasicCommandKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.MessageSenderKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $MessageSenderKJS {

 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}

export namespace $MessageSenderKJS {
const probejs$$marker: never
}
export class $MessageSenderKJS$$Static implements $MessageSenderKJS {


 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageSenderKJS$$Type = ($MessageSenderKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageSenderKJS_ = $MessageSenderKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.bindings.DirectionWrapper" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$EnumSet, $EnumSet$$Type} from "java.util.EnumSet"

export interface $DirectionWrapper {

}

export namespace $DirectionWrapper {
const down: $Direction
const up: $Direction
const north: $Direction
const south: $Direction
const west: $Direction
const east: $Direction
const DOWN: $Direction
const UP: $Direction
const NORTH: $Direction
const SOUTH: $Direction
const WEST: $Direction
const EAST: $Direction
const VALUES: ($Direction)[]
const NONE: ($Direction)[]
const ALL: $Map<(string), ($Direction)>
const ALL_SET: $EnumSet<($Direction)>
const EMPTY_SET: $EnumSet<($Direction)>
const probejs$$marker: never
}
export class $DirectionWrapper$$Static implements $DirectionWrapper {
static readonly "down": $Direction
static readonly "up": $Direction
static readonly "north": $Direction
static readonly "south": $Direction
static readonly "west": $Direction
static readonly "east": $Direction
static readonly "DOWN": $Direction
static readonly "UP": $Direction
static readonly "NORTH": $Direction
static readonly "SOUTH": $Direction
static readonly "WEST": $Direction
static readonly "EAST": $Direction
static readonly "VALUES": ($Direction)[]
static readonly "NONE": ($Direction)[]
static readonly "ALL": $Map<(string), ($Direction)>
static readonly "ALL_SET": $EnumSet<($Direction)>
static readonly "EMPTY_SET": $EnumSet<($Direction)>


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectionWrapper$$Type = ($DirectionWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DirectionWrapper_ = $DirectionWrapper$$Type;
}}
declare module "dev.latvian.mods.rhino.MemberType" {
import {$Context, $Context$$Type} from "dev.latvian.mods.rhino.Context"
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $MemberType extends $Enum<($MemberType)> {
static readonly "UNDEFINED": $MemberType
static readonly "OBJECT": $MemberType
static readonly "FUNCTION": $MemberType
static readonly "SYMBOL": $MemberType
static readonly "STRING": $MemberType
static readonly "NUMBER": $MemberType
static readonly "BOOLEAN": $MemberType


public static "get"(value: any, cx: $Context$$Type): $MemberType
public "toString"(): string
public static "values"(): ($MemberType)[]
public static "valueOf"(name: string): $MemberType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MemberType$$Type = (("undefined") | ("object") | ("function") | ("symbol") | ("string") | ("number") | ("boolean"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MemberType_ = $MemberType$$Type;
}}
declare module "dev.latvian.apps.tinyserver.http.response.HTTPResponseBuilder" {
import {$WSSession, $WSSession$$Type} from "dev.latvian.apps.tinyserver.ws.WSSession"
import {$HTTPResponse, $HTTPResponse$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPResponse"
import {$DateTimeFormatter, $DateTimeFormatter$$Type} from "java.time.format.DateTimeFormatter"
import {$HTTPStatus, $HTTPStatus$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPStatus"
import {$OutputStream, $OutputStream$$Type} from "java.io.OutputStream"
import {$ResponseContent, $ResponseContent$$Type} from "dev.latvian.apps.tinyserver.content.ResponseContent"

export class $HTTPResponseBuilder {
static readonly "DATE_TIME_FORMATTER": $DateTimeFormatter

constructor()

public "write"(arg0: $OutputStream$$Type, arg1: boolean): void
public "setHeader"(arg0: string, arg1: any): void
public "setBody"(arg0: $ResponseContent$$Type): void
public "setResponse"(arg0: $HTTPResponse$$Type): void
public "setStatus"(arg0: $HTTPStatus$$Type): void
public "wsSession"(): $WSSession<(any)>
set "body"(value: $ResponseContent$$Type)
set "response"(value: $HTTPResponse$$Type)
set "status"(value: $HTTPStatus$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HTTPResponseBuilder$$Type = ($HTTPResponseBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HTTPResponseBuilder_ = $HTTPResponseBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.text.action.TooltipActionType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$TextAction, $TextAction$$Type} from "dev.latvian.mods.kubejs.text.action.TextAction"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $TooltipActionType<T extends $TextAction> extends $Record {

constructor(type: integer, streamCodec: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>)

public "type"(): integer
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipActionType$$Type<T> = ({"type"?: integer, "streamCodec"?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (never)>}) | ([type?: integer, streamCodec?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (never)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TooltipActionType_<T> = $TooltipActionType$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.recipe.special.KubeJSCraftingRecipe" {
import {$CraftingInput, $CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IngredientActionHolder, $IngredientActionHolder$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeType, $RecipeType$$Type} from "net.minecraft.world.item.crafting.RecipeType"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$CraftingBookCategory, $CraftingBookCategory$$Type} from "net.minecraft.world.item.crafting.CraftingBookCategory"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$CraftingRecipe, $CraftingRecipe$$Type} from "net.minecraft.world.item.crafting.CraftingRecipe"
import {$RecipeSerializer, $RecipeSerializer$$Type} from "net.minecraft.world.item.crafting.RecipeSerializer"

export interface $KubeJSCraftingRecipe extends $CraftingRecipe {

 "kjs$getStage"(): string
 "kjs$assemble"(arg0: $CraftingInput$$Type, arg1: $HolderLookup$Provider$$Type): $ItemStack
 "kjs$getModifyResult"(): string
 "kjs$getIngredientActions"(): $List<($IngredientActionHolder)>
 "kjs$getRemainingItems"(arg0: $CraftingInput$$Type): $NonNullList<($ItemStack)>
 "getType"(): $RecipeType<(any)>
 "category"(): $CraftingBookCategory
 "matches"(arg0: $CraftingInput$$Type, arg1: $Level$$Type): boolean
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
 "getGroup"(): string
 "getRemainingItems"(arg0: $CraftingInput$$Type): $NonNullList<($ItemStack)>
 "isSpecial"(): boolean
 "assemble"(arg0: $CraftingInput$$Type, arg1: $HolderLookup$Provider$$Type): $ItemStack
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "getResultItem"(arg0: $HolderLookup$Provider$$Type): $ItemStack
 "isIncomplete"(): boolean
 "getIngredients"(): $NonNullList<($Ingredient)>
 "getToastSymbol"(): $ItemStack
get "type"(): $RecipeType<(any)>
get "group"(): string
get "special"(): boolean
get "serializer"(): $RecipeSerializer<(any)>
get "incomplete"(): boolean
get "ingredients"(): $NonNullList<($Ingredient)>
get "toastSymbol"(): $ItemStack
}

export namespace $KubeJSCraftingRecipe {
const STAGE_KEY: string
const MIRROR_KEY: string
const INGREDIENT_ACTIONS_KEY: string
const MODIFY_RESULT_KEY: string
const probejs$$marker: never
}
export class $KubeJSCraftingRecipe$$Static implements $KubeJSCraftingRecipe {
static readonly "STAGE_KEY": string
static readonly "MIRROR_KEY": string
static readonly "INGREDIENT_ACTIONS_KEY": string
static readonly "MODIFY_RESULT_KEY": string


 "kjs$getStage"(): string
 "kjs$assemble"(arg0: $CraftingInput$$Type, arg1: $HolderLookup$Provider$$Type): $ItemStack
 "kjs$getModifyResult"(): string
 "kjs$getIngredientActions"(): $List<($IngredientActionHolder)>
 "kjs$getRemainingItems"(arg0: $CraftingInput$$Type): $NonNullList<($ItemStack)>
 "getType"(): $RecipeType<(any)>
 "category"(): $CraftingBookCategory
 "matches"(arg0: $CraftingInput$$Type, arg1: $Level$$Type): boolean
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
 "getGroup"(): string
 "getRemainingItems"(arg0: $CraftingInput$$Type): $NonNullList<($ItemStack)>
 "isSpecial"(): boolean
 "assemble"(arg0: $CraftingInput$$Type, arg1: $HolderLookup$Provider$$Type): $ItemStack
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "getResultItem"(arg0: $HolderLookup$Provider$$Type): $ItemStack
 "isIncomplete"(): boolean
 "getIngredients"(): $NonNullList<($Ingredient)>
 "getToastSymbol"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSCraftingRecipe$$Type = ($KubeJSCraftingRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSCraftingRecipe_ = $KubeJSCraftingRecipe$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Helmet" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder, $ArmorItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type, $ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ArmorItemBuilder$Helmet extends $ArmorItemBuilder {
static readonly "HELMET_TAGS": ($ResourceLocation)[]
readonly "armorType": $ArmorItem$Type
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Helmet$$Type = ($ArmorItemBuilder$Helmet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorItemBuilder$Helmet_ = $ArmorItemBuilder$Helmet$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.match.ItemMatch" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$ItemLike, $ItemLike$$Type} from "net.minecraft.world.level.ItemLike"

export interface $ItemMatch extends $ReplacementMatch {

 "matches"(arg1: $ItemLike$$Type, arg2: boolean): boolean
 "matches"(arg1: $Ingredient$$Type, arg2: boolean): boolean
 "matches"(arg1: $ItemStack$$Type, arg2: boolean): boolean
 "matchesAny"(arg1: $Iterable$$Type<($ItemLike$$Type)>, arg2: boolean): boolean
}

export namespace $ItemMatch {
function wrap(arg1: any): $ReplacementMatch
const probejs$$marker: never
}
export class $ItemMatch$$Static implements $ItemMatch {


 "matches"(arg1: $ItemLike$$Type, arg2: boolean): boolean
 "matches"(arg1: $Ingredient$$Type, arg2: boolean): boolean
 "matches"(arg1: $ItemStack$$Type, arg2: boolean): boolean
 "matchesAny"(arg1: $Iterable$$Type<($ItemLike$$Type)>, arg2: boolean): boolean
static "wrap"(arg1: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemMatch$$Type = ($ItemMatch);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemMatch_ = $ItemMatch$$Type;
}}
declare module "dev.latvian.apps.tinyserver.ws.WSSessionFactory" {
import {$WSSession, $WSSession$$Type} from "dev.latvian.apps.tinyserver.ws.WSSession"
import {$HTTPRequest, $HTTPRequest$$Type} from "dev.latvian.apps.tinyserver.http.HTTPRequest"

export interface $WSSessionFactory<REQ extends $HTTPRequest, WSS extends $WSSession<(REQ)>> {

 "create"(): WSS

(): WSS
}

export namespace $WSSessionFactory {
const DEFAULT: $WSSessionFactory<($HTTPRequest), ($WSSession<($HTTPRequest)>)>
const probejs$$marker: never
}
export class $WSSessionFactory$$Static<REQ extends $HTTPRequest, WSS extends $WSSession<(REQ)>> implements $WSSessionFactory {
static readonly "DEFAULT": $WSSessionFactory<($HTTPRequest), ($WSSession<($HTTPRequest)>)>


 "create"(): WSS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WSSessionFactory$$Type<REQ, WSS> = (() => WSS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WSSessionFactory_<REQ, WSS> = $WSSessionFactory$$Type<(REQ), (WSS)>;
}}
declare module "dev.latvian.mods.kubejs.client.ClientKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Minecraft, $Minecraft$$Type} from "net.minecraft.client.Minecraft"

export interface $ClientKubeEvent extends $KubeEvent {

 "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
get "client"(): $Minecraft
}

export namespace $ClientKubeEvent {
const probejs$$marker: never
}
export class $ClientKubeEvent$$Static implements $ClientKubeEvent {


 "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientKubeEvent$$Type = ($ClientKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientKubeEvent_ = $ClientKubeEvent$$Type;
}}
declare module "dev.latvian.apps.tinyserver.http.HTTPHandler" {
import {$HTTPResponse, $HTTPResponse$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPResponse"
import {$HTTPRequest, $HTTPRequest$$Type} from "dev.latvian.apps.tinyserver.http.HTTPRequest"

export interface $HTTPHandler<REQ extends $HTTPRequest> {

 "handle"(arg0: REQ): $HTTPResponse

(arg0: REQ): $HTTPResponse$$Type
}

export namespace $HTTPHandler {
const probejs$$marker: never
}
export class $HTTPHandler$$Static<REQ extends $HTTPRequest> implements $HTTPHandler {


 "handle"(arg0: REQ): $HTTPResponse
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HTTPHandler$$Type<REQ> = ((arg0: REQ) => $HTTPResponse$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HTTPHandler_<REQ> = $HTTPHandler$$Type<(REQ)>;
}}
declare module "dev.latvian.mods.kubejs.item.ItemStackSet" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $ItemStackSet implements $Iterable<($ItemStack)> {

constructor(...arg0: ($ItemStack$$Type)[])
constructor()
constructor(arg0: integer)

public "remove"(arg0: $ItemStack$$Type): void
public "size"(): integer
public "isEmpty"(): boolean
public "add"(arg0: $ItemStack$$Type): void
public "toArray"(): ($ItemStack)[]
public "iterator"(): $Iterator<($ItemStack)>
public "toList"(): $List<($ItemStack)>
public "stream"(): $Stream<($ItemStack)>
public "contains"(arg0: $ItemStack$$Type): boolean
public "forEach"(arg0: $Consumer$$Type<($ItemStack)>): void
public "getFirst"(): $ItemStack
public "addItem"(arg0: $Item$$Type): void
public "spliterator"(): $Spliterator<($ItemStack)>
[Symbol.iterator](): IterableIterator<$ItemStack>;
get "empty"(): boolean
get "first"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackSet$$Type = ($ItemStackSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackSet_ = $ItemStackSet$$Type;
}}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent$Callback" {
import {$ChestMenuInventoryClickEvent, $ChestMenuInventoryClickEvent$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent"

export interface $ChestMenuInventoryClickEvent$Callback {

 "onClick"(arg0: $ChestMenuInventoryClickEvent$$Type): void

(arg0: $ChestMenuInventoryClickEvent): void
}

export namespace $ChestMenuInventoryClickEvent$Callback {
const probejs$$marker: never
}
export class $ChestMenuInventoryClickEvent$Callback$$Static implements $ChestMenuInventoryClickEvent$Callback {


 "onClick"(arg0: $ChestMenuInventoryClickEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuInventoryClickEvent$Callback$$Type = ((arg0: $ChestMenuInventoryClickEvent) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuInventoryClickEvent$Callback_ = $ChestMenuInventoryClickEvent$Callback$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeMappingRegistry" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchemaStorage, $RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"

export class $RecipeMappingRegistry implements $KubeEvent {

constructor(arg0: $RecipeSchemaStorage$$Type)

public "register"(arg0: string, arg1: $ResourceLocation$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeMappingRegistry$$Type = ($RecipeMappingRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeMappingRegistry_ = $RecipeMappingRegistry$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.ClientPlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$KubeJSInventoryListener, $KubeJSInventoryListener$$Type} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$PlayerKJS, $PlayerKJS$$Type} from "dev.latvian.mods.kubejs.core.PlayerKJS"
import {$Stages, $Stages$$Type} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties, $FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$NotificationToastData, $NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS, $PlayerStatsJS$$Type} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$EntityPotionEffectsJS, $EntityPotionEffectsJS$$Type} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$KGUIActions, $KGUIActions$$Type} from "dev.latvian.mods.kubejs.kgui.action.KGUIActions"
import {$Attribute, $Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile, $GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$RayTraceResultJS, $RayTraceResultJS$$Type} from "dev.latvian.mods.kubejs.entity.RayTraceResultJS"
import {$EntityArrayList, $EntityArrayList$$Type} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export interface $ClientPlayerKJS extends $PlayerKJS {

 "self"(): $LivingEntity
 "isMiningBlock"(): boolean
 "sendData"(arg0: string, arg1: $CompoundTag$$Type): void
 "getStats"(): $PlayerStatsJS
 "notify"(arg0: $NotificationToastData$$Type): void
 "isSelf"(): boolean
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "spawn"(): void
 "setStatusMessage"(arg0: $Component$$Type): void
 "getStages"(): $Stages
 "getInventory"(): $InventoryKJS
 "addExhaustion"(arg0: float): void
 "getXpLevel"(): integer
 "setSaturation"(arg0: float): void
 "addFood"(arg0: integer, arg1: float): void
 "addXPLevels"(arg0: integer): void
 "giveInHand"(arg0: $ItemStack$$Type): void
 "getFoodLevel"(): integer
 "setFoodLevel"(arg0: integer): void
 "getKgui"(): $KGUIActions
 "setMouseItem"(arg0: $ItemStack$$Type): void
 "getSaturation"(): float
 "getMouseItem"(): $ItemStack
 "setXpLevel"(arg0: integer): void
 "isPlayer"(): boolean
 "getProfile"(): $GameProfile
 "addItemCooldown"(arg0: $Item$$Type, arg1: integer): void
 "getCraftingGrid"(): $InventoryKJS
 "setSelectedSlot"(arg0: integer): void
 "getSelectedSlot"(): integer
 "boostElytraFlight"(): void
 "sendInventoryUpdate"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addXP"(arg0: integer): void
 "setXp"(arg0: integer): void
 "getXp"(): integer
 "give"(arg0: $ItemStack$$Type): void
 "isFake"(): boolean
 "notify"(arg0: $Component$$Type, arg1: $Component$$Type): void
 "setDefaultMovementSpeed"(arg0: double): void
 "setMovementSpeedAddition"(arg0: double): void
 "getDefaultMovementSpeed"(): double
 "swing"(): void
 "swing"(arg0: $InteractionHand$$Type): void
 "foodEaten"(arg0: $ItemStack$$Type, arg1: $FoodProperties$$Type): void
 "getHeldItem"(arg0: $InteractionHand$$Type): $ItemStack
 "isUndead"(): boolean
 "rayTrace"(): $RayTraceResultJS
 "setOffHandItem"(arg0: $ItemStack$$Type): void
 "getEquipment"(arg0: $EquipmentSlot$$Type): $ItemStack
 "setMaxHealth"(arg0: float): void
 "rayTraceEntity"(arg0: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(arg0: $InteractionHand$$Type, arg1: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setEquipment"(arg0: $EquipmentSlot$$Type, arg1: $ItemStack$$Type): void
 "setDefaultMovementSpeedMultiplier"(arg0: double): void
 "setTotalMovementSpeedMultiplier"(arg0: double): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer): void
 "canEntityBeSeen"(arg0: $LivingEntity$$Type): boolean
 "setLegsArmorItem"(arg0: $ItemStack$$Type): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type): void
 "getMainHandItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "setFeetArmorItem"(arg0: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>, arg1: double): void
 "getReachDistance"(): double
 "isHoldingInAnyHand"(arg0: $ItemPredicate$$Type): boolean
 "modifyAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type, arg2: double, arg3: $AttributeModifier$Operation$$Type): void
 "getAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>): double
 "setMainHandItem"(arg0: $ItemStack$$Type): void
 "setChestArmorItem"(arg0: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(arg0: $ItemStack$$Type): void
 "getAttributeTotalValue"(arg0: $Holder$$Type<($Attribute)>): double
 "getChestArmorItem"(): $ItemStack
 "sendData"(arg0: string): void
 "getData"(): $AttachedData<($Player)>
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "getItem"(): $ItemStack
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "getPersistentData"(): $CompoundTag

(): $AttachedData$$Type<($Player$$Type)>
get "miningBlock"(): boolean
get "stats"(): $PlayerStatsJS
get "inventoryChangeListener"(): $KubeJSInventoryListener
set "statusMessage"(value: $Component$$Type)
get "stages"(): $Stages
get "inventory"(): $InventoryKJS
get "xpLevel"(): integer
set "saturation"(value: float)
get "foodLevel"(): integer
set "foodLevel"(value: integer)
get "kgui"(): $KGUIActions
set "mouseItem"(value: $ItemStack$$Type)
get "saturation"(): float
get "mouseItem"(): $ItemStack
set "xpLevel"(value: integer)
get "player"(): boolean
get "profile"(): $GameProfile
get "craftingGrid"(): $InventoryKJS
set "selectedSlot"(value: integer)
get "selectedSlot"(): integer
get "openInventory"(): $AbstractContainerMenu
set "xp"(value: integer)
get "xp"(): integer
get "fake"(): boolean
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
get "defaultMovementSpeed"(): double
get "undead"(): boolean
set "offHandItem"(value: $ItemStack$$Type)
set "maxHealth"(value: float)
get "living"(): boolean
get "offHandItem"(): $ItemStack
set "defaultMovementSpeedMultiplier"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
set "legsArmorItem"(value: $ItemStack$$Type)
get "potionEffects"(): $EntityPotionEffectsJS
get "mainHandItem"(): $ItemStack
get "totalMovementSpeed"(): double
set "feetArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
get "reachDistance"(): double
set "mainHandItem"(value: $ItemStack$$Type)
set "chestArmorItem"(value: $ItemStack$$Type)
get "feetArmorItem"(): $ItemStack
get "headArmorItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "data"(): $AttachedData<($Player)>
set "nbt"(value: $CompoundTag$$Type)
get "nbt"(): $CompoundTag
set "y"(value: double)
set "x"(value: double)
set "z"(value: double)
get "name"(): $Component
get "displayName"(): $Component
get "passengers"(): $EntityArrayList
get "server"(): $MinecraftServer
get "type"(): string
set "position"(value: $BlockContainerJS$$Type)
get "monster"(): boolean
set "motionX"(value: double)
get "level"(): $Level
set "motionY"(value: double)
get "motionX"(): double
get "item"(): $ItemStack
set "motionZ"(value: double)
get "block"(): $BlockContainerJS
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "motionZ"(): double
get "teamId"(): string
get "facing"(): $Direction
get "animal"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
set "activePostShader"(value: $ResourceLocation$$Type)
get "persistentData"(): $CompoundTag
}

export namespace $ClientPlayerKJS {
const probejs$$marker: never
}
export class $ClientPlayerKJS$$Static implements $ClientPlayerKJS {


 "self"(): $LivingEntity
 "isMiningBlock"(): boolean
 "sendData"(arg0: string, arg1: $CompoundTag$$Type): void
 "getStats"(): $PlayerStatsJS
 "notify"(arg0: $NotificationToastData$$Type): void
 "isSelf"(): boolean
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "spawn"(): void
 "setStatusMessage"(arg0: $Component$$Type): void
 "getStages"(): $Stages
 "getInventory"(): $InventoryKJS
 "addExhaustion"(arg0: float): void
 "getXpLevel"(): integer
 "setSaturation"(arg0: float): void
 "addFood"(arg0: integer, arg1: float): void
 "addXPLevels"(arg0: integer): void
 "giveInHand"(arg0: $ItemStack$$Type): void
 "getFoodLevel"(): integer
 "setFoodLevel"(arg0: integer): void
 "getKgui"(): $KGUIActions
 "setMouseItem"(arg0: $ItemStack$$Type): void
 "getSaturation"(): float
 "getMouseItem"(): $ItemStack
 "setXpLevel"(arg0: integer): void
 "isPlayer"(): boolean
 "getProfile"(): $GameProfile
 "addItemCooldown"(arg0: $Item$$Type, arg1: integer): void
 "getCraftingGrid"(): $InventoryKJS
 "setSelectedSlot"(arg0: integer): void
 "getSelectedSlot"(): integer
 "boostElytraFlight"(): void
 "sendInventoryUpdate"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addXP"(arg0: integer): void
 "setXp"(arg0: integer): void
 "getXp"(): integer
 "give"(arg0: $ItemStack$$Type): void
 "isFake"(): boolean
 "notify"(arg0: $Component$$Type, arg1: $Component$$Type): void
 "setDefaultMovementSpeed"(arg0: double): void
 "setMovementSpeedAddition"(arg0: double): void
 "getDefaultMovementSpeed"(): double
 "swing"(): void
 "swing"(arg0: $InteractionHand$$Type): void
 "foodEaten"(arg0: $ItemStack$$Type, arg1: $FoodProperties$$Type): void
 "getHeldItem"(arg0: $InteractionHand$$Type): $ItemStack
 "isUndead"(): boolean
 "rayTrace"(): $RayTraceResultJS
 "setOffHandItem"(arg0: $ItemStack$$Type): void
 "getEquipment"(arg0: $EquipmentSlot$$Type): $ItemStack
 "setMaxHealth"(arg0: float): void
 "rayTraceEntity"(arg0: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(arg0: $InteractionHand$$Type, arg1: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(arg0: $InteractionHand$$Type, arg1: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setEquipment"(arg0: $EquipmentSlot$$Type, arg1: $ItemStack$$Type): void
 "setDefaultMovementSpeedMultiplier"(arg0: double): void
 "setTotalMovementSpeedMultiplier"(arg0: double): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer, arg2: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(arg0: $EquipmentSlot$$Type, arg1: integer): void
 "canEntityBeSeen"(arg0: $LivingEntity$$Type): boolean
 "setLegsArmorItem"(arg0: $ItemStack$$Type): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type): void
 "getMainHandItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "setFeetArmorItem"(arg0: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>, arg1: double): void
 "getReachDistance"(): double
 "isHoldingInAnyHand"(arg0: $ItemPredicate$$Type): boolean
 "modifyAttribute"(arg0: $Holder$$Type<($Attribute)>, arg1: $ResourceLocation$$Type, arg2: double, arg3: $AttributeModifier$Operation$$Type): void
 "getAttributeBaseValue"(arg0: $Holder$$Type<($Attribute)>): double
 "setMainHandItem"(arg0: $ItemStack$$Type): void
 "setChestArmorItem"(arg0: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(arg0: $ItemStack$$Type): void
 "getAttributeTotalValue"(arg0: $Holder$$Type<($Attribute)>): double
 "getChestArmorItem"(): $ItemStack
 "sendData"(arg0: string): void
 "getData"(): $AttachedData<($Player)>
 "setNbt"(arg0: $CompoundTag$$Type): void
 "getNbt"(): $CompoundTag
 "setY"(arg0: double): void
 "attack"(arg0: float): void
 "setX"(arg0: double): void
 "setZ"(arg0: double): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
 "getPassengers"(): $EntityArrayList
 "getServer"(): $MinecraftServer
 "rayTrace"(arg0: double, arg1: boolean): $RayTraceResultJS
 "rayTrace"(arg0: double): $RayTraceResultJS
 "getDistanceSq"(arg0: $BlockPos$$Type): double
 "getType"(): string
 "setPosition"(arg0: $BlockContainerJS$$Type): void
 "setPosition"(arg0: double, arg1: double, arg2: double): void
 "isMonster"(): boolean
 "setMotionX"(arg0: double): void
 "getLevel"(): $Level
 "setMotionY"(arg0: double): void
 "mergeNbt"(arg0: $CompoundTag$$Type): $Entity
 "playSound"(arg0: $SoundEvent$$Type, arg1: float, arg2: float): void
 "playSound"(arg0: $SoundEvent$$Type): void
 "getMotionX"(): double
 "getItem"(): $ItemStack
 "rayTraceEntity"(arg0: double, arg1: $Predicate$$Type<($Entity)>): $Entity
 "teleportTo"(arg0: $ResourceLocation$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: float): void
 "setMotionZ"(arg0: double): void
 "getBlock"(): $BlockContainerJS
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getMotionZ"(): double
 "getTeamId"(): string
 "getFacing"(): $Direction
 "getDistance"(arg0: double, arg1: double, arg2: double): double
 "getDistance"(arg0: $BlockPos$$Type): double
 "isAnimal"(): boolean
 "setRotation"(arg0: float, arg1: float): void
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "isOnScoreboardTeam"(arg0: string): boolean
 "setPositionAndRotation"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientPlayerKJS_ = $ClientPlayerKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.script.ScriptFile" {
import {$ScriptFileInfo, $ScriptFileInfo$$Type} from "dev.latvian.mods.kubejs.script.ScriptFileInfo"
import {$ScriptPack, $ScriptPack$$Type} from "dev.latvian.mods.kubejs.script.ScriptPack"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$List, $List$$Type} from "java.util.List"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptFile implements $Comparable<($ScriptFile)> {
readonly "pack": $ScriptPack
readonly "info": $ScriptFileInfo
 "lines": (string)[]
 "lastModified": long

constructor(arg0: $ScriptPack$$Type, arg1: $ScriptFileInfo$$Type)

public "getProperty"(arg0: string, arg1: string): string
public "compareTo"(arg0: any): integer
public "compareTo"(arg0: $ScriptFile$$Type): integer
public "load"(): void
public "getProperties"(arg0: string): $List<(string)>
public "getPriority"(): integer
public "skipLoading"(): string
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptFile$$Type = ($ScriptFile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptFile_ = $ScriptFile$$Type;
}}
declare module "dev.latvian.mods.kubejs.event.EventTargetType" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$EventTargetType$Transformer, $EventTargetType$Transformer$$Type} from "dev.latvian.mods.kubejs.event.EventTargetType$Transformer"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"

export class $EventTargetType<T> {
static readonly "STRING": $EventTargetType<(string)>
static readonly "ID": $EventTargetType<($ResourceLocation)>
static readonly "REGISTRY": $EventTargetType<($ResourceKey<($Registry<(any)>)>)>
readonly "type": $Class<(T)>


public "toString"(arg0: $EventTargetType$Transformer$$Type): $EventTargetType<(T)>
public "identity"(): $EventTargetType<(T)>
public static "create"<T>(arg0: $Class$$Type<(T)>): $EventTargetType<(T)>
public "transformer"(arg0: $EventTargetType$Transformer$$Type): $EventTargetType<(T)>
public "validator"(arg0: $Predicate$$Type<(any)>): $EventTargetType<(T)>
public static "fromEnum"<T extends $Enum<(T)>>(arg0: $Class$$Type<(T)>): $EventTargetType<(T)>
public static "registryKey"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>, arg1: $Class$$Type<(any)>): $EventTargetType<($ResourceKey<(T)>)>
public "describeType"(arg0: $TypeInfo$$Type): $EventTargetType<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventTargetType$$Type<T> = ($EventTargetType<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventTargetType_<T> = $EventTargetType$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.net.NetworkKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$KubePlayerEvent, $KubePlayerEvent$$Type} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a network packet is received.
 * 
 * Note that the behaviour of this event is depending on the **script type**.
 * 
 * In `server_scripts`, this event is invoked on the server side when a packet is received from a client.
 * 
 * In `client_scripts`, this event is invoked on the client side when a packet is received from the server.
 */
export class $NetworkKubeEvent implements $KubePlayerEvent {

constructor(arg0: $Player$$Type, arg1: string, arg2: $CompoundTag$$Type)

/**
 * The channel of the packet.
 */
public "getChannel"(): string
/**
 * The data of the packet.
 */
public "getData"(): $CompoundTag
/**
 * The player that sent the packet. Always `Minecraft.player` in `client_scripts`.
 */
public "getEntity"(): $Player
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "channel"(): string
get "data"(): $CompoundTag
get "entity"(): $Player
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkKubeEvent$$Type = ($NetworkKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkKubeEvent_ = $NetworkKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.RecipesKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Pattern, $Pattern$$Type} from "java.util.regex.Pattern"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DocumentedRecipes, $DocumentedRecipes$$Type} from "moe.wolfgirl.probejs.generated.DocumentedRecipes"
import {$List, $List$$Type} from "java.util.List"
import {$Shaped, $Shaped$$Type} from "moe.wolfgirl.probejs.generated.schema.kubejs.Shaped"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$ServerScriptManager, $ServerScriptManager$$Type} from "dev.latvian.mods.kubejs.server.ServerScriptManager"
import {$Stonecutting, $Stonecutting$$Type} from "moe.wolfgirl.probejs.generated.schema.minecraft.Stonecutting"
import {$RecipeSchemaStorage, $RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ReplacementMatchInfo, $ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$CookingBookCategory, $CookingBookCategory$$Type} from "net.minecraft.world.item.crafting.CookingBookCategory"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeTypeFunction, $RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$RecipeFilter, $RecipeFilter$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$TickDuration, $TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$SmithingTransform, $SmithingTransform$$Type} from "moe.wolfgirl.probejs.generated.schema.minecraft.SmithingTransform"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$RegistryOps, $RegistryOps$$Type} from "net.minecraft.resources.RegistryOps"
import {$Blasting, $Blasting$$Type} from "moe.wolfgirl.probejs.generated.schema.minecraft.Blasting"
import {$Smelting, $Smelting$$Type} from "moe.wolfgirl.probejs.generated.schema.minecraft.Smelting"
import {$CampfireCooking, $CampfireCooking$$Type} from "moe.wolfgirl.probejs.generated.schema.minecraft.CampfireCooking"
import {$CraftingBookCategory, $CraftingBookCategory$$Type} from "net.minecraft.world.item.crafting.CraftingBookCategory"
import {$Shapeless, $Shapeless$$Type} from "moe.wolfgirl.probejs.generated.schema.kubejs.Shapeless"
import {$Smoking, $Smoking$$Type} from "moe.wolfgirl.probejs.generated.schema.minecraft.Smoking"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$SmithingTrim, $SmithingTrim$$Type} from "moe.wolfgirl.probejs.generated.schema.minecraft.SmithingTrim"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$ResourceManager, $ResourceManager$$Type} from "net.minecraft.server.packs.resources.ResourceManager"

export class $RecipesKubeEvent implements $KubeEvent {
static readonly "POST_SKIP_ERROR": $Pattern
static readonly "CREATE_RECIPE_SKIP_ERROR": $Pattern
readonly "recipeSchemaStorage": $RecipeSchemaStorage
readonly "registries": $RegistryAccessContainer
readonly "resourceManager": $ResourceManager
readonly "jsonOps": $RegistryOps<($JsonElement)>
readonly "originalRecipes": $Map<($ResourceLocation), ($KubeRecipe)>
readonly "addedRecipes": $Collection<($KubeRecipe)>
readonly "removedRecipes": $Collection<($KubeRecipe)>
readonly "shaped": (result: $ItemStack$$Type, pattern: $List$$Type<(string)>, key: $Map$$Type<(character), ($Ingredient$$Type)>, category?: $CraftingBookCategory$$Type) => $Shaped
readonly "shapeless": (result: $ItemStack$$Type, ingredients: $List$$Type<($Ingredient$$Type)>, category?: $CraftingBookCategory$$Type) => $Shapeless
readonly "smelting": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, cookingTime?: $TickDuration$$Type, category?: $CookingBookCategory$$Type) => $Smelting
readonly "blasting": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, cookingTime?: $TickDuration$$Type, category?: $CookingBookCategory$$Type) => $Blasting
readonly "smoking": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, cookingTime?: $TickDuration$$Type, category?: $CookingBookCategory$$Type) => $Smoking
readonly "campfireCooking": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, cookingTime?: $TickDuration$$Type, category?: $CookingBookCategory$$Type) => $CampfireCooking
readonly "stonecutting": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type) => $Stonecutting
readonly "smithing": (result: $ItemStack$$Type, template: $Ingredient$$Type, base: $Ingredient$$Type, addition: $Ingredient$$Type) => $SmithingTransform
readonly "smithingTrim": (template: $Ingredient$$Type, base: $Ingredient$$Type, addition: $Ingredient$$Type) => $SmithingTrim

constructor(arg0: $ServerScriptManager$$Type, arg1: $ResourceManager$$Type)

public "remove"(arg1: $RecipeFilter$$Type): void
public "stage"(arg1: $RecipeFilter$$Type, arg2: string): void
public "custom"(arg1: $JsonObject$$Type): $KubeRecipe
public "replaceInput"(arg1: $RecipeFilter$$Type, arg2: $ReplacementMatchInfo$$Type, arg3: any): void
public "replaceOutput"(arg1: $RecipeFilter$$Type, arg2: $ReplacementMatchInfo$$Type, arg3: any): void
public "findRecipeIds"(arg1: $RecipeFilter$$Type): $Collection<($ResourceLocation)>
public "getRecipeFunction"(arg0: string): $RecipeTypeFunction
public "recipeStream"(arg1: $RecipeFilter$$Type): $Stream<($KubeRecipe)>
public "countRecipes"(arg1: $RecipeFilter$$Type): integer
public "findRecipes"(arg1: $RecipeFilter$$Type): $Collection<($KubeRecipe)>
public "forEachRecipe"(arg1: $RecipeFilter$$Type, arg2: $Consumer$$Type<($KubeRecipe)>): void
public "printAllTypes"(): void
public "printExamples"(arg0: string): void
public "getRecipes"(): $DocumentedRecipes
public "addRecipe"(arg0: $KubeRecipe$$Type, arg1: boolean): $KubeRecipe
public "containsRecipe"(arg1: $RecipeFilter$$Type): boolean
public "takeId"(arg0: $KubeRecipe$$Type, arg1: string, arg2: string): $ResourceLocation
public "printTypes"(): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "recipes"(): $DocumentedRecipes
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipesKubeEvent$$Type = ($RecipesKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipesKubeEvent_ = $RecipesKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.JsonUtils" {
import {$JsonPrimitive, $JsonPrimitive$$Type} from "com.google.gson.JsonPrimitive"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"

export interface $JsonUtils {

}

export namespace $JsonUtils {
function toString(arg0: $JsonElement$$Type): string
function of(arg1: any): $JsonElement
function copy(arg0: $JsonElement$$Type): $JsonElement
function fromString(arg0: string): $JsonElement
function toObject(arg0: $JsonElement$$Type): any
function toPrimitive(arg0: $JsonElement$$Type): any
function toPrettyString(arg0: $JsonElement$$Type): string
function primitiveOf(arg1: any): $JsonPrimitive
const probejs$$marker: never
}
export class $JsonUtils$$Static implements $JsonUtils {


static "toString"(arg0: $JsonElement$$Type): string
static "of"(arg1: any): $JsonElement
static "copy"(arg0: $JsonElement$$Type): $JsonElement
static "fromString"(arg0: string): $JsonElement
static "toObject"(arg0: $JsonElement$$Type): any
static "toPrimitive"(arg0: $JsonElement$$Type): any
static "toPrettyString"(arg0: $JsonElement$$Type): string
static "primitiveOf"(arg1: any): $JsonPrimitive
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonUtils$$Type = ($JsonUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JsonUtils_ = $JsonUtils$$Type;
}}
declare module "dev.latvian.mods.kubejs.misc.MobEffectBuilder" {
import {$MobEffectBuilder$EffectEntityCallback, $MobEffectBuilder$EffectEntityCallback$$Type} from "dev.latvian.mods.kubejs.misc.MobEffectBuilder$EffectEntityCallback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$MobEffectCategory, $MobEffectCategory$$Type} from "net.minecraft.world.effect.MobEffectCategory"
import {$MobEffect, $MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"

export class $MobEffectBuilder extends $BuilderBase<($MobEffect)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "color"(arg0: $KubeColor$$Type): this
public "instant"(): this
public "instant"(arg0: boolean): this
public "category"(arg0: $MobEffectCategory$$Type): this
public "modifyAttribute"(arg0: $ResourceLocation$$Type, arg1: $ResourceLocation$$Type, arg2: double, arg3: $AttributeModifier$Operation$$Type): this
public "getTranslationKeyGroup"(): string
public "beneficial"(): this
public "harmful"(): this
public "effectTick"(arg0: $MobEffectBuilder$EffectEntityCallback$$Type): this
get "translationKeyGroup"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectBuilder$$Type = ($MobEffectBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobEffectBuilder_ = $MobEffectBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.event.EventResult" {
import {$ICancellableEvent, $ICancellableEvent$$Type} from "net.neoforged.bus.api.ICancellableEvent"
import {$EventResult$Type, $EventResult$Type$$Type} from "dev.latvian.mods.kubejs.event.EventResult$Type"
import {$TriState, $TriState$$Type} from "net.neoforged.neoforge.common.util.TriState"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $EventResult {
static readonly "PASS": $EventResult


public "type"(): $EventResult$Type
public "value"(): any
public "override"(): boolean
public "pass"(): boolean
public "interruptTrue"(): boolean
public "interruptDefault"(): boolean
public "interruptFalse"(): boolean
public "applyCancel"(arg0: $ICancellableEvent$$Type): boolean
public "applyTristate"(arg0: $Consumer$$Type<($TriState)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventResult$$Type = ($EventResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventResult_ = $EventResult$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.special.ShapelessKubeJSRecipe$SerializerKJS" {
import {$ShapelessKubeJSRecipe, $ShapelessKubeJSRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.special.ShapelessKubeJSRecipe"
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Recipe, $Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"
import {$RecipeSerializer, $RecipeSerializer$$Type} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $ShapelessKubeJSRecipe$SerializerKJS implements $RecipeSerializer<($ShapelessKubeJSRecipe)> {
static readonly "CODEC": $MapCodec<($ShapelessKubeJSRecipe)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ShapelessKubeJSRecipe)>

constructor()

public "codec"(): $MapCodec<($ShapelessKubeJSRecipe)>
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ShapelessKubeJSRecipe)>
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapelessKubeJSRecipe$SerializerKJS$$Type = ($ShapelessKubeJSRecipe$SerializerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapelessKubeJSRecipe$SerializerKJS_ = $ShapelessKubeJSRecipe$SerializerKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.BlockBuilderProvider" {
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"

export interface $BlockBuilderProvider {

 "getBlockBuilder"(): $BlockBuilder
get "blockBuilder"(): $BlockBuilder
}

export namespace $BlockBuilderProvider {
const probejs$$marker: never
}
export class $BlockBuilderProvider$$Static implements $BlockBuilderProvider {


 "getBlockBuilder"(): $BlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBuilderProvider$$Type = ($BlockBuilderProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBuilderProvider_ = $BlockBuilderProvider$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent" {
import {$ScheduledEvents, $ScheduledEvents$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents"

export class $ScheduledEvents$ScheduledEvent {
 "scheduledEvents": $ScheduledEvents
 "id": integer
 "ofTicks": boolean
 "repeating": boolean
 "timer": long
 "endTime": long

constructor()

public "clear"(): void
public "reschedule"(): $ScheduledEvents$ScheduledEvent
public "reschedule"(arg0: long): $ScheduledEvents$ScheduledEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$ScheduledEvent$$Type = ($ScheduledEvents$ScheduledEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScheduledEvents$ScheduledEvent_ = $ScheduledEvents$ScheduledEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.registry.BuilderBase" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $BuilderBase<T> implements $Supplier<(T)> {
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "get"(): T
public "toString"(): string
/**
 * Sets the display name for this object, e.g. `Stone`.
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(arg0: $Component$$Type): this
/**
 * Adds a tag to this object, e.g. `minecraft:stone`.
 */
public "tag"(arg0: ($ResourceLocation$$Type)[]): this
/**
 * Sets the translation key for this object, e.g. `block.minecraft.stone`.
 */
public "translationKey"(arg0: string): this
public "getBuilderTranslationKey"(): string
public "getTranslationKeyGroup"(): string
/**
 * Combined method of formattedDisplayName().displayName(name).
 */
public "formattedDisplayName"(arg0: $Component$$Type): this
/**
 * Makes displayName() override language files.
 */
public "formattedDisplayName"(): this
get "builderTranslationKey"(): string
get "translationKeyGroup"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuilderBase$$Type<T> = ($BuilderBase<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BuilderBase_<T> = $BuilderBase$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.event.EventExit" {
import {$Exception, $Exception$$Type} from "java.lang.Exception"
import {$EventResult, $EventResult$$Type} from "dev.latvian.mods.kubejs.event.EventResult"

export class $EventExit extends $Exception {
readonly "result": $EventResult

constructor(arg0: $EventResult$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventExit$$Type = ($EventExit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventExit_ = $EventExit$$Type;
}}
declare module "dev.latvian.mods.rhino.ExternalArrayData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ExternalArrayData {

 "getArrayLength"(): integer
 "setArrayElement"(arg0: integer, arg1: any): void
 "getArrayElement"(arg0: integer): any
get "arrayLength"(): integer
}

export namespace $ExternalArrayData {
const probejs$$marker: never
}
export class $ExternalArrayData$$Static implements $ExternalArrayData {


 "getArrayLength"(): integer
 "setArrayElement"(arg0: integer, arg1: any): void
 "getArrayElement"(arg0: integer): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExternalArrayData$$Type = ($ExternalArrayData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExternalArrayData_ = $ExternalArrayData$$Type;
}}
declare module "dev.latvian.mods.kubejs.generator.KubeAssetGenerator" {
import {$ParticleGenerator, $ParticleGenerator$$Type} from "dev.latvian.mods.kubejs.client.ParticleGenerator"
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$SoundsGenerator, $SoundsGenerator$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator"
import {$Map, $Map$$Type} from "java.util.Map"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$KubeResourceGenerator, $KubeResourceGenerator$$Type} from "dev.latvian.mods.kubejs.generator.KubeResourceGenerator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$VariantBlockStateGenerator, $VariantBlockStateGenerator$$Type} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator"
import {$ModelGenerator, $ModelGenerator$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$MultipartBlockStateGenerator, $MultipartBlockStateGenerator$$Type} from "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$LoadedTexture, $LoadedTexture$$Type} from "dev.latvian.mods.kubejs.client.LoadedTexture"

export interface $KubeAssetGenerator extends $KubeResourceGenerator {

 "mask"(arg0: $ResourceLocation$$Type, arg1: $ResourceLocation$$Type, arg2: $ResourceLocation$$Type): boolean
 "texture"(arg0: $ResourceLocation$$Type, arg1: $LoadedTexture$$Type): void
 "blockState"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($VariantBlockStateGenerator)>): void
 "defaultItemModel"(arg0: $ResourceLocation$$Type): void
 "particle"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($ParticleGenerator)>): void
 "sounds"(arg0: string, arg1: $Consumer$$Type<($SoundsGenerator)>): void
 "defaultHandheldItemModel"(arg0: $ResourceLocation$$Type): void
 "loadTexture"(arg0: $ResourceLocation$$Type): $LoadedTexture
 "multipartState"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($MultipartBlockStateGenerator)>): void
 "buildSounds"(): void
 "stencil"(arg0: $ResourceLocation$$Type, arg1: $ResourceLocation$$Type, arg2: $Map$$Type<($KubeColor$$Type), ($KubeColor$$Type)>): void
 "blockModel"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($ModelGenerator)>): void
 "itemModel"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($ModelGenerator)>): void
 "add"(arg0: $GeneratedData$$Type): void
 "text"(arg0: $ResourceLocation$$Type, arg1: string): void
 "json"(arg0: $ResourceLocation$$Type, arg1: $JsonElement$$Type): void
 "getGenerated"(arg0: $ResourceLocation$$Type): $GeneratedData
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}

export namespace $KubeAssetGenerator {
const GENERATED_ITEM_MODEL: $ResourceLocation
const HANDHELD_ITEM_MODEL: $ResourceLocation
const CUBE_BLOCK_MODEL: $ResourceLocation
const CUBE_ALL_BLOCK_MODEL: $ResourceLocation
const probejs$$marker: never
}
export class $KubeAssetGenerator$$Static implements $KubeAssetGenerator {
static readonly "GENERATED_ITEM_MODEL": $ResourceLocation
static readonly "HANDHELD_ITEM_MODEL": $ResourceLocation
static readonly "CUBE_BLOCK_MODEL": $ResourceLocation
static readonly "CUBE_ALL_BLOCK_MODEL": $ResourceLocation


 "mask"(arg0: $ResourceLocation$$Type, arg1: $ResourceLocation$$Type, arg2: $ResourceLocation$$Type): boolean
 "texture"(arg0: $ResourceLocation$$Type, arg1: $LoadedTexture$$Type): void
 "blockState"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($VariantBlockStateGenerator)>): void
 "defaultItemModel"(arg0: $ResourceLocation$$Type): void
 "particle"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($ParticleGenerator)>): void
 "sounds"(arg0: string, arg1: $Consumer$$Type<($SoundsGenerator)>): void
 "defaultHandheldItemModel"(arg0: $ResourceLocation$$Type): void
 "loadTexture"(arg0: $ResourceLocation$$Type): $LoadedTexture
 "multipartState"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($MultipartBlockStateGenerator)>): void
 "buildSounds"(): void
 "stencil"(arg0: $ResourceLocation$$Type, arg1: $ResourceLocation$$Type, arg2: $Map$$Type<($KubeColor$$Type), ($KubeColor$$Type)>): void
 "blockModel"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($ModelGenerator)>): void
 "itemModel"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($ModelGenerator)>): void
 "add"(arg0: $GeneratedData$$Type): void
 "text"(arg0: $ResourceLocation$$Type, arg1: string): void
 "json"(arg0: $ResourceLocation$$Type, arg1: $JsonElement$$Type): void
 "getGenerated"(arg0: $ResourceLocation$$Type): $GeneratedData
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeAssetGenerator$$Type = ($KubeAssetGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeAssetGenerator_ = $KubeAssetGenerator$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$SurviveCallback" {
import {$LevelReader, $LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $CropBlockBuilder$SurviveCallback {

 "survive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean

(arg0: $BlockState, arg1: $LevelReader, arg2: $BlockPos): boolean
}

export namespace $CropBlockBuilder$SurviveCallback {
const probejs$$marker: never
}
export class $CropBlockBuilder$SurviveCallback$$Static implements $CropBlockBuilder$SurviveCallback {


 "survive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$SurviveCallback$$Type = ((arg0: $BlockState, arg1: $LevelReader, arg2: $BlockPos) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CropBlockBuilder$SurviveCallback_ = $CropBlockBuilder$SurviveCallback$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.FluidAmounts" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $FluidAmounts {

}

export namespace $FluidAmounts {
const BUCKET: long
const MILLIBUCKET: long
const B: long
const MB: long
const INGOT: long
const NUGGET: long
const METAL_BLOCK: long
const BOTTLE: long
const probejs$$marker: never
}
export class $FluidAmounts$$Static implements $FluidAmounts {
static readonly "BUCKET": long
static readonly "MILLIBUCKET": long
static readonly "B": long
static readonly "MB": long
static readonly "INGOT": long
static readonly "NUGGET": long
static readonly "METAL_BLOCK": long
static readonly "BOTTLE": long


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidAmounts$$Type = ($FluidAmounts);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidAmounts_ = $FluidAmounts$$Type;
}}
declare module "dev.latvian.mods.kubejs.web.KJSHTTPRequest" {
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$BlockableEventLoop, $BlockableEventLoop$$Type} from "net.minecraft.util.thread.BlockableEventLoop"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"
import {$HTTPRequest, $HTTPRequest$$Type} from "dev.latvian.apps.tinyserver.http.HTTPRequest"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export class $KJSHTTPRequest extends $HTTPRequest {
 "eventLoop": $BlockableEventLoop<(any)>

constructor()

public "id"(arg0: string, arg1: string): $ResourceLocation
public "id"(): $ResourceLocation
public "components"(arg0: $DynamicOps$$Type<($Tag$$Type)>): $DataComponentPatch
public "runInMainThread"(arg0: $Runnable$$Type): void
public "supplyInMainThread"<T>(arg0: $Supplier$$Type<(T)>): T
public "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KJSHTTPRequest$$Type = ($KJSHTTPRequest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KJSHTTPRequest_ = $KJSHTTPRequest$$Type;
}}
declare module "dev.latvian.mods.kubejs.registry.RegistryKubeEvent" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeStartupEvent, $KubeStartupEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeStartupEvent"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$List, $List$$Type} from "java.util.List"
import {$CustomBuilderObject, $CustomBuilderObject$$Type} from "dev.latvian.mods.kubejs.registry.CustomBuilderObject"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$AdditionalObjectRegistry, $AdditionalObjectRegistry$$Type} from "dev.latvian.mods.kubejs.registry.AdditionalObjectRegistry"

export class $RegistryKubeEvent<T> implements $KubeStartupEvent, $AdditionalObjectRegistry {
readonly "created": $List<($BuilderBase<(T)>)>

constructor(arg0: $ResourceKey$$Type<($Registry<(T)>)>)

public "add"<R>(arg0: $ResourceKey$$Type<($Registry<(R)>)>, arg1: $BuilderBase$$Type<(R)>): void
public "create"(arg1: $ResourceLocation$$Type, arg2: string): $BuilderBase<(T)>
public "create"(arg1: $ResourceLocation$$Type): $BuilderBase<(T)>
public "createCustom"(arg1: $ResourceLocation$$Type, arg2: $Supplier$$Type<(any)>): $CustomBuilderObject
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryKubeEvent$$Type<T> = ($RegistryKubeEvent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryKubeEvent_<T> = $RegistryKubeEvent$$Type<(T)>;
}}
declare module "dev.latvian.apps.tinyserver.http.HTTPMethod" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"

export class $HTTPMethod extends $Enum<($HTTPMethod)> {
static readonly "HEAD": $HTTPMethod
static readonly "GET": $HTTPMethod
static readonly "POST": $HTTPMethod
static readonly "PUT": $HTTPMethod
static readonly "PATCH": $HTTPMethod
static readonly "DELETE": $HTTPMethod
static readonly "OPTIONS": $HTTPMethod
static readonly "TRACE": $HTTPMethod
static readonly "CONNECT": $HTTPMethod


public static "values"(): ($HTTPMethod)[]
public static "valueOf"(arg0: string): $HTTPMethod
public "body"(): boolean
public static "fromString"(arg0: string): $HTTPMethod
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HTTPMethod$$Type = (("head") | ("get") | ("post") | ("put") | ("patch") | ("delete") | ("options") | ("trace") | ("connect"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HTTPMethod_ = $HTTPMethod$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.UnknownKubeRecipe" {
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction, $RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$KubeRecipeFactory, $KubeRecipeFactory$$Type} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ReplacementMatchInfo, $ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"

export class $UnknownKubeRecipe extends $KubeRecipe {
static readonly "RECIPE_FACTORY": $KubeRecipeFactory
static readonly "CHANGED_MARKER": string
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "sourceLine": $SourceLine
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean
 "creationError": boolean

constructor()

public "deserialize"(arg0: boolean): void
public "serialize"(): void
public "hasOutput"(arg1: $ReplacementMatchInfo$$Type): boolean
public "replaceInput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "replaceOutput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "hasInput"(arg1: $ReplacementMatchInfo$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnknownKubeRecipe$$Type = ($UnknownKubeRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnknownKubeRecipe_ = $UnknownKubeRecipe$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Info" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $ItemData$Info extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData$Info)>

constructor(filter: $Ingredient$$Type, info: $List$$Type<($Component$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "filter"(): $Ingredient
public "info"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$Info$$Type = ({"filter"?: $Ingredient$$Type, "info"?: $List$$Type<($Component$$Type)>}) | ([filter?: $Ingredient$$Type, info?: $List$$Type<($Component$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemData$Info_ = $ItemData$Info$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.FoodEatenKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$KubeEntityEvent, $KubeEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an entity eats food.
 */
export class $FoodEatenKubeEvent implements $KubeEntityEvent {

constructor(arg0: $LivingEntity$$Type, arg1: $ItemStack$$Type)

/**
 * The food that was eaten.
 */
public "getItem"(): $ItemStack
/**
 * The entity that ate the food.
 */
public "getEntity"(): $Entity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "item"(): $ItemStack
get "entity"(): $Entity
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoodEatenKubeEvent$$Type = ($FoodEatenKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FoodEatenKubeEvent_ = $FoodEatenKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.FluidIngredientKJS" {
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$FluidMatch, $FluidMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.FluidMatch"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"

export interface $FluidIngredientKJS extends $FluidMatch {

 "matches"(arg1: $FluidStack$$Type, arg2: boolean): boolean
 "matches"(arg1: $FluidIngredient$$Type, arg2: boolean): boolean
}

export namespace $FluidIngredientKJS {
function wrap(arg1: any): $ReplacementMatch
const probejs$$marker: never
}
export class $FluidIngredientKJS$$Static implements $FluidIngredientKJS {


 "matches"(arg1: $FluidStack$$Type, arg2: boolean): boolean
 "matches"(arg1: $FluidIngredient$$Type, arg2: boolean): boolean
static "wrap"(arg1: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidIngredientKJS$$Type = ($FluidIngredientKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidIngredientKJS_ = $FluidIngredientKJS$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.GroupEntriesKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $GroupEntriesKubeEvent<E, F> extends $KubeEvent {

 "group"(arg1: F, arg2: $ResourceLocation$$Type, arg3: $Component$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any

(arg1: F, arg2: $ResourceLocation, arg3: $Component): void
}

export namespace $GroupEntriesKubeEvent {
const probejs$$marker: never
}
export class $GroupEntriesKubeEvent$$Static<E, F> implements $GroupEntriesKubeEvent {


 "group"(arg1: F, arg2: $ResourceLocation$$Type, arg3: $Component$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GroupEntriesKubeEvent$$Type<E, F> = ((arg1: any, arg2: $ResourceLocation, arg3: $Component) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GroupEntriesKubeEvent_<E, F> = $GroupEntriesKubeEvent$$Type<(E), (F)>;
}}
declare module "dev.latvian.mods.kubejs.core.mixin.RecipeHolderMixin" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeHolder, $RecipeHolder$$Type} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$Recipe, $Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"
import {$RecipeHolderKJS, $RecipeHolderKJS$$Type} from "dev.latvian.mods.kubejs.core.RecipeHolderKJS"
import {$RecipeSerializer, $RecipeSerializer$$Type} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$ReplacementMatchInfo, $ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"

export interface $RecipeHolderMixin extends $RecipeHolderKJS {

 "hasOutput"(arg1: $ReplacementMatchInfo$$Type): boolean
 "setGroup"(arg0: string): void
 "replaceInput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "getGroup"(): string
 "getOrCreateId"(): $ResourceLocation
 "getRecipe"(): $Recipe<(any)>
 "getSchema"(): $RecipeSchema
 "replaceOutput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "self"(): $RecipeHolder<(any)>
 "getType"(): $ResourceLocation
 "hasInput"(arg1: $ReplacementMatchInfo$$Type): boolean
 "kjs$getMod"(): string
set "group"(value: string)
get "serializer"(): $RecipeSerializer<(any)>
get "group"(): string
get "orCreateId"(): $ResourceLocation
get "recipe"(): $Recipe<(any)>
get "schema"(): $RecipeSchema
get "type"(): $ResourceLocation
}

export namespace $RecipeHolderMixin {
const probejs$$marker: never
}
export class $RecipeHolderMixin$$Static implements $RecipeHolderMixin {


 "hasOutput"(arg1: $ReplacementMatchInfo$$Type): boolean
 "setGroup"(arg0: string): void
 "replaceInput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "getGroup"(): string
 "getOrCreateId"(): $ResourceLocation
 "getRecipe"(): $Recipe<(any)>
 "getSchema"(): $RecipeSchema
 "replaceOutput"(arg1: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "self"(): $RecipeHolder<(any)>
 "getType"(): $ResourceLocation
 "hasInput"(arg1: $ReplacementMatchInfo$$Type): boolean
 "kjs$getMod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeHolderMixin$$Type = ($RecipeHolderMixin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeHolderMixin_ = $RecipeHolderMixin$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.SlabBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $SlabBlockBuilder extends $ShapedBlockBuilder {
static readonly "SLAB_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlabBlockBuilder$$Type = ($SlabBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlabBlockBuilder_ = $SlabBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$NameCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $ItemBuilder$NameCallback {

 "apply"(arg0: $ItemStack$$Type): $Component

(arg0: $ItemStack): $Component$$Type
}

export namespace $ItemBuilder$NameCallback {
const probejs$$marker: never
}
export class $ItemBuilder$NameCallback$$Static implements $ItemBuilder$NameCallback {


 "apply"(arg0: $ItemStack$$Type): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$NameCallback$$Type = ((arg0: $ItemStack) => $Component$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBuilder$NameCallback_ = $ItemBuilder$NameCallback$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$CreativeModeTab$TabVisibility, $CreativeModeTab$TabVisibility$$Type} from "net.minecraft.world.item.CreativeModeTab$TabVisibility"

export interface $CreativeTabCallback {

 "remove"(arg0: $ItemPredicate$$Type, arg1: boolean, arg2: boolean): void
 "addAfter"(arg0: $ItemStack$$Type, arg1: ($ItemStack$$Type)[], arg2: $CreativeModeTab$TabVisibility$$Type): void
 "addBefore"(arg0: $ItemStack$$Type, arg1: ($ItemStack$$Type)[], arg2: $CreativeModeTab$TabVisibility$$Type): void
}

export namespace $CreativeTabCallback {
const probejs$$marker: never
}
export class $CreativeTabCallback$$Static implements $CreativeTabCallback {


 "remove"(arg0: $ItemPredicate$$Type, arg1: boolean, arg2: boolean): void
 "addAfter"(arg0: $ItemStack$$Type, arg1: ($ItemStack$$Type)[], arg2: $CreativeModeTab$TabVisibility$$Type): void
 "addBefore"(arg0: $ItemStack$$Type, arg1: ($ItemStack$$Type)[], arg2: $CreativeModeTab$TabVisibility$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabCallback$$Type = ($CreativeTabCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabCallback_ = $CreativeTabCallback$$Type;
}}
declare module "dev.latvian.mods.kubejs.core.WithAttachedData" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MessageSenderKJS, $MessageSenderKJS$$Type} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"

export interface $WithAttachedData<T> extends $MessageSenderKJS {

 "getData"(): $AttachedData<(T)>
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void

(): $AttachedData$$Type<(T)>
get "data"(): $AttachedData<(T)>
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}

export namespace $WithAttachedData {
const probejs$$marker: never
}
export class $WithAttachedData$$Static<T> implements $WithAttachedData {


 "getData"(): $AttachedData<(T)>
 "setStatusMessage"(arg0: $Component$$Type): void
 "setActivePostShader"(arg0: $ResourceLocation$$Type): void
 "runCommandSilent"(arg0: string): void
 "tell"(arg0: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "runCommand"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithAttachedData$$Type<T> = (() => $AttachedData$$Type<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WithAttachedData_<T> = $WithAttachedData$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.item.custom.ItemToolTierRegistryKubeEvent" {
import {$MutableToolTier, $MutableToolTier$$Type} from "dev.latvian.mods.kubejs.item.MutableToolTier"
import {$Map, $Map$$Type} from "java.util.Map"
import {$KubeStartupEvent, $KubeStartupEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeStartupEvent"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"
import {$Record, $Record$$Type} from "java.lang.Record"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

/**
 * Invoked when the game is starting up and the item tool tiers are being registered.
 */
export class $ItemToolTierRegistryKubeEvent extends $Record implements $KubeStartupEvent {

constructor(tiers: $Map$$Type<(string), ($Tier$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
/**
 * Adds a new tool tier.
 */
public "add"(arg0: string, arg1: $Consumer$$Type<($MutableToolTier)>): void
public "addBasedOnExisting"(arg0: string, arg1: string, arg2: $Consumer$$Type<($MutableToolTier)>): void
public "addExisting"(arg0: string, arg1: $Tier$$Type): void
public "tiers"(): $Map<(string), ($Tier)>
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemToolTierRegistryKubeEvent$$Type = ({"tiers"?: $Map$$Type<(string), ($Tier$$Type)>}) | ([tiers?: $Map$$Type<(string), ($Tier$$Type)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemToolTierRegistryKubeEvent_ = $ItemToolTierRegistryKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.registry.AdditionalObjectRegistry" {
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"

export interface $AdditionalObjectRegistry {

 "add"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>, arg1: $BuilderBase$$Type<(T)>): void

(arg0: $ResourceKey<($Registry<(T)>)>, arg1: $BuilderBase<(T)>): void
}

export namespace $AdditionalObjectRegistry {
const probejs$$marker: never
}
export class $AdditionalObjectRegistry$$Static implements $AdditionalObjectRegistry {


 "add"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>, arg1: $BuilderBase$$Type<(T)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdditionalObjectRegistry$$Type = ((arg0: $ResourceKey<($Registry<(T)>)>, arg1: $BuilderBase<(T)>) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AdditionalObjectRegistry_ = $AdditionalObjectRegistry$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundGen" {
import {$SoundsGenerator$SoundInstance, $SoundsGenerator$SoundInstance$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundInstance"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $SoundsGenerator$SoundGen {

constructor()

public "replace"(): $SoundsGenerator$SoundGen
public "replace"(arg0: boolean): $SoundsGenerator$SoundGen
public "toJson"(): $JsonObject
public "sound"(arg0: string, arg1: $Consumer$$Type<($SoundsGenerator$SoundInstance)>): $SoundsGenerator$SoundGen
public "sound"(arg0: string): $SoundsGenerator$SoundGen
public "sounds"(...arg0: (string)[]): $SoundsGenerator$SoundGen
public "subtitle"(arg0: string): $SoundsGenerator$SoundGen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundsGenerator$SoundGen$$Type = ($SoundsGenerator$SoundGen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundsGenerator$SoundGen_ = $SoundsGenerator$SoundGen$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.ClassWrapper" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$CustomJavaToJsWrapper, $CustomJavaToJsWrapper$$Type} from "dev.latvian.mods.rhino.util.CustomJavaToJsWrapper"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $ClassWrapper<T> extends $Record implements $CustomJavaToJsWrapper {

constructor(wrappedClass: $Class$$Type<(T)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "convertJavaToJs"(arg1: $Scriptable$$Type, arg2: $TypeInfo$$Type): $Scriptable
public "wrappedClass"(): $Class<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassWrapper$$Type<T> = ({"wrappedClass"?: $Class$$Type<(never)>}) | ([wrappedClass?: $Class$$Type<(never)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassWrapper_<T> = $ClassWrapper$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.entity.BeforeLivingEntityHurtKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$LivingDamageEvent$Pre, $LivingDamageEvent$Pre$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDamageEvent$Pre"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent, $KubeLivingEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked before an entity is hurt by a damage source.
 */
export class $BeforeLivingEntityHurtKubeEvent implements $KubeLivingEntityEvent {

constructor(arg0: $LivingDamageEvent$Pre$$Type)

/**
 * The damage source.
 */
public "getSource"(): $DamageSource
/**
 * The entity that was hurt.
 */
public "getEntity"(): $Entity
public "setDamage"(arg0: float): void
/**
 * The amount of damage.
 */
public "getDamage"(): float
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "source"(): $DamageSource
get "entity"(): $Entity
set "damage"(value: float)
get "damage"(): float
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeforeLivingEntityHurtKubeEvent$$Type = ($BeforeLivingEntityHurtKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BeforeLivingEntityHurtKubeEvent_ = $BeforeLivingEntityHurtKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.server.tag.PreTagKubeEvent" {
import {$EventExceptionHandler, $EventExceptionHandler$$Type} from "dev.latvian.mods.kubejs.event.EventExceptionHandler"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PreTagWrapper, $PreTagWrapper$$Type} from "dev.latvian.mods.kubejs.server.tag.PreTagWrapper"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$List, $List$$Type} from "java.util.List"
import {$Set, $Set$$Type} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$TagKubeEvent, $TagKubeEvent$$Type} from "dev.latvian.mods.kubejs.server.tag.TagKubeEvent"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $PreTagKubeEvent extends $TagKubeEvent {
readonly "tags": $Map<($ResourceLocation), ($PreTagWrapper)>
readonly "actions": $List<($Consumer<($TagKubeEvent)>)>
 "invalid": boolean
static readonly "TAG_EVENT_HANDLER": $EventExceptionHandler
static readonly "SOURCE": string
readonly "registryKey": $ResourceKey<(any)>
readonly "vanillaRegistry": $Registry<(any)>
 "totalAdded": integer
 "totalRemoved": integer

constructor(arg0: $ResourceKey$$Type<(any)>)

public static "handle"(arg0: $Map$$Type<($ResourceKey$$Type<(any)>), ($PreTagKubeEvent$$Type)>): void
public "getElementIds"(): $Set<($ResourceLocation)>
public "removeAllTagsFrom"(...arg0: (any)[]): void
get "elementIds"(): $Set<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PreTagKubeEvent$$Type = ($PreTagKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PreTagKubeEvent_ = $PreTagKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.match.Replaceable" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Replaceable {

 "replaceThisWith"(arg1: any): any
}

export namespace $Replaceable {
const probejs$$marker: never
}
export class $Replaceable$$Static implements $Replaceable {


 "replaceThisWith"(arg1: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Replaceable$$Type = ($Replaceable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Replaceable_ = $Replaceable$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.WallBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $WallBlockBuilder extends $ShapedBlockBuilder {
static readonly "WALL_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallBlockBuilder$$Type = ($WallBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WallBlockBuilder_ = $WallBlockBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.viewer.AddInformationKubeEvent" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $AddInformationKubeEvent<E, F> extends $KubeEvent {

 "add"(arg1: F, arg2: $List$$Type<($Component$$Type)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any

(arg1: F, arg2: $List<($Component)>): void
}

export namespace $AddInformationKubeEvent {
const probejs$$marker: never
}
export class $AddInformationKubeEvent$$Static<E, F> implements $AddInformationKubeEvent {


 "add"(arg1: F, arg2: $List$$Type<($Component$$Type)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddInformationKubeEvent$$Type<E, F> = ((arg1: any, arg2: $List<($Component)>) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AddInformationKubeEvent_<E, F> = $AddInformationKubeEvent$$Type<(E), (F)>;
}}
declare module "dev.latvian.mods.kubejs.block.BlockBuilder" {
import {$BlockRenderType, $BlockRenderType$$Type} from "dev.latvian.mods.kubejs.block.BlockRenderType"
import {$BlockRightClickedKubeEvent, $BlockRightClickedKubeEvent$$Type} from "dev.latvian.mods.kubejs.block.BlockRightClickedKubeEvent"
import {$MapColor, $MapColor$$Type} from "net.minecraft.world.level.material.MapColor"
import {$BlockStateModifyCallbackJS, $BlockStateModifyCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.BlockStateModifyCallbackJS"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BlockExplodedCallbackJS, $BlockExplodedCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.BlockExplodedCallbackJS"
import {$NoteBlockInstrument, $NoteBlockInstrument$$Type} from "net.minecraft.world.level.block.state.properties.NoteBlockInstrument"
import {$BlockDropSupplier, $BlockDropSupplier$$Type} from "dev.latvian.mods.kubejs.block.drop.BlockDropSupplier"
import {$EntitySteppedOnBlockCallbackJS, $EntitySteppedOnBlockCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.EntitySteppedOnBlockCallbackJS"
import {$BlockStateMirrorCallbackJS, $BlockStateMirrorCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.BlockStateMirrorCallbackJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$ItemBuilder, $ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockTintFunction, $BlockTintFunction$$Type} from "dev.latvian.mods.kubejs.block.BlockTintFunction"
import {$AfterEntityFallenOnBlockCallbackJS, $AfterEntityFallenOnBlockCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.AfterEntityFallenOnBlockCallbackJS"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.RandomTickCallbackJS"
import {$BlockEntityInfo, $BlockEntityInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityInfo"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockStateRotateCallbackJS, $BlockStateRotateCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.BlockStateRotateCallbackJS"
import {$ModelledBuilderBase, $ModelledBuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.ModelledBuilderBase"
import {$CanBeReplacedCallbackJS, $CanBeReplacedCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.CanBeReplacedCallbackJS"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$BlockStateModifyPlacementCallbackJS, $BlockStateModifyPlacementCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.BlockStateModifyPlacementCallbackJS"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$EntityFallenOnBlockCallbackJS, $EntityFallenOnBlockCallbackJS$$Type} from "dev.latvian.mods.kubejs.block.callbacks.EntityFallenOnBlockCallbackJS"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$AABB, $AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $BlockBuilder extends $ModelledBuilderBase<($Block)> {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
readonly "id": $ResourceLocation
 "sourceLine": $SourceLine
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(arg0: $ResourceLocation$$Type)

public "createProperties"(): $BlockBehaviour$Properties
/**
 * Add a blockstate property to the block.
 * 
 * For example, facing, lit, etc.
 */
public "property"(arg0: $Property$$Type<(any)>): this
/**
 * Set the shape of the block.
 */
public "box"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): this
/**
 * Set the shape of the block.
 */
public "box"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): this
/**
 * Set the color of a specific layer of the block.
 */
public "color"(arg0: $BlockTintFunction$$Type): this
/**
 * Set the color of a specific layer of the block.
 */
public "color"(arg0: integer, arg1: $BlockTintFunction$$Type): this
/**
 * Sets the display name for this object, e.g. `Stone`.
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(arg0: $Component$$Type): $BuilderBase<($Block)>
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(arg0: ($ResourceLocation$$Type)[]): this
/**
 * Modifies the block's item representation.
 */
public "item"(arg0: $Consumer$$Type<($ItemBuilder)>): this
/**
 * Note block instrument.
 */
public "instrument"(arg0: $NoteBlockInstrument$$Type): this
public "transformObject"(arg0: $Block$$Type): $Block
/**
 * Sets the blast resistance of the block. Defaults to 3.
 */
public "resistance"(arg0: float): this
/**
 * Change drops of this block
 */
public "drops"(arg0: $BlockDropSupplier$$Type): this
/**
 * Sets the render type of the block. Can be `cutout`, `cutout_mipped`, `translucent`, or `basic`.
 */
public "renderType"(arg0: $BlockRenderType$$Type): this
/**
 * Sets the opacity of the block. Opaque blocks do not let light through.
 */
public "opaque"(arg0: boolean): this
/**
 * Set how high you can jump on the block.
 */
public "jumpFactor"(arg0: float): this
/**
 * Sets the block's sound type. Defaults to wood.
 */
public "soundType"(arg0: $SoundType$$Type): this
/**
 * Sets the block's map color. Defaults to NONE.
 */
public "mapColor"(arg0: $MapColor$$Type): this
/**
 * Sets random tick callback for this black.
 */
public "randomTick"(arg0: $Consumer$$Type<($RandomTickCallbackJS)>): this
/**
 * Sets the light level of the block. Defaults to 0 (no light).
 */
public "lightLevel"(arg0: float): this
/**
 * Makes the block transparent.
 */
public "transparent"(arg0: boolean): this
/**
 * Makes the block not collide with entities.
 */
public "noCollision"(): this
/**
 * Set the callback used for right-clicking on the block
 */
public "rightClick"(arg0: $Consumer$$Type<($BlockRightClickedKubeEvent)>): this
/**
 * Makes the block unbreakable.
 */
public "unbreakable"(): this
/**
 * Set how fast you can walk on the block.
 * 
 * Any value above 1 will make you walk insanely fast as your speed is multiplied by this value each tick.
 * 
 * Recommended values are between 0.1 and 1, useful for mimicking soul sand or ice.
 */
public "speedFactor"(arg0: float): this
/**
 * Sets the hardness of the block. Defaults to 1.5.
 * 
 * Setting this to -1 will make the block unbreakable like bedrock.
 */
public "hardness"(arg0: float): this
/**
 * Sets the block should be a full block or not, like cactus or doors.
 */
public "fullBlock"(arg0: boolean): this
/**
 * Makes the block not be solid.
 */
public "notSolid"(): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tagBoth"(arg0: ($ResourceLocation$$Type)[]): this
/**
 * Set the block to have no corresponding item.
 */
public "noItem"(): this
/**
 * Clears all drops for the block.
 */
public "noDrops"(): this
/**
 * Set what happens when an entity falls on the block. Do not use this for moving them, use bounce instead!
 */
public "fallenOn"(arg0: $Consumer$$Type<($EntityFallenOnBlockCallbackJS)>): this
/**
 * Bounces entities that land on this block by bounciness * their fall velocity.
 * Do not make bounciness negative, as that is a recipe for a long and laggy trip to the void
 */
public "bounciness"(arg0: float): this
/**
 * Set how this block reacts after an explosion. Note the block has already been destroyed at this point
 */
public "exploded"(arg0: $Consumer$$Type<($BlockExplodedCallbackJS)>): this
/**
 * Tags the block with the given tag.
 */
public "tagBlock"(arg0: ($ResourceLocation$$Type)[]): this
/**
 * Tags the item with the given tag.
 */
public "tagItem"(arg0: ($ResourceLocation$$Type)[]): this
/**
 * Set what happens when an entity steps on the block
 * This is called every tick for every entity standing on the block, so be careful what you do here.
 */
public "steppedOn"(arg0: $Consumer$$Type<($EntitySteppedOnBlockCallbackJS)>): this
/**
 * Makes the block can be waterlogged.
 */
public "waterlogged"(): this
/**
 * Makes the block suffocating.
 */
public "suffocating"(arg0: boolean): this
/**
 * Creates a Block Entity for this block
 */
public "blockEntity"(arg0: $Consumer$$Type<($BlockEntityInfo)>): this
/**
 * Set if the block can be replaced by something else.
 */
public "canBeReplaced"(arg0: $Predicate$$Type<($CanBeReplacedCallbackJS)>): this
/**
 * Set the default state of the block.
 */
public "defaultState"(arg0: $Consumer$$Type<($BlockStateModifyCallbackJS)>): this
/**
 * Set the callback for determining the blocks state when placed.
 */
public "placementState"(arg0: $Consumer$$Type<($BlockStateModifyPlacementCallbackJS)>): this
/**
 * Set the callback used for determining how the block rotates
 */
public "rotateState"(arg0: $Consumer$$Type<($BlockStateRotateCallbackJS)>): this
/**
 * Makes the block require a tool to have drops when broken.
 */
public "requiresTool"(arg0: boolean): this
/**
 * Makes the block require a tool to have drops when broken.
 */
public "requiresTool"(): this
/**
 * Set the callback used for determining how the block is mirrored
 */
public "mirrorState"(arg0: $Consumer$$Type<($BlockStateMirrorCallbackJS)>): this
/**
 * Makes mobs not spawn on the block.
 */
public "noValidSpawns"(arg0: boolean): this
/**
 * Makes the block view blocking.
 */
public "viewBlocking"(arg0: boolean): this
public "copyPropertiesFrom"(arg0: $Block$$Type): this
public "stoneSoundType"(): this
public "woodSoundType"(): this
public "cropSoundType"(): this
public "noSoundType"(): this
/**
 * Makes the block a redstone conductor.
 */
public "redstoneConductor"(arg0: boolean): this
/**
 * 
 * @deprecated
 */
public "getWaterlogged"(): boolean
/**
 * Set how slippery the block is.
 */
public "slipperiness"(arg0: float): this
public "gravelSoundType"(): this
/**
 * Helper method for setting the render type of the block to `cutout` correctly.
 */
public "defaultCutout"(): this
/**
 * Set how this block bounces/moves entities that land on top of this. Do not use this to modify the block, use fallOn instead!
 * Use ctx.bounce(height) or ctx.setVelocity(x, y, z) to change the entities velocity.
 */
public "afterFallenOn"(arg0: $Consumer$$Type<($AfterEntityFallenOnBlockCallbackJS)>): this
public "grassSoundType"(): this
public "sandSoundType"(): this
public "glassSoundType"(): this
/**
 * Sets the block's map color dynamically per block state. If unset, defaults to NONE.
 */
public "dynamicMapColor"(arg0: $Function$$Type<($BlockState), (any)>): this
public static "createShape"(arg0: $List$$Type<($AABB$$Type)>): $VoxelShape
/**
 * Checks if the block can be waterlogged.
 */
public "canBeWaterlogged"(): boolean
/**
 * 
 * @deprecated
 */
public "setWaterlogged"(arg0: boolean): this
/**
 * Helper method for setting the render type of the block to `translucent` correctly.
 */
public "defaultTranslucent"(): this
public "generateLootTable"(): $LootTable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBuilder$$Type = ($BlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBuilder_ = $BlockBuilder$$Type;
}}
declare module "dev.latvian.mods.rhino.ScriptableObject" {
import {$MemberType, $MemberType$$Type} from "dev.latvian.mods.rhino.MemberType"
import {$SymbolScriptable, $SymbolScriptable$$Type} from "dev.latvian.mods.rhino.SymbolScriptable"
import {$Symbol, $Symbol$$Type} from "dev.latvian.mods.rhino.Symbol"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ExternalArrayData, $ExternalArrayData$$Type} from "dev.latvian.mods.rhino.ExternalArrayData"
import {$Callable, $Callable$$Type} from "dev.latvian.mods.rhino.Callable"
import {$WrappedExecutable, $WrappedExecutable$$Type} from "dev.latvian.mods.rhino.WrappedExecutable"
import {$Context, $Context$$Type} from "dev.latvian.mods.rhino.Context"
import {$DefaultValueTypeHint, $DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$ConstProperties, $ConstProperties$$Type} from "dev.latvian.mods.rhino.ConstProperties"

export class $ScriptableObject implements $Scriptable, $SymbolScriptable, $ConstProperties {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor()
constructor(scope: $Scriptable$$Type, prototype: $Scriptable$$Type)

public "size"(): integer
public "get"(key: any): any
public "get"(key: $Symbol$$Type, start: $Scriptable$$Type): any
public "get"(index: integer, start: $Scriptable$$Type): any
public "get"(name: string, start: $Scriptable$$Type): any
public "put"(key: $Symbol$$Type, start: $Scriptable$$Type, value: any): void
public "put"(index: integer, start: $Scriptable$$Type, value: any): void
public "put"(name: string, start: $Scriptable$$Type, value: any): void
public static "getProperty"(obj: $Scriptable$$Type, key: $Symbol$$Type, cx: $Context$$Type): any
public static "getProperty"(obj: $Scriptable$$Type, name: string, cx: $Context$$Type): any
public static "getProperty"(obj: $Scriptable$$Type, index: integer, cx: $Context$$Type): any
public "isEmpty"(): boolean
public "isSealed"(): boolean
public static "defineClass"<T extends $Scriptable>(scope: $Scriptable$$Type, clazz: $Class$$Type<(T)>, cx: $Context$$Type): void
public static "defineClass"<T extends $Scriptable>(scope: $Scriptable$$Type, clazz: $Class$$Type<(T)>, sealed: boolean, cx: $Context$$Type): void
public static "defineClass"<T extends $Scriptable>(scope: $Scriptable$$Type, clazz: $Class$$Type<(T)>, sealed: boolean, mapInheritance: boolean, cx: $Context$$Type): string
public "delete"(key: $Symbol$$Type): void
public "delete"(index: integer): void
public "delete"(name: string): void
public "getDefaultValue"(typeHint: $DefaultValueTypeHint$$Type): any
public static "getDefaultValue"(object: $Scriptable$$Type, typeHint: $DefaultValueTypeHint$$Type, cx: $Context$$Type): any
public "getClassName"(): string
public "getAttributes"(sym: $Symbol$$Type): integer
public "getAttributes"(index: integer): integer
public "getAttributes"(name: string): integer
public "has"(name: string, start: $Scriptable$$Type): boolean
public "has"(index: integer, start: $Scriptable$$Type): boolean
public "has"(key: $Symbol$$Type, start: $Scriptable$$Type): boolean
public "setAttributes"(index: integer, attributes: integer): void
public "setAttributes"(name: string, attributes: integer): void
public "setAttributes"(key: $Symbol$$Type, attributes: integer): void
public static "hasProperty"(obj: $Scriptable$$Type, key: $Symbol$$Type, cx: $Context$$Type): boolean
public static "hasProperty"(obj: $Scriptable$$Type, index: integer, cx: $Context$$Type): boolean
public static "hasProperty"(obj: $Scriptable$$Type, name: string, cx: $Context$$Type): boolean
public "defineFunctionProperties"(names: (string)[], clazz: $Class$$Type<(any)>, attributes: integer): void
public static "getFunctionPrototype"(scope: $Scriptable$$Type, cx: $Context$$Type): $Scriptable
public "avoidObjectDetection"(): boolean
public "setExternalArrayData"(array: $ExternalArrayData$$Type): void
public "getExternalArrayLength"(): any
public static "defineConstProperty"(destination: $Scriptable$$Type, propertyName: string, cx: $Context$$Type): void
public "getExternalArrayData"(): $ExternalArrayData
public "defineOwnProperties"(props: $ScriptableObject$$Type): void
public "getTypeOf"(): $MemberType
public "getAllIds"(): (any)[]
public "getIds"(): (any)[]
public static "getGeneratorFunctionPrototype"(scope: $Scriptable$$Type, cx: $Context$$Type): $Scriptable
public "getParentScope"(): $Scriptable
public "getPrototype"(): $Scriptable
public "hasInstance"(instance: $Scriptable$$Type): boolean
public "setPrototype"(m: $Scriptable$$Type): void
public "setParentScope"(m: $Scriptable$$Type): void
public "sealObject"(): void
public "putConst"(name: string, start: $Scriptable$$Type, value: any): void
public "isConst"(name: string): boolean
public static "putProperty"(obj: $Scriptable$$Type, index: integer, value: any, cx: $Context$$Type): void
public static "putProperty"(obj: $Scriptable$$Type, name: string, value: any, cx: $Context$$Type): void
public static "putProperty"(obj: $Scriptable$$Type, key: $Symbol$$Type, value: any, cx: $Context$$Type): void
public "associateValue"(key: any, value: any): any
public "getAssociatedValue"(key: any): any
public static "getTopLevelScope"(obj: $Scriptable$$Type): $Scriptable
public static "putConstProperty"(obj: $Scriptable$$Type, name: string, value: any, cx: $Context$$Type): void
public static "redefineProperty"(obj: $Scriptable$$Type, name: string, isConst: boolean, cx: $Context$$Type): void
public "isExtensible"(): boolean
public static "getClassPrototype"(scope: $Scriptable$$Type, className: string, cx: $Context$$Type): $Scriptable
public "defineConst"(name: string, start: $Scriptable$$Type): void
public "defineProperty"(propertyName: string, value: any, attributes: integer): void
public static "defineProperty"(destination: $Scriptable$$Type, propertyName: string, value: any, attributes: integer, cx: $Context$$Type): void
public "defineProperty"(propertyName: string, clazz: $Class$$Type<(any)>, attributes: integer): void
public "defineProperty"(propertyName: string, delegateTo: any, getter: $WrappedExecutable$$Type, setter: $WrappedExecutable$$Type, attributes: integer): void
public "defineProperty"(key: $Symbol$$Type, value: any, attributes: integer): void
public static "getArrayPrototype"(scope: $Scriptable$$Type, cx: $Context$$Type): $Scriptable
public static "deleteProperty"(obj: $Scriptable$$Type, index: integer, cx: $Context$$Type): boolean
public static "deleteProperty"(obj: $Scriptable$$Type, name: string, cx: $Context$$Type): boolean
public static "getPropertyIds"(obj: $Scriptable$$Type): (any)[]
public static "getTopScopeValue"(scope: $Scriptable$$Type, key: any, cx: $Context$$Type): any
public static "getObjectPrototype"(scope: $Scriptable$$Type, cx: $Context$$Type): $Scriptable
public "setGetterOrSetter"(name: string, index: integer, getterOrSetter: $Callable$$Type, isSetter: boolean): void
public "preventExtensions"(): void
public "getGetterOrSetter"(name: string, index: integer, isSetter: boolean): any
public "defineOwnProperty"(id: any, desc: $ScriptableObject$$Type): void
public "enumerationIteratorHasNext"(currentId: $Consumer$$Type<(any)>): boolean
public "enumerationIteratorNext"(currentId: $Consumer$$Type<(any)>): boolean
get "empty"(): boolean
get "sealed"(): boolean
get "className"(): string
set "externalArrayData"(value: $ExternalArrayData$$Type)
get "externalArrayLength"(): any
get "externalArrayData"(): $ExternalArrayData
get "typeOf"(): $MemberType
get "allIds"(): (any)[]
get "ids"(): (any)[]
get "parentScope"(): $Scriptable
get "prototype"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
set "parentScope"(value: $Scriptable$$Type)
get "extensible"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptableObject$$Type = ($ScriptableObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptableObject_ = $ScriptableObject$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.CachedTagLookup$Entry" {
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$CachedTagLookup, $CachedTagLookup$$Type} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup"
import {$Record, $Record$$Type} from "java.lang.Record"

export class $CachedTagLookup$Entry<T> extends $Record {

constructor(key: $ResourceKey$$Type<(T)>, registry: $Registry$$Type<(T)>, lookup: $CachedTagLookup$$Type<(T)>)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "lookup"(): $CachedTagLookup<(T)>
public "key"(): $ResourceKey<(T)>
public "registry"(): $Registry<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedTagLookup$Entry$$Type<T> = ({"registry"?: $Registry$$Type<(never)>, "key"?: $ResourceKey$$Type<(never)>, "lookup"?: $CachedTagLookup$$Type<(never)>}) | ([registry?: $Registry$$Type<(never)>, key?: $ResourceKey$$Type<(never)>, lookup?: $CachedTagLookup$$Type<(never)>]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedTagLookup$Entry_<T> = $CachedTagLookup$Entry$$Type<(T)>;
}}
declare module "dev.latvian.mods.kubejs.color.KubeColor" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$SpecialEquality, $SpecialEquality$$Type} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$TextColor, $TextColor$$Type} from "net.minecraft.network.chat.TextColor"
import {$ByteBuf, $ByteBuf$$Type} from "io.netty.buffer.ByteBuf"

export interface $KubeColor extends $SpecialEquality {

 "getRgb"(): integer
 "createTextColor"(): $TextColor
 "specialEquals"(arg1: any, arg2: boolean): boolean
 "getArgb"(): integer
 "toHexString"(): string
 "getFireworkRGB"(): integer
 "serialize"(): string

(): integer
get "rgb"(): integer
get "argb"(): integer
get "fireworkRGB"(): integer
}

export namespace $KubeColor {
const CODEC: $Codec<($KubeColor)>
const STREAM_CODEC: $StreamCodec<($ByteBuf), ($KubeColor)>
function checkSpecialEquality(o: any, o1: any, shallow: boolean): boolean
const probejs$$marker: never
}
export class $KubeColor$$Static implements $KubeColor {
static readonly "CODEC": $Codec<($KubeColor)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($KubeColor)>


 "getRgb"(): integer
 "createTextColor"(): $TextColor
 "specialEquals"(arg1: any, arg2: boolean): boolean
 "getArgb"(): integer
 "toHexString"(): string
 "getFireworkRGB"(): integer
 "serialize"(): string
static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeColor$$Type = (("") | ("light_blue_dye") | ("blue_dye") | ("purple_dye") | ("dark_red") | ("lightgraydye") | ("dark_aqua") | ("none") | ("green_dye") | ("blackdye") | ("dark_blue") | ("red") | ("pink_dye") | ("aqua") | ("white") | ("white_dye") | ("dark_gray") | ("light_purple") | ("brown_dye") | ("black") | ("darkpurple") | ("lightbluedye") | ("limedye") | ("magenta_dye") | ("-") | ("lime_dye") | ("yellowdye") | ("graydye") | ("purpledye") | ("dark_purple") | ("orange_dye") | ("darkgray") | ("browndye") | ("yellow") | ("bluedye") | ("pinkdye") | ("cyandye") | ("gold") | ("gray") | ("blue") | ("darkblue") | ("transparent") | ("red_dye") | ("darkred") | ("greendye") | ("reddye") | ("gray_dye") | ("orangedye") | ("yellow_dye") | ("black_dye") | ("magentadye") | ("green") | ("light_gray_dye") | ("darkgreen") | ("dark_green") | ("lightpurple") | ("darkaqua") | ("cyan_dye") | ("whitedye")) | (`#${string}`) | (integer) | (() => integer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeColor_ = $KubeColor$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate$PropertyObject" {
import {$Record, $Record$$Type} from "java.lang.Record"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $BlockIDPredicate$PropertyObject extends $Record {

constructor(property: $Property$$Type<(any)>, value: any)

public "value"(): any
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "property"(): $Property<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIDPredicate$PropertyObject$$Type = ({"property"?: $Property$$Type<(never)>, "value"?: any}) | ([property?: $Property$$Type<(never)>, value?: any]);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockIDPredicate$PropertyObject_ = $BlockIDPredicate$PropertyObject$$Type;
}}
declare module "dev.latvian.mods.kubejs.util.RegistryAccessContainer" {
import {$RegistryWrapper, $RegistryWrapper$$Type} from "dev.latvian.mods.kubejs.bindings.RegistryWrapper"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$DamageSources, $DamageSources$$Type} from "net.minecraft.world.damagesource.DamageSources"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$CachedItemTagLookup, $CachedItemTagLookup$$Type} from "dev.latvian.mods.kubejs.recipe.CachedItemTagLookup"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryAccess$Frozen, $RegistryAccess$Frozen$$Type} from "net.minecraft.core.RegistryAccess$Frozen"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$ICondition$IContext, $ICondition$IContext$$Type} from "net.neoforged.neoforge.common.conditions.ICondition$IContext"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RegistryOps, $RegistryOps$$Type} from "net.minecraft.resources.RegistryOps"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$CachedTagLookup$Entry, $CachedTagLookup$Entry$$Type} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup$Entry"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$CachedTagLookup, $CachedTagLookup$$Type} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup"

export class $RegistryAccessContainer implements $ICondition$IContext {
static readonly "BUILTIN": $RegistryAccessContainer
static "current": $RegistryAccessContainer
readonly "cachedRegistryTags": $Map<($ResourceKey<(any)>), ($CachedTagLookup$Entry<(any)>)>
 "cachedItemTags": $CachedItemTagLookup
 "cachedBlockTags": $CachedTagLookup<($Block)>
 "cachedFluidTags": $CachedTagLookup<($Fluid)>

constructor(arg0: $RegistryAccess$Frozen$$Type)

public "decode"<T>(arg1: $Codec$$Type<(T)>, arg2: any): T
public static "of"(): $RegistryAccessContainer
public "access"(): $RegistryAccess$Frozen
public "java"(): $RegistryOps<(any)>
public "json"(): $RegistryOps<($JsonElement)>
public "getAllTags"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $Map<($ResourceLocation), ($Collection<($Holder<(T)>)>)>
public "damageSources"(): $DamageSources
public "nbt"(): $RegistryOps<($Tag)>
public "wrapRegistry"(arg0: $ResourceLocation$$Type): $RegistryWrapper<(any)>
public "itemStackParseCache"(): $Map<(string), ($ItemStack)>
public "decodeJson"<T>(arg0: $Codec$$Type<(T)>, arg1: $JsonElement$$Type): T
public "decodeJson"<T>(arg0: $MapCodec$$Type<(T)>, arg1: $JsonElement$$Type): T
public "decodeNbt"<T>(arg0: $Codec$$Type<(T)>, arg1: $Tag$$Type): T
public "decodeMap"<T>(arg1: $MapCodec$$Type<(T)>, arg2: any): T
public "cacheTags"<T>(arg0: $Registry$$Type<(T)>, arg1: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>): void
public "getTag"<T>(arg0: $TagKey$$Type<(T)>): $Collection<($Holder<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryAccessContainer$$Type = ($RegistryAccessContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryAccessContainer_ = $RegistryAccessContainer$$Type;
}}
declare module "dev.latvian.apps.tinyserver.ws.WSCloseStatus" {
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$StatusCode, $StatusCode$$Type} from "dev.latvian.apps.tinyserver.StatusCode"

export class $WSCloseStatus extends $Enum<($WSCloseStatus)> {
static readonly "CLOSED": $WSCloseStatus
static readonly "GOING_AWAY": $WSCloseStatus
static readonly "PROTOCOL_ERROR": $WSCloseStatus
static readonly "UNSUPPORTED_DATA": $WSCloseStatus
readonly "statusCode": $StatusCode


public static "values"(): ($WSCloseStatus)[]
public static "valueOf"(arg0: string): $WSCloseStatus
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WSCloseStatus$$Type = (("closed") | ("going_away") | ("protocol_error") | ("unsupported_data"));
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WSCloseStatus_ = $WSCloseStatus$$Type;
}}
declare module "dev.latvian.mods.kubejs.item.MutableToolTier" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Tool, $Tool$$Type} from "net.minecraft.world.item.component.Tool"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"

export class $MutableToolTier implements $Tier {
readonly "parent": $Tier

constructor(arg0: $Tier$$Type)

public "getUses"(): integer
public "setSpeed"(arg0: float): void
public "getSpeed"(): float
public "setEnchantmentValue"(arg0: integer): void
public "setRepairIngredient"(arg0: $Ingredient$$Type): void
public "setUses"(arg0: integer): void
public "getAttackDamageBonus"(): float
public "getIncorrectBlocksForDrops"(): $TagKey<($Block)>
public "getVanillaRepairIngredient"(): $Ingredient
public "getEnchantmentValue"(): integer
public "setIncorrectBlocksForDropsTag"(arg0: $ResourceLocation$$Type): void
public "getIncorrectBlocksForDropsTag"(): $ResourceLocation
public "setAttackDamageBonus"(arg0: float): void
public "createToolProperties"(arg0: $TagKey$$Type<($Block)>): $Tool
get "uses"(): integer
set "speed"(value: float)
get "speed"(): float
set "enchantmentValue"(value: integer)
set "repairIngredient"(value: $Ingredient$$Type)
set "uses"(value: integer)
get "attackDamageBonus"(): float
get "incorrectBlocksForDrops"(): $TagKey<($Block)>
get "vanillaRepairIngredient"(): $Ingredient
get "enchantmentValue"(): integer
set "incorrectBlocksForDropsTag"(value: $ResourceLocation$$Type)
get "incorrectBlocksForDropsTag"(): $ResourceLocation
set "attackDamageBonus"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableToolTier$$Type = ($MutableToolTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutableToolTier_ = $MutableToolTier$$Type;
}}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$ModelGenerator$Element, $ModelGenerator$Element$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator$Element"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $ModelGenerator {

constructor()

public "parent"(arg0: $ResourceLocation$$Type): void
public "element"(arg0: $Consumer$$Type<($ModelGenerator$Element)>): void
public "textures"(arg0: $Map$$Type<(string), (string)>): void
public "texture"(arg0: (string)[], arg1: string): void
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$$Type = ($ModelGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelGenerator_ = $ModelGenerator$$Type;
}}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuSlot" {
import {$ChestMenuData, $ChestMenuData$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuData"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ChestMenuClickHandler, $ChestMenuClickHandler$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickHandler"
import {$List, $List$$Type} from "java.util.List"
import {$ChestMenuClickEvent$Callback, $ChestMenuClickEvent$Callback$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"

export class $ChestMenuSlot {
readonly "gui": $ChestMenuData
readonly "index": integer
readonly "x": integer
readonly "y": integer
 "data": $Map<(string), (any)>
readonly "clickHandlers": $List<($ChestMenuClickHandler)>
 "inventory": $InventoryKJS
 "inventorySlot": integer

constructor(arg0: $ChestMenuData$$Type, arg1: integer)

public "toString"(): string
public "setThrown"(arg0: $ChestMenuClickEvent$Callback$$Type): void
public "getItem"(): $ItemStack
public "setItem"(arg0: $ItemStack$$Type): void
public "clicked"(arg0: $ClickType$$Type, arg1: integer, arg2: $ChestMenuClickEvent$Callback$$Type, arg3: boolean): void
public "setDoubleClicked"(arg0: $ChestMenuClickEvent$Callback$$Type): void
public "resetClickHandlers"(): void
public "setRightClicked"(arg0: $ChestMenuClickEvent$Callback$$Type): void
public "setMiddleClicked"(arg0: $ChestMenuClickEvent$Callback$$Type): void
public "setSwapped"(arg0: $ChestMenuClickEvent$Callback$$Type): void
public "setShiftLeftClicked"(arg0: $ChestMenuClickEvent$Callback$$Type): void
public "setShiftRightClicked"(arg0: $ChestMenuClickEvent$Callback$$Type): void
public "setLeftClicked"(arg0: $ChestMenuClickEvent$Callback$$Type): void
set "thrown"(value: $ChestMenuClickEvent$Callback$$Type)
get "item"(): $ItemStack
set "item"(value: $ItemStack$$Type)
set "doubleClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "rightClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "middleClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "swapped"(value: $ChestMenuClickEvent$Callback$$Type)
set "shiftLeftClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "shiftRightClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "leftClicked"(value: $ChestMenuClickEvent$Callback$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuSlot$$Type = ($ChestMenuSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuSlot_ = $ChestMenuSlot$$Type;
}}
declare module "dev.latvian.mods.rhino.ScriptStackElement" {
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"

export class $ScriptStackElement {
readonly "fileName": string
readonly "functionName": string
readonly "lineNumber": integer

constructor(fileName: string, functionName: string, lineNumber: integer)

public "toString"(): string
public "renderJavaStyle"(sb: $StringBuilder$$Type): void
public "renderMozillaStyle"(sb: $StringBuilder$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptStackElement$$Type = ($ScriptStackElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptStackElement_ = $ScriptStackElement$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$ShapeBuilder" {
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$List, $List$$Type} from "java.util.List"

export class $CropBlockBuilder$ShapeBuilder {

constructor(arg0: integer)

/**
 * Describe the shape of the crop at a specific age.
 * 
 * min/max coordinates are double values between 0 and 16.
 */
public "shape"(arg0: integer, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like beetroot for each stage.
 */
public "beetroot"(): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like carrot for each stage.
 */
public "carrot"(): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like potato for each stage.
 */
public "potato"(): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like wheat for each stage.
 */
public "wheat"(): $CropBlockBuilder$ShapeBuilder
public "getShapes"(): $List<($VoxelShape)>
get "shapes"(): $List<($VoxelShape)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$ShapeBuilder$$Type = ($CropBlockBuilder$ShapeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CropBlockBuilder$ShapeBuilder_ = $CropBlockBuilder$ShapeBuilder$$Type;
}}
declare module "dev.latvian.mods.kubejs.level.ExplosionKubeEvent" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Explosion, $Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$KubeLevelEvent, $KubeLevelEvent$$Type} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $ExplosionKubeEvent implements $KubeLevelEvent {

constructor(arg0: $Level$$Type, arg1: $Explosion$$Type)

public "getLevel"(): $Level
public "getBlock"(): $BlockContainerJS
public "getY"(): double
public "getZ"(): double
public "getX"(): double
public "getPosition"(): $Vec3
public "getExploder"(): $LivingEntity
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "level"(): $Level
get "block"(): $BlockContainerJS
get "y"(): double
get "z"(): double
get "x"(): double
get "position"(): $Vec3
get "exploder"(): $LivingEntity
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionKubeEvent$$Type = ($ExplosionKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionKubeEvent_ = $ExplosionKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeComponentFactory" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$StringReader, $StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeSchemaStorage, $RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RecipeComponentFactory {

 "readComponent"(arg0: $RegistryAccessContainer$$Type, arg1: $RecipeSchemaStorage$$Type, arg2: $StringReader$$Type): $RecipeComponent<(any)>

(arg0: $RegistryAccessContainer, arg1: $RecipeSchemaStorage, arg2: $StringReader): $RecipeComponent$$Type<(any)>
}

export namespace $RecipeComponentFactory {
function readOneComponent(arg0: $Function$$Type<($RecipeComponent<(any)>), ($RecipeComponent$$Type<(any)>)>): $RecipeComponentFactory
function readTwoComponents(arg0: $BiFunction$$Type<($RecipeComponent<(any)>), ($RecipeComponent<(any)>), ($RecipeComponent$$Type<(any)>)>): $RecipeComponentFactory
const probejs$$marker: never
}
export class $RecipeComponentFactory$$Static implements $RecipeComponentFactory {


 "readComponent"(arg0: $RegistryAccessContainer$$Type, arg1: $RecipeSchemaStorage$$Type, arg2: $StringReader$$Type): $RecipeComponent<(any)>
static "readOneComponent"(arg0: $Function$$Type<($RecipeComponent<(any)>), ($RecipeComponent$$Type<(any)>)>): $RecipeComponentFactory
static "readTwoComponents"(arg0: $BiFunction$$Type<($RecipeComponent<(any)>), ($RecipeComponent<(any)>), ($RecipeComponent$$Type<(any)>)>): $RecipeComponentFactory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentFactory$$Type = ((arg0: $RegistryAccessContainer, arg1: $RecipeSchemaStorage, arg2: $StringReader) => $RecipeComponent$$Type<(any)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeComponentFactory_ = $RecipeComponentFactory$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.FarmlandTrampledKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEvent$FarmlandTrampleEvent, $BlockEvent$FarmlandTrampleEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$FarmlandTrampleEvent"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$KubeEntityEvent, $KubeEntityEvent$$Type} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an entity attempts to trample farmland.
 */
export class $FarmlandTrampledKubeEvent implements $KubeEntityEvent {

constructor(arg0: $BlockEvent$FarmlandTrampleEvent$$Type)

/**
 * The level that the farmland and the entity are in.
 */
public "getLevel"(): $Level
/**
 * The entity that is attempting to trample the farmland.
 */
public "getEntity"(): $Entity
/**
 * The farmland block.
 */
public "getBlock"(): $BlockContainerJS
/**
 * The distance of the entity from the block.
 */
public "getDistance"(): float
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "level"(): $Level
get "entity"(): $Entity
get "block"(): $BlockContainerJS
get "distance"(): float
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FarmlandTrampledKubeEvent$$Type = ($FarmlandTrampledKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FarmlandTrampledKubeEvent_ = $FarmlandTrampledKubeEvent$$Type;
}}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityTickKubeEvent" {
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$KubeLevelEvent, $KubeLevelEvent$$Type} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockContainerJS, $BlockContainerJS$$Type} from "dev.latvian.mods.kubejs.level.BlockContainerJS"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $BlockEntityTickKubeEvent implements $KubeLevelEvent {

constructor(arg0: $KubeBlockEntity$$Type)

public "getLevel"(): $Level
public "getBlock"(): $BlockContainerJS
public "getTick"(): integer
public "getCycle"(): integer
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(arg1: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(arg1: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
get "level"(): $Level
get "block"(): $BlockContainerJS
get "tick"(): integer
get "cycle"(): integer
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityTickKubeEvent$$Type = ($BlockEntityTickKubeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityTickKubeEvent_ = $BlockEntityTickKubeEvent$$Type;
}}
declare module "dev.latvian.mods.rhino.util.wrap.TypeWrappers" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$TypeWrapperValidator, $TypeWrapperValidator$$Type} from "dev.latvian.mods.rhino.util.wrap.TypeWrapperValidator"
import {$Map, $Map$$Type} from "java.util.Map"
import {$TypeWrapperFactory, $TypeWrapperFactory$$Type} from "dev.latvian.mods.rhino.util.wrap.TypeWrapperFactory"
import {$TypeWrapper, $TypeWrapper$$Type} from "dev.latvian.mods.rhino.util.wrap.TypeWrapper"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$DirectTypeWrapperFactory, $DirectTypeWrapperFactory$$Type} from "dev.latvian.mods.rhino.util.wrap.DirectTypeWrapperFactory"

export class $TypeWrappers {
readonly "wrappers": $Map<($Class<(any)>), ($TypeWrapper<(any)>)>

constructor()

public "register"<T>(target: $Class$$Type<(T)>, factory: $TypeWrapperFactory$$Type<(T)>): void
public "register"<T>(target: $Class$$Type<(T)>, validator: $TypeWrapperValidator$$Type, factory: $TypeWrapperFactory$$Type<(T)>): void
public "getWrapperFactory"(from: any, target: $TypeInfo$$Type): $TypeWrapperFactory<(any)>
public "hasWrapper"(from: any, target: $TypeInfo$$Type): boolean
public "registerDirect"<T>(target: $Class$$Type<(T)>, factory: $DirectTypeWrapperFactory$$Type<(T)>): void
public "registerDirect"<T>(target: $Class$$Type<(T)>, validator: $TypeWrapperValidator$$Type, factory: $DirectTypeWrapperFactory$$Type<(T)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeWrappers$$Type = ($TypeWrappers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeWrappers_ = $TypeWrappers$$Type;
}}
