declare module "it.unimi.dsi.fastutil.objects.ObjectLinkedOpenCustomHashSet" {
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$AbstractObjectSortedSet, $AbstractObjectSortedSet$$Type} from "it.unimi.dsi.fastutil.objects.AbstractObjectSortedSet"
import {$SortedSet, $SortedSet$$Type} from "java.util.SortedSet"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Hash, $Hash$$Type} from "it.unimi.dsi.fastutil.Hash"
import {$ObjectIterator, $ObjectIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectIterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ObjectSpliterator, $ObjectSpliterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSpliterator"
import {$ObjectCollection, $ObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.ObjectCollection"
import {$Hash$Strategy, $Hash$Strategy$$Type} from "it.unimi.dsi.fastutil.Hash$Strategy"
import {$SequencedSet, $SequencedSet$$Type} from "java.util.SequencedSet"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$Cloneable, $Cloneable$$Type} from "java.lang.Cloneable"
import {$Set, $Set$$Type} from "java.util.Set"

export class $ObjectLinkedOpenCustomHashSet<K> extends $AbstractObjectSortedSet<(K)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: (K)[], arg1: integer, arg2: integer, arg3: float, arg4: $Hash$Strategy$$Type<(K)>)
constructor(arg0: $Iterator$$Type<(K)>, arg1: $Hash$Strategy$$Type<(K)>)
constructor(arg0: $Iterator$$Type<(K)>, arg1: float, arg2: $Hash$Strategy$$Type<(K)>)
constructor(arg0: $ObjectCollection$$Type<(K)>, arg1: $Hash$Strategy$$Type<(K)>)
constructor(arg0: (K)[], arg1: integer, arg2: integer, arg3: $Hash$Strategy$$Type<(K)>)
constructor(arg0: (K)[], arg1: float, arg2: $Hash$Strategy$$Type<(K)>)
constructor(arg0: (K)[], arg1: $Hash$Strategy$$Type<(K)>)
constructor(arg0: integer, arg1: float, arg2: $Hash$Strategy$$Type<(K)>)
constructor(arg0: integer, arg1: $Hash$Strategy$$Type<(K)>)
constructor(arg0: $Hash$Strategy$$Type<(K)>)
constructor(arg0: $ObjectCollection$$Type<(K)>, arg1: float, arg2: $Hash$Strategy$$Type<(K)>)
constructor(arg0: $Collection$$Type<(K)>, arg1: $Hash$Strategy$$Type<(K)>)
constructor(arg0: $Collection$$Type<(K)>, arg1: float, arg2: $Hash$Strategy$$Type<(K)>)

public "remove"(arg0: any): boolean
public "size"(): integer
public "get"(arg0: any): K
public "hashCode"(): integer
public "clone"(): $ObjectLinkedOpenCustomHashSet<(K)>
public "clear"(): void
public "isEmpty"(): boolean
public "add"(arg0: K): boolean
public "iterator"(arg0: any): $ObjectBidirectionalIterator<(any)>
public "iterator"(): $ObjectIterator<(any)>
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "contains"(arg0: any): boolean
public "last"(): K
public "spliterator"(): $ObjectSpliterator<(K)>
public "addAll"(arg0: $Collection$$Type<(K)>): boolean
public "first"(): K
public "forEach"(arg0: $Consumer$$Type<(K)>): void
public "ensureCapacity"(arg0: integer): void
public "removeFirst"(): K
public "removeLast"(): K
public "comparator"(): $Comparator<(K)>
public "subSet"(arg0: any, arg1: any): $SortedSet<(any)>
public "headSet"(arg0: any): $SortedSet<(any)>
public "tailSet"(arg0: any): $SortedSet<(any)>
public "strategy"(): $Hash$Strategy<(K)>
public "addOrGet"(arg0: K): K
public "addAndMoveToFirst"(arg0: K): boolean
public "addAndMoveToLast"(arg0: K): boolean
public static "of"<K>(arg0: K, arg1: K): $ObjectSet<(K)>
public static "of"<K>(...arg0: (K)[]): $ObjectSet<(K)>
public static "of"<K>(arg0: K, arg1: K, arg2: K): $ObjectSet<(K)>
public static "of"<K>(): $ObjectSet<(K)>
public static "of"<K>(arg0: K): $ObjectSet<(K)>
public "reversed"(): $SequencedSet<(any)>
public static "copyOf"<E>(arg0: $Collection$$Type<(E)>): $Set<(E)>
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public "removeAll"(arg0: $Collection$$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectLinkedOpenCustomHashSet$$Type<K> = ($ObjectLinkedOpenCustomHashSet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectLinkedOpenCustomHashSet_<K> = $ObjectLinkedOpenCustomHashSet$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.chars.Char2ShortFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Char2ShortFunction extends $Function<(character), (short)>, $IntUnaryOperator {

 "remove"(arg0: character): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: short): short
 "put"(arg0: character, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: character, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): short
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: character): short
}

export namespace $Char2ShortFunction {
function identity(): $IntUnaryOperator
const probejs$$marker: never
}
export class $Char2ShortFunction$$Static implements $Char2ShortFunction {


 "remove"(arg0: character): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: short): short
 "put"(arg0: character, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: character, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): short
static "identity"(): $IntUnaryOperator
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ShortFunction$$Type = ((arg0: character) => short);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ShortFunction_ = $Char2ShortFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2ShortFunction" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Int2ShortFunction extends $Function<(integer), (short)>, $IntUnaryOperator {

 "remove"(arg0: integer): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: short): short
 "put"(arg0: integer, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: integer, arg1: short): short
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): short
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: integer): short
}

export namespace $Int2ShortFunction {
function identity(): $IntUnaryOperator
const probejs$$marker: never
}
export class $Int2ShortFunction$$Static implements $Int2ShortFunction {


 "remove"(arg0: integer): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: short): short
 "put"(arg0: integer, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: integer, arg1: short): short
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): short
static "identity"(): $IntUnaryOperator
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ShortFunction$$Type = ((arg0: integer) => short);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ShortFunction_ = $Int2ShortFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.IntIterator" {
import {$IntConsumer as $IntConsumer$0, $IntConsumer$$Type as $IntConsumer$0$$Type} from "java.util.function.IntConsumer"
import {$PrimitiveIterator$OfInt, $PrimitiveIterator$OfInt$$Type} from "java.util.PrimitiveIterator$OfInt"
import {$IntConsumer, $IntConsumer$$Type} from "it.unimi.dsi.fastutil.ints.IntConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $IntIterator extends $PrimitiveIterator$OfInt {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(integer)>): void
 "forEachRemaining"(arg0: $IntConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "skip"(arg0: integer): integer
 "nextInt"(): integer
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $IntConsumer$0$$Type): void
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $IntIterator {
const probejs$$marker: never
}
export class $IntIterator$$Static implements $IntIterator {


/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(integer)>): void
 "forEachRemaining"(arg0: $IntConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "skip"(arg0: integer): integer
 "nextInt"(): integer
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $IntConsumer$0$$Type): void
 "remove"(): void
 "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntIterator$$Type = ($IntIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntIterator_ = $IntIterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.floats.FloatBinaryOperator" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BinaryOperator, $BinaryOperator$$Type} from "java.util.function.BinaryOperator"
import {$DoubleBinaryOperator, $DoubleBinaryOperator$$Type} from "java.util.function.DoubleBinaryOperator"

export interface $FloatBinaryOperator extends $BinaryOperator<(float)>, $DoubleBinaryOperator {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: float, arg1: float): float
 "apply"(arg0: float, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double, arg1: double): double
 "andThen"<V>(arg0: $Function$$Type<(float), (V)>): $BiFunction<(float), (float), (V)>

(arg0: float, arg1: float): float
}

export namespace $FloatBinaryOperator {
function minBy<T>(arg0: $Comparator$$Type<(float)>): $BinaryOperator<(float)>
function maxBy<T>(arg0: $Comparator$$Type<(float)>): $BinaryOperator<(float)>
const probejs$$marker: never
}
export class $FloatBinaryOperator$$Static implements $FloatBinaryOperator {


/**
 * 
 * @deprecated
 */
 "apply"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: float, arg1: float): float
 "apply"(arg0: float, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double, arg1: double): double
static "minBy"<T>(arg0: $Comparator$$Type<(float)>): $BinaryOperator<(float)>
static "maxBy"<T>(arg0: $Comparator$$Type<(float)>): $BinaryOperator<(float)>
 "andThen"<V>(arg0: $Function$$Type<(float), (V)>): $BiFunction<(float), (float), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatBinaryOperator$$Type = ((arg0: float, arg1: float) => float);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatBinaryOperator_ = $FloatBinaryOperator$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.ShortUnaryOperator" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Function, $Function$$Type} from "java.util.function.Function"

export interface $ShortUnaryOperator extends $UnaryOperator<(short)>, $IntUnaryOperator {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: short): short
 "apply"(arg0: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "compose"<V>(arg0: $Function$$Type<(V), (short)>): $Function<(V), (short)>
 "andThen"<V>(arg0: $Function$$Type<(short), (V)>): $Function<(short), (V)>

(arg0: short): short
}

export namespace $ShortUnaryOperator {
function identity(): $ShortUnaryOperator
function negation(): $ShortUnaryOperator
const probejs$$marker: never
}
export class $ShortUnaryOperator$$Static implements $ShortUnaryOperator {


/**
 * 
 * @deprecated
 */
 "apply"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: short): short
 "apply"(arg0: short): short
static "identity"(): $ShortUnaryOperator
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
static "negation"(): $ShortUnaryOperator
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "compose"<V>(arg0: $Function$$Type<(V), (short)>): $Function<(V), (short)>
 "andThen"<V>(arg0: $Function$$Type<(short), (V)>): $Function<(short), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortUnaryOperator$$Type = ((arg0: short) => short);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortUnaryOperator_ = $ShortUnaryOperator$$Type;
}}
declare module "it.unimi.dsi.fastutil.bytes.Byte2LongFunction" {
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$IntToLongFunction, $IntToLongFunction$$Type} from "java.util.function.IntToLongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Byte2LongFunction extends $Function<(byte), (long)>, $IntToLongFunction {

 "remove"(arg0: byte): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: long): long
 "put"(arg0: byte, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: byte, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): long

(arg0: byte): long
}

export namespace $Byte2LongFunction {
function identity<T>(): $Function$0<(byte), (byte)>
const probejs$$marker: never
}
export class $Byte2LongFunction$$Static implements $Byte2LongFunction {


 "remove"(arg0: byte): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: long): long
 "put"(arg0: byte, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: byte, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): long
static "identity"<T>(): $Function$0<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2LongFunction$$Type = ((arg0: byte) => long);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2LongFunction_ = $Byte2LongFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.Hash" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Hash {

}

export namespace $Hash {
const DEFAULT_INITIAL_SIZE: integer
const DEFAULT_LOAD_FACTOR: float
const FAST_LOAD_FACTOR: float
const VERY_FAST_LOAD_FACTOR: float
const DEFAULT_GROWTH_FACTOR: integer
const FREE: byte
const OCCUPIED: byte
const REMOVED: byte
const PRIMES: (integer)[]
const probejs$$marker: never
}
export class $Hash$$Static implements $Hash {
static readonly "DEFAULT_INITIAL_SIZE": integer
static readonly "DEFAULT_LOAD_FACTOR": float
static readonly "FAST_LOAD_FACTOR": float
static readonly "VERY_FAST_LOAD_FACTOR": float
/**
 * 
 * @deprecated
 */
static readonly "DEFAULT_GROWTH_FACTOR": integer
/**
 * 
 * @deprecated
 */
static readonly "FREE": byte
/**
 * 
 * @deprecated
 */
static readonly "OCCUPIED": byte
/**
 * 
 * @deprecated
 */
static readonly "REMOVED": byte
/**
 * 
 * @deprecated
 */
static readonly "PRIMES": (integer)[]


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Hash$$Type = ($Hash);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Hash_ = $Hash$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.ShortIterable" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$IntIterator, $IntIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntIterator"
import {$ShortConsumer, $ShortConsumer$$Type} from "it.unimi.dsi.fastutil.shorts.ShortConsumer"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$IntConsumer, $IntConsumer$$Type} from "java.util.function.IntConsumer"
import {$IntSpliterator, $IntSpliterator$$Type} from "it.unimi.dsi.fastutil.ints.IntSpliterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ShortIterable extends $Iterable<(short)> {

 "iterator"(): $Iterator<(any)>
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $ShortConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(short)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
 "intIterator"(): $IntIterator
 "intSpliterator"(): $IntSpliterator
[Symbol.iterator](): IterableIterator<any>;
}

export namespace $ShortIterable {
const probejs$$marker: never
}
export class $ShortIterable$$Static implements $ShortIterable {


 "iterator"(): $Iterator<(any)>
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $ShortConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(short)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
 "intIterator"(): $IntIterator
 "intSpliterator"(): $IntSpliterator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortIterable$$Type = ($ShortIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortIterable_ = $ShortIterable$$Type;
}}
declare module "it.unimi.dsi.fastutil.doubles.Double2CharFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$DoubleToIntFunction, $DoubleToIntFunction$$Type} from "java.util.function.DoubleToIntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Double2CharFunction extends $Function<(double), (character)>, $DoubleToIntFunction {

 "remove"(arg0: double): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: character): character
 "put"(arg0: double, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: double, arg1: character): character
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): character

(arg0: double): character
}

export namespace $Double2CharFunction {
function identity<T>(): $Function$0<(double), (double)>
const probejs$$marker: never
}
export class $Double2CharFunction$$Static implements $Double2CharFunction {


 "remove"(arg0: double): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: character): character
 "put"(arg0: double, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: double, arg1: character): character
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): character
static "identity"<T>(): $Function$0<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2CharFunction$$Type = ((arg0: double) => character);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2CharFunction_ = $Double2CharFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.doubles.Double2ByteFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$DoubleToIntFunction, $DoubleToIntFunction$$Type} from "java.util.function.DoubleToIntFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Double2ByteFunction extends $Function<(double), (byte)>, $DoubleToIntFunction {

 "remove"(arg0: double): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: byte): byte
 "put"(arg0: double, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: double, arg1: byte): byte
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): byte

(arg0: double): byte
}

export namespace $Double2ByteFunction {
function identity<T>(): $Function$0<(double), (double)>
const probejs$$marker: never
}
export class $Double2ByteFunction$$Static implements $Double2ByteFunction {


 "remove"(arg0: double): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: byte): byte
 "put"(arg0: double, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: double, arg1: byte): byte
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): byte
static "identity"<T>(): $Function$0<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2ByteFunction$$Type = ((arg0: double) => byte);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2ByteFunction_ = $Double2ByteFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2ObjectMap" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Reference2ObjectMap$Entry, $Reference2ObjectMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectMap$Entry"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Reference2ObjectMap<K, V> extends $Reference2ObjectFunction<(K), (V)>, $Map<(K), (V)> {

 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "size"(): integer
 "put"(arg0: K, arg1: V): V
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: V): V
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(K), (V)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Reference2ObjectFunction$$Type<(K), (V)>): V
 "keySet"(): $Set<(any)>
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
/**
 * 
 * @deprecated
 */
 "computeObjectIfAbsentPartial"(arg0: K, arg1: $Reference2ObjectFunction$$Type<(K), (V)>): V
 "reference2ObjectEntrySet"(): $ObjectSet<($Reference2ObjectMap$Entry<(K), (V)>)>
 "get"(arg0: any): V
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Reference2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2ObjectFunction<(V)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (V), (V)>): void
 "putAll"(arg0: $Map$$Type<(K), (V)>): void
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (V)>): V
 "containsValue"(arg0: any): boolean
 "apply"(arg0: K): V
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(K), (V)>
[index: string | number]: V
get "empty"(): boolean
}

export namespace $Reference2ObjectMap {
function copyOf<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
function of<K, V>(): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
function entry<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
function identity<T>(): $Function<(K), (K)>
const probejs$$marker: never
}
export class $Reference2ObjectMap$$Static<K, V> implements $Reference2ObjectMap {


 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "size"(): integer
 "put"(arg0: K, arg1: V): V
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: V): V
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(K), (V)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Reference2ObjectFunction$$Type<(K), (V)>): V
 "keySet"(): $Set<(any)>
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
/**
 * 
 * @deprecated
 */
 "computeObjectIfAbsentPartial"(arg0: K, arg1: $Reference2ObjectFunction$$Type<(K), (V)>): V
 "reference2ObjectEntrySet"(): $ObjectSet<($Reference2ObjectMap$Entry<(K), (V)>)>
 "get"(arg0: any): V
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Reference2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2ObjectFunction<(V)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (V), (V)>): void
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
static "of"<K, V>(): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
 "putAll"(arg0: $Map$$Type<(K), (V)>): void
static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (V)>): V
 "containsValue"(arg0: any): boolean
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
 "apply"(arg0: K): V
static "identity"<T>(): $Function<(K), (K)>
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ObjectMap$$Type<K, V> = ($Reference2ObjectMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ObjectMap_<K, V> = $Reference2ObjectMap$$Type<(K), (V)>;
}}
declare module "it.unimi.dsi.fastutil.longs.Long2BooleanFunction" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$LongPredicate, $LongPredicate$$Type} from "java.util.function.LongPredicate"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Long2BooleanFunction extends $Function<(long), (boolean)>, $LongPredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: long, arg1: boolean): boolean
 "test"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
 "getOrDefault"(arg0: long, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): boolean
 "or"(arg0: $LongPredicate$$Type): $LongPredicate
 "negate"(): $LongPredicate
 "and"(arg0: $LongPredicate$$Type): $LongPredicate

(arg0: long): boolean
}

export namespace $Long2BooleanFunction {
function identity<T>(): $Function$0<(long), (long)>
const probejs$$marker: never
}
export class $Long2BooleanFunction$$Static implements $Long2BooleanFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: long, arg1: boolean): boolean
 "test"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
 "getOrDefault"(arg0: long, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): boolean
 "or"(arg0: $LongPredicate$$Type): $LongPredicate
 "negate"(): $LongPredicate
 "and"(arg0: $LongPredicate$$Type): $LongPredicate
static "identity"<T>(): $Function$0<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2BooleanFunction$$Type = ((arg0: long) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2BooleanFunction_ = $Long2BooleanFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.IntIterable" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$IntIterator, $IntIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntIterator"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$$Type as $IntConsumer$0$$Type} from "java.util.function.IntConsumer"
import {$IntSpliterator, $IntSpliterator$$Type} from "it.unimi.dsi.fastutil.ints.IntSpliterator"
import {$IntConsumer, $IntConsumer$$Type} from "it.unimi.dsi.fastutil.ints.IntConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $IntIterable extends $Iterable<(integer)> {

 "iterator"(): $Iterator<(any)>
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $IntConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(integer)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
 "intIterator"(): $IntIterator
 "intSpliterator"(): $IntSpliterator
[Symbol.iterator](): IterableIterator<any>;
}

export namespace $IntIterable {
const probejs$$marker: never
}
export class $IntIterable$$Static implements $IntIterable {


 "iterator"(): $Iterator<(any)>
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $IntConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(integer)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
 "intIterator"(): $IntIterator
 "intSpliterator"(): $IntSpliterator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntIterable$$Type = ($IntIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntIterable_ = $IntIterable$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.Short2BooleanMap" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$IntPredicate, $IntPredicate$$Type} from "java.util.function.IntPredicate"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$BooleanCollection, $BooleanCollection$$Type} from "it.unimi.dsi.fastutil.booleans.BooleanCollection"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Short2BooleanMap$Entry, $Short2BooleanMap$Entry$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanMap$Entry"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Short2BooleanMap extends $Short2BooleanFunction, $Map<(short), (boolean)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
 "remove"(arg0: short, arg1: boolean): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: boolean): boolean
 "values"(): $BooleanCollection
 "clear"(): void
 "replace"(arg0: short, arg1: boolean, arg2: boolean): boolean
 "replace"(arg0: short, arg1: boolean): boolean
 "merge"(arg0: short, arg1: boolean, arg2: $BiFunction$$Type<(boolean), (boolean), (boolean)>): boolean
/**
 * 
 * @deprecated
 */
 "entrySet"(): $Set<(any)>
 "putIfAbsent"(arg0: short, arg1: boolean): boolean
 "compute"(arg0: short, arg1: $BiFunction$$Type<(short), (boolean), (boolean)>): boolean
 "forEach"(arg0: $BiConsumer$$Type<(short), (boolean)>): void
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: short, arg1: $IntPredicate$$Type): boolean
 "computeIfAbsent"(arg0: short, arg1: $Short2BooleanFunction$$Type): boolean
 "keySet"(): $Set<(any)>
 "containsValue"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "getOrDefault"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "computeIfPresent"(arg0: short, arg1: $BiFunction$$Type<(short), (boolean), (boolean)>): boolean
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "short2BooleanEntrySet"(): $ObjectSet<($Short2BooleanMap$Entry)>
 "computeIfAbsentNullable"(arg0: short, arg1: $IntFunction$$Type<(boolean)>): boolean
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: short, arg1: $Short2BooleanFunction$$Type): boolean
 "remove"(arg0: short): boolean
 "get"(arg0: short): boolean
 "put"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (short)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(boolean), (T)>): $Function<(short), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2BooleanFunction
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: short, arg1: boolean, arg2: boolean): boolean
 "replace"(arg0: short, arg1: boolean): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(short), (boolean), (boolean)>): void
 "merge"(arg0: short, arg1: boolean, arg2: $BiFunction$$Type<(boolean), (boolean), (boolean)>): boolean
 "putAll"(arg0: $Map$$Type<(short), (boolean)>): void
 "putIfAbsent"(arg0: short, arg1: boolean): boolean
 "compute"(arg0: short, arg1: $BiFunction$$Type<(short), (boolean), (boolean)>): boolean
 "computeIfAbsent"(arg0: short, arg1: $Function$$Type<(short), (boolean)>): boolean
 "computeIfPresent"(arg0: short, arg1: $BiFunction$$Type<(short), (boolean), (boolean)>): boolean
 "apply"(arg0: short): boolean
 "or"(arg0: $IntPredicate$$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$$Type): $IntPredicate
[index: string | number]: any
get "empty"(): boolean
}

export namespace $Short2BooleanMap {
function copyOf<K, V>(arg0: $Map$$Type<(short), (boolean)>): $Map<(short), (boolean)>
function of<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean): $Map<(short), (boolean)>
function of<K, V>(): $Map<(short), (boolean)>
function of<K, V>(arg0: short, arg1: boolean): $Map<(short), (boolean)>
function of<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean): $Map<(short), (boolean)>
function of<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean): $Map<(short), (boolean)>
function of<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean, arg8: short, arg9: boolean, arg10: short, arg11: boolean, arg12: short, arg13: boolean, arg14: short, arg15: boolean, arg16: short, arg17: boolean, arg18: short, arg19: boolean): $Map<(short), (boolean)>
function of<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean, arg8: short, arg9: boolean, arg10: short, arg11: boolean, arg12: short, arg13: boolean, arg14: short, arg15: boolean, arg16: short, arg17: boolean): $Map<(short), (boolean)>
function of<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean, arg8: short, arg9: boolean, arg10: short, arg11: boolean, arg12: short, arg13: boolean, arg14: short, arg15: boolean): $Map<(short), (boolean)>
function of<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean, arg8: short, arg9: boolean, arg10: short, arg11: boolean, arg12: short, arg13: boolean): $Map<(short), (boolean)>
function of<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean, arg8: short, arg9: boolean, arg10: short, arg11: boolean): $Map<(short), (boolean)>
function of<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean, arg8: short, arg9: boolean): $Map<(short), (boolean)>
function entry<K, V>(arg0: short, arg1: boolean): $Map$Entry<(short), (boolean)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(short), (boolean)>)[]): $Map<(short), (boolean)>
function identity<T>(): $Function<(short), (short)>
const probejs$$marker: never
}
export class $Short2BooleanMap$$Static implements $Short2BooleanMap {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
 "remove"(arg0: short, arg1: boolean): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: boolean): boolean
 "values"(): $BooleanCollection
 "clear"(): void
 "replace"(arg0: short, arg1: boolean, arg2: boolean): boolean
 "replace"(arg0: short, arg1: boolean): boolean
 "merge"(arg0: short, arg1: boolean, arg2: $BiFunction$$Type<(boolean), (boolean), (boolean)>): boolean
/**
 * 
 * @deprecated
 */
 "entrySet"(): $Set<(any)>
 "putIfAbsent"(arg0: short, arg1: boolean): boolean
 "compute"(arg0: short, arg1: $BiFunction$$Type<(short), (boolean), (boolean)>): boolean
 "forEach"(arg0: $BiConsumer$$Type<(short), (boolean)>): void
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: short, arg1: $IntPredicate$$Type): boolean
 "computeIfAbsent"(arg0: short, arg1: $Short2BooleanFunction$$Type): boolean
 "keySet"(): $Set<(any)>
 "containsValue"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "getOrDefault"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "computeIfPresent"(arg0: short, arg1: $BiFunction$$Type<(short), (boolean), (boolean)>): boolean
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "short2BooleanEntrySet"(): $ObjectSet<($Short2BooleanMap$Entry)>
 "computeIfAbsentNullable"(arg0: short, arg1: $IntFunction$$Type<(boolean)>): boolean
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: short, arg1: $Short2BooleanFunction$$Type): boolean
 "remove"(arg0: short): boolean
 "get"(arg0: short): boolean
 "put"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (short)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(boolean), (T)>): $Function<(short), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2BooleanFunction
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(short), (boolean)>): $Map<(short), (boolean)>
 "isEmpty"(): boolean
 "replace"(arg0: short, arg1: boolean, arg2: boolean): boolean
 "replace"(arg0: short, arg1: boolean): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(short), (boolean), (boolean)>): void
static "of"<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean): $Map<(short), (boolean)>
static "of"<K, V>(): $Map<(short), (boolean)>
static "of"<K, V>(arg0: short, arg1: boolean): $Map<(short), (boolean)>
static "of"<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean): $Map<(short), (boolean)>
static "of"<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean): $Map<(short), (boolean)>
static "of"<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean, arg8: short, arg9: boolean, arg10: short, arg11: boolean, arg12: short, arg13: boolean, arg14: short, arg15: boolean, arg16: short, arg17: boolean, arg18: short, arg19: boolean): $Map<(short), (boolean)>
static "of"<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean, arg8: short, arg9: boolean, arg10: short, arg11: boolean, arg12: short, arg13: boolean, arg14: short, arg15: boolean, arg16: short, arg17: boolean): $Map<(short), (boolean)>
static "of"<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean, arg8: short, arg9: boolean, arg10: short, arg11: boolean, arg12: short, arg13: boolean, arg14: short, arg15: boolean): $Map<(short), (boolean)>
static "of"<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean, arg8: short, arg9: boolean, arg10: short, arg11: boolean, arg12: short, arg13: boolean): $Map<(short), (boolean)>
static "of"<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean, arg8: short, arg9: boolean, arg10: short, arg11: boolean): $Map<(short), (boolean)>
static "of"<K, V>(arg0: short, arg1: boolean, arg2: short, arg3: boolean, arg4: short, arg5: boolean, arg6: short, arg7: boolean, arg8: short, arg9: boolean): $Map<(short), (boolean)>
 "merge"(arg0: short, arg1: boolean, arg2: $BiFunction$$Type<(boolean), (boolean), (boolean)>): boolean
 "putAll"(arg0: $Map$$Type<(short), (boolean)>): void
 "putIfAbsent"(arg0: short, arg1: boolean): boolean
 "compute"(arg0: short, arg1: $BiFunction$$Type<(short), (boolean), (boolean)>): boolean
static "entry"<K, V>(arg0: short, arg1: boolean): $Map$Entry<(short), (boolean)>
 "computeIfAbsent"(arg0: short, arg1: $Function$$Type<(short), (boolean)>): boolean
 "computeIfPresent"(arg0: short, arg1: $BiFunction$$Type<(short), (boolean), (boolean)>): boolean
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(short), (boolean)>)[]): $Map<(short), (boolean)>
 "apply"(arg0: short): boolean
 "or"(arg0: $IntPredicate$$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$$Type): $IntPredicate
static "identity"<T>(): $Function<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2BooleanMap$$Type = ($Short2BooleanMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2BooleanMap_ = $Short2BooleanMap$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.LongListIterator" {
import {$ListIterator, $ListIterator$$Type} from "java.util.ListIterator"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$$Type as $LongConsumer$0$$Type} from "java.util.function.LongConsumer"
import {$LongBidirectionalIterator, $LongBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.longs.LongBidirectionalIterator"
import {$LongConsumer, $LongConsumer$$Type} from "it.unimi.dsi.fastutil.longs.LongConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $LongListIterator extends $LongBidirectionalIterator, $ListIterator<(long)> {

 "remove"(): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): void
 "add"(arg0: long): void
/**
 * 
 * @deprecated
 */
 "next"(): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: long): void
 "set"(arg0: long): void
/**
 * 
 * @deprecated
 */
 "previous"(): any
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousLong"(): long
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(long)>): void
 "forEachRemaining"(arg0: $LongConsumer$$Type): void
 "nextLong"(): long
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $LongConsumer$0$$Type): void
}

export namespace $LongListIterator {
const probejs$$marker: never
}
export class $LongListIterator$$Static implements $LongListIterator {


 "remove"(): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): void
 "add"(arg0: long): void
/**
 * 
 * @deprecated
 */
 "next"(): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: long): void
 "set"(arg0: long): void
/**
 * 
 * @deprecated
 */
 "previous"(): any
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousLong"(): long
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(long)>): void
 "forEachRemaining"(arg0: $LongConsumer$$Type): void
 "nextLong"(): long
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $LongConsumer$0$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongListIterator$$Type = ($LongListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongListIterator_ = $LongListIterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.doubles.DoubleCollection" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$DoubleIterable, $DoubleIterable$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleIterable"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$DoubleIterator, $DoubleIterator$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleIterator"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$$Type as $DoubleConsumer$0$$Type} from "java.util.function.DoubleConsumer"
import {$DoublePredicate as $DoublePredicate$0, $DoublePredicate$$Type as $DoublePredicate$0$$Type} from "it.unimi.dsi.fastutil.doubles.DoublePredicate"
import {$DoubleSpliterator, $DoubleSpliterator$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleSpliterator"
import {$DoubleConsumer, $DoubleConsumer$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleConsumer"
import {$DoubleStream, $DoubleStream$$Type} from "java.util.stream.DoubleStream"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$DoublePredicate, $DoublePredicate$$Type} from "java.util.function.DoublePredicate"

export interface $DoubleCollection extends $Collection<(double)>, $DoubleIterable {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "add"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: double): boolean
 "toArray"(arg0: (double)[]): (double)[]
 "iterator"(): $DoubleIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(double)>
 "contains"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: $DoubleCollection$$Type): boolean
 "removeIf"(arg0: $DoublePredicate$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(double)>): boolean
 "removeIf"(arg0: $DoublePredicate$0$$Type): boolean
 "removeAll"(arg0: $DoubleCollection$$Type): boolean
 "retainAll"(arg0: $DoubleCollection$$Type): boolean
 "containsAll"(arg0: $DoubleCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(double)>
 "rem"(arg0: double): boolean
 "doubleStream"(): $DoubleStream
/**
 * 
 * @deprecated
 */
 "toDoubleArray"(arg0: (double)[]): (double)[]
 "toDoubleArray"(): (double)[]
 "doubleIterator"(): $DoubleIterator
 "doubleSpliterator"(): $DoubleSpliterator
 "doubleParallelStream"(): $DoubleStream
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$$Type<(double)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "forEach"(arg0: $DoubleConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(double)>): void
 "forEach"(arg0: $DoubleConsumer$$Type): void
get "empty"(): boolean
}

export namespace $DoubleCollection {
const probejs$$marker: never
}
export class $DoubleCollection$$Static implements $DoubleCollection {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "add"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: double): boolean
 "toArray"(arg0: (double)[]): (double)[]
 "iterator"(): $DoubleIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(double)>
 "contains"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: $DoubleCollection$$Type): boolean
 "removeIf"(arg0: $DoublePredicate$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(double)>): boolean
 "removeIf"(arg0: $DoublePredicate$0$$Type): boolean
 "removeAll"(arg0: $DoubleCollection$$Type): boolean
 "retainAll"(arg0: $DoubleCollection$$Type): boolean
 "containsAll"(arg0: $DoubleCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(double)>
 "rem"(arg0: double): boolean
 "doubleStream"(): $DoubleStream
/**
 * 
 * @deprecated
 */
 "toDoubleArray"(arg0: (double)[]): (double)[]
 "toDoubleArray"(): (double)[]
 "doubleIterator"(): $DoubleIterator
 "doubleSpliterator"(): $DoubleSpliterator
 "doubleParallelStream"(): $DoubleStream
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$$Type<(double)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "forEach"(arg0: $DoubleConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(double)>): void
 "forEach"(arg0: $DoubleConsumer$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleCollection$$Type = ($DoubleCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleCollection_ = $DoubleCollection$$Type;
}}
declare module "it.unimi.dsi.fastutil.floats.Float2ObjectFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$DoubleFunction, $DoubleFunction$$Type} from "java.util.function.DoubleFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Float2ObjectFunction<V> extends $Function<(float), (V)>, $DoubleFunction<(V)> {

 "remove"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Float2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Float2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(float), (V)>

(arg0: float): V
}

export namespace $Float2ObjectFunction {
function identity<T>(): $Function$0<(float), (float)>
const probejs$$marker: never
}
export class $Float2ObjectFunction$$Static<V> implements $Float2ObjectFunction {


 "remove"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Float2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Float2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): V
static "identity"<T>(): $Function$0<(float), (float)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(float), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2ObjectFunction$$Type<V> = ((arg0: float) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2ObjectFunction_<V> = $Float2ObjectFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.shorts.ShortIterator" {
import {$ShortConsumer, $ShortConsumer$$Type} from "it.unimi.dsi.fastutil.shorts.ShortConsumer"
import {$IntConsumer, $IntConsumer$$Type} from "java.util.function.IntConsumer"
import {$PrimitiveIterator, $PrimitiveIterator$$Type} from "java.util.PrimitiveIterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ShortIterator extends $PrimitiveIterator<(short), ($ShortConsumer)> {

 "forEachRemaining"(arg0: $IntConsumer$$Type): void
 "forEachRemaining"(arg0: $ShortConsumer$$Type): void
 "forEachRemaining"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(short)>): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "skip"(arg0: integer): integer
 "nextShort"(): short
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $ShortIterator {
const probejs$$marker: never
}
export class $ShortIterator$$Static implements $ShortIterator {


 "forEachRemaining"(arg0: $IntConsumer$$Type): void
 "forEachRemaining"(arg0: $ShortConsumer$$Type): void
 "forEachRemaining"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(short)>): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "skip"(arg0: integer): integer
 "nextShort"(): short
 "remove"(): void
 "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortIterator$$Type = ($ShortIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortIterator_ = $ShortIterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.floats.Float2ShortFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$DoubleToIntFunction, $DoubleToIntFunction$$Type} from "java.util.function.DoubleToIntFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Float2ShortFunction extends $Function<(float), (short)>, $DoubleToIntFunction {

 "remove"(arg0: float): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: short): short
 "put"(arg0: float, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: float, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): short

(arg0: float): short
}

export namespace $Float2ShortFunction {
function identity<T>(): $Function$0<(float), (float)>
const probejs$$marker: never
}
export class $Float2ShortFunction$$Static implements $Float2ShortFunction {


 "remove"(arg0: float): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: short): short
 "put"(arg0: float, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: float, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): short
static "identity"<T>(): $Function$0<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2ShortFunction$$Type = ((arg0: float) => short);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2ShortFunction_ = $Float2ShortFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction" {
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$$Type} from "java.util.function.IntToDoubleFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Byte2FloatFunction extends $Function<(byte), (float)>, $IntToDoubleFunction {

 "remove"(arg0: byte): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: float): float
 "put"(arg0: byte, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: byte, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): float

(arg0: byte): float
}

export namespace $Byte2FloatFunction {
function identity<T>(): $Function$0<(byte), (byte)>
const probejs$$marker: never
}
export class $Byte2FloatFunction$$Static implements $Byte2FloatFunction {


 "remove"(arg0: byte): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: float): float
 "put"(arg0: byte, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: byte, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): float
static "identity"<T>(): $Function$0<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2FloatFunction$$Type = ((arg0: byte) => float);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2FloatFunction_ = $Byte2FloatFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.IntBinaryOperator" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BinaryOperator, $BinaryOperator$$Type} from "java.util.function.BinaryOperator"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$$Type as $IntBinaryOperator$0$$Type} from "java.util.function.IntBinaryOperator"

export interface $IntBinaryOperator extends $BinaryOperator<(integer)>, $IntBinaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer, arg1: integer): integer
 "apply"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer, arg1: integer): integer
 "andThen"<V>(arg0: $Function$$Type<(integer), (V)>): $BiFunction<(integer), (integer), (V)>

(arg0: integer, arg1: integer): integer
}

export namespace $IntBinaryOperator {
function minBy<T>(arg0: $Comparator$$Type<(integer)>): $BinaryOperator<(integer)>
function maxBy<T>(arg0: $Comparator$$Type<(integer)>): $BinaryOperator<(integer)>
const probejs$$marker: never
}
export class $IntBinaryOperator$$Static implements $IntBinaryOperator {


/**
 * 
 * @deprecated
 */
 "apply"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer, arg1: integer): integer
 "apply"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer, arg1: integer): integer
static "minBy"<T>(arg0: $Comparator$$Type<(integer)>): $BinaryOperator<(integer)>
static "maxBy"<T>(arg0: $Comparator$$Type<(integer)>): $BinaryOperator<(integer)>
 "andThen"<V>(arg0: $Function$$Type<(integer), (V)>): $BiFunction<(integer), (integer), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntBinaryOperator$$Type = ((arg0: integer, arg1: integer) => integer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntBinaryOperator_ = $IntBinaryOperator$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.IntList" {
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$$Type as $IntPredicate$0$$Type} from "java.util.function.IntPredicate"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$$Type as $IntConsumer$0$$Type} from "java.util.function.IntConsumer"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "it.unimi.dsi.fastutil.ints.IntUnaryOperator"
import {$IntComparator, $IntComparator$$Type} from "it.unimi.dsi.fastutil.ints.IntComparator"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$IntStream, $IntStream$$Type} from "java.util.stream.IntStream"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IntCollection, $IntCollection$$Type} from "it.unimi.dsi.fastutil.ints.IntCollection"
import {$IntSpliterator, $IntSpliterator$$Type} from "it.unimi.dsi.fastutil.ints.IntSpliterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$IntListIterator, $IntListIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntListIterator"
import {$IntUnaryOperator as $IntUnaryOperator$0, $IntUnaryOperator$$Type as $IntUnaryOperator$0$$Type} from "java.util.function.IntUnaryOperator"
import {$IntIterator, $IntIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntIterator"
import {$ListIterator, $ListIterator$$Type} from "java.util.ListIterator"
import {$IntPredicate, $IntPredicate$$Type} from "it.unimi.dsi.fastutil.ints.IntPredicate"
import {$IntConsumer, $IntConsumer$$Type} from "it.unimi.dsi.fastutil.ints.IntConsumer"

export interface $IntList extends $List<(integer)>, $Comparable<($List<(integer)>)>, $IntCollection {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: integer): any
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "size"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): any
 "indexOf"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getInt"(arg0: integer): integer
 "lastIndexOf"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "replaceAll"(arg0: $IntUnaryOperator$$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$$Type<(integer)>): void
 "replaceAll"(arg0: $IntUnaryOperator$0$$Type): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
 "add"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: any): void
 "add"(arg0: integer): boolean
 "subList"(arg0: integer, arg1: integer): $List<(any)>
 "iterator"(): $IntListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: integer, arg1: $IntCollection$$Type): boolean
 "addAll"(arg0: $IntList$$Type): boolean
 "addAll"(arg0: integer, arg1: $IntList$$Type): boolean
 "set"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: any): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: integer): integer
 "sort"(arg0: $IntComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$$Type<(integer)>): void
 "listIterator"(arg0: integer): $ListIterator<(any)>
 "listIterator"(): $ListIterator<(any)>
 "getElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
 "unstableSort"(arg0: $IntComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$$Type<(integer)>): void
 "removeInt"(arg0: integer): integer
 "setElements"(arg0: (integer)[]): void
 "setElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (integer)[]): void
 "addElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (integer)[]): void
 "removeElements"(arg0: integer, arg1: integer): void
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: $Collection$$Type<(integer)>): boolean
 "addAll"(arg0: integer, arg1: $Collection$$Type<(integer)>): boolean
 "getFirst"(): integer
 "getLast"(): integer
 "addFirst"(arg0: integer): void
 "addLast"(arg0: integer): void
 "removeFirst"(): integer
 "removeLast"(): integer
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "reversed"(): $SequencedCollection<(any)>
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "compareTo"(arg0: $List$$Type<(integer)>): integer
 "toArray"(arg0: (integer)[]): (integer)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
 "contains"(arg0: integer): boolean
 "addAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(integer)>): boolean
 "removeIf"(arg0: $IntPredicate$0$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $IntCollection$$Type): boolean
 "retainAll"(arg0: $IntCollection$$Type): boolean
 "containsAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
 "rem"(arg0: integer): boolean
 "toIntArray"(): (integer)[]
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $IntConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(integer)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
set "elements"(value: (integer)[])
get "empty"(): boolean
get "first"(): integer
get "last"(): integer
}

export namespace $IntList {
function of(...arg0: (integer)[]): $IntList
function of(): $IntList
function of(arg0: integer, arg1: integer): $IntList
function of(arg0: integer): $IntList
function of(arg0: integer, arg1: integer, arg2: integer): $IntList
function copyOf<E>(arg0: $Collection$$Type<(integer)>): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $List<(integer)>
function of<E>(arg0: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $List<(integer)>
function of<E>(...arg0: (integer)[]): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $List<(integer)>
const probejs$$marker: never
}
export class $IntList$$Static implements $IntList {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: integer): any
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "size"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): any
 "indexOf"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getInt"(arg0: integer): integer
 "lastIndexOf"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "replaceAll"(arg0: $IntUnaryOperator$$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$$Type<(integer)>): void
 "replaceAll"(arg0: $IntUnaryOperator$0$$Type): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
 "add"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: any): void
 "add"(arg0: integer): boolean
 "subList"(arg0: integer, arg1: integer): $List<(any)>
 "iterator"(): $IntListIterator
static "of"(...arg0: (integer)[]): $IntList
static "of"(): $IntList
static "of"(arg0: integer, arg1: integer): $IntList
static "of"(arg0: integer): $IntList
static "of"(arg0: integer, arg1: integer, arg2: integer): $IntList
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: integer, arg1: $IntCollection$$Type): boolean
 "addAll"(arg0: $IntList$$Type): boolean
 "addAll"(arg0: integer, arg1: $IntList$$Type): boolean
 "set"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: any): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: integer): integer
 "sort"(arg0: $IntComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$$Type<(integer)>): void
 "listIterator"(arg0: integer): $ListIterator<(any)>
 "listIterator"(): $ListIterator<(any)>
 "getElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
 "unstableSort"(arg0: $IntComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$$Type<(integer)>): void
 "removeInt"(arg0: integer): integer
 "setElements"(arg0: (integer)[]): void
 "setElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (integer)[]): void
 "addElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (integer)[]): void
 "removeElements"(arg0: integer, arg1: integer): void
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<E>(arg0: $Collection$$Type<(integer)>): $List<(integer)>
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
static "of"<E>(arg0: integer, arg1: integer, arg2: integer): $List<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $List<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $List<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $List<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $List<(integer)>
static "of"<E>(arg0: integer): $List<(integer)>
static "of"<E>(arg0: integer, arg1: integer): $List<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $List<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $List<(integer)>
static "of"<E>(...arg0: (integer)[]): $List<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $List<(integer)>
 "addAll"(arg0: $Collection$$Type<(integer)>): boolean
 "addAll"(arg0: integer, arg1: $Collection$$Type<(integer)>): boolean
 "getFirst"(): integer
 "getLast"(): integer
 "addFirst"(arg0: integer): void
 "addLast"(arg0: integer): void
 "removeFirst"(): integer
 "removeLast"(): integer
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "reversed"(): $SequencedCollection<(any)>
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "compareTo"(arg0: $List$$Type<(integer)>): integer
 "toArray"(arg0: (integer)[]): (integer)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
 "contains"(arg0: integer): boolean
 "addAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(integer)>): boolean
 "removeIf"(arg0: $IntPredicate$0$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $IntCollection$$Type): boolean
 "retainAll"(arg0: $IntCollection$$Type): boolean
 "containsAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
 "rem"(arg0: integer): boolean
 "toIntArray"(): (integer)[]
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $IntConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(integer)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntList$$Type = ($IntList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntList_ = $IntList$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.ObjectList" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ObjectCollection, $ObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.ObjectCollection"
import {$ListIterator, $ListIterator$$Type} from "java.util.ListIterator"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$ObjectListIterator, $ObjectListIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectListIterator"

export interface $ObjectList<K> extends $List<(K)>, $Comparable<($List<(K)>)>, $ObjectCollection<(K)> {

 "size"(arg0: integer): void
 "subList"(arg0: integer, arg1: integer): $ObjectList<(K)>
 "iterator"(): $Iterator<(any)>
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: $ObjectList$$Type<(K)>): boolean
 "addAll"(arg0: integer, arg1: $ObjectList$$Type<(K)>): boolean
 "sort"(arg0: $Comparator$$Type<(K)>): void
 "listIterator"(arg0: integer): $ObjectListIterator<(K)>
 "listIterator"(): $ListIterator<(any)>
 "getElements"(arg0: integer, arg1: (any)[], arg2: integer, arg3: integer): void
 "unstableSort"(arg0: $Comparator$$Type<(K)>): void
 "setElements"(arg0: integer, arg1: (K)[]): void
 "setElements"(arg0: (K)[]): void
 "setElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (K)[]): void
 "removeElements"(arg0: integer, arg1: integer): void
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): K
 "size"(): integer
 "get"(arg0: integer): K
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "indexOf"(arg0: any): integer
 "clear"(): void
 "lastIndexOf"(arg0: any): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $UnaryOperator$$Type<(K)>): void
 "add"(arg0: K): boolean
 "add"(arg0: integer, arg1: K): void
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$$Type<(K)>): boolean
 "addAll"(arg0: integer, arg1: $Collection$$Type<(K)>): boolean
 "set"(arg0: integer, arg1: K): K
 "getFirst"(): K
 "getLast"(): K
 "addFirst"(arg0: K): void
 "addLast"(arg0: K): void
 "removeFirst"(): K
 "removeLast"(): K
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "reversed"(): $SequencedCollection<(any)>
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "compareTo"(arg0: $List$$Type<(K)>): integer
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$$Type<(K)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
[Symbol.iterator](): IterableIterator<any>;
[index: number]: any
set "elements"(value: (K)[])
get "empty"(): boolean
get "first"(): K
get "last"(): K
}

export namespace $ObjectList {
function of<K>(...arg0: (K)[]): $ObjectList<(K)>
function of<K>(arg0: K, arg1: K, arg2: K): $ObjectList<(K)>
function of<K>(arg0: K, arg1: K): $ObjectList<(K)>
function of<K>(): $ObjectList<(K)>
function of<K>(arg0: K): $ObjectList<(K)>
function copyOf<E>(arg0: $Collection$$Type<(K)>): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $List<(K)>
const probejs$$marker: never
}
export class $ObjectList$$Static<K> implements $ObjectList {


 "size"(arg0: integer): void
 "subList"(arg0: integer, arg1: integer): $ObjectList<(K)>
 "iterator"(): $Iterator<(any)>
static "of"<K>(...arg0: (K)[]): $ObjectList<(K)>
static "of"<K>(arg0: K, arg1: K, arg2: K): $ObjectList<(K)>
static "of"<K>(arg0: K, arg1: K): $ObjectList<(K)>
static "of"<K>(): $ObjectList<(K)>
static "of"<K>(arg0: K): $ObjectList<(K)>
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: $ObjectList$$Type<(K)>): boolean
 "addAll"(arg0: integer, arg1: $ObjectList$$Type<(K)>): boolean
 "sort"(arg0: $Comparator$$Type<(K)>): void
 "listIterator"(arg0: integer): $ObjectListIterator<(K)>
 "listIterator"(): $ListIterator<(any)>
 "getElements"(arg0: integer, arg1: (any)[], arg2: integer, arg3: integer): void
 "unstableSort"(arg0: $Comparator$$Type<(K)>): void
 "setElements"(arg0: integer, arg1: (K)[]): void
 "setElements"(arg0: (K)[]): void
 "setElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (K)[]): void
 "removeElements"(arg0: integer, arg1: integer): void
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): K
 "size"(): integer
 "get"(arg0: integer): K
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<E>(arg0: $Collection$$Type<(K)>): $List<(K)>
 "indexOf"(arg0: any): integer
 "clear"(): void
 "lastIndexOf"(arg0: any): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $UnaryOperator$$Type<(K)>): void
 "add"(arg0: K): boolean
 "add"(arg0: integer, arg1: K): void
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K): $List<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $List<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $List<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $List<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $List<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $List<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $List<(K)>
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$$Type<(K)>): boolean
 "addAll"(arg0: integer, arg1: $Collection$$Type<(K)>): boolean
 "set"(arg0: integer, arg1: K): K
 "getFirst"(): K
 "getLast"(): K
 "addFirst"(arg0: K): void
 "addLast"(arg0: K): void
 "removeFirst"(): K
 "removeLast"(): K
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "reversed"(): $SequencedCollection<(any)>
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "compareTo"(arg0: $List$$Type<(K)>): integer
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$$Type<(K)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectList$$Type<K> = ($ObjectList<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectList_<K> = $ObjectList$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.objects.ReferenceSet" {
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$ReferenceCollection, $ReferenceCollection$$Type} from "it.unimi.dsi.fastutil.objects.ReferenceCollection"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ReferenceSet<K> extends $ReferenceCollection<(K)>, $Set<(K)> {

 "iterator"(): $Iterator<(any)>
 "spliterator"(): $Spliterator<(any)>
 "remove"(arg0: any): boolean
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "add"(arg0: K): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$$Type<(K)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$$Type<(K)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
[Symbol.iterator](): IterableIterator<any>;
get "empty"(): boolean
}

export namespace $ReferenceSet {
function of<K>(arg0: K, arg1: K): $ReferenceSet<(K)>
function of<K>(...arg0: (K)[]): $ReferenceSet<(K)>
function of<K>(arg0: K, arg1: K, arg2: K): $ReferenceSet<(K)>
function of<K>(): $ReferenceSet<(K)>
function of<K>(arg0: K): $ReferenceSet<(K)>
function copyOf<E>(arg0: $Collection$$Type<(K)>): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
const probejs$$marker: never
}
export class $ReferenceSet$$Static<K> implements $ReferenceSet {


 "iterator"(): $Iterator<(any)>
static "of"<K>(arg0: K, arg1: K): $ReferenceSet<(K)>
static "of"<K>(...arg0: (K)[]): $ReferenceSet<(K)>
static "of"<K>(arg0: K, arg1: K, arg2: K): $ReferenceSet<(K)>
static "of"<K>(): $ReferenceSet<(K)>
static "of"<K>(arg0: K): $ReferenceSet<(K)>
 "spliterator"(): $Spliterator<(any)>
 "remove"(arg0: any): boolean
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<E>(arg0: $Collection$$Type<(K)>): $Set<(K)>
 "clear"(): void
 "isEmpty"(): boolean
 "add"(arg0: K): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$$Type<(K)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$$Type<(K)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReferenceSet$$Type<K> = ($ReferenceSet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReferenceSet_<K> = $ReferenceSet$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2DoubleMap" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$DoubleBinaryOperator, $DoubleBinaryOperator$$Type} from "java.util.function.DoubleBinaryOperator"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Set, $Set$$Type} from "java.util.Set"
import {$IntToDoubleFunction, $IntToDoubleFunction$$Type} from "java.util.function.IntToDoubleFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Int2DoubleMap$Entry, $Int2DoubleMap$Entry$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleMap$Entry"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Map, $Map$$Type} from "java.util.Map"
import {$DoubleCollection, $DoubleCollection$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleCollection"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$DoubleBinaryOperator as $DoubleBinaryOperator$0, $DoubleBinaryOperator$$Type as $DoubleBinaryOperator$0$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleBinaryOperator"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Int2DoubleMap extends $Int2DoubleFunction, $Map<(integer), (double)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
 "remove"(arg0: integer, arg1: double): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: double): double
 "values"(): $DoubleCollection
 "clear"(): void
 "replace"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: double): double
 "replace"(arg0: integer, arg1: double, arg2: double): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: double, arg2: double): boolean
 "merge"(arg0: integer, arg1: double, arg2: $BiFunction$$Type<(double), (double), (double)>): double
/**
 * 
 * @deprecated
 */
 "merge"(arg0: integer, arg1: double, arg2: $BiFunction$$Type<(double), (double), (double)>): double
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(integer), (double)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: integer, arg1: double): double
 "putIfAbsent"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (double), (double)>): double
/**
 * 
 * @deprecated
 */
 "compute"(arg0: any, arg1: $BiFunction$$Type<(any), (any), (any)>): any
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (double), (double)>): double
 "forEach"(arg0: $BiConsumer$$Type<(integer), (double)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $IntToDoubleFunction$$Type): double
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: any, arg1: $Function$$Type<(any), (any)>): any
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: integer, arg1: $Function$$Type<(integer), (double)>): double
 "computeIfAbsent"(arg0: integer, arg1: $Int2DoubleFunction$$Type): double
 "keySet"(): $Set<(any)>
 "containsValue"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "getOrDefault"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (double), (double)>): double
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: any, arg1: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (double), (double)>): double
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "computeIfAbsentNullable"(arg0: integer, arg1: $IntFunction$$Type<(double)>): double
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2DoubleFunction$$Type): double
 "mergeDouble"(arg0: integer, arg1: double, arg2: $DoubleBinaryOperator$0$$Type): double
 "mergeDouble"(arg0: integer, arg1: double, arg2: $DoubleBinaryOperator$$Type): double
 "int2DoubleEntrySet"(): $ObjectSet<($Int2DoubleMap$Entry)>
 "remove"(arg0: integer): double
 "get"(arg0: integer): double
 "put"(arg0: integer, arg1: double): double
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (integer)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(double), (T)>): $Function<(integer), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2DoubleFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(integer), (double), (double)>): void
 "putAll"(arg0: $Map$$Type<(integer), (double)>): void
 "apply"(arg0: integer): double
[index: string | number]: double
get "empty"(): boolean
}

export namespace $Int2DoubleMap {
function copyOf<K, V>(arg0: $Map$$Type<(integer), (double)>): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double): $Map<(integer), (double)>
function of<K, V>(): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double, arg14: integer, arg15: double, arg16: integer, arg17: double, arg18: integer, arg19: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double, arg14: integer, arg15: double, arg16: integer, arg17: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double, arg14: integer, arg15: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double): $Map<(integer), (double)>
function entry<K, V>(arg0: integer, arg1: double): $Map$Entry<(integer), (double)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(integer), (double)>)[]): $Map<(integer), (double)>
function identity<T>(): $Function<(integer), (integer)>
const probejs$$marker: never
}
export class $Int2DoubleMap$$Static implements $Int2DoubleMap {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
 "remove"(arg0: integer, arg1: double): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: double): double
 "values"(): $DoubleCollection
 "clear"(): void
 "replace"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: double): double
 "replace"(arg0: integer, arg1: double, arg2: double): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: double, arg2: double): boolean
 "merge"(arg0: integer, arg1: double, arg2: $BiFunction$$Type<(double), (double), (double)>): double
/**
 * 
 * @deprecated
 */
 "merge"(arg0: integer, arg1: double, arg2: $BiFunction$$Type<(double), (double), (double)>): double
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(integer), (double)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: integer, arg1: double): double
 "putIfAbsent"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (double), (double)>): double
/**
 * 
 * @deprecated
 */
 "compute"(arg0: any, arg1: $BiFunction$$Type<(any), (any), (any)>): any
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (double), (double)>): double
 "forEach"(arg0: $BiConsumer$$Type<(integer), (double)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $IntToDoubleFunction$$Type): double
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: any, arg1: $Function$$Type<(any), (any)>): any
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: integer, arg1: $Function$$Type<(integer), (double)>): double
 "computeIfAbsent"(arg0: integer, arg1: $Int2DoubleFunction$$Type): double
 "keySet"(): $Set<(any)>
 "containsValue"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "getOrDefault"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (double), (double)>): double
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: any, arg1: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (double), (double)>): double
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "computeIfAbsentNullable"(arg0: integer, arg1: $IntFunction$$Type<(double)>): double
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2DoubleFunction$$Type): double
 "mergeDouble"(arg0: integer, arg1: double, arg2: $DoubleBinaryOperator$0$$Type): double
 "mergeDouble"(arg0: integer, arg1: double, arg2: $DoubleBinaryOperator$$Type): double
 "int2DoubleEntrySet"(): $ObjectSet<($Int2DoubleMap$Entry)>
 "remove"(arg0: integer): double
 "get"(arg0: integer): double
 "put"(arg0: integer, arg1: double): double
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (integer)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(double), (T)>): $Function<(integer), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2DoubleFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(integer), (double)>): $Map<(integer), (double)>
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(integer), (double), (double)>): void
static "of"<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double): $Map<(integer), (double)>
static "of"<K, V>(): $Map<(integer), (double)>
static "of"<K, V>(arg0: integer, arg1: double): $Map<(integer), (double)>
static "of"<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double): $Map<(integer), (double)>
static "of"<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double): $Map<(integer), (double)>
static "of"<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double, arg14: integer, arg15: double, arg16: integer, arg17: double, arg18: integer, arg19: double): $Map<(integer), (double)>
static "of"<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double, arg14: integer, arg15: double, arg16: integer, arg17: double): $Map<(integer), (double)>
static "of"<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double, arg14: integer, arg15: double): $Map<(integer), (double)>
static "of"<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double): $Map<(integer), (double)>
static "of"<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double): $Map<(integer), (double)>
static "of"<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double): $Map<(integer), (double)>
 "putAll"(arg0: $Map$$Type<(integer), (double)>): void
static "entry"<K, V>(arg0: integer, arg1: double): $Map$Entry<(integer), (double)>
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(integer), (double)>)[]): $Map<(integer), (double)>
 "apply"(arg0: integer): double
static "identity"<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2DoubleMap$$Type = ($Int2DoubleMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2DoubleMap_ = $Int2DoubleMap$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.ObjectSet" {
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$ObjectCollection, $ObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.ObjectCollection"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ObjectSet<K> extends $ObjectCollection<(K)>, $Set<(K)> {

 "iterator"(): $Iterator<(any)>
 "spliterator"(): $Spliterator<(any)>
 "remove"(arg0: any): boolean
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "add"(arg0: K): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$$Type<(K)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$$Type<(K)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
[Symbol.iterator](): IterableIterator<any>;
get "empty"(): boolean
}

export namespace $ObjectSet {
function of<K>(arg0: K, arg1: K): $ObjectSet<(K)>
function of<K>(...arg0: (K)[]): $ObjectSet<(K)>
function of<K>(arg0: K, arg1: K, arg2: K): $ObjectSet<(K)>
function of<K>(): $ObjectSet<(K)>
function of<K>(arg0: K): $ObjectSet<(K)>
function copyOf<E>(arg0: $Collection$$Type<(K)>): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
const probejs$$marker: never
}
export class $ObjectSet$$Static<K> implements $ObjectSet {


 "iterator"(): $Iterator<(any)>
static "of"<K>(arg0: K, arg1: K): $ObjectSet<(K)>
static "of"<K>(...arg0: (K)[]): $ObjectSet<(K)>
static "of"<K>(arg0: K, arg1: K, arg2: K): $ObjectSet<(K)>
static "of"<K>(): $ObjectSet<(K)>
static "of"<K>(arg0: K): $ObjectSet<(K)>
 "spliterator"(): $Spliterator<(any)>
 "remove"(arg0: any): boolean
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<E>(arg0: $Collection$$Type<(K)>): $Set<(K)>
 "clear"(): void
 "isEmpty"(): boolean
 "add"(arg0: K): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$$Type<(K)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$$Type<(K)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectSet$$Type<K> = ($ObjectSet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectSet_<K> = $ObjectSet$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$ToDoubleFunction, $ToDoubleFunction$$Type} from "java.util.function.ToDoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Reference2DoubleFunction<K> extends $Function<(K), (double)>, $ToDoubleFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getDouble"(arg0: any): double
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(K), (T)>
 "removeDouble"(arg0: any): double
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): double
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (double)>

(arg0: any): double
}

export namespace $Reference2DoubleFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Reference2DoubleFunction$$Static<K> implements $Reference2DoubleFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getDouble"(arg0: any): double
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(K), (T)>
 "removeDouble"(arg0: any): double
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): double
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2DoubleFunction$$Type<K> = ((arg0: any) => double);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2DoubleFunction_<K> = $Reference2DoubleFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction" {
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Byte2ByteFunction extends $Function<(byte), (byte)>, $IntUnaryOperator {

 "remove"(arg0: byte): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: byte, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: byte, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): byte
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: byte): byte
}

export namespace $Byte2ByteFunction {
function identity(): $Byte2ByteFunction
const probejs$$marker: never
}
export class $Byte2ByteFunction$$Static implements $Byte2ByteFunction {


 "remove"(arg0: byte): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: byte, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: byte): byte
static "identity"(): $Byte2ByteFunction
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: byte, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): byte
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2ByteFunction$$Type = ((arg0: byte) => byte);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2ByteFunction_ = $Byte2ByteFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2DoubleFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$$Type} from "java.util.function.IntToDoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Int2DoubleFunction extends $Function<(integer), (double)>, $IntToDoubleFunction {

 "remove"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: double): double
 "put"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: integer, arg1: double): double
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): double

(arg0: integer): double
}

export namespace $Int2DoubleFunction {
function identity<T>(): $Function$0<(integer), (integer)>
const probejs$$marker: never
}
export class $Int2DoubleFunction$$Static implements $Int2DoubleFunction {


 "remove"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: double): double
 "put"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: integer, arg1: double): double
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): double
static "identity"<T>(): $Function$0<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2DoubleFunction$$Type = ((arg0: integer) => double);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2DoubleFunction_ = $Int2DoubleFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.Function" {
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"

export interface $Function<K, V> extends $Function$0<(K), (V)> {

 "remove"(arg0: any): V
 "size"(): integer
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "clear"(): void
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: any, arg1: V): V
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(K), (V)>

(arg0: any): V
}

export namespace $Function {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Function$$Static<K, V> implements $Function {


 "remove"(arg0: any): V
 "size"(): integer
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "clear"(): void
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: any, arg1: V): V
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function$$Type<K, V> = ((arg0: any) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function_<K, V> = $Function$$Type<(K), (V)>;
}}
declare module "it.unimi.dsi.fastutil.longs.LongBinaryOperator" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$LongBinaryOperator as $LongBinaryOperator$0, $LongBinaryOperator$$Type as $LongBinaryOperator$0$$Type} from "java.util.function.LongBinaryOperator"
import {$BinaryOperator, $BinaryOperator$$Type} from "java.util.function.BinaryOperator"

export interface $LongBinaryOperator extends $BinaryOperator<(long)>, $LongBinaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: long, arg1: long): long
 "apply"(arg0: long, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: long, arg1: long): long
 "andThen"<V>(arg0: $Function$$Type<(long), (V)>): $BiFunction<(long), (long), (V)>

(arg0: long, arg1: long): long
}

export namespace $LongBinaryOperator {
function minBy<T>(arg0: $Comparator$$Type<(long)>): $BinaryOperator<(long)>
function maxBy<T>(arg0: $Comparator$$Type<(long)>): $BinaryOperator<(long)>
const probejs$$marker: never
}
export class $LongBinaryOperator$$Static implements $LongBinaryOperator {


/**
 * 
 * @deprecated
 */
 "apply"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: long, arg1: long): long
 "apply"(arg0: long, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: long, arg1: long): long
static "minBy"<T>(arg0: $Comparator$$Type<(long)>): $BinaryOperator<(long)>
static "maxBy"<T>(arg0: $Comparator$$Type<(long)>): $BinaryOperator<(long)>
 "andThen"<V>(arg0: $Function$$Type<(long), (V)>): $BiFunction<(long), (long), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongBinaryOperator$$Type = ((arg0: long, arg1: long) => long);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongBinaryOperator_ = $LongBinaryOperator$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.LongList" {
import {$LongPredicate as $LongPredicate$0, $LongPredicate$$Type as $LongPredicate$0$$Type} from "java.util.function.LongPredicate"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$LongComparator, $LongComparator$$Type} from "it.unimi.dsi.fastutil.longs.LongComparator"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$LongPredicate, $LongPredicate$$Type} from "it.unimi.dsi.fastutil.longs.LongPredicate"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$$Type as $LongConsumer$0$$Type} from "java.util.function.LongConsumer"
import {$LongSpliterator, $LongSpliterator$$Type} from "it.unimi.dsi.fastutil.longs.LongSpliterator"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$LongCollection, $LongCollection$$Type} from "it.unimi.dsi.fastutil.longs.LongCollection"
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$LongStream, $LongStream$$Type} from "java.util.stream.LongStream"
import {$LongUnaryOperator, $LongUnaryOperator$$Type} from "it.unimi.dsi.fastutil.longs.LongUnaryOperator"
import {$LongUnaryOperator as $LongUnaryOperator$0, $LongUnaryOperator$$Type as $LongUnaryOperator$0$$Type} from "java.util.function.LongUnaryOperator"
import {$LongConsumer, $LongConsumer$$Type} from "it.unimi.dsi.fastutil.longs.LongConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$LongListIterator, $LongListIterator$$Type} from "it.unimi.dsi.fastutil.longs.LongListIterator"
import {$ListIterator, $ListIterator$$Type} from "java.util.ListIterator"
import {$LongIterator, $LongIterator$$Type} from "it.unimi.dsi.fastutil.longs.LongIterator"

export interface $LongList extends $List<(long)>, $Comparable<($List<(long)>)>, $LongCollection {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: integer): any
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "size"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): any
 "indexOf"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getLong"(arg0: integer): long
 "lastIndexOf"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "replaceAll"(arg0: $LongUnaryOperator$$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$$Type<(long)>): void
 "replaceAll"(arg0: $LongUnaryOperator$0$$Type): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
 "add"(arg0: integer, arg1: long): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: long): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: any): void
 "add"(arg0: long): boolean
 "subList"(arg0: integer, arg1: integer): $List<(any)>
 "iterator"(): $LongListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: integer, arg1: $LongCollection$$Type): boolean
 "addAll"(arg0: $LongList$$Type): boolean
 "addAll"(arg0: integer, arg1: $LongList$$Type): boolean
 "set"(arg0: integer, arg1: long): long
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: any): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: long): long
 "sort"(arg0: $LongComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$$Type<(long)>): void
 "listIterator"(arg0: integer): $ListIterator<(any)>
 "listIterator"(): $ListIterator<(any)>
 "getElements"(arg0: integer, arg1: (long)[], arg2: integer, arg3: integer): void
 "unstableSort"(arg0: $LongComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$$Type<(long)>): void
 "removeLong"(arg0: integer): long
 "setElements"(arg0: (long)[]): void
 "setElements"(arg0: integer, arg1: (long)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (long)[]): void
 "addElements"(arg0: integer, arg1: (long)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (long)[]): void
 "removeElements"(arg0: integer, arg1: integer): void
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: $Collection$$Type<(long)>): boolean
 "addAll"(arg0: integer, arg1: $Collection$$Type<(long)>): boolean
 "getFirst"(): long
 "getLast"(): long
 "addFirst"(arg0: long): void
 "addLast"(arg0: long): void
 "removeFirst"(): long
 "removeLast"(): long
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "reversed"(): $SequencedCollection<(any)>
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "compareTo"(arg0: $List$$Type<(long)>): integer
 "toArray"(arg0: (long)[]): (long)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
 "addAll"(arg0: $LongCollection$$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(long)>): boolean
 "removeIf"(arg0: $LongPredicate$$Type): boolean
 "removeAll"(arg0: $LongCollection$$Type): boolean
 "retainAll"(arg0: $LongCollection$$Type): boolean
 "containsAll"(arg0: $LongCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "rem"(arg0: long): boolean
 "longStream"(): $LongStream
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "toLongArray"(): (long)[]
 "longIterator"(): $LongIterator
 "longParallelStream"(): $LongStream
 "longSpliterator"(): $LongSpliterator
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $LongConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(long)>): void
 "forEach"(arg0: $LongConsumer$$Type): void
set "elements"(value: (long)[])
get "empty"(): boolean
get "first"(): long
get "last"(): long
}

export namespace $LongList {
function of(...arg0: (long)[]): $LongList
function of(): $LongList
function of(arg0: long, arg1: long): $LongList
function of(arg0: long): $LongList
function of(arg0: long, arg1: long, arg2: long): $LongList
function copyOf<E>(arg0: $Collection$$Type<(long)>): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $List<(long)>
function of<E>(arg0: long): $List<(long)>
function of<E>(arg0: long, arg1: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $List<(long)>
function of<E>(...arg0: (long)[]): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $List<(long)>
const probejs$$marker: never
}
export class $LongList$$Static implements $LongList {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: integer): any
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "size"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): any
 "indexOf"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getLong"(arg0: integer): long
 "lastIndexOf"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "replaceAll"(arg0: $LongUnaryOperator$$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$$Type<(long)>): void
 "replaceAll"(arg0: $LongUnaryOperator$0$$Type): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
 "add"(arg0: integer, arg1: long): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: long): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: any): void
 "add"(arg0: long): boolean
 "subList"(arg0: integer, arg1: integer): $List<(any)>
 "iterator"(): $LongListIterator
static "of"(...arg0: (long)[]): $LongList
static "of"(): $LongList
static "of"(arg0: long, arg1: long): $LongList
static "of"(arg0: long): $LongList
static "of"(arg0: long, arg1: long, arg2: long): $LongList
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: integer, arg1: $LongCollection$$Type): boolean
 "addAll"(arg0: $LongList$$Type): boolean
 "addAll"(arg0: integer, arg1: $LongList$$Type): boolean
 "set"(arg0: integer, arg1: long): long
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: any): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: long): long
 "sort"(arg0: $LongComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$$Type<(long)>): void
 "listIterator"(arg0: integer): $ListIterator<(any)>
 "listIterator"(): $ListIterator<(any)>
 "getElements"(arg0: integer, arg1: (long)[], arg2: integer, arg3: integer): void
 "unstableSort"(arg0: $LongComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$$Type<(long)>): void
 "removeLong"(arg0: integer): long
 "setElements"(arg0: (long)[]): void
 "setElements"(arg0: integer, arg1: (long)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (long)[]): void
 "addElements"(arg0: integer, arg1: (long)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (long)[]): void
 "removeElements"(arg0: integer, arg1: integer): void
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<E>(arg0: $Collection$$Type<(long)>): $List<(long)>
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
static "of"<E>(arg0: long, arg1: long, arg2: long): $List<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long): $List<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $List<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $List<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $List<(long)>
static "of"<E>(arg0: long): $List<(long)>
static "of"<E>(arg0: long, arg1: long): $List<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $List<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $List<(long)>
static "of"<E>(...arg0: (long)[]): $List<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $List<(long)>
 "addAll"(arg0: $Collection$$Type<(long)>): boolean
 "addAll"(arg0: integer, arg1: $Collection$$Type<(long)>): boolean
 "getFirst"(): long
 "getLast"(): long
 "addFirst"(arg0: long): void
 "addLast"(arg0: long): void
 "removeFirst"(): long
 "removeLast"(): long
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "reversed"(): $SequencedCollection<(any)>
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "compareTo"(arg0: $List$$Type<(long)>): integer
 "toArray"(arg0: (long)[]): (long)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
 "addAll"(arg0: $LongCollection$$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(long)>): boolean
 "removeIf"(arg0: $LongPredicate$$Type): boolean
 "removeAll"(arg0: $LongCollection$$Type): boolean
 "retainAll"(arg0: $LongCollection$$Type): boolean
 "containsAll"(arg0: $LongCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "rem"(arg0: long): boolean
 "longStream"(): $LongStream
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "toLongArray"(): (long)[]
 "longIterator"(): $LongIterator
 "longParallelStream"(): $LongStream
 "longSpliterator"(): $LongSpliterator
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $LongConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(long)>): void
 "forEach"(arg0: $LongConsumer$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongList$$Type = ($LongList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongList_ = $LongList$$Type;
}}
declare module "it.unimi.dsi.fastutil.doubles.DoubleList" {
import {$DoubleUnaryOperator, $DoubleUnaryOperator$$Type} from "java.util.function.DoubleUnaryOperator"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$DoubleIterator, $DoubleIterator$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleIterator"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$DoublePredicate as $DoublePredicate$0, $DoublePredicate$$Type as $DoublePredicate$0$$Type} from "it.unimi.dsi.fastutil.doubles.DoublePredicate"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$DoubleUnaryOperator as $DoubleUnaryOperator$0, $DoubleUnaryOperator$$Type as $DoubleUnaryOperator$0$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleUnaryOperator"
import {$DoublePredicate, $DoublePredicate$$Type} from "java.util.function.DoublePredicate"
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$DoubleComparator, $DoubleComparator$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleComparator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$DoubleCollection, $DoubleCollection$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleCollection"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$DoubleListIterator, $DoubleListIterator$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleListIterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$DoubleConsumer, $DoubleConsumer$$Type} from "java.util.function.DoubleConsumer"
import {$ListIterator, $ListIterator$$Type} from "java.util.ListIterator"
import {$DoubleSpliterator, $DoubleSpliterator$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleSpliterator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$$Type as $DoubleConsumer$0$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleConsumer"
import {$DoubleStream, $DoubleStream$$Type} from "java.util.stream.DoubleStream"

export interface $DoubleList extends $List<(double)>, $Comparable<($List<(double)>)>, $DoubleCollection {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: integer): any
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "size"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): any
 "indexOf"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getDouble"(arg0: integer): double
 "lastIndexOf"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "replaceAll"(arg0: $DoubleUnaryOperator$0$$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$$Type<(double)>): void
 "replaceAll"(arg0: $DoubleUnaryOperator$$Type): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: double): boolean
 "add"(arg0: integer, arg1: double): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: double): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: any): void
 "add"(arg0: double): boolean
 "subList"(arg0: integer, arg1: integer): $List<(any)>
 "iterator"(): $DoubleListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: integer, arg1: $DoubleCollection$$Type): boolean
 "addAll"(arg0: $DoubleList$$Type): boolean
 "addAll"(arg0: integer, arg1: $DoubleList$$Type): boolean
 "set"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: any): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: double): double
 "sort"(arg0: $DoubleComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$$Type<(double)>): void
 "listIterator"(arg0: integer): $ListIterator<(any)>
 "listIterator"(): $ListIterator<(any)>
 "getElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
 "removeDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$$Type<(double)>): void
 "unstableSort"(arg0: $DoubleComparator$$Type): void
 "setElements"(arg0: integer, arg1: (double)[]): void
 "setElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: (double)[]): void
 "addElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (double)[]): void
 "removeElements"(arg0: integer, arg1: integer): void
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: $Collection$$Type<(double)>): boolean
 "addAll"(arg0: integer, arg1: $Collection$$Type<(double)>): boolean
 "getFirst"(): double
 "getLast"(): double
 "addFirst"(arg0: double): void
 "addLast"(arg0: double): void
 "removeFirst"(): double
 "removeLast"(): double
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "reversed"(): $SequencedCollection<(any)>
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "compareTo"(arg0: $List$$Type<(double)>): integer
 "toArray"(arg0: (double)[]): (double)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(double)>
 "contains"(arg0: double): boolean
 "addAll"(arg0: $DoubleCollection$$Type): boolean
 "removeIf"(arg0: $DoublePredicate$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(double)>): boolean
 "removeIf"(arg0: $DoublePredicate$0$$Type): boolean
 "removeAll"(arg0: $DoubleCollection$$Type): boolean
 "retainAll"(arg0: $DoubleCollection$$Type): boolean
 "containsAll"(arg0: $DoubleCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(double)>
 "rem"(arg0: double): boolean
 "doubleStream"(): $DoubleStream
/**
 * 
 * @deprecated
 */
 "toDoubleArray"(arg0: (double)[]): (double)[]
 "toDoubleArray"(): (double)[]
 "doubleIterator"(): $DoubleIterator
 "doubleSpliterator"(): $DoubleSpliterator
 "doubleParallelStream"(): $DoubleStream
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $DoubleConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(double)>): void
 "forEach"(arg0: $DoubleConsumer$0$$Type): void
set "elements"(value: (double)[])
get "empty"(): boolean
get "first"(): double
get "last"(): double
}

export namespace $DoubleList {
function of(...arg0: (double)[]): $DoubleList
function of(): $DoubleList
function of(arg0: double, arg1: double): $DoubleList
function of(arg0: double): $DoubleList
function of(arg0: double, arg1: double, arg2: double): $DoubleList
function copyOf<E>(arg0: $Collection$$Type<(double)>): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): $List<(double)>
function of<E>(arg0: double): $List<(double)>
function of<E>(arg0: double, arg1: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): $List<(double)>
function of<E>(...arg0: (double)[]): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): $List<(double)>
const probejs$$marker: never
}
export class $DoubleList$$Static implements $DoubleList {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: integer): any
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "size"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): any
 "indexOf"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getDouble"(arg0: integer): double
 "lastIndexOf"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "replaceAll"(arg0: $DoubleUnaryOperator$0$$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$$Type<(double)>): void
 "replaceAll"(arg0: $DoubleUnaryOperator$$Type): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: double): boolean
 "add"(arg0: integer, arg1: double): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: double): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: any): void
 "add"(arg0: double): boolean
 "subList"(arg0: integer, arg1: integer): $List<(any)>
 "iterator"(): $DoubleListIterator
static "of"(...arg0: (double)[]): $DoubleList
static "of"(): $DoubleList
static "of"(arg0: double, arg1: double): $DoubleList
static "of"(arg0: double): $DoubleList
static "of"(arg0: double, arg1: double, arg2: double): $DoubleList
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: integer, arg1: $DoubleCollection$$Type): boolean
 "addAll"(arg0: $DoubleList$$Type): boolean
 "addAll"(arg0: integer, arg1: $DoubleList$$Type): boolean
 "set"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: any): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: double): double
 "sort"(arg0: $DoubleComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$$Type<(double)>): void
 "listIterator"(arg0: integer): $ListIterator<(any)>
 "listIterator"(): $ListIterator<(any)>
 "getElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
 "removeDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$$Type<(double)>): void
 "unstableSort"(arg0: $DoubleComparator$$Type): void
 "setElements"(arg0: integer, arg1: (double)[]): void
 "setElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: (double)[]): void
 "addElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (double)[]): void
 "removeElements"(arg0: integer, arg1: integer): void
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<E>(arg0: $Collection$$Type<(double)>): $List<(double)>
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
static "of"<E>(arg0: double, arg1: double, arg2: double): $List<(double)>
static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double): $List<(double)>
static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double): $List<(double)>
static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double): $List<(double)>
static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): $List<(double)>
static "of"<E>(arg0: double): $List<(double)>
static "of"<E>(arg0: double, arg1: double): $List<(double)>
static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): $List<(double)>
static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): $List<(double)>
static "of"<E>(...arg0: (double)[]): $List<(double)>
static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): $List<(double)>
 "addAll"(arg0: $Collection$$Type<(double)>): boolean
 "addAll"(arg0: integer, arg1: $Collection$$Type<(double)>): boolean
 "getFirst"(): double
 "getLast"(): double
 "addFirst"(arg0: double): void
 "addLast"(arg0: double): void
 "removeFirst"(): double
 "removeLast"(): double
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "reversed"(): $SequencedCollection<(any)>
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "compareTo"(arg0: $List$$Type<(double)>): integer
 "toArray"(arg0: (double)[]): (double)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(double)>
 "contains"(arg0: double): boolean
 "addAll"(arg0: $DoubleCollection$$Type): boolean
 "removeIf"(arg0: $DoublePredicate$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(double)>): boolean
 "removeIf"(arg0: $DoublePredicate$0$$Type): boolean
 "removeAll"(arg0: $DoubleCollection$$Type): boolean
 "retainAll"(arg0: $DoubleCollection$$Type): boolean
 "containsAll"(arg0: $DoubleCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(double)>
 "rem"(arg0: double): boolean
 "doubleStream"(): $DoubleStream
/**
 * 
 * @deprecated
 */
 "toDoubleArray"(arg0: (double)[]): (double)[]
 "toDoubleArray"(): (double)[]
 "doubleIterator"(): $DoubleIterator
 "doubleSpliterator"(): $DoubleSpliterator
 "doubleParallelStream"(): $DoubleStream
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $DoubleConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(double)>): void
 "forEach"(arg0: $DoubleConsumer$0$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleList$$Type = ($DoubleList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleList_ = $DoubleList$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Reference2ObjectFunction<K, V> extends $Function<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(K), (V)>

(arg0: any): V
}

export namespace $Reference2ObjectFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Reference2ObjectFunction$$Static<K, V> implements $Reference2ObjectFunction {


 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ObjectFunction$$Type<K, V> = ((arg0: any) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ObjectFunction_<K, V> = $Reference2ObjectFunction$$Type<(K), (V)>;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2FloatFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$ToDoubleFunction, $ToDoubleFunction$$Type} from "java.util.function.ToDoubleFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"

export interface $Reference2FloatFunction<K> extends $Function<(K), (float)>, $ToDoubleFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getFloat"(arg0: any): float
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2FloatFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2FloatFunction
 "removeFloat"(arg0: any): float
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): float
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (float)>

(arg0: any): float
}

export namespace $Reference2FloatFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Reference2FloatFunction$$Static<K> implements $Reference2FloatFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getFloat"(arg0: any): float
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2FloatFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2FloatFunction
 "removeFloat"(arg0: any): float
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): float
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2FloatFunction$$Type<K> = ((arg0: any) => float);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2FloatFunction_<K> = $Reference2FloatFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.longs.Long2ObjectFunction" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$LongFunction, $LongFunction$$Type} from "java.util.function.LongFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"

export interface $Long2ObjectFunction<V> extends $Function<(long), (V)>, $LongFunction<(V)> {

 "remove"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Long2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Long2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(long), (V)>

(arg0: long): V
}

export namespace $Long2ObjectFunction {
function identity<T>(): $Function$0<(long), (long)>
const probejs$$marker: never
}
export class $Long2ObjectFunction$$Static<V> implements $Long2ObjectFunction {


 "remove"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Long2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Long2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): V
static "identity"<T>(): $Function$0<(long), (long)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(long), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectFunction$$Type<V> = ((arg0: long) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectFunction_<V> = $Long2ObjectFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.shorts.ShortCollection" {
import {$ShortPredicate, $ShortPredicate$$Type} from "it.unimi.dsi.fastutil.shorts.ShortPredicate"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$IntStream, $IntStream$$Type} from "java.util.stream.IntStream"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IntPredicate, $IntPredicate$$Type} from "java.util.function.IntPredicate"
import {$IntSpliterator, $IntSpliterator$$Type} from "it.unimi.dsi.fastutil.ints.IntSpliterator"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$IntIterator, $IntIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntIterator"
import {$ShortConsumer, $ShortConsumer$$Type} from "it.unimi.dsi.fastutil.shorts.ShortConsumer"
import {$IntConsumer, $IntConsumer$$Type} from "java.util.function.IntConsumer"
import {$ShortIterable, $ShortIterable$$Type} from "it.unimi.dsi.fastutil.shorts.ShortIterable"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$ShortIterator, $ShortIterator$$Type} from "it.unimi.dsi.fastutil.shorts.ShortIterator"

export interface $ShortCollection extends $Collection<(short)>, $ShortIterable {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "add"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: short): boolean
 "toArray"(arg0: (short)[]): (short)[]
 "iterator"(): $ShortIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(short)>
 "intStream"(): $IntStream
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "contains"(arg0: short): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: $ShortCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(short)>): boolean
 "removeIf"(arg0: $ShortPredicate$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $ShortCollection$$Type): boolean
 "retainAll"(arg0: $ShortCollection$$Type): boolean
 "containsAll"(arg0: $ShortCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(short)>
 "rem"(arg0: short): boolean
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "toShortArray"(): (short)[]
/**
 * 
 * @deprecated
 */
 "toShortArray"(arg0: (short)[]): (short)[]
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$$Type<(short)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "forEach"(arg0: $ShortConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(short)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
get "empty"(): boolean
}

export namespace $ShortCollection {
const probejs$$marker: never
}
export class $ShortCollection$$Static implements $ShortCollection {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "add"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: short): boolean
 "toArray"(arg0: (short)[]): (short)[]
 "iterator"(): $ShortIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(short)>
 "intStream"(): $IntStream
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "contains"(arg0: short): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: $ShortCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(short)>): boolean
 "removeIf"(arg0: $ShortPredicate$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $ShortCollection$$Type): boolean
 "retainAll"(arg0: $ShortCollection$$Type): boolean
 "containsAll"(arg0: $ShortCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(short)>
 "rem"(arg0: short): boolean
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "toShortArray"(): (short)[]
/**
 * 
 * @deprecated
 */
 "toShortArray"(arg0: (short)[]): (short)[]
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$$Type<(short)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "forEach"(arg0: $ShortConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(short)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortCollection$$Type = ($ShortCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortCollection_ = $ShortCollection$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.AbstractReference2ObjectMap" {
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Reference2ObjectMap, $Reference2ObjectMap$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectMap"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ObjectCollection, $ObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.ObjectCollection"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$AbstractReference2ObjectFunction, $AbstractReference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.AbstractReference2ObjectFunction"
import {$Reference2ObjectMap$Entry, $Reference2ObjectMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectMap$Entry"

export class $AbstractReference2ObjectMap<K, V> extends $AbstractReference2ObjectFunction<(K), (V)> implements $Reference2ObjectMap<(K), (V)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $ObjectCollection<(V)>
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$$Type<(K), (V)>): void
public "containsKey"(arg0: any): boolean
public "keySet"(): $Set<(any)>
public "containsValue"(arg0: any): boolean
public "remove"(arg0: any): V
public "remove"(arg0: any, arg1: any): boolean
public "size"(): integer
public "put"(arg0: K, arg1: V): V
public "clear"(): void
public "replace"(arg0: K, arg1: V): V
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
public "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
public "forEach"(arg0: $BiConsumer$$Type<(K), (V)>): void
public "computeIfAbsent"(arg0: K, arg1: $Reference2ObjectFunction$$Type<(K), (V)>): V
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
/**
 * 
 * @deprecated
 */
public "computeObjectIfAbsentPartial"(arg0: K, arg1: $Reference2ObjectFunction$$Type<(K), (V)>): V
public "reference2ObjectEntrySet"(): $ObjectSet<($Reference2ObjectMap$Entry<(K), (V)>)>
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public "replaceAll"(arg0: $BiFunction$$Type<(K), (V), (V)>): void
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (V)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(K), (K)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractReference2ObjectMap$$Type<K, V> = ($AbstractReference2ObjectMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractReference2ObjectMap_<K, V> = $AbstractReference2ObjectMap$$Type<(K), (V)>;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2ReferenceMap" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Reference2ReferenceMap$Entry, $Reference2ReferenceMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceMap$Entry"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"

export interface $Reference2ReferenceMap<K, V> extends $Reference2ReferenceFunction<(K), (V)>, $Map<(K), (V)> {

 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "size"(): integer
 "put"(arg0: K, arg1: V): V
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: V): V
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(K), (V)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Reference2ReferenceFunction$$Type<(K), (V)>): V
 "keySet"(): $Set<(any)>
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "reference2ReferenceEntrySet"(): $ObjectSet<($Reference2ReferenceMap$Entry<(K), (V)>)>
/**
 * 
 * @deprecated
 */
 "computeReferenceIfAbsentPartial"(arg0: K, arg1: $Reference2ReferenceFunction$$Type<(K), (V)>): V
 "get"(arg0: any): V
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Reference2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2ReferenceFunction<(V)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (V), (V)>): void
 "putAll"(arg0: $Map$$Type<(K), (V)>): void
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (V)>): V
 "containsValue"(arg0: any): boolean
 "apply"(arg0: K): V
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(K), (V)>
[index: string | number]: V
get "empty"(): boolean
}

export namespace $Reference2ReferenceMap {
function copyOf<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
function of<K, V>(): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
function entry<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
function identity<T>(): $Function<(K), (K)>
const probejs$$marker: never
}
export class $Reference2ReferenceMap$$Static<K, V> implements $Reference2ReferenceMap {


 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "size"(): integer
 "put"(arg0: K, arg1: V): V
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: V): V
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(K), (V)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Reference2ReferenceFunction$$Type<(K), (V)>): V
 "keySet"(): $Set<(any)>
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "reference2ReferenceEntrySet"(): $ObjectSet<($Reference2ReferenceMap$Entry<(K), (V)>)>
/**
 * 
 * @deprecated
 */
 "computeReferenceIfAbsentPartial"(arg0: K, arg1: $Reference2ReferenceFunction$$Type<(K), (V)>): V
 "get"(arg0: any): V
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Reference2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2ReferenceFunction<(V)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (V), (V)>): void
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
static "of"<K, V>(): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
 "putAll"(arg0: $Map$$Type<(K), (V)>): void
static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (V)>): V
 "containsValue"(arg0: any): boolean
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
 "apply"(arg0: K): V
static "identity"<T>(): $Function<(K), (K)>
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ReferenceMap$$Type<K, V> = ($Reference2ReferenceMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ReferenceMap_<K, V> = $Reference2ReferenceMap$$Type<(K), (V)>;
}}
declare module "it.unimi.dsi.fastutil.doubles.DoubleIterable" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$DoubleConsumer, $DoubleConsumer$$Type} from "java.util.function.DoubleConsumer"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$DoubleSpliterator, $DoubleSpliterator$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleSpliterator"
import {$DoubleIterator, $DoubleIterator$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleIterator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$$Type as $DoubleConsumer$0$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $DoubleIterable extends $Iterable<(double)> {

 "iterator"(): $Iterator<(any)>
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $DoubleConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(double)>): void
 "forEach"(arg0: $DoubleConsumer$0$$Type): void
 "doubleIterator"(): $DoubleIterator
 "doubleSpliterator"(): $DoubleSpliterator
[Symbol.iterator](): IterableIterator<any>;
}

export namespace $DoubleIterable {
const probejs$$marker: never
}
export class $DoubleIterable$$Static implements $DoubleIterable {


 "iterator"(): $Iterator<(any)>
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $DoubleConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(double)>): void
 "forEach"(arg0: $DoubleConsumer$0$$Type): void
 "doubleIterator"(): $DoubleIterator
 "doubleSpliterator"(): $DoubleSpliterator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleIterable$$Type = ($DoubleIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleIterable_ = $DoubleIterable$$Type;
}}
declare module "it.unimi.dsi.fastutil.doubles.DoubleDoublePair" {
import {$Pair, $Pair$$Type} from "it.unimi.dsi.fastutil.Pair"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"

export interface $DoubleDoublePair extends $Pair<(double), (double)> {

 "value"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "value"(): double
/**
 * 
 * @deprecated
 */
 "value"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "value"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
 "first"(): any
/**
 * 
 * @deprecated
 */
 "first"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "first"(arg0: any): $Pair<(any), (any)>
 "first"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "second"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
 "second"(): double
 "second"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "second"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "key"(arg0: double): $DoubleDoublePair
 "key"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "key"(): any
/**
 * 
 * @deprecated
 */
 "key"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
 "left"(): double
 "left"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "left"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "left"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
 "right"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "right"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
 "right"(): double
 "right"(arg0: double): $DoubleDoublePair
 "leftDouble"(): double
 "firstDouble"(): double
 "secondDouble"(): double
 "valueDouble"(): double
 "rightDouble"(): double
 "keyDouble"(): double
}

export namespace $DoubleDoublePair {
function of(arg0: double, arg1: double): $DoubleDoublePair
function lexComparator(): $Comparator<($DoubleDoublePair)>
function of<L, R>(arg0: double, arg1: double): $Pair<(double), (double)>
const probejs$$marker: never
}
export class $DoubleDoublePair$$Static implements $DoubleDoublePair {


 "value"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "value"(): double
/**
 * 
 * @deprecated
 */
 "value"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "value"(arg0: any): $Pair<(any), (any)>
static "of"(arg0: double, arg1: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "first"(): any
/**
 * 
 * @deprecated
 */
 "first"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "first"(arg0: any): $Pair<(any), (any)>
 "first"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "second"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
 "second"(): double
 "second"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "second"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "key"(arg0: double): $DoubleDoublePair
 "key"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "key"(): any
/**
 * 
 * @deprecated
 */
 "key"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
 "left"(): double
 "left"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "left"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "left"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
 "right"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
 "right"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
 "right"(): double
 "right"(arg0: double): $DoubleDoublePair
 "leftDouble"(): double
 "firstDouble"(): double
 "secondDouble"(): double
 "valueDouble"(): double
 "rightDouble"(): double
static "lexComparator"(): $Comparator<($DoubleDoublePair)>
 "keyDouble"(): double
static "of"<L, R>(arg0: double, arg1: double): $Pair<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleDoublePair$$Type = ($DoubleDoublePair);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleDoublePair_ = $DoubleDoublePair$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.IntUnaryOperator" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$IntUnaryOperator as $IntUnaryOperator$0, $IntUnaryOperator$$Type as $IntUnaryOperator$0$$Type} from "java.util.function.IntUnaryOperator"
import {$Function, $Function$$Type} from "java.util.function.Function"

export interface $IntUnaryOperator extends $UnaryOperator<(integer)>, $IntUnaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): integer
 "apply"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$0$$Type): $IntUnaryOperator$0
 "andThen"(arg0: $IntUnaryOperator$0$$Type): $IntUnaryOperator$0
 "compose"<V>(arg0: $Function$$Type<(V), (integer)>): $Function<(V), (integer)>
 "andThen"<V>(arg0: $Function$$Type<(integer), (V)>): $Function<(integer), (V)>

(arg0: integer): integer
}

export namespace $IntUnaryOperator {
function identity(): $IntUnaryOperator
function negation(): $IntUnaryOperator
const probejs$$marker: never
}
export class $IntUnaryOperator$$Static implements $IntUnaryOperator {


/**
 * 
 * @deprecated
 */
 "apply"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): integer
 "apply"(arg0: integer): integer
static "identity"(): $IntUnaryOperator
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
static "negation"(): $IntUnaryOperator
 "compose"(arg0: $IntUnaryOperator$0$$Type): $IntUnaryOperator$0
 "andThen"(arg0: $IntUnaryOperator$0$$Type): $IntUnaryOperator$0
 "compose"<V>(arg0: $Function$$Type<(V), (integer)>): $Function<(V), (integer)>
 "andThen"<V>(arg0: $Function$$Type<(integer), (V)>): $Function<(integer), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntUnaryOperator$$Type = ((arg0: integer) => integer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntUnaryOperator_ = $IntUnaryOperator$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2BooleanFunction" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Object2BooleanFunction<K> extends $Function<(K), (boolean)>, $Predicate<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: K, arg1: boolean): boolean
 "getBoolean"(arg0: any): boolean
 "test"(arg0: K): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2BooleanFunction
 "removeBoolean"(arg0: any): boolean
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): boolean
 "containsKey"(arg0: any): boolean
 "or"(arg0: $Predicate$$Type<(K)>): $Predicate<(K)>
 "negate"(): $Predicate<(K)>
 "and"(arg0: $Predicate$$Type<(K)>): $Predicate<(K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (boolean)>

(arg0: any): boolean
}

export namespace $Object2BooleanFunction {
function not<T>(arg0: $Predicate$$Type<(K)>): $Predicate<(K)>
function isEqual<T>(arg0: any): $Predicate<(K)>
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Object2BooleanFunction$$Static<K> implements $Object2BooleanFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: K, arg1: boolean): boolean
 "getBoolean"(arg0: any): boolean
 "test"(arg0: K): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2BooleanFunction
 "removeBoolean"(arg0: any): boolean
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): boolean
 "containsKey"(arg0: any): boolean
 "or"(arg0: $Predicate$$Type<(K)>): $Predicate<(K)>
 "negate"(): $Predicate<(K)>
 "and"(arg0: $Predicate$$Type<(K)>): $Predicate<(K)>
static "not"<T>(arg0: $Predicate$$Type<(K)>): $Predicate<(K)>
static "isEqual"<T>(arg0: any): $Predicate<(K)>
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2BooleanFunction$$Type<K> = ((arg0: any) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2BooleanFunction_<K> = $Object2BooleanFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.floats.Float2DoubleFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$$Type} from "java.util.function.DoubleUnaryOperator"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Float2DoubleFunction extends $Function<(float), (double)>, $DoubleUnaryOperator {

 "remove"(arg0: float): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: double): double
 "put"(arg0: float, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: float, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): double
 "compose"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator

(arg0: float): double
}

export namespace $Float2DoubleFunction {
function identity(): $DoubleUnaryOperator
const probejs$$marker: never
}
export class $Float2DoubleFunction$$Static implements $Float2DoubleFunction {


 "remove"(arg0: float): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: double): double
 "put"(arg0: float, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: float, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): double
static "identity"(): $DoubleUnaryOperator
 "compose"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2DoubleFunction$$Type = ((arg0: float) => double);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2DoubleFunction_ = $Float2DoubleFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction" {
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Byte2ObjectFunction<V> extends $Function<(byte), (V)>, $IntFunction<(V)> {

 "remove"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Byte2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Byte2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(byte), (V)>

(arg0: byte): V
}

export namespace $Byte2ObjectFunction {
function identity<T>(): $Function$0<(byte), (byte)>
const probejs$$marker: never
}
export class $Byte2ObjectFunction$$Static<V> implements $Byte2ObjectFunction {


 "remove"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Byte2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Byte2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): V
static "identity"<T>(): $Function$0<(byte), (byte)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(byte), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2ObjectFunction$$Type<V> = ((arg0: byte) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2ObjectFunction_<V> = $Byte2ObjectFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.objects.AbstractObject2IntFunction" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export class $AbstractObject2IntFunction<K> implements $Object2IntFunction<(K)>, $Serializable {


public "defaultReturnValue"(arg0: integer): void
public "defaultReturnValue"(): integer
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): any
public "put"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "put"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "put"(arg0: any, arg1: any): any
public "getInt"(arg0: any): integer
public "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: integer): integer
public "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
public "andThen"<T>(arg0: $Function$$Type<(integer), (T)>): $Function<(K), (T)>
public "andThenInt"(arg0: $Int2IntFunction$$Type): $Object2IntFunction<(K)>
public "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2IntFunction
public "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
public "andThenByte"(arg0: $Int2ByteFunction$$Type): $Object2ByteFunction<(K)>
public "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2IntFunction
public "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2IntFunction
public "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2IntFunction
public "andThenLong"(arg0: $Int2LongFunction$$Type): $Object2LongFunction<(K)>
public "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Object2FloatFunction<(K)>
public "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2IntFunction<(T)>
public "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2IntFunction
public "andThenChar"(arg0: $Int2CharFunction$$Type): $Object2CharFunction<(K)>
public "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2IntFunction<(T)>
public "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2IntFunction
public "andThenShort"(arg0: $Int2ShortFunction$$Type): $Object2ShortFunction<(K)>
public "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
public "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
public "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2IntFunction
public "removeInt"(arg0: any): integer
public "size"(): integer
public "clear"(): void
public "apply"(arg0: K): integer
public "containsKey"(arg0: any): boolean
public static "identity"<T>(): $Function<(K), (K)>
public "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2IntFunction$$Type<K> = ($AbstractObject2IntFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2IntFunction_<K> = $AbstractObject2IntFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2FloatFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$$Type} from "java.util.function.IntToDoubleFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Int2FloatFunction extends $Function<(integer), (float)>, $IntToDoubleFunction {

 "remove"(arg0: integer): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: float): float
 "put"(arg0: integer, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: integer, arg1: float): float
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): float

(arg0: integer): float
}

export namespace $Int2FloatFunction {
function identity<T>(): $Function$0<(integer), (integer)>
const probejs$$marker: never
}
export class $Int2FloatFunction$$Static implements $Int2FloatFunction {


 "remove"(arg0: integer): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: float): float
 "put"(arg0: integer, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: integer, arg1: float): float
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): float
static "identity"<T>(): $Function$0<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2FloatFunction$$Type = ((arg0: integer) => float);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2FloatFunction_ = $Int2FloatFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$IntPredicate, $IntPredicate$$Type} from "java.util.function.IntPredicate"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Short2BooleanFunction extends $Function<(short), (boolean)>, $IntPredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
 "getOrDefault"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): boolean
 "or"(arg0: $IntPredicate$$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$$Type): $IntPredicate

(arg0: short): boolean
}

export namespace $Short2BooleanFunction {
function identity<T>(): $Function$0<(short), (short)>
const probejs$$marker: never
}
export class $Short2BooleanFunction$$Static implements $Short2BooleanFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
 "getOrDefault"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): boolean
 "or"(arg0: $IntPredicate$$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$$Type): $IntPredicate
static "identity"<T>(): $Function$0<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2BooleanFunction$$Type = ((arg0: short) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2BooleanFunction_ = $Short2BooleanFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.AbstractLong2ObjectFunction" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export class $AbstractLong2ObjectFunction<V> implements $Long2ObjectFunction<(V)>, $Serializable {


public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public "remove"(arg0: long): V
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): V
public "get"(arg0: long): V
/**
 * 
 * @deprecated
 */
public "put"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
public "put"(arg0: any, arg1: any): any
public "put"(arg0: long, arg1: V): V
public "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
public "containsKey"(arg0: any): boolean
public "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: V): V
public "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
public "compose"<T>(arg0: $Function$$Type<(T), (long)>): $Function<(T), (V)>
public "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Long2IntFunction
public "composeInt"(arg0: $Int2LongFunction$$Type): $Int2ObjectFunction<(V)>
public "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Long2DoubleFunction
public "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Long2ByteFunction
public "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2ObjectFunction<(V)>
public "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2ObjectFunction<(V)>
public "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2ObjectFunction<(V)>
public "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Long2LongFunction
public "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Long2FloatFunction
public "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
public "composeLong"(arg0: $Long2LongFunction$$Type): $Long2ObjectFunction<(V)>
public "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Long2CharFunction
public "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
public "composeShort"(arg0: $Short2LongFunction$$Type): $Short2ObjectFunction<(V)>
public "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Long2ShortFunction
public "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Long2ReferenceFunction<(T)>
public "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Long2ObjectFunction<(T)>
public "composeChar"(arg0: $Char2LongFunction$$Type): $Char2ObjectFunction<(V)>
public "size"(): integer
public "clear"(): void
public "apply"(arg0: long): V
public static "identity"<T>(): $Function<(long), (long)>
public "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(long), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLong2ObjectFunction$$Type<V> = ($AbstractLong2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLong2ObjectFunction_<V> = $AbstractLong2ObjectFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2ShortFunction" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Object2ShortFunction<K> extends $Function<(K), (short)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getShort"(arg0: any): short
 "getOrDefault"(arg0: any, arg1: short): short
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2ShortFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2ShortFunction
 "removeShort"(arg0: any): short
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): short
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (short)>

(arg0: any): short
}

export namespace $Object2ShortFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Object2ShortFunction$$Static<K> implements $Object2ShortFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getShort"(arg0: any): short
 "getOrDefault"(arg0: any, arg1: short): short
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2ShortFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2ShortFunction
 "removeShort"(arg0: any): short
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): short
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ShortFunction$$Type<K> = ((arg0: any) => short);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ShortFunction_<K> = $Object2ShortFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.chars.Char2DoubleFunction" {
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$$Type} from "java.util.function.IntToDoubleFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Char2DoubleFunction extends $Function<(character), (double)>, $IntToDoubleFunction {

 "remove"(arg0: character): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: double): double
 "put"(arg0: character, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: character, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): double

(arg0: character): double
}

export namespace $Char2DoubleFunction {
function identity<T>(): $Function$0<(character), (character)>
const probejs$$marker: never
}
export class $Char2DoubleFunction$$Static implements $Char2DoubleFunction {


 "remove"(arg0: character): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: double): double
 "put"(arg0: character, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: character, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): double
static "identity"<T>(): $Function$0<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2DoubleFunction$$Type = ((arg0: character) => double);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2DoubleFunction_ = $Char2DoubleFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.Hash$Strategy" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Hash$Strategy<K> {

 "equals"(arg0: K, arg1: K): boolean
 "hashCode"(arg0: K): integer
}

export namespace $Hash$Strategy {
const probejs$$marker: never
}
export class $Hash$Strategy$$Static<K> implements $Hash$Strategy {


 "equals"(arg0: K, arg1: K): boolean
 "hashCode"(arg0: K): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Hash$Strategy$$Type<K> = ($Hash$Strategy<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Hash$Strategy_<K> = $Hash$Strategy$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.doubles.DoubleIterator" {
import {$DoubleConsumer, $DoubleConsumer$$Type} from "java.util.function.DoubleConsumer"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$$Type as $DoubleConsumer$0$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleConsumer"
import {$PrimitiveIterator$OfDouble, $PrimitiveIterator$OfDouble$$Type} from "java.util.PrimitiveIterator$OfDouble"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $DoubleIterator extends $PrimitiveIterator$OfDouble {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(double)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "skip"(arg0: integer): integer
 "nextDouble"(): double
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $DoubleConsumer$$Type): void
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $DoubleIterator {
const probejs$$marker: never
}
export class $DoubleIterator$$Static implements $DoubleIterator {


/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(double)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "skip"(arg0: integer): integer
 "nextDouble"(): double
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $DoubleConsumer$$Type): void
 "remove"(): void
 "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleIterator$$Type = ($DoubleIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleIterator_ = $DoubleIterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.LongUnaryOperator" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$LongUnaryOperator as $LongUnaryOperator$0, $LongUnaryOperator$$Type as $LongUnaryOperator$0$$Type} from "java.util.function.LongUnaryOperator"

export interface $LongUnaryOperator extends $UnaryOperator<(long)>, $LongUnaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: long): long
 "apply"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: long): long
 "compose"(arg0: $LongUnaryOperator$0$$Type): $LongUnaryOperator$0
 "andThen"(arg0: $LongUnaryOperator$0$$Type): $LongUnaryOperator$0
 "compose"<V>(arg0: $Function$$Type<(V), (long)>): $Function<(V), (long)>
 "andThen"<V>(arg0: $Function$$Type<(long), (V)>): $Function<(long), (V)>

(arg0: long): long
}

export namespace $LongUnaryOperator {
function identity(): $LongUnaryOperator
function negation(): $LongUnaryOperator
const probejs$$marker: never
}
export class $LongUnaryOperator$$Static implements $LongUnaryOperator {


/**
 * 
 * @deprecated
 */
 "apply"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: long): long
 "apply"(arg0: long): long
static "identity"(): $LongUnaryOperator
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: long): long
static "negation"(): $LongUnaryOperator
 "compose"(arg0: $LongUnaryOperator$0$$Type): $LongUnaryOperator$0
 "andThen"(arg0: $LongUnaryOperator$0$$Type): $LongUnaryOperator$0
 "compose"<V>(arg0: $Function$$Type<(V), (long)>): $Function<(V), (long)>
 "andThen"<V>(arg0: $Function$$Type<(long), (V)>): $Function<(long), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongUnaryOperator$$Type = ((arg0: long) => long);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongUnaryOperator_ = $LongUnaryOperator$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2BooleanFunction" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$IntPredicate, $IntPredicate$$Type} from "java.util.function.IntPredicate"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Int2BooleanFunction extends $Function<(integer), (boolean)>, $IntPredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: integer, arg1: boolean): boolean
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
 "getOrDefault"(arg0: integer, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): boolean
 "or"(arg0: $IntPredicate$$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$$Type): $IntPredicate

(arg0: integer): boolean
}

export namespace $Int2BooleanFunction {
function identity<T>(): $Function$0<(integer), (integer)>
const probejs$$marker: never
}
export class $Int2BooleanFunction$$Static implements $Int2BooleanFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: integer, arg1: boolean): boolean
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
 "getOrDefault"(arg0: integer, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): boolean
 "or"(arg0: $IntPredicate$$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$$Type): $IntPredicate
static "identity"<T>(): $Function$0<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2BooleanFunction$$Type = ((arg0: integer) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2BooleanFunction_ = $Int2BooleanFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.chars.Char2LongFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$IntToLongFunction, $IntToLongFunction$$Type} from "java.util.function.IntToLongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Char2LongFunction extends $Function<(character), (long)>, $IntToLongFunction {

 "remove"(arg0: character): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: long): long
 "put"(arg0: character, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: character, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): long

(arg0: character): long
}

export namespace $Char2LongFunction {
function identity<T>(): $Function$0<(character), (character)>
const probejs$$marker: never
}
export class $Char2LongFunction$$Static implements $Char2LongFunction {


 "remove"(arg0: character): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: long): long
 "put"(arg0: character, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: character, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): long
static "identity"<T>(): $Function$0<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2LongFunction$$Type = ((arg0: character) => long);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2LongFunction_ = $Char2LongFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Short2ReferenceFunction<V> extends $Function<(short), (V)>, $IntFunction<(V)> {

 "remove"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Short2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Short2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(short), (V)>

(arg0: short): V
}

export namespace $Short2ReferenceFunction {
function identity<T>(): $Function$0<(short), (short)>
const probejs$$marker: never
}
export class $Short2ReferenceFunction$$Static<V> implements $Short2ReferenceFunction {


 "remove"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Short2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Short2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): V
static "identity"<T>(): $Function$0<(short), (short)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(short), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2ReferenceFunction$$Type<V> = ((arg0: short) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2ReferenceFunction_<V> = $Short2ReferenceFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Int2ReferenceFunction<V> extends $Function<(integer), (V)>, $IntFunction<(V)> {

 "remove"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Int2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Int2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(integer), (V)>

(arg0: integer): V
}

export namespace $Int2ReferenceFunction {
function identity<T>(): $Function$0<(integer), (integer)>
const probejs$$marker: never
}
export class $Int2ReferenceFunction$$Static<V> implements $Int2ReferenceFunction {


 "remove"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Int2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Int2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): V
static "identity"<T>(): $Function$0<(integer), (integer)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(integer), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ReferenceFunction$$Type<V> = ((arg0: integer) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ReferenceFunction_<V> = $Int2ReferenceFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap" {
import {$AbstractObject2IntMap, $AbstractObject2IntMap$$Type} from "it.unimi.dsi.fastutil.objects.AbstractObject2IntMap"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Hash, $Hash$$Type} from "it.unimi.dsi.fastutil.Hash"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$IntCollection, $IntCollection$$Type} from "it.unimi.dsi.fastutil.ints.IntCollection"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Object2IntMap, $Object2IntMap$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntMap"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Cloneable, $Cloneable$$Type} from "java.lang.Cloneable"

export class $Object2IntOpenHashMap<K> extends $AbstractObject2IntMap<(K)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$$Type<(K), (integer)>)
constructor(arg0: $Object2IntMap$$Type<(K)>, arg1: float)
constructor(arg0: $Object2IntMap$$Type<(K)>)
constructor(arg0: (K)[], arg1: (integer)[], arg2: float)
constructor(arg0: (K)[], arg1: (integer)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$$Type<(K), (integer)>, arg1: float)

public "remove"(arg0: any, arg1: integer): boolean
public "size"(): integer
public "put"(arg0: K, arg1: integer): integer
public "values"(): $IntCollection
public "hashCode"(): integer
public "clone"(): $Object2IntOpenHashMap<(K)>
public "getInt"(arg0: any): integer
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: K, arg1: integer, arg2: integer): boolean
public "replace"(arg0: K, arg1: integer): integer
public "trim"(arg0: integer): boolean
public "trim"(): boolean
public "merge"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
public "putAll"(arg0: $Map$$Type<(K), (integer)>): void
public "putIfAbsent"(arg0: K, arg1: integer): integer
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: K, arg1: $Object2IntFunction$$Type<(K)>): integer
public "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$$Type<(K)>): integer
public "keySet"(): $ObjectSet<(K)>
public "containsValue"(arg0: integer): boolean
public "getOrDefault"(arg0: any, arg1: integer): integer
public "ensureCapacity"(arg0: integer): void
public "addTo"(arg0: K, arg1: integer): integer
public "removeInt"(arg0: any): integer
public "computeInt"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
public "computeIntIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
public "object2IntEntrySet"(): $ObjectSet<(any)>
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): any
public "defaultReturnValue"(): integer
public "defaultReturnValue"(arg0: integer): void
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2IntOpenHashMap$$Type<K> = ($Object2IntOpenHashMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2IntOpenHashMap_<K> = $Object2IntOpenHashMap$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.bytes.Byte2IntFunction" {
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Byte2IntFunction extends $Function<(byte), (integer)>, $IntUnaryOperator {

 "remove"(arg0: byte): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: integer): integer
 "put"(arg0: byte, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: byte, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): integer
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: byte): integer
}

export namespace $Byte2IntFunction {
function identity(): $IntUnaryOperator
const probejs$$marker: never
}
export class $Byte2IntFunction$$Static implements $Byte2IntFunction {


 "remove"(arg0: byte): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: integer): integer
 "put"(arg0: byte, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: byte, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): integer
static "identity"(): $IntUnaryOperator
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2IntFunction$$Type = ((arg0: byte) => integer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2IntFunction_ = $Byte2IntFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.ReferenceCollection" {
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$ObjectSpliterator, $ObjectSpliterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSpliterator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$ObjectIterable, $ObjectIterable$$Type} from "it.unimi.dsi.fastutil.objects.ObjectIterable"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ReferenceCollection<K> extends $Collection<(K)>, $ObjectIterable<(K)> {

 "iterator"(): $Iterator<(any)>
 "spliterator"(): $ObjectSpliterator<(K)>
 "remove"(arg0: any): boolean
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "add"(arg0: K): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "stream"(): $Stream<(K)>
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$$Type<(K)>): boolean
 "removeIf"(arg0: $Predicate$$Type<(K)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
[Symbol.iterator](): IterableIterator<any>;
get "empty"(): boolean
}

export namespace $ReferenceCollection {
const probejs$$marker: never
}
export class $ReferenceCollection$$Static<K> implements $ReferenceCollection {


 "iterator"(): $Iterator<(any)>
 "spliterator"(): $ObjectSpliterator<(K)>
 "remove"(arg0: any): boolean
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "add"(arg0: K): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "stream"(): $Stream<(K)>
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$$Type<(K)>): boolean
 "removeIf"(arg0: $Predicate$$Type<(K)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReferenceCollection$$Type<K> = ($ReferenceCollection<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReferenceCollection_<K> = $ReferenceCollection$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction" {
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$DoubleFunction, $DoubleFunction$$Type} from "java.util.function.DoubleFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"

export interface $Float2ReferenceFunction<V> extends $Function<(float), (V)>, $DoubleFunction<(V)> {

 "remove"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Float2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Float2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(float), (V)>

(arg0: float): V
}

export namespace $Float2ReferenceFunction {
function identity<T>(): $Function$0<(float), (float)>
const probejs$$marker: never
}
export class $Float2ReferenceFunction$$Static<V> implements $Float2ReferenceFunction {


 "remove"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Float2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Float2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): V
static "identity"<T>(): $Function$0<(float), (float)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(float), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2ReferenceFunction$$Type<V> = ((arg0: float) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2ReferenceFunction_<V> = $Float2ReferenceFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2IntFunction" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Int2IntFunction extends $Function<(integer), (integer)>, $IntUnaryOperator {

 "remove"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: integer, arg1: integer): integer
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: integer): integer
}

export namespace $Int2IntFunction {
function identity(): $Int2IntFunction
const probejs$$marker: never
}
export class $Int2IntFunction$$Static implements $Int2IntFunction {


 "remove"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: integer): integer
static "identity"(): $Int2IntFunction
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: integer, arg1: integer): integer
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2IntFunction$$Type = ((arg0: integer) => integer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2IntFunction_ = $Int2IntFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.LongConsumer" {
import {$LongConsumer as $LongConsumer$0, $LongConsumer$$Type as $LongConsumer$0$$Type} from "java.util.function.LongConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $LongConsumer extends $Consumer<(long)>, $LongConsumer$0 {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: long): void
 "andThen"(arg0: $LongConsumer$0$$Type): $LongConsumer$0
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$$Type<(long)>): $Consumer<(long)>
 "andThen"(arg0: $LongConsumer$$Type): $LongConsumer
 "accept"(arg0: long): void

(arg0: long): void
}

export namespace $LongConsumer {
const probejs$$marker: never
}
export class $LongConsumer$$Static implements $LongConsumer {


/**
 * 
 * @deprecated
 */
 "accept"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: long): void
 "andThen"(arg0: $LongConsumer$0$$Type): $LongConsumer$0
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$$Type<(long)>): $Consumer<(long)>
 "andThen"(arg0: $LongConsumer$$Type): $LongConsumer
 "accept"(arg0: long): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongConsumer$$Type = ((arg0: long) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongConsumer_ = $LongConsumer$$Type;
}}
declare module "it.unimi.dsi.fastutil.bytes.Byte2CharFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Byte2CharFunction extends $Function<(byte), (character)>, $IntUnaryOperator {

 "remove"(arg0: byte): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: character): character
 "put"(arg0: byte, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: byte, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): character
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: byte): character
}

export namespace $Byte2CharFunction {
function identity(): $IntUnaryOperator
const probejs$$marker: never
}
export class $Byte2CharFunction$$Static implements $Byte2CharFunction {


 "remove"(arg0: byte): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: character): character
 "put"(arg0: byte, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: byte, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): character
static "identity"(): $IntUnaryOperator
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2CharFunction$$Type = ((arg0: byte) => character);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2CharFunction_ = $Byte2CharFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2DoubleFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$ToDoubleFunction, $ToDoubleFunction$$Type} from "java.util.function.ToDoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Object2DoubleFunction<K> extends $Function<(K), (double)>, $ToDoubleFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getDouble"(arg0: any): double
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(K), (T)>
 "removeDouble"(arg0: any): double
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): double
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (double)>

(arg0: any): double
}

export namespace $Object2DoubleFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Object2DoubleFunction$$Static<K> implements $Object2DoubleFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getDouble"(arg0: any): double
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(K), (T)>
 "removeDouble"(arg0: any): double
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): double
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2DoubleFunction$$Type<K> = ((arg0: any) => double);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2DoubleFunction_<K> = $Object2DoubleFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2ObjectSortedMap" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$IntSortedSet, $IntSortedSet$$Type} from "it.unimi.dsi.fastutil.ints.IntSortedSet"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$IntComparator, $IntComparator$$Type} from "it.unimi.dsi.fastutil.ints.IntComparator"
import {$SortedMap, $SortedMap$$Type} from "java.util.SortedMap"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$SequencedSet, $SequencedSet$$Type} from "java.util.SequencedSet"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$ObjectSortedSet, $ObjectSortedSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSortedSet"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Int2ObjectMap, $Int2ObjectMap$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectMap"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Int2ObjectSortedMap<V> extends $Int2ObjectMap<(V)>, $SortedMap<(integer), (V)> {

 "values"(): $Collection<(any)>
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSortedSet<($Map$Entry<(integer), (V)>)>
 "keySet"(): $IntSortedSet
 "comparator"(): $IntComparator
/**
 * 
 * @deprecated
 */
 "firstKey"(): any
/**
 * 
 * @deprecated
 */
 "subMap"(arg0: integer, arg1: integer): $Int2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "subMap"(arg0: any, arg1: any): $SortedMap<(any), (any)>
 "subMap"(arg0: integer, arg1: integer): $Int2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "headMap"(arg0: any): $SortedMap<(any), (any)>
 "headMap"(arg0: integer): $Int2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "headMap"(arg0: integer): $Int2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "tailMap"(arg0: integer): $Int2ObjectSortedMap<(V)>
 "tailMap"(arg0: integer): $Int2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "tailMap"(arg0: any): $SortedMap<(any), (any)>
/**
 * 
 * @deprecated
 */
 "lastKey"(): any
 "int2ObjectEntrySet"(): $ObjectSet<(any)>
 "lastIntKey"(): integer
 "firstIntKey"(): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: integer, arg1: any): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "clear"(): void
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "replace"(arg0: integer, arg1: V): V
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(integer), (V)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $Int2ObjectFunction$$Type<(V)>): V
 "computeIfAbsent"(arg0: integer, arg1: $IntFunction$$Type<(V)>): V
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2ObjectFunction$$Type<(V)>): V
 "reversed"(): $SortedMap<(integer), (V)>
 "putFirst"(arg0: integer, arg1: V): V
 "putLast"(arg0: integer, arg1: V): V
 "remove"(arg0: integer): V
 "get"(arg0: integer): V
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (integer)>): $Function<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Int2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Int2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Int2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "replace"(arg0: integer, arg1: V): V
 "replaceAll"(arg0: $BiFunction$$Type<(integer), (V), (V)>): void
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "putAll"(arg0: $Map$$Type<(integer), (V)>): void
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
 "computeIfAbsent"(arg0: integer, arg1: $Function$$Type<(integer), (V)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
 "sequencedKeySet"(): $SequencedSet<(integer)>
 "sequencedValues"(): $SequencedCollection<(V)>
 "sequencedEntrySet"(): $SequencedSet<($Map$Entry<(integer), (V)>)>
 "firstEntry"(): $Map$Entry<(integer), (V)>
 "lastEntry"(): $Map$Entry<(integer), (V)>
 "pollFirstEntry"(): $Map$Entry<(integer), (V)>
 "pollLastEntry"(): $Map$Entry<(integer), (V)>
 "apply"(arg0: integer): V
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(integer), (V)>
[index: string | number]: V
get "empty"(): boolean
}

export namespace $Int2ObjectSortedMap {
function copyOf<K, V>(arg0: $Map$$Type<(integer), (V)>): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V): $Map<(integer), (V)>
function of<K, V>(): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V, arg18: integer, arg19: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V): $Map<(integer), (V)>
function entry<K, V>(arg0: integer, arg1: V): $Map$Entry<(integer), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(integer), (V)>)[]): $Map<(integer), (V)>
function identity<T>(): $Function<(integer), (integer)>
const probejs$$marker: never
}
export class $Int2ObjectSortedMap$$Static<V> implements $Int2ObjectSortedMap {


 "values"(): $Collection<(any)>
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSortedSet<($Map$Entry<(integer), (V)>)>
 "keySet"(): $IntSortedSet
 "comparator"(): $IntComparator
/**
 * 
 * @deprecated
 */
 "firstKey"(): any
/**
 * 
 * @deprecated
 */
 "subMap"(arg0: integer, arg1: integer): $Int2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "subMap"(arg0: any, arg1: any): $SortedMap<(any), (any)>
 "subMap"(arg0: integer, arg1: integer): $Int2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "headMap"(arg0: any): $SortedMap<(any), (any)>
 "headMap"(arg0: integer): $Int2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "headMap"(arg0: integer): $Int2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "tailMap"(arg0: integer): $Int2ObjectSortedMap<(V)>
 "tailMap"(arg0: integer): $Int2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "tailMap"(arg0: any): $SortedMap<(any), (any)>
/**
 * 
 * @deprecated
 */
 "lastKey"(): any
 "int2ObjectEntrySet"(): $ObjectSet<(any)>
 "lastIntKey"(): integer
 "firstIntKey"(): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: integer, arg1: any): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "clear"(): void
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "replace"(arg0: integer, arg1: V): V
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(integer), (V)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $Int2ObjectFunction$$Type<(V)>): V
 "computeIfAbsent"(arg0: integer, arg1: $IntFunction$$Type<(V)>): V
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2ObjectFunction$$Type<(V)>): V
 "reversed"(): $SortedMap<(integer), (V)>
 "putFirst"(arg0: integer, arg1: V): V
 "putLast"(arg0: integer, arg1: V): V
 "remove"(arg0: integer): V
 "get"(arg0: integer): V
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (integer)>): $Function<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Int2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Int2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Int2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(integer), (V)>): $Map<(integer), (V)>
 "isEmpty"(): boolean
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "replace"(arg0: integer, arg1: V): V
 "replaceAll"(arg0: $BiFunction$$Type<(integer), (V), (V)>): void
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V): $Map<(integer), (V)>
static "of"<K, V>(): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V, arg18: integer, arg19: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V): $Map<(integer), (V)>
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "putAll"(arg0: $Map$$Type<(integer), (V)>): void
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
static "entry"<K, V>(arg0: integer, arg1: V): $Map$Entry<(integer), (V)>
 "computeIfAbsent"(arg0: integer, arg1: $Function$$Type<(integer), (V)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(integer), (V)>)[]): $Map<(integer), (V)>
 "sequencedKeySet"(): $SequencedSet<(integer)>
 "sequencedValues"(): $SequencedCollection<(V)>
 "sequencedEntrySet"(): $SequencedSet<($Map$Entry<(integer), (V)>)>
 "firstEntry"(): $Map$Entry<(integer), (V)>
 "lastEntry"(): $Map$Entry<(integer), (V)>
 "pollFirstEntry"(): $Map$Entry<(integer), (V)>
 "pollLastEntry"(): $Map$Entry<(integer), (V)>
 "apply"(arg0: integer): V
static "identity"<T>(): $Function<(integer), (integer)>
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(integer), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ObjectSortedMap$$Type<V> = ($Int2ObjectSortedMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ObjectSortedMap_<V> = $Int2ObjectSortedMap$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.longs.Long2CharFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$LongToIntFunction, $LongToIntFunction$$Type} from "java.util.function.LongToIntFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Long2CharFunction extends $Function<(long), (character)>, $LongToIntFunction {

 "remove"(arg0: long): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: character): character
 "put"(arg0: long, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: long, arg1: character): character
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): character

(arg0: long): character
}

export namespace $Long2CharFunction {
function identity<T>(): $Function$0<(long), (long)>
const probejs$$marker: never
}
export class $Long2CharFunction$$Static implements $Long2CharFunction {


 "remove"(arg0: long): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: character): character
 "put"(arg0: long, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: long, arg1: character): character
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): character
static "identity"<T>(): $Function$0<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2CharFunction$$Type = ((arg0: long) => character);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2CharFunction_ = $Long2CharFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.ShortSpliterator" {
import {$Spliterator$OfPrimitive, $Spliterator$OfPrimitive$$Type} from "java.util.Spliterator$OfPrimitive"
import {$ShortConsumer, $ShortConsumer$$Type} from "it.unimi.dsi.fastutil.shorts.ShortConsumer"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ShortSpliterator extends $Spliterator$OfPrimitive<(short), ($ShortConsumer), ($ShortSpliterator)> {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(short)>): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$$Type<(short)>): boolean
 "trySplit"(): $Spliterator$OfPrimitive<(any), (any), (any)>
 "getComparator"(): $Comparator<(any)>
 "forEachRemaining"(arg0: $ShortConsumer$$Type): void
 "tryAdvance"(arg0: $ShortConsumer$$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
get "comparator"(): $Comparator<(any)>
get "exactSizeIfKnown"(): long
}

export namespace $ShortSpliterator {
const probejs$$marker: never
}
export class $ShortSpliterator$$Static implements $ShortSpliterator {


/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(short)>): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$$Type<(short)>): boolean
 "trySplit"(): $Spliterator$OfPrimitive<(any), (any), (any)>
 "getComparator"(): $Comparator<(any)>
 "forEachRemaining"(arg0: $ShortConsumer$$Type): void
 "tryAdvance"(arg0: $ShortConsumer$$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortSpliterator$$Type = ($ShortSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortSpliterator_ = $ShortSpliterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2CharFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Object2CharFunction<K> extends $Function<(K), (character)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getChar"(arg0: any): character
 "getOrDefault"(arg0: any, arg1: character): character
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2CharFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2CharFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2CharFunction
 "removeChar"(arg0: any): character
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): character
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (character)>

(arg0: any): character
}

export namespace $Object2CharFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Object2CharFunction$$Static<K> implements $Object2CharFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getChar"(arg0: any): character
 "getOrDefault"(arg0: any, arg1: character): character
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2CharFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2CharFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2CharFunction
 "removeChar"(arg0: any): character
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): character
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2CharFunction$$Type<K> = ((arg0: any) => character);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2CharFunction_<K> = $Object2CharFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2LongFunction" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$IntToLongFunction, $IntToLongFunction$$Type} from "java.util.function.IntToLongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Int2LongFunction extends $Function<(integer), (long)>, $IntToLongFunction {

 "remove"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: long): long
 "put"(arg0: integer, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: integer, arg1: long): long
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): long

(arg0: integer): long
}

export namespace $Int2LongFunction {
function identity<T>(): $Function$0<(integer), (integer)>
const probejs$$marker: never
}
export class $Int2LongFunction$$Static implements $Int2LongFunction {


 "remove"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: long): long
 "put"(arg0: integer, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: integer, arg1: long): long
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): long
static "identity"<T>(): $Function$0<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2LongFunction$$Type = ((arg0: integer) => long);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2LongFunction_ = $Int2LongFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.booleans.BooleanCollection" {
import {$BooleanConsumer, $BooleanConsumer$$Type} from "it.unimi.dsi.fastutil.booleans.BooleanConsumer"
import {$BooleanPredicate, $BooleanPredicate$$Type} from "it.unimi.dsi.fastutil.booleans.BooleanPredicate"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$BooleanIterable, $BooleanIterable$$Type} from "it.unimi.dsi.fastutil.booleans.BooleanIterable"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$BooleanIterator, $BooleanIterator$$Type} from "it.unimi.dsi.fastutil.booleans.BooleanIterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $BooleanCollection extends $Collection<(boolean)>, $BooleanIterable {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "add"(arg0: boolean): boolean
 "toArray"(arg0: (boolean)[]): (boolean)[]
 "iterator"(): $BooleanIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "contains"(arg0: boolean): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: $BooleanCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(boolean)>): boolean
 "removeIf"(arg0: $BooleanPredicate$$Type): boolean
 "removeAll"(arg0: $BooleanCollection$$Type): boolean
 "retainAll"(arg0: $BooleanCollection$$Type): boolean
 "containsAll"(arg0: $BooleanCollection$$Type): boolean
 "rem"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "toBooleanArray"(arg0: (boolean)[]): (boolean)[]
 "toBooleanArray"(): (boolean)[]
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "stream"(): $Stream<(boolean)>
 "addAll"(arg0: $Collection$$Type<(boolean)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "parallelStream"(): $Stream<(boolean)>
 "forEach"(arg0: $BooleanConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(boolean)>): void
get "empty"(): boolean
}

export namespace $BooleanCollection {
const probejs$$marker: never
}
export class $BooleanCollection$$Static implements $BooleanCollection {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "add"(arg0: boolean): boolean
 "toArray"(arg0: (boolean)[]): (boolean)[]
 "iterator"(): $BooleanIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "contains"(arg0: boolean): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: $BooleanCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(boolean)>): boolean
 "removeIf"(arg0: $BooleanPredicate$$Type): boolean
 "removeAll"(arg0: $BooleanCollection$$Type): boolean
 "retainAll"(arg0: $BooleanCollection$$Type): boolean
 "containsAll"(arg0: $BooleanCollection$$Type): boolean
 "rem"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "toBooleanArray"(arg0: (boolean)[]): (boolean)[]
 "toBooleanArray"(): (boolean)[]
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "stream"(): $Stream<(boolean)>
 "addAll"(arg0: $Collection$$Type<(boolean)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "parallelStream"(): $Stream<(boolean)>
 "forEach"(arg0: $BooleanConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(boolean)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanCollection$$Type = ($BooleanCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanCollection_ = $BooleanCollection$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2IntMap" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2IntMap$Entry, $Int2IntMap$Entry$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntMap$Entry"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$IntBinaryOperator, $IntBinaryOperator$$Type} from "java.util.function.IntBinaryOperator"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Map, $Map$$Type} from "java.util.Map"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$$Type as $IntBinaryOperator$0$$Type} from "it.unimi.dsi.fastutil.ints.IntBinaryOperator"
import {$IntCollection, $IntCollection$$Type} from "it.unimi.dsi.fastutil.ints.IntCollection"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Int2IntMap extends $Int2IntFunction, $Map<(integer), (integer)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
 "remove"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: integer): integer
 "values"(): $IntCollection
 "clear"(): void
 "replace"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: integer): integer
 "replace"(arg0: integer, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: integer, arg2: integer): boolean
 "merge"(arg0: integer, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "merge"(arg0: integer, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(integer), (integer)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: integer, arg1: integer): integer
 "putIfAbsent"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "compute"(arg0: any, arg1: $BiFunction$$Type<(any), (any), (any)>): any
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (integer), (integer)>): integer
 "forEach"(arg0: $BiConsumer$$Type<(integer), (integer)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $IntUnaryOperator$$Type): integer
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: any, arg1: $Function$$Type<(any), (any)>): any
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: integer, arg1: $Function$$Type<(integer), (integer)>): integer
 "computeIfAbsent"(arg0: integer, arg1: $Int2IntFunction$$Type): integer
 "keySet"(): $Set<(any)>
 "containsValue"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "getOrDefault"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: any, arg1: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (integer), (integer)>): integer
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "mergeInt"(arg0: integer, arg1: integer, arg2: $IntBinaryOperator$0$$Type): integer
 "mergeInt"(arg0: integer, arg1: integer, arg2: $IntBinaryOperator$$Type): integer
 "int2IntEntrySet"(): $ObjectSet<($Int2IntMap$Entry)>
 "computeIfAbsentNullable"(arg0: integer, arg1: $IntFunction$$Type<(integer)>): integer
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2IntFunction$$Type): integer
 "remove"(arg0: integer): integer
 "get"(arg0: integer): integer
 "put"(arg0: integer, arg1: integer): integer
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (integer)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(integer), (T)>): $Function<(integer), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2IntFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(integer), (integer), (integer)>): void
 "putAll"(arg0: $Map$$Type<(integer), (integer)>): void
 "apply"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
[index: string | number]: integer
get "empty"(): boolean
}

export namespace $Int2IntMap {
function identity(): $Int2IntFunction
function copyOf<K, V>(arg0: $Map$$Type<(integer), (integer)>): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $Map<(integer), (integer)>
function of<K, V>(): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: integer, arg15: integer, arg16: integer, arg17: integer, arg18: integer, arg19: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: integer, arg15: integer, arg16: integer, arg17: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: integer, arg15: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $Map<(integer), (integer)>
function entry<K, V>(arg0: integer, arg1: integer): $Map$Entry<(integer), (integer)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(integer), (integer)>)[]): $Map<(integer), (integer)>
const probejs$$marker: never
}
export class $Int2IntMap$$Static implements $Int2IntMap {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
 "remove"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: integer): integer
 "values"(): $IntCollection
 "clear"(): void
 "replace"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: integer): integer
 "replace"(arg0: integer, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: integer, arg2: integer): boolean
 "merge"(arg0: integer, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "merge"(arg0: integer, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(integer), (integer)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: integer, arg1: integer): integer
 "putIfAbsent"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "compute"(arg0: any, arg1: $BiFunction$$Type<(any), (any), (any)>): any
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (integer), (integer)>): integer
 "forEach"(arg0: $BiConsumer$$Type<(integer), (integer)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $IntUnaryOperator$$Type): integer
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: any, arg1: $Function$$Type<(any), (any)>): any
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: integer, arg1: $Function$$Type<(integer), (integer)>): integer
 "computeIfAbsent"(arg0: integer, arg1: $Int2IntFunction$$Type): integer
 "keySet"(): $Set<(any)>
 "containsValue"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "getOrDefault"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: any, arg1: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (integer), (integer)>): integer
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "mergeInt"(arg0: integer, arg1: integer, arg2: $IntBinaryOperator$0$$Type): integer
 "mergeInt"(arg0: integer, arg1: integer, arg2: $IntBinaryOperator$$Type): integer
 "int2IntEntrySet"(): $ObjectSet<($Int2IntMap$Entry)>
 "computeIfAbsentNullable"(arg0: integer, arg1: $IntFunction$$Type<(integer)>): integer
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2IntFunction$$Type): integer
 "remove"(arg0: integer): integer
 "get"(arg0: integer): integer
 "put"(arg0: integer, arg1: integer): integer
static "identity"(): $Int2IntFunction
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (integer)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(integer), (T)>): $Function<(integer), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2IntFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(integer), (integer)>): $Map<(integer), (integer)>
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(integer), (integer), (integer)>): void
static "of"<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $Map<(integer), (integer)>
static "of"<K, V>(): $Map<(integer), (integer)>
static "of"<K, V>(arg0: integer, arg1: integer): $Map<(integer), (integer)>
static "of"<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $Map<(integer), (integer)>
static "of"<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $Map<(integer), (integer)>
static "of"<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: integer, arg15: integer, arg16: integer, arg17: integer, arg18: integer, arg19: integer): $Map<(integer), (integer)>
static "of"<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: integer, arg15: integer, arg16: integer, arg17: integer): $Map<(integer), (integer)>
static "of"<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: integer, arg15: integer): $Map<(integer), (integer)>
static "of"<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer): $Map<(integer), (integer)>
static "of"<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer): $Map<(integer), (integer)>
static "of"<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $Map<(integer), (integer)>
 "putAll"(arg0: $Map$$Type<(integer), (integer)>): void
static "entry"<K, V>(arg0: integer, arg1: integer): $Map$Entry<(integer), (integer)>
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(integer), (integer)>)[]): $Map<(integer), (integer)>
 "apply"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2IntMap$$Type = ($Int2IntMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2IntMap_ = $Int2IntMap$$Type;
}}
declare module "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"

export interface $Char2ReferenceFunction<V> extends $Function<(character), (V)>, $IntFunction<(V)> {

 "remove"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Char2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Char2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(character), (V)>

(arg0: character): V
}

export namespace $Char2ReferenceFunction {
function identity<T>(): $Function$0<(character), (character)>
const probejs$$marker: never
}
export class $Char2ReferenceFunction$$Static<V> implements $Char2ReferenceFunction {


 "remove"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Char2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Char2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): V
static "identity"<T>(): $Function$0<(character), (character)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(character), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ReferenceFunction$$Type<V> = ((arg0: character) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ReferenceFunction_<V> = $Char2ReferenceFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.doubles.DoubleSpliterator" {
import {$Spliterator$OfPrimitive, $Spliterator$OfPrimitive$$Type} from "java.util.Spliterator$OfPrimitive"
import {$DoubleConsumer, $DoubleConsumer$$Type} from "java.util.function.DoubleConsumer"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$$Type as $DoubleConsumer$0$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleConsumer"
import {$Spliterator$OfDouble, $Spliterator$OfDouble$$Type} from "java.util.Spliterator$OfDouble"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $DoubleSpliterator extends $Spliterator$OfDouble {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(double)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$0$$Type): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$$Type<(double)>): boolean
 "tryAdvance"(arg0: $DoubleConsumer$0$$Type): boolean
 "trySplit"(): $Spliterator$OfPrimitive<(any), (any), (any)>
 "getComparator"(): $Comparator<(any)>
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $DoubleConsumer$$Type): void
 "tryAdvance"(arg0: any): boolean
 "tryAdvance"(arg0: $DoubleConsumer$$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
get "comparator"(): $Comparator<(any)>
get "exactSizeIfKnown"(): long
}

export namespace $DoubleSpliterator {
const probejs$$marker: never
}
export class $DoubleSpliterator$$Static implements $DoubleSpliterator {


/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(double)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$0$$Type): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$$Type<(double)>): boolean
 "tryAdvance"(arg0: $DoubleConsumer$0$$Type): boolean
 "trySplit"(): $Spliterator$OfPrimitive<(any), (any), (any)>
 "getComparator"(): $Comparator<(any)>
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $DoubleConsumer$$Type): void
 "tryAdvance"(arg0: any): boolean
 "tryAdvance"(arg0: $DoubleConsumer$$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleSpliterator$$Type = ($DoubleSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleSpliterator_ = $DoubleSpliterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.chars.Char2BooleanFunction" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$IntPredicate, $IntPredicate$$Type} from "java.util.function.IntPredicate"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"

export interface $Char2BooleanFunction extends $Function<(character), (boolean)>, $IntPredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: character, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
 "getOrDefault"(arg0: character, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): boolean
 "or"(arg0: $IntPredicate$$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$$Type): $IntPredicate

(arg0: character): boolean
}

export namespace $Char2BooleanFunction {
function identity<T>(): $Function$0<(character), (character)>
const probejs$$marker: never
}
export class $Char2BooleanFunction$$Static implements $Char2BooleanFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: character, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
 "getOrDefault"(arg0: character, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): boolean
 "or"(arg0: $IntPredicate$$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$$Type): $IntPredicate
static "identity"<T>(): $Function$0<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2BooleanFunction$$Type = ((arg0: character) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2BooleanFunction_ = $Char2BooleanFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"

export interface $Reference2ReferenceFunction<K, V> extends $Function<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(K), (V)>

(arg0: any): V
}

export namespace $Reference2ReferenceFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Reference2ReferenceFunction$$Static<K, V> implements $Reference2ReferenceFunction {


 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ReferenceFunction$$Type<K, V> = ((arg0: any) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ReferenceFunction_<K, V> = $Reference2ReferenceFunction$$Type<(K), (V)>;
}}
declare module "it.unimi.dsi.fastutil.doubles.DoubleConsumer" {
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$$Type as $DoubleConsumer$0$$Type} from "java.util.function.DoubleConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $DoubleConsumer extends $Consumer<(double)>, $DoubleConsumer$0 {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: double): void
 "andThen"(arg0: $DoubleConsumer$0$$Type): $DoubleConsumer$0
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$$Type<(double)>): $Consumer<(double)>
 "andThen"(arg0: $DoubleConsumer$$Type): $DoubleConsumer
 "accept"(arg0: double): void

(arg0: double): void
}

export namespace $DoubleConsumer {
const probejs$$marker: never
}
export class $DoubleConsumer$$Static implements $DoubleConsumer {


/**
 * 
 * @deprecated
 */
 "accept"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: double): void
 "andThen"(arg0: $DoubleConsumer$0$$Type): $DoubleConsumer$0
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$$Type<(double)>): $Consumer<(double)>
 "andThen"(arg0: $DoubleConsumer$$Type): $DoubleConsumer
 "accept"(arg0: double): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleConsumer$$Type = ((arg0: double) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleConsumer_ = $DoubleConsumer$$Type;
}}
declare module "it.unimi.dsi.fastutil.booleans.BooleanConsumer" {
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $BooleanConsumer extends $Consumer<(boolean)> {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: boolean): void
 "accept"(arg0: boolean): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$$Type<(boolean)>): $Consumer<(boolean)>
 "andThen"(arg0: $BooleanConsumer$$Type): $BooleanConsumer

(arg0: boolean): void
}

export namespace $BooleanConsumer {
const probejs$$marker: never
}
export class $BooleanConsumer$$Static implements $BooleanConsumer {


/**
 * 
 * @deprecated
 */
 "accept"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: boolean): void
 "accept"(arg0: boolean): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$$Type<(boolean)>): $Consumer<(boolean)>
 "andThen"(arg0: $BooleanConsumer$$Type): $BooleanConsumer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanConsumer$$Type = ((arg0: boolean) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanConsumer_ = $BooleanConsumer$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.ShortList" {
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$List, $List$$Type} from "java.util.List"
import {$IntPredicate, $IntPredicate$$Type} from "java.util.function.IntPredicate"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$ShortConsumer, $ShortConsumer$$Type} from "it.unimi.dsi.fastutil.shorts.ShortConsumer"
import {$IntConsumer, $IntConsumer$$Type} from "java.util.function.IntConsumer"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$ShortUnaryOperator, $ShortUnaryOperator$$Type} from "it.unimi.dsi.fastutil.shorts.ShortUnaryOperator"
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$ShortPredicate, $ShortPredicate$$Type} from "it.unimi.dsi.fastutil.shorts.ShortPredicate"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$IntStream, $IntStream$$Type} from "java.util.stream.IntStream"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IntSpliterator, $IntSpliterator$$Type} from "it.unimi.dsi.fastutil.ints.IntSpliterator"
import {$ShortComparator, $ShortComparator$$Type} from "it.unimi.dsi.fastutil.shorts.ShortComparator"
import {$ShortSpliterator, $ShortSpliterator$$Type} from "it.unimi.dsi.fastutil.shorts.ShortSpliterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ShortListIterator, $ShortListIterator$$Type} from "it.unimi.dsi.fastutil.shorts.ShortListIterator"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$IntIterator, $IntIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntIterator"
import {$ShortCollection, $ShortCollection$$Type} from "it.unimi.dsi.fastutil.shorts.ShortCollection"
import {$ListIterator, $ListIterator$$Type} from "java.util.ListIterator"

export interface $ShortList extends $List<(short)>, $Comparable<($List<(short)>)>, $ShortCollection {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: integer): any
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "size"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): any
 "indexOf"(arg0: short): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getShort"(arg0: integer): short
 "lastIndexOf"(arg0: short): integer
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$$Type<(short)>): void
 "replaceAll"(arg0: $IntUnaryOperator$$Type): void
 "replaceAll"(arg0: $ShortUnaryOperator$$Type): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: short): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: any): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: short): boolean
 "add"(arg0: short): boolean
 "add"(arg0: integer, arg1: short): void
 "subList"(arg0: integer, arg1: integer): $ShortList
 "iterator"(): $ShortListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $ShortSpliterator
 "addAll"(arg0: $ShortList$$Type): boolean
 "addAll"(arg0: integer, arg1: $ShortCollection$$Type): boolean
 "addAll"(arg0: integer, arg1: $ShortList$$Type): boolean
 "set"(arg0: integer, arg1: short): short
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: any): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: short): short
 "sort"(arg0: $ShortComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$$Type<(short)>): void
 "listIterator"(): $ShortListIterator
 "listIterator"(arg0: integer): $ListIterator<(any)>
 "getElements"(arg0: integer, arg1: (short)[], arg2: integer, arg3: integer): void
 "unstableSort"(arg0: $ShortComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$$Type<(short)>): void
 "removeShort"(arg0: integer): short
 "setElements"(arg0: integer, arg1: (short)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (short)[]): void
 "setElements"(arg0: (short)[]): void
 "addElements"(arg0: integer, arg1: (short)[]): void
 "addElements"(arg0: integer, arg1: (short)[], arg2: integer, arg3: integer): void
 "removeElements"(arg0: integer, arg1: integer): void
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: $Collection$$Type<(short)>): boolean
 "addAll"(arg0: integer, arg1: $Collection$$Type<(short)>): boolean
 "getFirst"(): short
 "getLast"(): short
 "addFirst"(arg0: short): void
 "addLast"(arg0: short): void
 "removeFirst"(): short
 "removeLast"(): short
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "reversed"(): $SequencedCollection<(any)>
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "compareTo"(arg0: $List$$Type<(short)>): integer
 "toArray"(arg0: (short)[]): (short)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(short)>
 "intStream"(): $IntStream
 "contains"(arg0: short): boolean
 "addAll"(arg0: $ShortCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(short)>): boolean
 "removeIf"(arg0: $ShortPredicate$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $ShortCollection$$Type): boolean
 "retainAll"(arg0: $ShortCollection$$Type): boolean
 "containsAll"(arg0: $ShortCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(short)>
 "rem"(arg0: short): boolean
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "toShortArray"(): (short)[]
/**
 * 
 * @deprecated
 */
 "toShortArray"(arg0: (short)[]): (short)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $ShortConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(short)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
set "elements"(value: (short)[])
get "empty"(): boolean
get "first"(): short
get "last"(): short
}

export namespace $ShortList {
function of(arg0: short): $ShortList
function of(): $ShortList
function of(arg0: short, arg1: short, arg2: short): $ShortList
function of(...arg0: (short)[]): $ShortList
function of(arg0: short, arg1: short): $ShortList
function copyOf<E>(arg0: $Collection$$Type<(short)>): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short, arg9: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short): $List<(short)>
function of<E>(arg0: short): $List<(short)>
function of<E>(arg0: short, arg1: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short): $List<(short)>
function of<E>(...arg0: (short)[]): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short): $List<(short)>
const probejs$$marker: never
}
export class $ShortList$$Static implements $ShortList {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: integer): any
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "size"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): any
 "indexOf"(arg0: short): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getShort"(arg0: integer): short
 "lastIndexOf"(arg0: short): integer
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$$Type<(short)>): void
 "replaceAll"(arg0: $IntUnaryOperator$$Type): void
 "replaceAll"(arg0: $ShortUnaryOperator$$Type): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: short): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: any): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: short): boolean
 "add"(arg0: short): boolean
 "add"(arg0: integer, arg1: short): void
 "subList"(arg0: integer, arg1: integer): $ShortList
 "iterator"(): $ShortListIterator
static "of"(arg0: short): $ShortList
static "of"(): $ShortList
static "of"(arg0: short, arg1: short, arg2: short): $ShortList
static "of"(...arg0: (short)[]): $ShortList
static "of"(arg0: short, arg1: short): $ShortList
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $ShortSpliterator
 "addAll"(arg0: $ShortList$$Type): boolean
 "addAll"(arg0: integer, arg1: $ShortCollection$$Type): boolean
 "addAll"(arg0: integer, arg1: $ShortList$$Type): boolean
 "set"(arg0: integer, arg1: short): short
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: any): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: short): short
 "sort"(arg0: $ShortComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$$Type<(short)>): void
 "listIterator"(): $ShortListIterator
 "listIterator"(arg0: integer): $ListIterator<(any)>
 "getElements"(arg0: integer, arg1: (short)[], arg2: integer, arg3: integer): void
 "unstableSort"(arg0: $ShortComparator$$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$$Type<(short)>): void
 "removeShort"(arg0: integer): short
 "setElements"(arg0: integer, arg1: (short)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (short)[]): void
 "setElements"(arg0: (short)[]): void
 "addElements"(arg0: integer, arg1: (short)[]): void
 "addElements"(arg0: integer, arg1: (short)[], arg2: integer, arg3: integer): void
 "removeElements"(arg0: integer, arg1: integer): void
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<E>(arg0: $Collection$$Type<(short)>): $List<(short)>
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
static "of"<E>(arg0: short, arg1: short, arg2: short): $List<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short): $List<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short): $List<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short, arg9: short): $List<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short): $List<(short)>
static "of"<E>(arg0: short): $List<(short)>
static "of"<E>(arg0: short, arg1: short): $List<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short): $List<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short): $List<(short)>
static "of"<E>(...arg0: (short)[]): $List<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short): $List<(short)>
 "addAll"(arg0: $Collection$$Type<(short)>): boolean
 "addAll"(arg0: integer, arg1: $Collection$$Type<(short)>): boolean
 "getFirst"(): short
 "getLast"(): short
 "addFirst"(arg0: short): void
 "addLast"(arg0: short): void
 "removeFirst"(): short
 "removeLast"(): short
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "reversed"(): $SequencedCollection<(any)>
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "compareTo"(arg0: $List$$Type<(short)>): integer
 "toArray"(arg0: (short)[]): (short)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(short)>
 "intStream"(): $IntStream
 "contains"(arg0: short): boolean
 "addAll"(arg0: $ShortCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(short)>): boolean
 "removeIf"(arg0: $ShortPredicate$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $ShortCollection$$Type): boolean
 "retainAll"(arg0: $ShortCollection$$Type): boolean
 "containsAll"(arg0: $ShortCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(short)>
 "rem"(arg0: short): boolean
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "toShortArray"(): (short)[]
/**
 * 
 * @deprecated
 */
 "toShortArray"(arg0: (short)[]): (short)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $ShortConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(short)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortList$$Type = ($ShortList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortList_ = $ShortList$$Type;
}}
declare module "it.unimi.dsi.fastutil.floats.Float2BooleanFunction" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$DoublePredicate, $DoublePredicate$$Type} from "java.util.function.DoublePredicate"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"

export interface $Float2BooleanFunction extends $Function<(float), (boolean)>, $DoublePredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: float, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
 "getOrDefault"(arg0: float, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): boolean
 "or"(arg0: $DoublePredicate$$Type): $DoublePredicate
 "negate"(): $DoublePredicate
 "and"(arg0: $DoublePredicate$$Type): $DoublePredicate

(arg0: float): boolean
}

export namespace $Float2BooleanFunction {
function identity<T>(): $Function$0<(float), (float)>
const probejs$$marker: never
}
export class $Float2BooleanFunction$$Static implements $Float2BooleanFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: float, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
 "getOrDefault"(arg0: float, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): boolean
 "or"(arg0: $DoublePredicate$$Type): $DoublePredicate
 "negate"(): $DoublePredicate
 "and"(arg0: $DoublePredicate$$Type): $DoublePredicate
static "identity"<T>(): $Function$0<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2BooleanFunction$$Type = ((arg0: float) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2BooleanFunction_ = $Float2BooleanFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2IntMap" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$IntBinaryOperator, $IntBinaryOperator$$Type} from "java.util.function.IntBinaryOperator"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$$Type as $IntBinaryOperator$0$$Type} from "it.unimi.dsi.fastutil.ints.IntBinaryOperator"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Object2IntMap$Entry, $Object2IntMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntMap$Entry"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Object2IntMap<K> extends $Object2IntFunction<(K)>, $Map<(K), (integer)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
 "remove"(arg0: any, arg1: integer): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: integer): integer
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (integer)>)>
 "putIfAbsent"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
 "forEach"(arg0: $BiConsumer$$Type<(K), (integer)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$$Type<(K)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Object2IntFunction$$Type<(K)>): integer
 "keySet"(): $ObjectSet<(K)>
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: integer): boolean
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "mergeInt"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$$Type): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$0$$Type): integer
 "computeInt"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsentPartial"(arg0: K, arg1: $Object2IntFunction$$Type<(K)>): integer
 "computeIntIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
 "object2IntEntrySet"(): $ObjectSet<($Object2IntMap$Entry<(K)>)>
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsent"(arg0: K, arg1: $ToIntFunction$$Type<(K)>): integer
 "put"(arg0: K, arg1: integer): integer
 "getInt"(arg0: any): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(integer), (T)>): $Function<(K), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2IntFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2IntFunction
 "removeInt"(arg0: any): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (integer), (integer)>): void
 "putAll"(arg0: $Map$$Type<(K), (integer)>): void
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (integer)>): integer
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
 "apply"(arg0: K): integer
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (integer)>
[index: string | number]: integer
get "empty"(): boolean
}

export namespace $Object2IntMap {
function copyOf<K, V>(arg0: $Map$$Type<(K), (integer)>): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer): $Map<(K), (integer)>
function of<K, V>(): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer, arg18: K, arg19: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer): $Map<(K), (integer)>
function entry<K, V>(arg0: K, arg1: integer): $Map$Entry<(K), (integer)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(K), (integer)>)[]): $Map<(K), (integer)>
function identity<T>(): $Function<(K), (K)>
const probejs$$marker: never
}
export class $Object2IntMap$$Static<K> implements $Object2IntMap {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
 "remove"(arg0: any, arg1: integer): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: integer): integer
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (integer)>)>
 "putIfAbsent"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
 "forEach"(arg0: $BiConsumer$$Type<(K), (integer)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$$Type<(K)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Object2IntFunction$$Type<(K)>): integer
 "keySet"(): $ObjectSet<(K)>
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: integer): boolean
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "mergeInt"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$$Type): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$0$$Type): integer
 "computeInt"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsentPartial"(arg0: K, arg1: $Object2IntFunction$$Type<(K)>): integer
 "computeIntIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
 "object2IntEntrySet"(): $ObjectSet<($Object2IntMap$Entry<(K)>)>
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsent"(arg0: K, arg1: $ToIntFunction$$Type<(K)>): integer
 "put"(arg0: K, arg1: integer): integer
 "getInt"(arg0: any): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(integer), (T)>): $Function<(K), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2IntFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2IntFunction
 "removeInt"(arg0: any): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(K), (integer)>): $Map<(K), (integer)>
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (integer), (integer)>): void
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer): $Map<(K), (integer)>
static "of"<K, V>(): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer, arg18: K, arg19: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer): $Map<(K), (integer)>
 "putAll"(arg0: $Map$$Type<(K), (integer)>): void
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
static "entry"<K, V>(arg0: K, arg1: integer): $Map$Entry<(K), (integer)>
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (integer)>): integer
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (integer)>)[]): $Map<(K), (integer)>
 "apply"(arg0: K): integer
static "identity"<T>(): $Function<(K), (K)>
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2IntMap$$Type<K> = ($Object2IntMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2IntMap_<K> = $Object2IntMap$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$$Type} from "java.util.function.IntToDoubleFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Byte2DoubleFunction extends $Function<(byte), (double)>, $IntToDoubleFunction {

 "remove"(arg0: byte): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: double): double
 "put"(arg0: byte, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: byte, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): double

(arg0: byte): double
}

export namespace $Byte2DoubleFunction {
function identity<T>(): $Function$0<(byte), (byte)>
const probejs$$marker: never
}
export class $Byte2DoubleFunction$$Static implements $Byte2DoubleFunction {


 "remove"(arg0: byte): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: double): double
 "put"(arg0: byte, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: byte, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): double
static "identity"<T>(): $Function$0<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2DoubleFunction$$Type = ((arg0: byte) => double);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2DoubleFunction_ = $Byte2DoubleFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2ObjectFunction" {
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Object2ObjectFunction<K, V> extends $Function<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(K), (V)>

(arg0: any): V
}

export namespace $Object2ObjectFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Object2ObjectFunction$$Static<K, V> implements $Object2ObjectFunction {


 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectFunction$$Type<K, V> = ((arg0: any) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectFunction_<K, V> = $Object2ObjectFunction$$Type<(K), (V)>;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2ObjectArrayMap" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$AbstractReference2ObjectMap, $AbstractReference2ObjectMap$$Type} from "it.unimi.dsi.fastutil.objects.AbstractReference2ObjectMap"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$ReferenceSet, $ReferenceSet$$Type} from "it.unimi.dsi.fastutil.objects.ReferenceSet"
import {$Cloneable, $Cloneable$$Type} from "java.lang.Cloneable"
import {$Reference2ObjectMap, $Reference2ObjectMap$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectMap"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"

export class $Reference2ObjectArrayMap<K, V> extends $AbstractReference2ObjectMap<(K), (V)> implements $Serializable, $Cloneable {

constructor(arg0: (any)[], arg1: (any)[], arg2: integer)
constructor(arg0: $Map$$Type<(K), (V)>)
constructor(arg0: $Reference2ObjectMap$$Type<(K), (V)>)
constructor(arg0: (any)[], arg1: (any)[])
constructor()
constructor(arg0: integer)

public "remove"(arg0: any): V
public "size"(): integer
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "values"(): $Collection<(any)>
public "clone"(): $Reference2ObjectArrayMap<(K), (V)>
public "clear"(): void
public "isEmpty"(): boolean
public "containsKey"(arg0: any): boolean
public "keySet"(): $ReferenceSet<(K)>
public "containsValue"(arg0: any): boolean
public "reference2ObjectEntrySet"(): $ObjectSet<(any)>
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ObjectArrayMap$$Type<K, V> = ($Reference2ObjectArrayMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ObjectArrayMap_<K, V> = $Reference2ObjectArrayMap$$Type<(K), (V)>;
}}
declare module "it.unimi.dsi.fastutil.shorts.Short2LongFunction" {
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$IntToLongFunction, $IntToLongFunction$$Type} from "java.util.function.IntToLongFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Short2LongFunction extends $Function<(short), (long)>, $IntToLongFunction {

 "remove"(arg0: short): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: long): long
 "put"(arg0: short, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: short, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): long

(arg0: short): long
}

export namespace $Short2LongFunction {
function identity<T>(): $Function$0<(short), (short)>
const probejs$$marker: never
}
export class $Short2LongFunction$$Static implements $Short2LongFunction {


 "remove"(arg0: short): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: long): long
 "put"(arg0: short, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: short, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): long
static "identity"<T>(): $Function$0<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2LongFunction$$Type = ((arg0: short) => long);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2LongFunction_ = $Short2LongFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.AbstractReference2ObjectFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export class $AbstractReference2ObjectFunction<K, V> implements $Reference2ObjectFunction<(K), (V)>, $Serializable {


public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "getOrDefault"(arg0: any, arg1: V): V
public "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Reference2IntFunction<(K)>
public "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2ObjectFunction<(V)>
public "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Reference2DoubleFunction<(K)>
public "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Reference2ByteFunction<(K)>
public "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2ObjectFunction<(V)>
public "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2ObjectFunction<(V)>
public "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2ObjectFunction<(V)>
public "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Reference2LongFunction<(K)>
public "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Reference2FloatFunction<(K)>
public "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2ObjectFunction<(T), (V)>
public "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2ObjectFunction<(V)>
public "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Reference2CharFunction<(K)>
public "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2ObjectFunction<(T), (V)>
public "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2ObjectFunction<(V)>
public "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Reference2ShortFunction<(K)>
public "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Reference2ReferenceFunction<(K), (T)>
public "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Reference2ObjectFunction<(K), (T)>
public "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2ObjectFunction<(V)>
public "size"(): integer
public "clear"(): void
public "apply"(arg0: K): V
public "containsKey"(arg0: any): boolean
public static "identity"<T>(): $Function<(K), (K)>
public "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (V)>
public "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractReference2ObjectFunction$$Type<K, V> = ($AbstractReference2ObjectFunction<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractReference2ObjectFunction_<K, V> = $AbstractReference2ObjectFunction$$Type<(K), (V)>;
}}
declare module "it.unimi.dsi.fastutil.ints.IntSpliterator" {
import {$Spliterator$OfPrimitive, $Spliterator$OfPrimitive$$Type} from "java.util.Spliterator$OfPrimitive"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$$Type as $IntConsumer$0$$Type} from "java.util.function.IntConsumer"
import {$Spliterator$OfInt, $Spliterator$OfInt$$Type} from "java.util.Spliterator$OfInt"
import {$IntConsumer, $IntConsumer$$Type} from "it.unimi.dsi.fastutil.ints.IntConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $IntSpliterator extends $Spliterator$OfInt {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(integer)>): void
 "forEachRemaining"(arg0: $IntConsumer$$Type): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$$Type<(integer)>): boolean
 "tryAdvance"(arg0: $IntConsumer$$Type): boolean
 "trySplit"(): $Spliterator$OfPrimitive<(any), (any), (any)>
 "getComparator"(): $Comparator<(any)>
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $IntConsumer$0$$Type): void
 "tryAdvance"(arg0: any): boolean
 "tryAdvance"(arg0: $IntConsumer$0$$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
get "comparator"(): $Comparator<(any)>
get "exactSizeIfKnown"(): long
}

export namespace $IntSpliterator {
const probejs$$marker: never
}
export class $IntSpliterator$$Static implements $IntSpliterator {


/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(integer)>): void
 "forEachRemaining"(arg0: $IntConsumer$$Type): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$$Type<(integer)>): boolean
 "tryAdvance"(arg0: $IntConsumer$$Type): boolean
 "trySplit"(): $Spliterator$OfPrimitive<(any), (any), (any)>
 "getComparator"(): $Comparator<(any)>
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $IntConsumer$0$$Type): void
 "tryAdvance"(arg0: any): boolean
 "tryAdvance"(arg0: $IntConsumer$0$$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntSpliterator$$Type = ($IntSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntSpliterator_ = $IntSpliterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.LongCollection" {
import {$LongPredicate as $LongPredicate$0, $LongPredicate$$Type as $LongPredicate$0$$Type} from "java.util.function.LongPredicate"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$LongStream, $LongStream$$Type} from "java.util.stream.LongStream"
import {$LongConsumer, $LongConsumer$$Type} from "it.unimi.dsi.fastutil.longs.LongConsumer"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$LongPredicate, $LongPredicate$$Type} from "it.unimi.dsi.fastutil.longs.LongPredicate"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$$Type as $LongConsumer$0$$Type} from "java.util.function.LongConsumer"
import {$LongSpliterator, $LongSpliterator$$Type} from "it.unimi.dsi.fastutil.longs.LongSpliterator"
import {$LongIterator, $LongIterator$$Type} from "it.unimi.dsi.fastutil.longs.LongIterator"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$LongIterable, $LongIterable$$Type} from "it.unimi.dsi.fastutil.longs.LongIterable"

export interface $LongCollection extends $Collection<(long)>, $LongIterable {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
 "toArray"(arg0: (long)[]): (long)[]
 "iterator"(): $LongIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: $LongCollection$$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(long)>): boolean
 "removeIf"(arg0: $LongPredicate$$Type): boolean
 "removeAll"(arg0: $LongCollection$$Type): boolean
 "retainAll"(arg0: $LongCollection$$Type): boolean
 "containsAll"(arg0: $LongCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "rem"(arg0: long): boolean
 "longStream"(): $LongStream
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "toLongArray"(): (long)[]
 "longIterator"(): $LongIterator
 "longParallelStream"(): $LongStream
 "longSpliterator"(): $LongSpliterator
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$$Type<(long)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "forEach"(arg0: $LongConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(long)>): void
 "forEach"(arg0: $LongConsumer$$Type): void
get "empty"(): boolean
}

export namespace $LongCollection {
const probejs$$marker: never
}
export class $LongCollection$$Static implements $LongCollection {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
 "toArray"(arg0: (long)[]): (long)[]
 "iterator"(): $LongIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: $LongCollection$$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(long)>): boolean
 "removeIf"(arg0: $LongPredicate$$Type): boolean
 "removeAll"(arg0: $LongCollection$$Type): boolean
 "retainAll"(arg0: $LongCollection$$Type): boolean
 "containsAll"(arg0: $LongCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "rem"(arg0: long): boolean
 "longStream"(): $LongStream
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "toLongArray"(): (long)[]
 "longIterator"(): $LongIterator
 "longParallelStream"(): $LongStream
 "longSpliterator"(): $LongSpliterator
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$$Type<(long)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "forEach"(arg0: $LongConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(long)>): void
 "forEach"(arg0: $LongConsumer$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongCollection$$Type = ($LongCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongCollection_ = $LongCollection$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$LongFunction, $LongFunction$$Type} from "java.util.function.LongFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Long2ReferenceFunction<V> extends $Function<(long), (V)>, $LongFunction<(V)> {

 "remove"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Long2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Long2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(long), (V)>

(arg0: long): V
}

export namespace $Long2ReferenceFunction {
function identity<T>(): $Function$0<(long), (long)>
const probejs$$marker: never
}
export class $Long2ReferenceFunction$$Static<V> implements $Long2ReferenceFunction {


 "remove"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Long2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Long2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): V
static "identity"<T>(): $Function$0<(long), (long)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(long), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ReferenceFunction$$Type<V> = ((arg0: long) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ReferenceFunction_<V> = $Long2ReferenceFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction" {
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Boolean2ByteFunction extends $Function<(boolean), (byte)> {

 "remove"(arg0: boolean): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): byte
 "get"(arg0: boolean): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: byte): byte
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): byte

(arg0: boolean): byte
}

export namespace $Boolean2ByteFunction {
function identity<T>(): $Function$0<(boolean), (boolean)>
const probejs$$marker: never
}
export class $Boolean2ByteFunction$$Static implements $Boolean2ByteFunction {


 "remove"(arg0: boolean): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): byte
 "get"(arg0: boolean): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: byte): byte
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): byte
static "identity"<T>(): $Function$0<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2ByteFunction$$Type = ((arg0: boolean) => byte);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2ByteFunction_ = $Boolean2ByteFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.IntBidirectionalIterator" {
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator"
import {$IntIterator, $IntIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntIterator"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$$Type as $IntConsumer$0$$Type} from "java.util.function.IntConsumer"
import {$IntConsumer, $IntConsumer$$Type} from "it.unimi.dsi.fastutil.ints.IntConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $IntBidirectionalIterator extends $IntIterator, $ObjectBidirectionalIterator<(integer)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): integer
 "back"(arg0: integer): integer
 "previousInt"(): integer
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(integer)>): void
 "forEachRemaining"(arg0: $IntConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "nextInt"(): integer
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $IntConsumer$0$$Type): void
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $IntBidirectionalIterator {
const probejs$$marker: never
}
export class $IntBidirectionalIterator$$Static implements $IntBidirectionalIterator {


 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): integer
 "back"(arg0: integer): integer
 "previousInt"(): integer
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(integer)>): void
 "forEachRemaining"(arg0: $IntConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "nextInt"(): integer
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $IntConsumer$0$$Type): void
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntBidirectionalIterator$$Type = ($IntBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntBidirectionalIterator_ = $IntBidirectionalIterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.Long2ObjectMap" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$LongFunction, $LongFunction$$Type} from "java.util.function.LongFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$ObjectCollection, $ObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.ObjectCollection"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Long2ObjectMap$Entry, $Long2ObjectMap$Entry$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectMap$Entry"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Long2ObjectMap<V> extends $Long2ObjectFunction<(V)>, $Map<(long), (V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: long, arg1: any): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "values"(): $ObjectCollection<(V)>
 "clear"(): void
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replace"(arg0: long, arg1: V): V
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
/**
 * 
 * @deprecated
 */
 "entrySet"(): $Set<(any)>
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(long), (V)>): void
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$$Type<(V)>): V
 "computeIfAbsent"(arg0: long, arg1: $LongFunction$$Type<(V)>): V
 "keySet"(): $Set<(any)>
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "long2ObjectEntrySet"(): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: long, arg1: $Long2ObjectFunction$$Type<(V)>): V
 "remove"(arg0: long): V
 "get"(arg0: long): V
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (long)>): $Function<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Long2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Long2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Long2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replace"(arg0: long, arg1: V): V
 "replaceAll"(arg0: $BiFunction$$Type<(long), (V), (V)>): void
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "putAll"(arg0: $Map$$Type<(long), (V)>): void
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
 "computeIfAbsent"(arg0: long, arg1: $Function$$Type<(long), (V)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
 "apply"(arg0: long): V
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(long), (V)>
[index: string | number]: V
get "empty"(): boolean
}

export namespace $Long2ObjectMap {
function copyOf<K, V>(arg0: $Map$$Type<(long), (V)>): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V): $Map<(long), (V)>
function of<K, V>(): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V, arg18: long, arg19: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V): $Map<(long), (V)>
function entry<K, V>(arg0: long, arg1: V): $Map$Entry<(long), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(long), (V)>)[]): $Map<(long), (V)>
function identity<T>(): $Function<(long), (long)>
const probejs$$marker: never
}
export class $Long2ObjectMap$$Static<V> implements $Long2ObjectMap {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: long, arg1: any): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "values"(): $ObjectCollection<(V)>
 "clear"(): void
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replace"(arg0: long, arg1: V): V
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
/**
 * 
 * @deprecated
 */
 "entrySet"(): $Set<(any)>
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(long), (V)>): void
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$$Type<(V)>): V
 "computeIfAbsent"(arg0: long, arg1: $LongFunction$$Type<(V)>): V
 "keySet"(): $Set<(any)>
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "long2ObjectEntrySet"(): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: long, arg1: $Long2ObjectFunction$$Type<(V)>): V
 "remove"(arg0: long): V
 "get"(arg0: long): V
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (long)>): $Function<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Long2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Long2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Long2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(long), (V)>): $Map<(long), (V)>
 "isEmpty"(): boolean
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replace"(arg0: long, arg1: V): V
 "replaceAll"(arg0: $BiFunction$$Type<(long), (V), (V)>): void
static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V): $Map<(long), (V)>
static "of"<K, V>(): $Map<(long), (V)>
static "of"<K, V>(arg0: long, arg1: V): $Map<(long), (V)>
static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V): $Map<(long), (V)>
static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V): $Map<(long), (V)>
static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V, arg18: long, arg19: V): $Map<(long), (V)>
static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V): $Map<(long), (V)>
static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V): $Map<(long), (V)>
static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V): $Map<(long), (V)>
static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V): $Map<(long), (V)>
static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V): $Map<(long), (V)>
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "putAll"(arg0: $Map$$Type<(long), (V)>): void
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
static "entry"<K, V>(arg0: long, arg1: V): $Map$Entry<(long), (V)>
 "computeIfAbsent"(arg0: long, arg1: $Function$$Type<(long), (V)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(long), (V)>)[]): $Map<(long), (V)>
 "apply"(arg0: long): V
static "identity"<T>(): $Function<(long), (long)>
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(long), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectMap$$Type<V> = ($Long2ObjectMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectMap_<V> = $Long2ObjectMap$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2CharFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Int2CharFunction extends $Function<(integer), (character)>, $IntUnaryOperator {

 "remove"(arg0: integer): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: character): character
 "put"(arg0: integer, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: integer, arg1: character): character
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): character
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: integer): character
}

export namespace $Int2CharFunction {
function identity(): $IntUnaryOperator
const probejs$$marker: never
}
export class $Int2CharFunction$$Static implements $Int2CharFunction {


 "remove"(arg0: integer): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: character): character
 "put"(arg0: integer, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: integer, arg1: character): character
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): character
static "identity"(): $IntUnaryOperator
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2CharFunction$$Type = ((arg0: integer) => character);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2CharFunction_ = $Int2CharFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.IntSet" {
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$IntStream, $IntStream$$Type} from "java.util.stream.IntStream"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IntCollection, $IntCollection$$Type} from "it.unimi.dsi.fastutil.ints.IntCollection"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$$Type as $IntPredicate$0$$Type} from "java.util.function.IntPredicate"
import {$IntSpliterator, $IntSpliterator$$Type} from "it.unimi.dsi.fastutil.ints.IntSpliterator"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$IntIterator, $IntIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntIterator"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$$Type as $IntConsumer$0$$Type} from "java.util.function.IntConsumer"
import {$IntPredicate, $IntPredicate$$Type} from "it.unimi.dsi.fastutil.ints.IntPredicate"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$IntConsumer, $IntConsumer$$Type} from "it.unimi.dsi.fastutil.ints.IntConsumer"

export interface $IntSet extends $IntCollection, $Set<(integer)> {

 "remove"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "iterator"(): $Iterator<(any)>
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $IntSpliterator
/**
 * 
 * @deprecated
 */
 "rem"(arg0: integer): boolean
 "add"(arg0: integer): boolean
 "toArray"(arg0: (integer)[]): (integer)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
 "contains"(arg0: integer): boolean
 "addAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(integer)>): boolean
 "removeIf"(arg0: $IntPredicate$0$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $IntCollection$$Type): boolean
 "retainAll"(arg0: $IntCollection$$Type): boolean
 "containsAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
 "toIntArray"(): (integer)[]
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: $Collection$$Type<(integer)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $IntConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(integer)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
[Symbol.iterator](): IterableIterator<any>;
get "empty"(): boolean
}

export namespace $IntSet {
function of(arg0: integer, arg1: integer): $IntSet
function of(): $IntSet
function of(...arg0: (integer)[]): $IntSet
function of(arg0: integer): $IntSet
function of(arg0: integer, arg1: integer, arg2: integer): $IntSet
function copyOf<E>(arg0: $Collection$$Type<(integer)>): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $Set<(integer)>
function of<E>(...arg0: (integer)[]): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer): $Set<(integer)>
function of<E>(arg0: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer): $Set<(integer)>
const probejs$$marker: never
}
export class $IntSet$$Static implements $IntSet {


 "remove"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "iterator"(): $Iterator<(any)>
static "of"(arg0: integer, arg1: integer): $IntSet
static "of"(): $IntSet
static "of"(...arg0: (integer)[]): $IntSet
static "of"(arg0: integer): $IntSet
static "of"(arg0: integer, arg1: integer, arg2: integer): $IntSet
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $IntSpliterator
/**
 * 
 * @deprecated
 */
 "rem"(arg0: integer): boolean
 "add"(arg0: integer): boolean
 "toArray"(arg0: (integer)[]): (integer)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
 "contains"(arg0: integer): boolean
 "addAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(integer)>): boolean
 "removeIf"(arg0: $IntPredicate$0$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $IntCollection$$Type): boolean
 "retainAll"(arg0: $IntCollection$$Type): boolean
 "containsAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
 "toIntArray"(): (integer)[]
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<E>(arg0: $Collection$$Type<(integer)>): $Set<(integer)>
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $Set<(integer)>
static "of"<E>(...arg0: (integer)[]): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer): $Set<(integer)>
static "of"<E>(arg0: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer): $Set<(integer)>
 "addAll"(arg0: $Collection$$Type<(integer)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $IntConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(integer)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntSet$$Type = ($IntSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntSet_ = $IntSet$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.AbstractObjectSet" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$AbstractObjectCollection, $AbstractObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.AbstractObjectCollection"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$ObjectIterator, $ObjectIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectIterator"
import {$Cloneable, $Cloneable$$Type} from "java.lang.Cloneable"
import {$Set, $Set$$Type} from "java.util.Set"

export class $AbstractObjectSet<K> extends $AbstractObjectCollection<(K)> implements $Cloneable, $ObjectSet<(K)> {


public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "iterator"(): $ObjectIterator<(K)>
public static "of"<K>(arg0: K, arg1: K): $ObjectSet<(K)>
public static "of"<K>(...arg0: (K)[]): $ObjectSet<(K)>
public static "of"<K>(arg0: K, arg1: K, arg2: K): $ObjectSet<(K)>
public static "of"<K>(): $ObjectSet<(K)>
public static "of"<K>(arg0: K): $ObjectSet<(K)>
public "spliterator"(): $Spliterator<(any)>
public "remove"(arg0: any): boolean
public "size"(): integer
public static "copyOf"<E>(arg0: $Collection$$Type<(K)>): $Set<(K)>
public "clear"(): void
public "isEmpty"(): boolean
public "add"(arg0: K): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$$Type<(K)>): boolean
public "removeAll"(arg0: $Collection$$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObjectSet$$Type<K> = ($AbstractObjectSet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObjectSet_<K> = $AbstractObjectSet$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.longs.LongSet" {
import {$LongPredicate as $LongPredicate$0, $LongPredicate$$Type as $LongPredicate$0$$Type} from "java.util.function.LongPredicate"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$LongStream, $LongStream$$Type} from "java.util.stream.LongStream"
import {$LongConsumer, $LongConsumer$$Type} from "it.unimi.dsi.fastutil.longs.LongConsumer"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$LongPredicate, $LongPredicate$$Type} from "it.unimi.dsi.fastutil.longs.LongPredicate"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$$Type as $LongConsumer$0$$Type} from "java.util.function.LongConsumer"
import {$LongSpliterator, $LongSpliterator$$Type} from "it.unimi.dsi.fastutil.longs.LongSpliterator"
import {$Set, $Set$$Type} from "java.util.Set"
import {$LongIterator, $LongIterator$$Type} from "it.unimi.dsi.fastutil.longs.LongIterator"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$LongCollection, $LongCollection$$Type} from "it.unimi.dsi.fastutil.longs.LongCollection"

export interface $LongSet extends $LongCollection, $Set<(long)> {

 "remove"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "iterator"(): $Iterator<(any)>
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $LongSpliterator
/**
 * 
 * @deprecated
 */
 "rem"(arg0: long): boolean
 "add"(arg0: long): boolean
 "toArray"(arg0: (long)[]): (long)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
 "addAll"(arg0: $LongCollection$$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(long)>): boolean
 "removeIf"(arg0: $LongPredicate$$Type): boolean
 "removeAll"(arg0: $LongCollection$$Type): boolean
 "retainAll"(arg0: $LongCollection$$Type): boolean
 "containsAll"(arg0: $LongCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "longStream"(): $LongStream
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "toLongArray"(): (long)[]
 "longIterator"(): $LongIterator
 "longParallelStream"(): $LongStream
 "longSpliterator"(): $LongSpliterator
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: $Collection$$Type<(long)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $LongConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(long)>): void
 "forEach"(arg0: $LongConsumer$$Type): void
[Symbol.iterator](): IterableIterator<any>;
get "empty"(): boolean
}

export namespace $LongSet {
function of(arg0: long, arg1: long): $LongSet
function of(): $LongSet
function of(...arg0: (long)[]): $LongSet
function of(arg0: long): $LongSet
function of(arg0: long, arg1: long, arg2: long): $LongSet
function copyOf<E>(arg0: $Collection$$Type<(long)>): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $Set<(long)>
function of<E>(...arg0: (long)[]): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long): $Set<(long)>
function of<E>(arg0: long): $Set<(long)>
function of<E>(arg0: long, arg1: long): $Set<(long)>
const probejs$$marker: never
}
export class $LongSet$$Static implements $LongSet {


 "remove"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "iterator"(): $Iterator<(any)>
static "of"(arg0: long, arg1: long): $LongSet
static "of"(): $LongSet
static "of"(...arg0: (long)[]): $LongSet
static "of"(arg0: long): $LongSet
static "of"(arg0: long, arg1: long, arg2: long): $LongSet
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $LongSpliterator
/**
 * 
 * @deprecated
 */
 "rem"(arg0: long): boolean
 "add"(arg0: long): boolean
 "toArray"(arg0: (long)[]): (long)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
 "addAll"(arg0: $LongCollection$$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(long)>): boolean
 "removeIf"(arg0: $LongPredicate$$Type): boolean
 "removeAll"(arg0: $LongCollection$$Type): boolean
 "retainAll"(arg0: $LongCollection$$Type): boolean
 "containsAll"(arg0: $LongCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "longStream"(): $LongStream
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "toLongArray"(): (long)[]
 "longIterator"(): $LongIterator
 "longParallelStream"(): $LongStream
 "longSpliterator"(): $LongSpliterator
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<E>(arg0: $Collection$$Type<(long)>): $Set<(long)>
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $Set<(long)>
static "of"<E>(...arg0: (long)[]): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long): $Set<(long)>
static "of"<E>(arg0: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long): $Set<(long)>
 "addAll"(arg0: $Collection$$Type<(long)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $LongConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(long)>): void
 "forEach"(arg0: $LongConsumer$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongSet$$Type = ($LongSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongSet_ = $LongSet$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2ObjectFunction" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Int2ObjectFunction<V> extends $Function<(integer), (V)>, $IntFunction<(V)> {

 "remove"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Int2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Int2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(integer), (V)>

(arg0: integer): V
}

export namespace $Int2ObjectFunction {
function identity<T>(): $Function$0<(integer), (integer)>
const probejs$$marker: never
}
export class $Int2ObjectFunction$$Static<V> implements $Int2ObjectFunction {


 "remove"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Int2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Int2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): V
static "identity"<T>(): $Function$0<(integer), (integer)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(integer), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ObjectFunction$$Type<V> = ((arg0: integer) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ObjectFunction_<V> = $Int2ObjectFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.longs.AbstractLong2ObjectMap" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Long2ObjectMap, $Long2ObjectMap$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectMap"
import {$LongFunction, $LongFunction$$Type} from "java.util.function.LongFunction"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ObjectCollection, $ObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.ObjectCollection"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$AbstractLong2ObjectFunction, $AbstractLong2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.AbstractLong2ObjectFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Long2ObjectMap$Entry, $Long2ObjectMap$Entry$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectMap$Entry"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export class $AbstractLong2ObjectMap<V> extends $AbstractLong2ObjectFunction<(V)> implements $Long2ObjectMap<(V)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $ObjectCollection<(V)>
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$$Type<(long), (V)>): void
public "containsKey"(arg0: long): boolean
public "keySet"(): $Set<(any)>
public "containsValue"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): V
public "remove"(arg0: long, arg1: any): boolean
public "size"(): integer
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
public "put"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
public "put"(arg0: any, arg1: any): any
public "clear"(): void
public "replace"(arg0: long, arg1: V, arg2: V): boolean
public "replace"(arg0: long, arg1: V): V
public "merge"(arg0: long, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
/**
 * 
 * @deprecated
 */
public "entrySet"(): $Set<(any)>
public "putIfAbsent"(arg0: long, arg1: V): V
public "compute"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
public "forEach"(arg0: $BiConsumer$$Type<(long), (V)>): void
/**
 * 
 * @deprecated
 */
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$$Type<(V)>): V
public "computeIfAbsent"(arg0: long, arg1: $LongFunction$$Type<(V)>): V
public "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public "long2ObjectEntrySet"(): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
public "computeIfAbsentPartial"(arg0: long, arg1: $Long2ObjectFunction$$Type<(V)>): V
public "remove"(arg0: any, arg1: any): boolean
public static "copyOf"<K, V>(arg0: $Map$$Type<(long), (V)>): $Map<(long), (V)>
public "replace"(arg0: long, arg1: V, arg2: V): boolean
public "replace"(arg0: long, arg1: V): V
public "replaceAll"(arg0: $BiFunction$$Type<(long), (V), (V)>): void
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V): $Map<(long), (V)>
public static "of"<K, V>(): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V, arg18: long, arg19: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V): $Map<(long), (V)>
public "merge"(arg0: long, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
public "putIfAbsent"(arg0: long, arg1: V): V
public "compute"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
public static "entry"<K, V>(arg0: long, arg1: V): $Map$Entry<(long), (V)>
public "computeIfAbsent"(arg0: long, arg1: $Function$$Type<(long), (V)>): V
public "computeIfPresent"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(long), (V)>)[]): $Map<(long), (V)>
public static "identity"<T>(): $Function<(long), (long)>
[index: string | number]: V
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLong2ObjectMap$$Type<V> = ($AbstractLong2ObjectMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLong2ObjectMap_<V> = $AbstractLong2ObjectMap$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$DoubleFunction, $DoubleFunction$$Type} from "java.util.function.DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Double2ReferenceFunction<V> extends $Function<(double), (V)>, $DoubleFunction<(V)> {

 "remove"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: double, arg1: V): V
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: double, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Double2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Double2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(double), (V)>

(arg0: double): V
}

export namespace $Double2ReferenceFunction {
function identity<T>(): $Function$0<(double), (double)>
const probejs$$marker: never
}
export class $Double2ReferenceFunction$$Static<V> implements $Double2ReferenceFunction {


 "remove"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: double, arg1: V): V
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: double, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Double2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Double2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): V
static "identity"<T>(): $Function$0<(double), (double)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(double), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2ReferenceFunction$$Type<V> = ((arg0: double) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2ReferenceFunction_<V> = $Double2ReferenceFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.doubles.DoubleUnaryOperator" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$DoubleUnaryOperator as $DoubleUnaryOperator$0, $DoubleUnaryOperator$$Type as $DoubleUnaryOperator$0$$Type} from "java.util.function.DoubleUnaryOperator"
import {$Function, $Function$$Type} from "java.util.function.Function"

export interface $DoubleUnaryOperator extends $UnaryOperator<(double)>, $DoubleUnaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: double): double
 "apply"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double): double
 "compose"(arg0: $DoubleUnaryOperator$0$$Type): $DoubleUnaryOperator$0
 "andThen"(arg0: $DoubleUnaryOperator$0$$Type): $DoubleUnaryOperator$0
 "compose"<V>(arg0: $Function$$Type<(V), (double)>): $Function<(V), (double)>
 "andThen"<V>(arg0: $Function$$Type<(double), (V)>): $Function<(double), (V)>

(arg0: double): double
}

export namespace $DoubleUnaryOperator {
function identity(): $DoubleUnaryOperator
function negation(): $DoubleUnaryOperator
const probejs$$marker: never
}
export class $DoubleUnaryOperator$$Static implements $DoubleUnaryOperator {


/**
 * 
 * @deprecated
 */
 "apply"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: double): double
 "apply"(arg0: double): double
static "identity"(): $DoubleUnaryOperator
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double): double
static "negation"(): $DoubleUnaryOperator
 "compose"(arg0: $DoubleUnaryOperator$0$$Type): $DoubleUnaryOperator$0
 "andThen"(arg0: $DoubleUnaryOperator$0$$Type): $DoubleUnaryOperator$0
 "compose"<V>(arg0: $Function$$Type<(V), (double)>): $Function<(V), (double)>
 "andThen"<V>(arg0: $Function$$Type<(double), (V)>): $Function<(double), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleUnaryOperator$$Type = ((arg0: double) => double);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleUnaryOperator_ = $DoubleUnaryOperator$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2FloatMap" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$ToDoubleFunction, $ToDoubleFunction$$Type} from "java.util.function.ToDoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$FloatBinaryOperator, $FloatBinaryOperator$$Type} from "it.unimi.dsi.fastutil.floats.FloatBinaryOperator"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$DoubleBinaryOperator, $DoubleBinaryOperator$$Type} from "java.util.function.DoubleBinaryOperator"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2FloatMap$Entry, $Object2FloatMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatMap$Entry"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Object2FloatMap<K> extends $Object2FloatFunction<(K)>, $Map<(K), (float)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
 "remove"(arg0: any, arg1: float): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: float): float
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: float): float
 "replace"(arg0: K, arg1: float, arg2: float): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: float, arg2: float): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: float, arg2: $BiFunction$$Type<(float), (float), (float)>): float
 "merge"(arg0: K, arg1: float, arg2: $BiFunction$$Type<(float), (float), (float)>): float
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (float)>)>
 "putIfAbsent"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
 "forEach"(arg0: $BiConsumer$$Type<(K), (float)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToDoubleFunction$$Type<(K)>): float
 "computeIfAbsent"(arg0: K, arg1: $Object2FloatFunction$$Type<(K)>): float
 "keySet"(): $ObjectSet<(K)>
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: float): boolean
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "computeFloat"(arg0: K, arg1: $BiFunction$$Type<(K), (float), (float)>): float
/**
 * 
 * @deprecated
 */
 "computeFloatIfAbsentPartial"(arg0: K, arg1: $Object2FloatFunction$$Type<(K)>): float
 "computeFloatIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (float), (float)>): float
/**
 * 
 * @deprecated
 */
 "computeFloatIfAbsent"(arg0: K, arg1: $ToDoubleFunction$$Type<(K)>): float
 "object2FloatEntrySet"(): $ObjectSet<($Object2FloatMap$Entry<(K)>)>
 "mergeFloat"(arg0: K, arg1: float, arg2: $DoubleBinaryOperator$$Type): float
/**
 * 
 * @deprecated
 */
 "mergeFloat"(arg0: K, arg1: float, arg2: $BiFunction$$Type<(float), (float), (float)>): float
 "mergeFloat"(arg0: K, arg1: float, arg2: $FloatBinaryOperator$$Type): float
 "put"(arg0: K, arg1: float): float
 "getFloat"(arg0: any): float
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(float), (T)>): $Function<(K), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2FloatFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2FloatFunction
 "removeFloat"(arg0: any): float
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (float), (float)>): void
 "putAll"(arg0: $Map$$Type<(K), (float)>): void
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (float), (float)>): float
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (float)>): float
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (float), (float)>): float
 "apply"(arg0: K): float
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (float)>
[index: string | number]: float
get "empty"(): boolean
}

export namespace $Object2FloatMap {
function copyOf<K, V>(arg0: $Map$$Type<(K), (float)>): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float): $Map<(K), (float)>
function of<K, V>(): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float, arg16: K, arg17: float, arg18: K, arg19: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float, arg16: K, arg17: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float): $Map<(K), (float)>
function entry<K, V>(arg0: K, arg1: float): $Map$Entry<(K), (float)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(K), (float)>)[]): $Map<(K), (float)>
function identity<T>(): $Function<(K), (K)>
const probejs$$marker: never
}
export class $Object2FloatMap$$Static<K> implements $Object2FloatMap {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
 "remove"(arg0: any, arg1: float): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: float): float
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: float): float
 "replace"(arg0: K, arg1: float, arg2: float): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: float, arg2: float): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: float, arg2: $BiFunction$$Type<(float), (float), (float)>): float
 "merge"(arg0: K, arg1: float, arg2: $BiFunction$$Type<(float), (float), (float)>): float
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (float)>)>
 "putIfAbsent"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
 "forEach"(arg0: $BiConsumer$$Type<(K), (float)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToDoubleFunction$$Type<(K)>): float
 "computeIfAbsent"(arg0: K, arg1: $Object2FloatFunction$$Type<(K)>): float
 "keySet"(): $ObjectSet<(K)>
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: float): boolean
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "computeFloat"(arg0: K, arg1: $BiFunction$$Type<(K), (float), (float)>): float
/**
 * 
 * @deprecated
 */
 "computeFloatIfAbsentPartial"(arg0: K, arg1: $Object2FloatFunction$$Type<(K)>): float
 "computeFloatIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (float), (float)>): float
/**
 * 
 * @deprecated
 */
 "computeFloatIfAbsent"(arg0: K, arg1: $ToDoubleFunction$$Type<(K)>): float
 "object2FloatEntrySet"(): $ObjectSet<($Object2FloatMap$Entry<(K)>)>
 "mergeFloat"(arg0: K, arg1: float, arg2: $DoubleBinaryOperator$$Type): float
/**
 * 
 * @deprecated
 */
 "mergeFloat"(arg0: K, arg1: float, arg2: $BiFunction$$Type<(float), (float), (float)>): float
 "mergeFloat"(arg0: K, arg1: float, arg2: $FloatBinaryOperator$$Type): float
 "put"(arg0: K, arg1: float): float
 "getFloat"(arg0: any): float
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(float), (T)>): $Function<(K), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2FloatFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2FloatFunction
 "removeFloat"(arg0: any): float
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(K), (float)>): $Map<(K), (float)>
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (float), (float)>): void
static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float): $Map<(K), (float)>
static "of"<K, V>(): $Map<(K), (float)>
static "of"<K, V>(arg0: K, arg1: float): $Map<(K), (float)>
static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float): $Map<(K), (float)>
static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float): $Map<(K), (float)>
static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float, arg16: K, arg17: float, arg18: K, arg19: float): $Map<(K), (float)>
static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float, arg16: K, arg17: float): $Map<(K), (float)>
static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float): $Map<(K), (float)>
static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float): $Map<(K), (float)>
static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float): $Map<(K), (float)>
static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float): $Map<(K), (float)>
 "putAll"(arg0: $Map$$Type<(K), (float)>): void
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (float), (float)>): float
static "entry"<K, V>(arg0: K, arg1: float): $Map$Entry<(K), (float)>
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (float)>): float
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (float), (float)>): float
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (float)>)[]): $Map<(K), (float)>
 "apply"(arg0: K): float
static "identity"<T>(): $Function<(K), (K)>
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2FloatMap$$Type<K> = ($Object2FloatMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2FloatMap_<K> = $Object2FloatMap$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.ints.IntListIterator" {
import {$ListIterator, $ListIterator$$Type} from "java.util.ListIterator"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$$Type as $IntConsumer$0$$Type} from "java.util.function.IntConsumer"
import {$IntConsumer, $IntConsumer$$Type} from "it.unimi.dsi.fastutil.ints.IntConsumer"
import {$IntBidirectionalIterator, $IntBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntBidirectionalIterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $IntListIterator extends $IntBidirectionalIterator, $ListIterator<(integer)> {

 "remove"(): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): void
 "add"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "next"(): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer): void
 "set"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "previous"(): any
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousInt"(): integer
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(integer)>): void
 "forEachRemaining"(arg0: $IntConsumer$$Type): void
 "nextInt"(): integer
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $IntConsumer$0$$Type): void
}

export namespace $IntListIterator {
const probejs$$marker: never
}
export class $IntListIterator$$Static implements $IntListIterator {


 "remove"(): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): void
 "add"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "next"(): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer): void
 "set"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "previous"(): any
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousInt"(): integer
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(integer)>): void
 "forEachRemaining"(arg0: $IntConsumer$$Type): void
 "nextInt"(): integer
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $IntConsumer$0$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntListIterator$$Type = ($IntListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntListIterator_ = $IntListIterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.ShortSet" {
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$ShortPredicate, $ShortPredicate$$Type} from "it.unimi.dsi.fastutil.shorts.ShortPredicate"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$IntStream, $IntStream$$Type} from "java.util.stream.IntStream"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IntPredicate, $IntPredicate$$Type} from "java.util.function.IntPredicate"
import {$IntSpliterator, $IntSpliterator$$Type} from "it.unimi.dsi.fastutil.ints.IntSpliterator"
import {$ShortSpliterator, $ShortSpliterator$$Type} from "it.unimi.dsi.fastutil.shorts.ShortSpliterator"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$IntIterator, $IntIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntIterator"
import {$ShortConsumer, $ShortConsumer$$Type} from "it.unimi.dsi.fastutil.shorts.ShortConsumer"
import {$ShortCollection, $ShortCollection$$Type} from "it.unimi.dsi.fastutil.shorts.ShortCollection"
import {$IntConsumer, $IntConsumer$$Type} from "java.util.function.IntConsumer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"

export interface $ShortSet extends $ShortCollection, $Set<(short)> {

 "remove"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "iterator"(): $Iterator<(any)>
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $ShortSpliterator
/**
 * 
 * @deprecated
 */
 "rem"(arg0: short): boolean
 "add"(arg0: short): boolean
 "toArray"(arg0: (short)[]): (short)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(short)>
 "intStream"(): $IntStream
 "contains"(arg0: short): boolean
 "addAll"(arg0: $ShortCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(short)>): boolean
 "removeIf"(arg0: $ShortPredicate$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $ShortCollection$$Type): boolean
 "retainAll"(arg0: $ShortCollection$$Type): boolean
 "containsAll"(arg0: $ShortCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(short)>
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "toShortArray"(): (short)[]
/**
 * 
 * @deprecated
 */
 "toShortArray"(arg0: (short)[]): (short)[]
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: $Collection$$Type<(short)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $ShortConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(short)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
[Symbol.iterator](): IterableIterator<any>;
get "empty"(): boolean
}

export namespace $ShortSet {
function of(arg0: short, arg1: short): $ShortSet
function of(): $ShortSet
function of(...arg0: (short)[]): $ShortSet
function of(arg0: short): $ShortSet
function of(arg0: short, arg1: short, arg2: short): $ShortSet
function copyOf<E>(arg0: $Collection$$Type<(short)>): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short, arg9: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short): $Set<(short)>
function of<E>(...arg0: (short)[]): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short): $Set<(short)>
function of<E>(arg0: short): $Set<(short)>
function of<E>(arg0: short, arg1: short): $Set<(short)>
const probejs$$marker: never
}
export class $ShortSet$$Static implements $ShortSet {


 "remove"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "iterator"(): $Iterator<(any)>
static "of"(arg0: short, arg1: short): $ShortSet
static "of"(): $ShortSet
static "of"(...arg0: (short)[]): $ShortSet
static "of"(arg0: short): $ShortSet
static "of"(arg0: short, arg1: short, arg2: short): $ShortSet
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $ShortSpliterator
/**
 * 
 * @deprecated
 */
 "rem"(arg0: short): boolean
 "add"(arg0: short): boolean
 "toArray"(arg0: (short)[]): (short)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(short)>
 "intStream"(): $IntStream
 "contains"(arg0: short): boolean
 "addAll"(arg0: $ShortCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(short)>): boolean
 "removeIf"(arg0: $ShortPredicate$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $ShortCollection$$Type): boolean
 "retainAll"(arg0: $ShortCollection$$Type): boolean
 "containsAll"(arg0: $ShortCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(short)>
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "toShortArray"(): (short)[]
/**
 * 
 * @deprecated
 */
 "toShortArray"(arg0: (short)[]): (short)[]
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<E>(arg0: $Collection$$Type<(short)>): $Set<(short)>
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short): $Set<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short): $Set<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short): $Set<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short, arg9: short): $Set<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short): $Set<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short): $Set<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short): $Set<(short)>
static "of"<E>(...arg0: (short)[]): $Set<(short)>
static "of"<E>(arg0: short, arg1: short, arg2: short): $Set<(short)>
static "of"<E>(arg0: short): $Set<(short)>
static "of"<E>(arg0: short, arg1: short): $Set<(short)>
 "addAll"(arg0: $Collection$$Type<(short)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "forEach"(arg0: $ShortConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(short)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortSet$$Type = ($ShortSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortSet_ = $ShortSet$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.IntBidirectionalIterable" {
import {$IntIterator, $IntIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntIterator"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$$Type as $IntConsumer$0$$Type} from "java.util.function.IntConsumer"
import {$IntSpliterator, $IntSpliterator$$Type} from "it.unimi.dsi.fastutil.ints.IntSpliterator"
import {$IntConsumer, $IntConsumer$$Type} from "it.unimi.dsi.fastutil.ints.IntConsumer"
import {$IntIterable, $IntIterable$$Type} from "it.unimi.dsi.fastutil.ints.IntIterable"
import {$IntBidirectionalIterator, $IntBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntBidirectionalIterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $IntBidirectionalIterable extends $IntIterable {

 "iterator"(): $IntBidirectionalIterator
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $IntConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(integer)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
 "intIterator"(): $IntIterator
 "intSpliterator"(): $IntSpliterator

(): $IntBidirectionalIterator$$Type
}

export namespace $IntBidirectionalIterable {
const probejs$$marker: never
}
export class $IntBidirectionalIterable$$Static implements $IntBidirectionalIterable {


 "iterator"(): $IntBidirectionalIterator
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $IntConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(integer)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
 "intIterator"(): $IntIterator
 "intSpliterator"(): $IntSpliterator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntBidirectionalIterable$$Type = (() => $IntBidirectionalIterator$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntBidirectionalIterable_ = $IntBidirectionalIterable$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2ByteFunction" {
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Reference2ByteFunction<K> extends $Function<(K), (byte)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getByte"(arg0: any): byte
 "getOrDefault"(arg0: any, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2ByteFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2ByteFunction
 "removeByte"(arg0: any): byte
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): byte
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (byte)>

(arg0: any): byte
}

export namespace $Reference2ByteFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Reference2ByteFunction$$Static<K> implements $Reference2ByteFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getByte"(arg0: any): byte
 "getOrDefault"(arg0: any, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2ByteFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2ByteFunction
 "removeByte"(arg0: any): byte
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): byte
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ByteFunction$$Type<K> = ((arg0: any) => byte);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ByteFunction_<K> = $Reference2ByteFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.objects.ObjectSortedSet" {
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$SortedSet, $SortedSet$$Type} from "java.util.SortedSet"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$ObjectBidirectionalIterable, $ObjectBidirectionalIterable$$Type} from "it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterable"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$SequencedSet, $SequencedSet$$Type} from "java.util.SequencedSet"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"

export interface $ObjectSortedSet<K> extends $ObjectSet<(K)>, $SortedSet<(K)>, $ObjectBidirectionalIterable<(K)> {

 "iterator"(): $Iterator<(any)>
 "iterator"(arg0: K): $ObjectBidirectionalIterator<(K)>
 "spliterator"(): $Spliterator<(any)>
 "subSet"(arg0: any, arg1: any): $SortedSet<(any)>
 "headSet"(arg0: any): $SortedSet<(any)>
 "tailSet"(arg0: any): $SortedSet<(any)>
 "last"(): K
 "first"(): K
 "getFirst"(): K
 "getLast"(): K
 "addFirst"(arg0: K): void
 "addLast"(arg0: K): void
 "removeFirst"(): K
 "removeLast"(): K
 "reversed"(): $SequencedSet<(any)>
 "comparator"(): $Comparator<(K)>
 "remove"(arg0: any): boolean
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "add"(arg0: K): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$$Type<(K)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$$Type<(K)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
[Symbol.iterator](): IterableIterator<any>;
get "empty"(): boolean
}

export namespace $ObjectSortedSet {
function of<K>(arg0: K, arg1: K): $ObjectSet<(K)>
function of<K>(...arg0: (K)[]): $ObjectSet<(K)>
function of<K>(arg0: K, arg1: K, arg2: K): $ObjectSet<(K)>
function of<K>(): $ObjectSet<(K)>
function of<K>(arg0: K): $ObjectSet<(K)>
function copyOf<E>(arg0: $Collection$$Type<(K)>): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
const probejs$$marker: never
}
export class $ObjectSortedSet$$Static<K> implements $ObjectSortedSet {


 "iterator"(): $Iterator<(any)>
 "iterator"(arg0: K): $ObjectBidirectionalIterator<(K)>
 "spliterator"(): $Spliterator<(any)>
 "subSet"(arg0: any, arg1: any): $SortedSet<(any)>
 "headSet"(arg0: any): $SortedSet<(any)>
 "tailSet"(arg0: any): $SortedSet<(any)>
static "of"<K>(arg0: K, arg1: K): $ObjectSet<(K)>
static "of"<K>(...arg0: (K)[]): $ObjectSet<(K)>
static "of"<K>(arg0: K, arg1: K, arg2: K): $ObjectSet<(K)>
static "of"<K>(): $ObjectSet<(K)>
static "of"<K>(arg0: K): $ObjectSet<(K)>
 "last"(): K
 "first"(): K
 "getFirst"(): K
 "getLast"(): K
 "addFirst"(arg0: K): void
 "addLast"(arg0: K): void
 "removeFirst"(): K
 "removeLast"(): K
 "reversed"(): $SequencedSet<(any)>
 "comparator"(): $Comparator<(K)>
 "remove"(arg0: any): boolean
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<E>(arg0: $Collection$$Type<(K)>): $Set<(K)>
 "clear"(): void
 "isEmpty"(): boolean
 "add"(arg0: K): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$$Type<(K)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$$Type<(K)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectSortedSet$$Type<K> = ($ObjectSortedSet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectSortedSet_<K> = $ObjectSortedSet$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.booleans.BooleanPredicate" {
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"

export interface $BooleanPredicate extends $Predicate<(boolean)> {

/**
 * 
 * @deprecated
 */
 "test"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: any): boolean
 "test"(arg0: boolean): boolean
 "or"(arg0: $BooleanPredicate$$Type): $BooleanPredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$$Type<(boolean)>): $Predicate<(boolean)>
 "negate"(): $Predicate<(any)>
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$$Type<(boolean)>): $Predicate<(boolean)>
 "and"(arg0: $BooleanPredicate$$Type): $BooleanPredicate

(arg0: boolean): boolean
}

export namespace $BooleanPredicate {
function identity(): $BooleanPredicate
function negation(): $BooleanPredicate
function not<T>(arg0: $Predicate$$Type<(boolean)>): $Predicate<(boolean)>
function isEqual<T>(arg0: any): $Predicate<(boolean)>
const probejs$$marker: never
}
export class $BooleanPredicate$$Static implements $BooleanPredicate {


/**
 * 
 * @deprecated
 */
 "test"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: any): boolean
 "test"(arg0: boolean): boolean
static "identity"(): $BooleanPredicate
 "or"(arg0: $BooleanPredicate$$Type): $BooleanPredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$$Type<(boolean)>): $Predicate<(boolean)>
 "negate"(): $Predicate<(any)>
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$$Type<(boolean)>): $Predicate<(boolean)>
 "and"(arg0: $BooleanPredicate$$Type): $BooleanPredicate
static "negation"(): $BooleanPredicate
static "not"<T>(arg0: $Predicate$$Type<(boolean)>): $Predicate<(boolean)>
static "isEqual"<T>(arg0: any): $Predicate<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanPredicate$$Type = ((arg0: boolean) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanPredicate_ = $BooleanPredicate$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.ObjectCollection" {
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$ObjectSpliterator, $ObjectSpliterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSpliterator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$ObjectIterable, $ObjectIterable$$Type} from "it.unimi.dsi.fastutil.objects.ObjectIterable"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ObjectCollection<K> extends $Collection<(K)>, $ObjectIterable<(K)> {

 "iterator"(): $Iterator<(any)>
 "spliterator"(): $ObjectSpliterator<(K)>
 "remove"(arg0: any): boolean
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "add"(arg0: K): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "stream"(): $Stream<(K)>
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$$Type<(K)>): boolean
 "removeIf"(arg0: $Predicate$$Type<(K)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
[Symbol.iterator](): IterableIterator<any>;
get "empty"(): boolean
}

export namespace $ObjectCollection {
const probejs$$marker: never
}
export class $ObjectCollection$$Static<K> implements $ObjectCollection {


 "iterator"(): $Iterator<(any)>
 "spliterator"(): $ObjectSpliterator<(K)>
 "remove"(arg0: any): boolean
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "add"(arg0: K): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "stream"(): $Stream<(K)>
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$$Type<(K)>): boolean
 "removeIf"(arg0: $Predicate$$Type<(K)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectCollection$$Type<K> = ($ObjectCollection<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectCollection_<K> = $ObjectCollection$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.longs.LongBidirectionalIterator" {
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$$Type as $LongConsumer$0$$Type} from "java.util.function.LongConsumer"
import {$LongIterator, $LongIterator$$Type} from "it.unimi.dsi.fastutil.longs.LongIterator"
import {$LongConsumer, $LongConsumer$$Type} from "it.unimi.dsi.fastutil.longs.LongConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $LongBidirectionalIterator extends $LongIterator, $ObjectBidirectionalIterator<(long)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): long
 "back"(arg0: integer): integer
 "previousLong"(): long
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(long)>): void
 "forEachRemaining"(arg0: $LongConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "nextLong"(): long
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $LongConsumer$0$$Type): void
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $LongBidirectionalIterator {
const probejs$$marker: never
}
export class $LongBidirectionalIterator$$Static implements $LongBidirectionalIterator {


 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): long
 "back"(arg0: integer): integer
 "previousLong"(): long
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(long)>): void
 "forEachRemaining"(arg0: $LongConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "nextLong"(): long
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $LongConsumer$0$$Type): void
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongBidirectionalIterator$$Type = ($LongBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongBidirectionalIterator_ = $LongBidirectionalIterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.Long2LongFunction" {
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$LongUnaryOperator, $LongUnaryOperator$$Type} from "java.util.function.LongUnaryOperator"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Long2LongFunction extends $Function<(long), (long)>, $LongUnaryOperator {

 "remove"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: long, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: long, arg1: long): long
 "applyAsLong"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): long
 "compose"(arg0: $LongUnaryOperator$$Type): $LongUnaryOperator
 "andThen"(arg0: $LongUnaryOperator$$Type): $LongUnaryOperator

(arg0: long): long
}

export namespace $Long2LongFunction {
function identity(): $Long2LongFunction
const probejs$$marker: never
}
export class $Long2LongFunction$$Static implements $Long2LongFunction {


 "remove"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: long, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: long): long
static "identity"(): $Long2LongFunction
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: long, arg1: long): long
 "applyAsLong"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): long
 "compose"(arg0: $LongUnaryOperator$$Type): $LongUnaryOperator
 "andThen"(arg0: $LongUnaryOperator$$Type): $LongUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2LongFunction$$Type = ((arg0: long) => long);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2LongFunction_ = $Long2LongFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.floats.Float2LongFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$DoubleToLongFunction, $DoubleToLongFunction$$Type} from "java.util.function.DoubleToLongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Float2LongFunction extends $Function<(float), (long)>, $DoubleToLongFunction {

 "remove"(arg0: float): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: long): long
 "put"(arg0: float, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: float, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: double): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): long

(arg0: float): long
}

export namespace $Float2LongFunction {
function identity<T>(): $Function$0<(float), (float)>
const probejs$$marker: never
}
export class $Float2LongFunction$$Static implements $Float2LongFunction {


 "remove"(arg0: float): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: long): long
 "put"(arg0: float, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: float, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: double): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): long
static "identity"<T>(): $Function$0<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2LongFunction$$Type = ((arg0: float) => long);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2LongFunction_ = $Float2LongFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.Pair" {
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"

export interface $Pair<L, R> {

 "value"(): R
 "value"(arg0: R): $Pair<(L), (R)>
 "first"(arg0: L): $Pair<(L), (R)>
 "first"(): L
 "second"(): R
 "second"(arg0: R): $Pair<(L), (R)>
 "key"(): L
 "key"(arg0: L): $Pair<(L), (R)>
 "left"(): L
 "left"(arg0: L): $Pair<(L), (R)>
 "right"(): R
 "right"(arg0: R): $Pair<(L), (R)>
}

export namespace $Pair {
function of<L, R>(arg0: L, arg1: R): $Pair<(L), (R)>
function lexComparator<L, R>(): $Comparator<($Pair<(L), (R)>)>
const probejs$$marker: never
}
export class $Pair$$Static<L, R> implements $Pair {


 "value"(): R
 "value"(arg0: R): $Pair<(L), (R)>
static "of"<L, R>(arg0: L, arg1: R): $Pair<(L), (R)>
 "first"(arg0: L): $Pair<(L), (R)>
 "first"(): L
 "second"(): R
 "second"(arg0: R): $Pair<(L), (R)>
 "key"(): L
 "key"(arg0: L): $Pair<(L), (R)>
 "left"(): L
 "left"(arg0: L): $Pair<(L), (R)>
 "right"(): R
 "right"(arg0: R): $Pair<(L), (R)>
static "lexComparator"<L, R>(): $Comparator<($Pair<(L), (R)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Pair$$Type<L, R> = ($Pair<(L), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Pair_<L, R> = $Pair$$Type<(L), (R)>;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction" {
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"

export interface $Reference2BooleanFunction<K> extends $Function<(K), (boolean)>, $Predicate<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: K, arg1: boolean): boolean
 "getBoolean"(arg0: any): boolean
 "test"(arg0: K): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2BooleanFunction
 "removeBoolean"(arg0: any): boolean
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): boolean
 "containsKey"(arg0: any): boolean
 "or"(arg0: $Predicate$$Type<(K)>): $Predicate<(K)>
 "negate"(): $Predicate<(K)>
 "and"(arg0: $Predicate$$Type<(K)>): $Predicate<(K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (boolean)>

(arg0: any): boolean
}

export namespace $Reference2BooleanFunction {
function not<T>(arg0: $Predicate$$Type<(K)>): $Predicate<(K)>
function isEqual<T>(arg0: any): $Predicate<(K)>
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Reference2BooleanFunction$$Static<K> implements $Reference2BooleanFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: K, arg1: boolean): boolean
 "getBoolean"(arg0: any): boolean
 "test"(arg0: K): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2BooleanFunction
 "removeBoolean"(arg0: any): boolean
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): boolean
 "containsKey"(arg0: any): boolean
 "or"(arg0: $Predicate$$Type<(K)>): $Predicate<(K)>
 "negate"(): $Predicate<(K)>
 "and"(arg0: $Predicate$$Type<(K)>): $Predicate<(K)>
static "not"<T>(arg0: $Predicate$$Type<(K)>): $Predicate<(K)>
static "isEqual"<T>(arg0: any): $Predicate<(K)>
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2BooleanFunction$$Type<K> = ((arg0: any) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2BooleanFunction_<K> = $Reference2BooleanFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.chars.Char2CharFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"

export interface $Char2CharFunction extends $Function<(character), (character)>, $IntUnaryOperator {

 "remove"(arg0: character): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: character, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: character, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): character
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: character): character
}

export namespace $Char2CharFunction {
function identity(): $Char2CharFunction
const probejs$$marker: never
}
export class $Char2CharFunction$$Static implements $Char2CharFunction {


 "remove"(arg0: character): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: character, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: character): character
static "identity"(): $Char2CharFunction
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: character, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): character
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2CharFunction$$Type = ((arg0: character) => character);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2CharFunction_ = $Char2CharFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.Short2CharFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Short2CharFunction extends $Function<(short), (character)>, $IntUnaryOperator {

 "remove"(arg0: short): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: character): character
 "put"(arg0: short, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: short, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): character
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: short): character
}

export namespace $Short2CharFunction {
function identity(): $IntUnaryOperator
const probejs$$marker: never
}
export class $Short2CharFunction$$Static implements $Short2CharFunction {


 "remove"(arg0: short): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: character): character
 "put"(arg0: short, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: short, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): character
static "identity"(): $IntUnaryOperator
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2CharFunction$$Type = ((arg0: short) => character);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2CharFunction_ = $Short2CharFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2FloatFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$ToDoubleFunction, $ToDoubleFunction$$Type} from "java.util.function.ToDoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Object2FloatFunction<K> extends $Function<(K), (float)>, $ToDoubleFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getFloat"(arg0: any): float
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2FloatFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2FloatFunction
 "removeFloat"(arg0: any): float
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): float
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (float)>

(arg0: any): float
}

export namespace $Object2FloatFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Object2FloatFunction$$Static<K> implements $Object2FloatFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getFloat"(arg0: any): float
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2FloatFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2FloatFunction
 "removeFloat"(arg0: any): float
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): float
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2FloatFunction$$Type<K> = ((arg0: any) => float);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2FloatFunction_<K> = $Object2FloatFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.shorts.ShortPredicate" {
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IntPredicate, $IntPredicate$$Type} from "java.util.function.IntPredicate"

export interface $ShortPredicate extends $Predicate<(short)>, $IntPredicate {

/**
 * 
 * @deprecated
 */
 "test"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: short): boolean
 "test"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
 "or"(arg0: $ShortPredicate$$Type): $ShortPredicate
 "or"(arg0: $IntPredicate$$Type): $ShortPredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$$Type<(short)>): $Predicate<(short)>
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$$Type): $IntPredicate
 "and"(arg0: $ShortPredicate$$Type): $ShortPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$$Type<(short)>): $Predicate<(short)>

(arg0: short): boolean
}

export namespace $ShortPredicate {
function not<T>(arg0: $Predicate$$Type<(short)>): $Predicate<(short)>
function isEqual<T>(arg0: any): $Predicate<(short)>
const probejs$$marker: never
}
export class $ShortPredicate$$Static implements $ShortPredicate {


/**
 * 
 * @deprecated
 */
 "test"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: short): boolean
 "test"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
 "or"(arg0: $ShortPredicate$$Type): $ShortPredicate
 "or"(arg0: $IntPredicate$$Type): $ShortPredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$$Type<(short)>): $Predicate<(short)>
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$$Type): $IntPredicate
 "and"(arg0: $ShortPredicate$$Type): $ShortPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$$Type<(short)>): $Predicate<(short)>
static "not"<T>(arg0: $Predicate$$Type<(short)>): $Predicate<(short)>
static "isEqual"<T>(arg0: any): $Predicate<(short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortPredicate$$Type = ((arg0: short) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortPredicate_ = $ShortPredicate$$Type;
}}
declare module "it.unimi.dsi.fastutil.doubles.Double2FloatFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$$Type} from "java.util.function.DoubleUnaryOperator"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Double2FloatFunction extends $Function<(double), (float)>, $DoubleUnaryOperator {

 "remove"(arg0: double): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: float): float
 "put"(arg0: double, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: double, arg1: float): float
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): float
 "compose"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator

(arg0: double): float
}

export namespace $Double2FloatFunction {
function identity(): $DoubleUnaryOperator
const probejs$$marker: never
}
export class $Double2FloatFunction$$Static implements $Double2FloatFunction {


 "remove"(arg0: double): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: float): float
 "put"(arg0: double, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: double, arg1: float): float
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): float
static "identity"(): $DoubleUnaryOperator
 "compose"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2FloatFunction$$Type = ((arg0: double) => float);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2FloatFunction_ = $Double2FloatFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2LongFunction" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$ToLongFunction, $ToLongFunction$$Type} from "java.util.function.ToLongFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Object2LongFunction<K> extends $Function<(K), (long)>, $ToLongFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getLong"(arg0: any): long
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "applyAsLong"(arg0: K): long
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2LongFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2LongFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2LongFunction
 "removeLong"(arg0: any): long
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): long
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (long)>

(arg0: any): long
}

export namespace $Object2LongFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Object2LongFunction$$Static<K> implements $Object2LongFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getLong"(arg0: any): long
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "applyAsLong"(arg0: K): long
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2LongFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2LongFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2LongFunction
 "removeLong"(arg0: any): long
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): long
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2LongFunction$$Type<K> = ((arg0: any) => long);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2LongFunction_<K> = $Object2LongFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.floats.Float2ByteFunction" {
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$DoubleToIntFunction, $DoubleToIntFunction$$Type} from "java.util.function.DoubleToIntFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Float2ByteFunction extends $Function<(float), (byte)>, $DoubleToIntFunction {

 "remove"(arg0: float): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: byte): byte
 "put"(arg0: float, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: float, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): byte

(arg0: float): byte
}

export namespace $Float2ByteFunction {
function identity<T>(): $Function$0<(float), (float)>
const probejs$$marker: never
}
export class $Float2ByteFunction$$Static implements $Float2ByteFunction {


 "remove"(arg0: float): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: byte): byte
 "put"(arg0: float, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: float, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): byte
static "identity"<T>(): $Function$0<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2ByteFunction$$Type = ((arg0: float) => byte);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2ByteFunction_ = $Float2ByteFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$$Type} from "java.util.function.IntToDoubleFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Short2DoubleFunction extends $Function<(short), (double)>, $IntToDoubleFunction {

 "remove"(arg0: short): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: double): double
 "put"(arg0: short, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: short, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): double

(arg0: short): double
}

export namespace $Short2DoubleFunction {
function identity<T>(): $Function$0<(short), (short)>
const probejs$$marker: never
}
export class $Short2DoubleFunction$$Static implements $Short2DoubleFunction {


 "remove"(arg0: short): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: double): double
 "put"(arg0: short, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: short, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): double
static "identity"<T>(): $Function$0<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2DoubleFunction$$Type = ((arg0: short) => double);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2DoubleFunction_ = $Short2DoubleFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.Long2ByteFunction" {
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$LongToIntFunction, $LongToIntFunction$$Type} from "java.util.function.LongToIntFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Long2ByteFunction extends $Function<(long), (byte)>, $LongToIntFunction {

 "remove"(arg0: long): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: byte): byte
 "put"(arg0: long, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: long, arg1: byte): byte
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): byte

(arg0: long): byte
}

export namespace $Long2ByteFunction {
function identity<T>(): $Function$0<(long), (long)>
const probejs$$marker: never
}
export class $Long2ByteFunction$$Static implements $Long2ByteFunction {


 "remove"(arg0: long): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: byte): byte
 "put"(arg0: long, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: long, arg1: byte): byte
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): byte
static "identity"<T>(): $Function$0<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ByteFunction$$Type = ((arg0: long) => byte);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ByteFunction_ = $Long2ByteFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2LongFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$ToLongFunction, $ToLongFunction$$Type} from "java.util.function.ToLongFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Reference2LongFunction<K> extends $Function<(K), (long)>, $ToLongFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getLong"(arg0: any): long
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "applyAsLong"(arg0: K): long
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2LongFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2LongFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2LongFunction
 "removeLong"(arg0: any): long
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): long
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (long)>

(arg0: any): long
}

export namespace $Reference2LongFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Reference2LongFunction$$Static<K> implements $Reference2LongFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getLong"(arg0: any): long
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "applyAsLong"(arg0: K): long
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2LongFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2LongFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2LongFunction
 "removeLong"(arg0: any): long
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): long
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2LongFunction$$Type<K> = ((arg0: any) => long);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2LongFunction_<K> = $Reference2LongFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2LongMap" {
import {$LongBinaryOperator, $LongBinaryOperator$$Type} from "it.unimi.dsi.fastutil.longs.LongBinaryOperator"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$Object2LongMap$Entry, $Object2LongMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongMap$Entry"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$ToLongFunction, $ToLongFunction$$Type} from "java.util.function.ToLongFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$LongBinaryOperator as $LongBinaryOperator$0, $LongBinaryOperator$$Type as $LongBinaryOperator$0$$Type} from "java.util.function.LongBinaryOperator"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Object2LongMap<K> extends $Object2LongFunction<(K)>, $Map<(K), (long)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
 "remove"(arg0: any, arg1: long): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: long): long
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: long): long
 "replace"(arg0: K, arg1: long, arg2: long): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: long, arg2: long): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: long, arg2: $BiFunction$$Type<(long), (long), (long)>): long
 "merge"(arg0: K, arg1: long, arg2: $BiFunction$$Type<(long), (long), (long)>): long
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (long)>)>
 "putIfAbsent"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
 "forEach"(arg0: $BiConsumer$$Type<(K), (long)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToLongFunction$$Type<(K)>): long
 "computeIfAbsent"(arg0: K, arg1: $Object2LongFunction$$Type<(K)>): long
 "keySet"(): $ObjectSet<(K)>
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: long): boolean
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "object2LongEntrySet"(): $ObjectSet<($Object2LongMap$Entry<(K)>)>
/**
 * 
 * @deprecated
 */
 "mergeLong"(arg0: K, arg1: long, arg2: $BiFunction$$Type<(long), (long), (long)>): long
 "mergeLong"(arg0: K, arg1: long, arg2: $LongBinaryOperator$$Type): long
 "mergeLong"(arg0: K, arg1: long, arg2: $LongBinaryOperator$0$$Type): long
 "computeLong"(arg0: K, arg1: $BiFunction$$Type<(K), (long), (long)>): long
/**
 * 
 * @deprecated
 */
 "computeLongIfAbsent"(arg0: K, arg1: $ToLongFunction$$Type<(K)>): long
/**
 * 
 * @deprecated
 */
 "computeLongIfAbsentPartial"(arg0: K, arg1: $Object2LongFunction$$Type<(K)>): long
 "computeLongIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (long), (long)>): long
 "put"(arg0: K, arg1: long): long
 "getLong"(arg0: any): long
 "applyAsLong"(arg0: K): long
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(long), (T)>): $Function<(K), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2LongFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2LongFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2LongFunction
 "removeLong"(arg0: any): long
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (long), (long)>): void
 "putAll"(arg0: $Map$$Type<(K), (long)>): void
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (long), (long)>): long
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (long)>): long
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (long), (long)>): long
 "apply"(arg0: K): long
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (long)>
[index: string | number]: long
get "empty"(): boolean
}

export namespace $Object2LongMap {
function copyOf<K, V>(arg0: $Map$$Type<(K), (long)>): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long): $Map<(K), (long)>
function of<K, V>(): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long, arg12: K, arg13: long, arg14: K, arg15: long, arg16: K, arg17: long, arg18: K, arg19: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long, arg12: K, arg13: long, arg14: K, arg15: long, arg16: K, arg17: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long, arg12: K, arg13: long, arg14: K, arg15: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long, arg12: K, arg13: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long): $Map<(K), (long)>
function of<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long): $Map<(K), (long)>
function entry<K, V>(arg0: K, arg1: long): $Map$Entry<(K), (long)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(K), (long)>)[]): $Map<(K), (long)>
function identity<T>(): $Function<(K), (K)>
const probejs$$marker: never
}
export class $Object2LongMap$$Static<K> implements $Object2LongMap {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
 "remove"(arg0: any, arg1: long): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: long): long
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: long): long
 "replace"(arg0: K, arg1: long, arg2: long): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: long, arg2: long): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: long, arg2: $BiFunction$$Type<(long), (long), (long)>): long
 "merge"(arg0: K, arg1: long, arg2: $BiFunction$$Type<(long), (long), (long)>): long
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (long)>)>
 "putIfAbsent"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
 "forEach"(arg0: $BiConsumer$$Type<(K), (long)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToLongFunction$$Type<(K)>): long
 "computeIfAbsent"(arg0: K, arg1: $Object2LongFunction$$Type<(K)>): long
 "keySet"(): $ObjectSet<(K)>
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: long): boolean
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "object2LongEntrySet"(): $ObjectSet<($Object2LongMap$Entry<(K)>)>
/**
 * 
 * @deprecated
 */
 "mergeLong"(arg0: K, arg1: long, arg2: $BiFunction$$Type<(long), (long), (long)>): long
 "mergeLong"(arg0: K, arg1: long, arg2: $LongBinaryOperator$$Type): long
 "mergeLong"(arg0: K, arg1: long, arg2: $LongBinaryOperator$0$$Type): long
 "computeLong"(arg0: K, arg1: $BiFunction$$Type<(K), (long), (long)>): long
/**
 * 
 * @deprecated
 */
 "computeLongIfAbsent"(arg0: K, arg1: $ToLongFunction$$Type<(K)>): long
/**
 * 
 * @deprecated
 */
 "computeLongIfAbsentPartial"(arg0: K, arg1: $Object2LongFunction$$Type<(K)>): long
 "computeLongIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (long), (long)>): long
 "put"(arg0: K, arg1: long): long
 "getLong"(arg0: any): long
 "applyAsLong"(arg0: K): long
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(long), (T)>): $Function<(K), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2LongFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2LongFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2LongFunction
 "removeLong"(arg0: any): long
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(K), (long)>): $Map<(K), (long)>
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (long), (long)>): void
static "of"<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long): $Map<(K), (long)>
static "of"<K, V>(): $Map<(K), (long)>
static "of"<K, V>(arg0: K, arg1: long): $Map<(K), (long)>
static "of"<K, V>(arg0: K, arg1: long, arg2: K, arg3: long): $Map<(K), (long)>
static "of"<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long): $Map<(K), (long)>
static "of"<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long, arg12: K, arg13: long, arg14: K, arg15: long, arg16: K, arg17: long, arg18: K, arg19: long): $Map<(K), (long)>
static "of"<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long, arg12: K, arg13: long, arg14: K, arg15: long, arg16: K, arg17: long): $Map<(K), (long)>
static "of"<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long, arg12: K, arg13: long, arg14: K, arg15: long): $Map<(K), (long)>
static "of"<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long, arg12: K, arg13: long): $Map<(K), (long)>
static "of"<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long, arg10: K, arg11: long): $Map<(K), (long)>
static "of"<K, V>(arg0: K, arg1: long, arg2: K, arg3: long, arg4: K, arg5: long, arg6: K, arg7: long, arg8: K, arg9: long): $Map<(K), (long)>
 "putAll"(arg0: $Map$$Type<(K), (long)>): void
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (long), (long)>): long
static "entry"<K, V>(arg0: K, arg1: long): $Map$Entry<(K), (long)>
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (long)>): long
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (long), (long)>): long
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (long)>)[]): $Map<(K), (long)>
 "apply"(arg0: K): long
static "identity"<T>(): $Function<(K), (K)>
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2LongMap$$Type<K> = ($Object2LongMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2LongMap_<K> = $Object2LongMap$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap" {
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Hash, $Hash$$Type} from "it.unimi.dsi.fastutil.Hash"
import {$ReferenceSet, $ReferenceSet$$Type} from "it.unimi.dsi.fastutil.objects.ReferenceSet"
import {$Reference2ObjectMap, $Reference2ObjectMap$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectMap"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ObjectCollection, $ObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.ObjectCollection"
import {$AbstractReference2ObjectMap, $AbstractReference2ObjectMap$$Type} from "it.unimi.dsi.fastutil.objects.AbstractReference2ObjectMap"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Cloneable, $Cloneable$$Type} from "java.lang.Cloneable"

export class $Reference2ObjectOpenHashMap<K, V> extends $AbstractReference2ObjectMap<(K), (V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$$Type<(K), (V)>)
constructor(arg0: $Reference2ObjectMap$$Type<(K), (V)>, arg1: float)
constructor(arg0: $Reference2ObjectMap$$Type<(K), (V)>)
constructor(arg0: (K)[], arg1: (V)[], arg2: float)
constructor(arg0: (K)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$$Type<(K), (V)>, arg1: float)

public "remove"(arg0: any, arg1: any): boolean
public "remove"(arg0: any): V
public "size"(): integer
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "values"(): $ObjectCollection<(V)>
public "hashCode"(): integer
public "clone"(): $Reference2ObjectOpenHashMap<(K), (V)>
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: K, arg1: V): V
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
public "putAll"(arg0: $Map$$Type<(K), (V)>): void
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: K, arg1: $Reference2ObjectFunction$$Type<(K), (V)>): V
public "keySet"(): $ReferenceSet<(K)>
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
public "ensureCapacity"(arg0: integer): void
public "reference2ObjectEntrySet"(): $ObjectSet<(any)>
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ObjectOpenHashMap$$Type<K, V> = ($Reference2ObjectOpenHashMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ObjectOpenHashMap_<K, V> = $Reference2ObjectOpenHashMap$$Type<(K), (V)>;
}}
declare module "it.unimi.dsi.fastutil.doubles.DoubleListIterator" {
import {$DoubleConsumer, $DoubleConsumer$$Type} from "java.util.function.DoubleConsumer"
import {$ListIterator, $ListIterator$$Type} from "java.util.ListIterator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$$Type as $DoubleConsumer$0$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleConsumer"
import {$DoubleBidirectionalIterator, $DoubleBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleBidirectionalIterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $DoubleListIterator extends $DoubleBidirectionalIterator, $ListIterator<(double)> {

 "remove"(): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: double): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): void
 "add"(arg0: double): void
/**
 * 
 * @deprecated
 */
 "next"(): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: double): void
 "set"(arg0: double): void
/**
 * 
 * @deprecated
 */
 "previous"(): any
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousDouble"(): double
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(double)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$0$$Type): void
 "nextDouble"(): double
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $DoubleConsumer$$Type): void
}

export namespace $DoubleListIterator {
const probejs$$marker: never
}
export class $DoubleListIterator$$Static implements $DoubleListIterator {


 "remove"(): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: double): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): void
 "add"(arg0: double): void
/**
 * 
 * @deprecated
 */
 "next"(): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: double): void
 "set"(arg0: double): void
/**
 * 
 * @deprecated
 */
 "previous"(): any
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousDouble"(): double
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(double)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$0$$Type): void
 "nextDouble"(): double
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $DoubleConsumer$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleListIterator$$Type = ($DoubleListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleListIterator_ = $DoubleListIterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.ShortConsumer" {
import {$IntConsumer, $IntConsumer$$Type} from "java.util.function.IntConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ShortConsumer extends $Consumer<(short)>, $IntConsumer {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: integer): void
 "accept"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$$Type<(short)>): $Consumer<(short)>
 "andThen"(arg0: $IntConsumer$$Type): $IntConsumer
 "andThen"(arg0: $ShortConsumer$$Type): $ShortConsumer

(arg0: short): void
}

export namespace $ShortConsumer {
const probejs$$marker: never
}
export class $ShortConsumer$$Static implements $ShortConsumer {


/**
 * 
 * @deprecated
 */
 "accept"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: integer): void
 "accept"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$$Type<(short)>): $Consumer<(short)>
 "andThen"(arg0: $IntConsumer$$Type): $IntConsumer
 "andThen"(arg0: $ShortConsumer$$Type): $ShortConsumer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortConsumer$$Type = ((arg0: short) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortConsumer_ = $ShortConsumer$$Type;
}}
declare module "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"

export interface $Boolean2CharFunction extends $Function<(boolean), (character)> {

 "remove"(arg0: boolean): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): character
 "get"(arg0: boolean): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: character): character
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: character): character
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): character

(arg0: boolean): character
}

export namespace $Boolean2CharFunction {
function identity<T>(): $Function$0<(boolean), (boolean)>
const probejs$$marker: never
}
export class $Boolean2CharFunction$$Static implements $Boolean2CharFunction {


 "remove"(arg0: boolean): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): character
 "get"(arg0: boolean): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: character): character
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: character): character
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): character
static "identity"<T>(): $Function$0<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2CharFunction$$Type = ((arg0: boolean) => character);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2CharFunction_ = $Boolean2CharFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.chars.Char2ByteFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Char2ByteFunction extends $Function<(character), (byte)>, $IntUnaryOperator {

 "remove"(arg0: character): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: byte): byte
 "put"(arg0: character, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: character, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): byte
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: character): byte
}

export namespace $Char2ByteFunction {
function identity(): $IntUnaryOperator
const probejs$$marker: never
}
export class $Char2ByteFunction$$Static implements $Char2ByteFunction {


 "remove"(arg0: character): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: byte): byte
 "put"(arg0: character, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: character, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): byte
static "identity"(): $IntUnaryOperator
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ByteFunction$$Type = ((arg0: character) => byte);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ByteFunction_ = $Char2ByteFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Object2ReferenceFunction<K, V> extends $Function<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(K), (V)>

(arg0: any): V
}

export namespace $Object2ReferenceFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Object2ReferenceFunction$$Static<K, V> implements $Object2ReferenceFunction {


 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ReferenceFunction$$Type<K, V> = ((arg0: any) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ReferenceFunction_<K, V> = $Object2ReferenceFunction$$Type<(K), (V)>;
}}
declare module "it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Hash, $Hash$$Type} from "it.unimi.dsi.fastutil.Hash"
import {$LongSet, $LongSet$$Type} from "it.unimi.dsi.fastutil.longs.LongSet"
import {$Long2ObjectMap, $Long2ObjectMap$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectMap"
import {$LongFunction, $LongFunction$$Type} from "java.util.function.LongFunction"
import {$LongComparator, $LongComparator$$Type} from "it.unimi.dsi.fastutil.longs.LongComparator"
import {$Long2ObjectSortedMap, $Long2ObjectSortedMap$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectSortedMap"
import {$AbstractLong2ObjectSortedMap, $AbstractLong2ObjectSortedMap$$Type} from "it.unimi.dsi.fastutil.longs.AbstractLong2ObjectSortedMap"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Cloneable, $Cloneable$$Type} from "java.lang.Cloneable"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export class $Long2ObjectLinkedOpenHashMap<V> extends $AbstractLong2ObjectSortedMap<(V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$$Type<(long), (V)>)
constructor(arg0: $Long2ObjectMap$$Type<(V)>, arg1: float)
constructor(arg0: $Long2ObjectMap$$Type<(V)>)
constructor(arg0: (long)[], arg1: (V)[], arg2: float)
constructor(arg0: (long)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$$Type<(long), (V)>, arg1: float)

public "remove"(arg0: long): V
public "remove"(arg0: long, arg1: any): boolean
public "size"(): integer
public "get"(arg0: long): V
public "put"(arg0: long, arg1: V): V
public "values"(): $Collection<(any)>
public "hashCode"(): integer
public "clone"(): any
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: long, arg1: V): V
public "replace"(arg0: long, arg1: V, arg2: V): boolean
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: long, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
public "putAll"(arg0: $Map$$Type<(long), (V)>): void
public "putIfAbsent"(arg0: long, arg1: V): V
public "compute"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
public "containsKey"(arg0: long): boolean
public "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$$Type<(V)>): V
public "computeIfAbsent"(arg0: long, arg1: $LongFunction$$Type<(V)>): V
public "keySet"(): $LongSet
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: long, arg1: V): V
public "computeIfPresent"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
public "ensureCapacity"(arg0: integer): void
public "removeFirst"(): V
public "removeLast"(): V
public "comparator"(): $LongComparator
public "subMap"(arg0: long, arg1: long): $Long2ObjectSortedMap<(V)>
public "headMap"(arg0: long): $Long2ObjectSortedMap<(V)>
public "tailMap"(arg0: long): $Long2ObjectSortedMap<(V)>
public "putAndMoveToLast"(arg0: long, arg1: V): V
public "getAndMoveToLast"(arg0: long): V
public "long2ObjectEntrySet"(): $ObjectSet<(any)>
public "putAndMoveToFirst"(arg0: long, arg1: V): V
public "getAndMoveToFirst"(arg0: long): V
public "lastLongKey"(): long
public "firstLongKey"(): long
/**
 * 
 * @deprecated
 */
public "firstKey"(): any
/**
 * 
 * @deprecated
 */
public "lastKey"(): any
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectLinkedOpenHashMap$$Type<V> = ($Long2ObjectLinkedOpenHashMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectLinkedOpenHashMap_<V> = $Long2ObjectLinkedOpenHashMap$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.booleans.BooleanIterator" {
import {$BooleanConsumer, $BooleanConsumer$$Type} from "it.unimi.dsi.fastutil.booleans.BooleanConsumer"
import {$PrimitiveIterator, $PrimitiveIterator$$Type} from "java.util.PrimitiveIterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $BooleanIterator extends $PrimitiveIterator<(boolean), ($BooleanConsumer)> {

 "forEachRemaining"(arg0: $BooleanConsumer$$Type): void
 "forEachRemaining"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(boolean)>): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "skip"(arg0: integer): integer
 "nextBoolean"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $BooleanIterator {
const probejs$$marker: never
}
export class $BooleanIterator$$Static implements $BooleanIterator {


 "forEachRemaining"(arg0: $BooleanConsumer$$Type): void
 "forEachRemaining"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(boolean)>): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "skip"(arg0: integer): integer
 "nextBoolean"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanIterator$$Type = ($BooleanIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanIterator_ = $BooleanIterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Short2ObjectFunction<V> extends $Function<(short), (V)>, $IntFunction<(V)> {

 "remove"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Short2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Short2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(short), (V)>

(arg0: short): V
}

export namespace $Short2ObjectFunction {
function identity<T>(): $Function$0<(short), (short)>
const probejs$$marker: never
}
export class $Short2ObjectFunction$$Static<V> implements $Short2ObjectFunction {


 "remove"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Short2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Short2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): V
static "identity"<T>(): $Function$0<(short), (short)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(short), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2ObjectFunction$$Type<V> = ((arg0: short) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2ObjectFunction_<V> = $Short2ObjectFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.doubles.DoublePredicate" {
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$DoublePredicate as $DoublePredicate$0, $DoublePredicate$$Type as $DoublePredicate$0$$Type} from "java.util.function.DoublePredicate"

export interface $DoublePredicate extends $Predicate<(double)>, $DoublePredicate$0 {

/**
 * 
 * @deprecated
 */
 "test"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$$Type<(double)>): $Predicate<(double)>
 "or"(arg0: $DoublePredicate$0$$Type): $DoublePredicate
 "or"(arg0: $DoublePredicate$$Type): $DoublePredicate
 "negate"(): $DoublePredicate$0
 "and"(arg0: $DoublePredicate$0$$Type): $DoublePredicate$0
 "and"(arg0: $DoublePredicate$$Type): $DoublePredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$$Type<(double)>): $Predicate<(double)>
 "test"(arg0: double): boolean

(arg0: double): boolean
}

export namespace $DoublePredicate {
function not<T>(arg0: $Predicate$$Type<(double)>): $Predicate<(double)>
function isEqual<T>(arg0: any): $Predicate<(double)>
const probejs$$marker: never
}
export class $DoublePredicate$$Static implements $DoublePredicate {


/**
 * 
 * @deprecated
 */
 "test"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$$Type<(double)>): $Predicate<(double)>
 "or"(arg0: $DoublePredicate$0$$Type): $DoublePredicate
 "or"(arg0: $DoublePredicate$$Type): $DoublePredicate
 "negate"(): $DoublePredicate$0
 "and"(arg0: $DoublePredicate$0$$Type): $DoublePredicate$0
 "and"(arg0: $DoublePredicate$$Type): $DoublePredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$$Type<(double)>): $Predicate<(double)>
static "not"<T>(arg0: $Predicate$$Type<(double)>): $Predicate<(double)>
static "isEqual"<T>(arg0: any): $Predicate<(double)>
 "test"(arg0: double): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoublePredicate$$Type = ((arg0: double) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoublePredicate_ = $DoublePredicate$$Type;
}}
declare module "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$DoubleFunction, $DoubleFunction$$Type} from "java.util.function.DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Double2ObjectFunction<V> extends $Function<(double), (V)>, $DoubleFunction<(V)> {

 "remove"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: double, arg1: V): V
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: double, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Double2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Double2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(double), (V)>

(arg0: double): V
}

export namespace $Double2ObjectFunction {
function identity<T>(): $Function$0<(double), (double)>
const probejs$$marker: never
}
export class $Double2ObjectFunction$$Static<V> implements $Double2ObjectFunction {


 "remove"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: double, arg1: V): V
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: double, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Double2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Double2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): V
static "identity"<T>(): $Function$0<(double), (double)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(double), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2ObjectFunction$$Type<V> = ((arg0: double) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2ObjectFunction_<V> = $Double2ObjectFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction" {
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Byte2ReferenceFunction<V> extends $Function<(byte), (V)>, $IntFunction<(V)> {

 "remove"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Byte2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Byte2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(byte), (V)>

(arg0: byte): V
}

export namespace $Byte2ReferenceFunction {
function identity<T>(): $Function$0<(byte), (byte)>
const probejs$$marker: never
}
export class $Byte2ReferenceFunction$$Static<V> implements $Byte2ReferenceFunction {


 "remove"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Byte2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Byte2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): V
static "identity"<T>(): $Function$0<(byte), (byte)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(byte), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2ReferenceFunction$$Type<V> = ((arg0: byte) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2ReferenceFunction_<V> = $Byte2ReferenceFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.floats.Float2IntFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$DoubleToIntFunction, $DoubleToIntFunction$$Type} from "java.util.function.DoubleToIntFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Float2IntFunction extends $Function<(float), (integer)>, $DoubleToIntFunction {

 "remove"(arg0: float): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: integer): integer
 "put"(arg0: float, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: float, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): integer

(arg0: float): integer
}

export namespace $Float2IntFunction {
function identity<T>(): $Function$0<(float), (float)>
const probejs$$marker: never
}
export class $Float2IntFunction$$Static implements $Float2IntFunction {


 "remove"(arg0: float): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: integer): integer
 "put"(arg0: float, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: float, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): integer
static "identity"<T>(): $Function$0<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2IntFunction$$Type = ((arg0: float) => integer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2IntFunction_ = $Float2IntFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.doubles.Double2ShortFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$DoubleToIntFunction, $DoubleToIntFunction$$Type} from "java.util.function.DoubleToIntFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"

export interface $Double2ShortFunction extends $Function<(double), (short)>, $DoubleToIntFunction {

 "remove"(arg0: double): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: short): short
 "put"(arg0: double, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: double, arg1: short): short
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): short

(arg0: double): short
}

export namespace $Double2ShortFunction {
function identity<T>(): $Function$0<(double), (double)>
const probejs$$marker: never
}
export class $Double2ShortFunction$$Static implements $Double2ShortFunction {


 "remove"(arg0: double): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: short): short
 "put"(arg0: double, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: double, arg1: short): short
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): short
static "identity"<T>(): $Function$0<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2ShortFunction$$Type = ((arg0: double) => short);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2ShortFunction_ = $Double2ShortFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Hash, $Hash$$Type} from "it.unimi.dsi.fastutil.Hash"
import {$LongSet, $LongSet$$Type} from "it.unimi.dsi.fastutil.longs.LongSet"
import {$Long2ObjectMap, $Long2ObjectMap$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectMap"
import {$LongFunction, $LongFunction$$Type} from "java.util.function.LongFunction"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ObjectCollection, $ObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.ObjectCollection"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Cloneable, $Cloneable$$Type} from "java.lang.Cloneable"
import {$Set, $Set$$Type} from "java.util.Set"
import {$AbstractLong2ObjectMap, $AbstractLong2ObjectMap$$Type} from "it.unimi.dsi.fastutil.longs.AbstractLong2ObjectMap"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export class $Long2ObjectOpenHashMap<V> extends $AbstractLong2ObjectMap<(V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$$Type<(long), (V)>)
constructor(arg0: $Long2ObjectMap$$Type<(V)>, arg1: float)
constructor(arg0: $Long2ObjectMap$$Type<(V)>)
constructor(arg0: (long)[], arg1: (V)[], arg2: float)
constructor(arg0: (long)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$$Type<(long), (V)>, arg1: float)

public "remove"(arg0: long, arg1: any): boolean
public "remove"(arg0: long): V
public "size"(): integer
public "get"(arg0: long): V
public "put"(arg0: long, arg1: V): V
public "values"(): $ObjectCollection<(V)>
public "hashCode"(): integer
public "clone"(): $Long2ObjectOpenHashMap<(V)>
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: long, arg1: V): V
public "replace"(arg0: long, arg1: V, arg2: V): boolean
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: long, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
public "putAll"(arg0: $Map$$Type<(long), (V)>): void
public "putIfAbsent"(arg0: long, arg1: V): V
public "compute"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
public "containsKey"(arg0: long): boolean
public "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$$Type<(V)>): V
public "computeIfAbsent"(arg0: long, arg1: $LongFunction$$Type<(V)>): V
public "keySet"(): $LongSet
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: long, arg1: V): V
public "computeIfPresent"(arg0: long, arg1: $BiFunction$$Type<(long), (V), (V)>): V
public "ensureCapacity"(arg0: integer): void
public "long2ObjectEntrySet"(): $ObjectSet<(any)>
/**
 * 
 * @deprecated
 */
public "entrySet"(): $Set<(any)>
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectOpenHashMap$$Type<V> = ($Long2ObjectOpenHashMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectOpenHashMap_<V> = $Long2ObjectOpenHashMap$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction" {
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Byte2ShortFunction extends $Function<(byte), (short)>, $IntUnaryOperator {

 "remove"(arg0: byte): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: short): short
 "put"(arg0: byte, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: byte, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): short
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: byte): short
}

export namespace $Byte2ShortFunction {
function identity(): $IntUnaryOperator
const probejs$$marker: never
}
export class $Byte2ShortFunction$$Static implements $Byte2ShortFunction {


 "remove"(arg0: byte): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: byte): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: short): short
 "put"(arg0: byte, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: byte, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): short
static "identity"(): $IntUnaryOperator
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2ShortFunction$$Type = ((arg0: byte) => short);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2ShortFunction_ = $Byte2ShortFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.AbstractObject2IntMap" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$$Type as $IntBinaryOperator$0$$Type} from "it.unimi.dsi.fastutil.ints.IntBinaryOperator"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$IntBinaryOperator, $IntBinaryOperator$$Type} from "java.util.function.IntBinaryOperator"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$AbstractObject2IntFunction, $AbstractObject2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.AbstractObject2IntFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Object2IntMap, $Object2IntMap$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntMap"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Object2IntMap$Entry, $Object2IntMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntMap$Entry"

export class $AbstractObject2IntMap<K> extends $AbstractObject2IntFunction<(K)> implements $Object2IntMap<(K)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $Collection<(any)>
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$$Type<(K), (integer)>): void
public "containsKey"(arg0: any): boolean
public "keySet"(): $Set<(any)>
public "containsValue"(arg0: integer): boolean
public "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$0$$Type): integer
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): any
public "remove"(arg0: any, arg1: integer): boolean
public "size"(): integer
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): integer
/**
 * 
 * @deprecated
 */
public "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
public "put"(arg0: K, arg1: integer): integer
public "clear"(): void
public "replace"(arg0: K, arg1: integer): integer
public "replace"(arg0: K, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
public "replace"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
public "replace"(arg0: K, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
public "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
public "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
public "merge"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
public "merge"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
public "entrySet"(): $ObjectSet<($Map$Entry<(K), (integer)>)>
public "putIfAbsent"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "putIfAbsent"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "putIfAbsent"(arg0: any, arg1: any): any
public "forEach"(arg0: $BiConsumer$$Type<(K), (integer)>): void
public "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$$Type<(K)>): integer
public "computeIfAbsent"(arg0: K, arg1: $Object2IntFunction$$Type<(K)>): integer
/**
 * 
 * @deprecated
 */
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: any): any
public "defaultReturnValue"(): integer
public "defaultReturnValue"(arg0: integer): void
/**
 * 
 * @deprecated
 */
public "mergeInt"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
public "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$$Type): integer
public "computeInt"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
public "computeIntIfAbsentPartial"(arg0: K, arg1: $Object2IntFunction$$Type<(K)>): integer
public "computeIntIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
public "object2IntEntrySet"(): $ObjectSet<($Object2IntMap$Entry<(K)>)>
/**
 * 
 * @deprecated
 */
public "computeIntIfAbsent"(arg0: K, arg1: $ToIntFunction$$Type<(K)>): integer
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (integer)>): $Map<(K), (integer)>
public "replaceAll"(arg0: $BiFunction$$Type<(K), (integer), (integer)>): void
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer): $Map<(K), (integer)>
public static "of"<K, V>(): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer, arg18: K, arg19: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer): $Map<(K), (integer)>
public "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
public static "entry"<K, V>(arg0: K, arg1: integer): $Map$Entry<(K), (integer)>
public "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (integer)>): integer
public "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (integer)>)[]): $Map<(K), (integer)>
public static "identity"<T>(): $Function<(K), (K)>
[index: string | number]: integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2IntMap$$Type<K> = ($AbstractObject2IntMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2IntMap_<K> = $AbstractObject2IntMap$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2IntMap" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$ReferenceSet, $ReferenceSet$$Type} from "it.unimi.dsi.fastutil.objects.ReferenceSet"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$IntBinaryOperator, $IntBinaryOperator$$Type} from "java.util.function.IntBinaryOperator"
import {$Reference2IntMap$Entry, $Reference2IntMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntMap$Entry"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$$Type as $IntBinaryOperator$0$$Type} from "it.unimi.dsi.fastutil.ints.IntBinaryOperator"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Reference2IntMap<K> extends $Reference2IntFunction<(K)>, $Map<(K), (integer)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
 "remove"(arg0: any, arg1: integer): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: integer): integer
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (integer)>)>
 "putIfAbsent"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
 "forEach"(arg0: $BiConsumer$$Type<(K), (integer)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$$Type<(K)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Reference2IntFunction$$Type<(K)>): integer
 "keySet"(): $ReferenceSet<(K)>
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: integer): boolean
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "mergeInt"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$$Type): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$0$$Type): integer
 "computeInt"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsentPartial"(arg0: K, arg1: $Reference2IntFunction$$Type<(K)>): integer
 "reference2IntEntrySet"(): $ObjectSet<($Reference2IntMap$Entry<(K)>)>
 "computeIntIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsent"(arg0: K, arg1: $ToIntFunction$$Type<(K)>): integer
 "put"(arg0: K, arg1: integer): integer
 "getInt"(arg0: any): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(integer), (T)>): $Function<(K), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2IntFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2IntFunction
 "removeInt"(arg0: any): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (integer), (integer)>): void
 "putAll"(arg0: $Map$$Type<(K), (integer)>): void
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (integer)>): integer
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
 "apply"(arg0: K): integer
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (integer)>
[index: string | number]: integer
get "empty"(): boolean
}

export namespace $Reference2IntMap {
function copyOf<K, V>(arg0: $Map$$Type<(K), (integer)>): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer): $Map<(K), (integer)>
function of<K, V>(): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer, arg18: K, arg19: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer): $Map<(K), (integer)>
function entry<K, V>(arg0: K, arg1: integer): $Map$Entry<(K), (integer)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(K), (integer)>)[]): $Map<(K), (integer)>
function identity<T>(): $Function<(K), (K)>
const probejs$$marker: never
}
export class $Reference2IntMap$$Static<K> implements $Reference2IntMap {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
 "remove"(arg0: any, arg1: integer): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: integer): integer
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (integer)>)>
 "putIfAbsent"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
 "forEach"(arg0: $BiConsumer$$Type<(K), (integer)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$$Type<(K)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Reference2IntFunction$$Type<(K)>): integer
 "keySet"(): $ReferenceSet<(K)>
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: integer): boolean
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "mergeInt"(arg0: K, arg1: integer, arg2: $BiFunction$$Type<(integer), (integer), (integer)>): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$$Type): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$0$$Type): integer
 "computeInt"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsentPartial"(arg0: K, arg1: $Reference2IntFunction$$Type<(K)>): integer
 "reference2IntEntrySet"(): $ObjectSet<($Reference2IntMap$Entry<(K)>)>
 "computeIntIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsent"(arg0: K, arg1: $ToIntFunction$$Type<(K)>): integer
 "put"(arg0: K, arg1: integer): integer
 "getInt"(arg0: any): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(integer), (T)>): $Function<(K), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2IntFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2IntFunction
 "removeInt"(arg0: any): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(K), (integer)>): $Map<(K), (integer)>
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (integer), (integer)>): void
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer): $Map<(K), (integer)>
static "of"<K, V>(): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer, arg18: K, arg19: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer): $Map<(K), (integer)>
static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer): $Map<(K), (integer)>
 "putAll"(arg0: $Map$$Type<(K), (integer)>): void
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
static "entry"<K, V>(arg0: K, arg1: integer): $Map$Entry<(K), (integer)>
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (integer)>): integer
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (integer), (integer)>): integer
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (integer)>)[]): $Map<(K), (integer)>
 "apply"(arg0: K): integer
static "identity"<T>(): $Function<(K), (K)>
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2IntMap$$Type<K> = ($Reference2IntMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2IntMap_<K> = $Reference2IntMap$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.booleans.BooleanIterable" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$BooleanConsumer, $BooleanConsumer$$Type} from "it.unimi.dsi.fastutil.booleans.BooleanConsumer"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $BooleanIterable extends $Iterable<(boolean)> {

 "iterator"(): $Iterator<(any)>
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $BooleanConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(boolean)>): void
[Symbol.iterator](): IterableIterator<any>;
}

export namespace $BooleanIterable {
const probejs$$marker: never
}
export class $BooleanIterable$$Static implements $BooleanIterable {


 "iterator"(): $Iterator<(any)>
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $BooleanConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(boolean)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanIterable$$Type = ($BooleanIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanIterable_ = $BooleanIterable$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.Short2ObjectMap" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$Short2ObjectMap$Entry, $Short2ObjectMap$Entry$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectMap$Entry"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$ObjectCollection, $ObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.ObjectCollection"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Short2ObjectMap<V> extends $Short2ObjectFunction<(V)>, $Map<(short), (V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: short, arg1: any): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "values"(): $ObjectCollection<(V)>
 "clear"(): void
 "replace"(arg0: short, arg1: V, arg2: V): boolean
 "replace"(arg0: short, arg1: V): V
 "merge"(arg0: short, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
/**
 * 
 * @deprecated
 */
 "entrySet"(): $Set<(any)>
 "putIfAbsent"(arg0: short, arg1: V): V
 "compute"(arg0: short, arg1: $BiFunction$$Type<(short), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(short), (V)>): void
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: short, arg1: $Short2ObjectFunction$$Type<(V)>): V
 "computeIfAbsent"(arg0: short, arg1: $IntFunction$$Type<(V)>): V
 "keySet"(): $Set<(any)>
 "getOrDefault"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: short, arg1: $BiFunction$$Type<(short), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "short2ObjectEntrySet"(): $ObjectSet<($Short2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: short, arg1: $Short2ObjectFunction$$Type<(V)>): V
 "remove"(arg0: short): V
 "get"(arg0: short): V
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (short)>): $Function<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Short2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Short2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Short2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: short, arg1: V, arg2: V): boolean
 "replace"(arg0: short, arg1: V): V
 "replaceAll"(arg0: $BiFunction$$Type<(short), (V), (V)>): void
 "merge"(arg0: short, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "putAll"(arg0: $Map$$Type<(short), (V)>): void
 "putIfAbsent"(arg0: short, arg1: V): V
 "compute"(arg0: short, arg1: $BiFunction$$Type<(short), (V), (V)>): V
 "computeIfAbsent"(arg0: short, arg1: $Function$$Type<(short), (V)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: short, arg1: $BiFunction$$Type<(short), (V), (V)>): V
 "apply"(arg0: short): V
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(short), (V)>
[index: string | number]: V
get "empty"(): boolean
}

export namespace $Short2ObjectMap {
function copyOf<K, V>(arg0: $Map$$Type<(short), (V)>): $Map<(short), (V)>
function of<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V): $Map<(short), (V)>
function of<K, V>(): $Map<(short), (V)>
function of<K, V>(arg0: short, arg1: V): $Map<(short), (V)>
function of<K, V>(arg0: short, arg1: V, arg2: short, arg3: V): $Map<(short), (V)>
function of<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V): $Map<(short), (V)>
function of<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V, arg8: short, arg9: V, arg10: short, arg11: V, arg12: short, arg13: V, arg14: short, arg15: V, arg16: short, arg17: V, arg18: short, arg19: V): $Map<(short), (V)>
function of<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V, arg8: short, arg9: V, arg10: short, arg11: V, arg12: short, arg13: V, arg14: short, arg15: V, arg16: short, arg17: V): $Map<(short), (V)>
function of<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V, arg8: short, arg9: V, arg10: short, arg11: V, arg12: short, arg13: V, arg14: short, arg15: V): $Map<(short), (V)>
function of<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V, arg8: short, arg9: V, arg10: short, arg11: V, arg12: short, arg13: V): $Map<(short), (V)>
function of<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V, arg8: short, arg9: V, arg10: short, arg11: V): $Map<(short), (V)>
function of<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V, arg8: short, arg9: V): $Map<(short), (V)>
function entry<K, V>(arg0: short, arg1: V): $Map$Entry<(short), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(short), (V)>)[]): $Map<(short), (V)>
function identity<T>(): $Function<(short), (short)>
const probejs$$marker: never
}
export class $Short2ObjectMap$$Static<V> implements $Short2ObjectMap {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: short, arg1: any): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "values"(): $ObjectCollection<(V)>
 "clear"(): void
 "replace"(arg0: short, arg1: V, arg2: V): boolean
 "replace"(arg0: short, arg1: V): V
 "merge"(arg0: short, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
/**
 * 
 * @deprecated
 */
 "entrySet"(): $Set<(any)>
 "putIfAbsent"(arg0: short, arg1: V): V
 "compute"(arg0: short, arg1: $BiFunction$$Type<(short), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(short), (V)>): void
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: short, arg1: $Short2ObjectFunction$$Type<(V)>): V
 "computeIfAbsent"(arg0: short, arg1: $IntFunction$$Type<(V)>): V
 "keySet"(): $Set<(any)>
 "getOrDefault"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: short, arg1: $BiFunction$$Type<(short), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "short2ObjectEntrySet"(): $ObjectSet<($Short2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: short, arg1: $Short2ObjectFunction$$Type<(V)>): V
 "remove"(arg0: short): V
 "get"(arg0: short): V
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (short)>): $Function<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Short2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Short2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Short2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(short), (V)>): $Map<(short), (V)>
 "isEmpty"(): boolean
 "replace"(arg0: short, arg1: V, arg2: V): boolean
 "replace"(arg0: short, arg1: V): V
 "replaceAll"(arg0: $BiFunction$$Type<(short), (V), (V)>): void
static "of"<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V): $Map<(short), (V)>
static "of"<K, V>(): $Map<(short), (V)>
static "of"<K, V>(arg0: short, arg1: V): $Map<(short), (V)>
static "of"<K, V>(arg0: short, arg1: V, arg2: short, arg3: V): $Map<(short), (V)>
static "of"<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V): $Map<(short), (V)>
static "of"<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V, arg8: short, arg9: V, arg10: short, arg11: V, arg12: short, arg13: V, arg14: short, arg15: V, arg16: short, arg17: V, arg18: short, arg19: V): $Map<(short), (V)>
static "of"<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V, arg8: short, arg9: V, arg10: short, arg11: V, arg12: short, arg13: V, arg14: short, arg15: V, arg16: short, arg17: V): $Map<(short), (V)>
static "of"<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V, arg8: short, arg9: V, arg10: short, arg11: V, arg12: short, arg13: V, arg14: short, arg15: V): $Map<(short), (V)>
static "of"<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V, arg8: short, arg9: V, arg10: short, arg11: V, arg12: short, arg13: V): $Map<(short), (V)>
static "of"<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V, arg8: short, arg9: V, arg10: short, arg11: V): $Map<(short), (V)>
static "of"<K, V>(arg0: short, arg1: V, arg2: short, arg3: V, arg4: short, arg5: V, arg6: short, arg7: V, arg8: short, arg9: V): $Map<(short), (V)>
 "merge"(arg0: short, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "putAll"(arg0: $Map$$Type<(short), (V)>): void
 "putIfAbsent"(arg0: short, arg1: V): V
 "compute"(arg0: short, arg1: $BiFunction$$Type<(short), (V), (V)>): V
static "entry"<K, V>(arg0: short, arg1: V): $Map$Entry<(short), (V)>
 "computeIfAbsent"(arg0: short, arg1: $Function$$Type<(short), (V)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: short, arg1: $BiFunction$$Type<(short), (V), (V)>): V
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(short), (V)>)[]): $Map<(short), (V)>
 "apply"(arg0: short): V
static "identity"<T>(): $Function<(short), (short)>
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(short), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2ObjectMap$$Type<V> = ($Short2ObjectMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2ObjectMap_<V> = $Short2ObjectMap$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.doubles.DoubleBinaryOperator" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BinaryOperator, $BinaryOperator$$Type} from "java.util.function.BinaryOperator"
import {$DoubleBinaryOperator as $DoubleBinaryOperator$0, $DoubleBinaryOperator$$Type as $DoubleBinaryOperator$0$$Type} from "java.util.function.DoubleBinaryOperator"

export interface $DoubleBinaryOperator extends $BinaryOperator<(double)>, $DoubleBinaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: double, arg1: double): double
 "apply"(arg0: double, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double, arg1: double): double
 "andThen"<V>(arg0: $Function$$Type<(double), (V)>): $BiFunction<(double), (double), (V)>

(arg0: double, arg1: double): double
}

export namespace $DoubleBinaryOperator {
function minBy<T>(arg0: $Comparator$$Type<(double)>): $BinaryOperator<(double)>
function maxBy<T>(arg0: $Comparator$$Type<(double)>): $BinaryOperator<(double)>
const probejs$$marker: never
}
export class $DoubleBinaryOperator$$Static implements $DoubleBinaryOperator {


/**
 * 
 * @deprecated
 */
 "apply"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "apply"(arg0: double, arg1: double): double
 "apply"(arg0: double, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double, arg1: double): double
static "minBy"<T>(arg0: $Comparator$$Type<(double)>): $BinaryOperator<(double)>
static "maxBy"<T>(arg0: $Comparator$$Type<(double)>): $BinaryOperator<(double)>
 "andThen"<V>(arg0: $Function$$Type<(double), (V)>): $BiFunction<(double), (double), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleBinaryOperator$$Type = ((arg0: double, arg1: double) => double);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleBinaryOperator_ = $DoubleBinaryOperator$$Type;
}}
declare module "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Boolean2IntFunction extends $Function<(boolean), (integer)> {

 "remove"(arg0: boolean): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
 "get"(arg0: boolean): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: integer): integer
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): integer

(arg0: boolean): integer
}

export namespace $Boolean2IntFunction {
function identity<T>(): $Function$0<(boolean), (boolean)>
const probejs$$marker: never
}
export class $Boolean2IntFunction$$Static implements $Boolean2IntFunction {


 "remove"(arg0: boolean): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
 "get"(arg0: boolean): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: integer): integer
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): integer
static "identity"<T>(): $Function$0<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2IntFunction$$Type = ((arg0: boolean) => integer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2IntFunction_ = $Boolean2IntFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.LongPredicate" {
import {$LongPredicate as $LongPredicate$0, $LongPredicate$$Type as $LongPredicate$0$$Type} from "java.util.function.LongPredicate"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"

export interface $LongPredicate extends $Predicate<(long)>, $LongPredicate$0 {

/**
 * 
 * @deprecated
 */
 "test"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$$Type<(long)>): $Predicate<(long)>
 "or"(arg0: $LongPredicate$0$$Type): $LongPredicate
 "or"(arg0: $LongPredicate$$Type): $LongPredicate
 "negate"(): $LongPredicate$0
 "and"(arg0: $LongPredicate$0$$Type): $LongPredicate$0
 "and"(arg0: $LongPredicate$$Type): $LongPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$$Type<(long)>): $Predicate<(long)>
 "test"(arg0: long): boolean

(arg0: long): boolean
}

export namespace $LongPredicate {
function not<T>(arg0: $Predicate$$Type<(long)>): $Predicate<(long)>
function isEqual<T>(arg0: any): $Predicate<(long)>
const probejs$$marker: never
}
export class $LongPredicate$$Static implements $LongPredicate {


/**
 * 
 * @deprecated
 */
 "test"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$$Type<(long)>): $Predicate<(long)>
 "or"(arg0: $LongPredicate$0$$Type): $LongPredicate
 "or"(arg0: $LongPredicate$$Type): $LongPredicate
 "negate"(): $LongPredicate$0
 "and"(arg0: $LongPredicate$0$$Type): $LongPredicate$0
 "and"(arg0: $LongPredicate$$Type): $LongPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$$Type<(long)>): $Predicate<(long)>
static "not"<T>(arg0: $Predicate$$Type<(long)>): $Predicate<(long)>
static "isEqual"<T>(arg0: any): $Predicate<(long)>
 "test"(arg0: long): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongPredicate$$Type = ((arg0: long) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongPredicate_ = $LongPredicate$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.Short2FloatFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$$Type} from "java.util.function.IntToDoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Short2FloatFunction extends $Function<(short), (float)>, $IntToDoubleFunction {

 "remove"(arg0: short): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: float): float
 "put"(arg0: short, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: short, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): float

(arg0: short): float
}

export namespace $Short2FloatFunction {
function identity<T>(): $Function$0<(short), (short)>
const probejs$$marker: never
}
export class $Short2FloatFunction$$Static implements $Short2FloatFunction {


 "remove"(arg0: short): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: float): float
 "put"(arg0: short, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: short, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): float
static "identity"<T>(): $Function$0<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2FloatFunction$$Type = ((arg0: short) => float);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2FloatFunction_ = $Short2FloatFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.LongSortedSet" {
import {$LongPredicate as $LongPredicate$0, $LongPredicate$$Type as $LongPredicate$0$$Type} from "java.util.function.LongPredicate"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$SortedSet, $SortedSet$$Type} from "java.util.SortedSet"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$LongSet, $LongSet$$Type} from "it.unimi.dsi.fastutil.longs.LongSet"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$LongBidirectionalIterator, $LongBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.longs.LongBidirectionalIterator"
import {$LongStream, $LongStream$$Type} from "java.util.stream.LongStream"
import {$LongBidirectionalIterable, $LongBidirectionalIterable$$Type} from "it.unimi.dsi.fastutil.longs.LongBidirectionalIterable"
import {$LongConsumer, $LongConsumer$$Type} from "it.unimi.dsi.fastutil.longs.LongConsumer"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$LongPredicate, $LongPredicate$$Type} from "it.unimi.dsi.fastutil.longs.LongPredicate"
import {$SequencedSet, $SequencedSet$$Type} from "java.util.SequencedSet"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$$Type as $LongConsumer$0$$Type} from "java.util.function.LongConsumer"
import {$LongSpliterator, $LongSpliterator$$Type} from "it.unimi.dsi.fastutil.longs.LongSpliterator"
import {$Set, $Set$$Type} from "java.util.Set"
import {$LongIterator, $LongIterator$$Type} from "it.unimi.dsi.fastutil.longs.LongIterator"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$LongCollection, $LongCollection$$Type} from "it.unimi.dsi.fastutil.longs.LongCollection"

export interface $LongSortedSet extends $LongSet, $SortedSet<(long)>, $LongBidirectionalIterable {

 "iterator"(): $LongIterator
 "iterator"(arg0: long): $LongBidirectionalIterator
/**
 * 
 * @deprecated
 */
 "last"(): any
 "spliterator"(): $Spliterator<(any)>
/**
 * 
 * @deprecated
 */
 "first"(): long
 "comparator"(): $Comparator<(any)>
 "subSet"(arg0: long, arg1: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "subSet"(arg0: any, arg1: any): $SortedSet<(any)>
/**
 * 
 * @deprecated
 */
 "subSet"(arg0: long, arg1: long): $LongSortedSet
 "headSet"(arg0: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "headSet"(arg0: any): $SortedSet<(any)>
/**
 * 
 * @deprecated
 */
 "headSet"(arg0: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "tailSet"(arg0: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "tailSet"(arg0: any): $SortedSet<(any)>
 "tailSet"(arg0: long): $LongSortedSet
 "lastLong"(): long
 "firstLong"(): long
 "remove"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "rem"(arg0: long): boolean
 "getFirst"(): long
 "getLast"(): long
 "addFirst"(arg0: long): void
 "addLast"(arg0: long): void
 "removeFirst"(): long
 "removeLast"(): long
 "reversed"(): $SequencedSet<(any)>
 "add"(arg0: long): boolean
 "toArray"(arg0: (long)[]): (long)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
 "addAll"(arg0: $LongCollection$$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(long)>): boolean
 "removeIf"(arg0: $LongPredicate$$Type): boolean
 "removeAll"(arg0: $LongCollection$$Type): boolean
 "retainAll"(arg0: $LongCollection$$Type): boolean
 "containsAll"(arg0: $LongCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "longStream"(): $LongStream
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "toLongArray"(): (long)[]
 "longIterator"(): $LongIterator
 "longParallelStream"(): $LongStream
 "longSpliterator"(): $LongSpliterator
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: $Collection$$Type<(long)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "forEach"(arg0: $LongConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(long)>): void
 "forEach"(arg0: $LongConsumer$$Type): void
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
get "empty"(): boolean
}

export namespace $LongSortedSet {
function of(arg0: long, arg1: long): $LongSet
function of(): $LongSet
function of(...arg0: (long)[]): $LongSet
function of(arg0: long): $LongSet
function of(arg0: long, arg1: long, arg2: long): $LongSet
function copyOf<E>(arg0: $Collection$$Type<(long)>): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $Set<(long)>
function of<E>(...arg0: (long)[]): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long): $Set<(long)>
function of<E>(arg0: long): $Set<(long)>
function of<E>(arg0: long, arg1: long): $Set<(long)>
const probejs$$marker: never
}
export class $LongSortedSet$$Static implements $LongSortedSet {


 "iterator"(): $LongIterator
 "iterator"(arg0: long): $LongBidirectionalIterator
/**
 * 
 * @deprecated
 */
 "last"(): any
 "spliterator"(): $Spliterator<(any)>
/**
 * 
 * @deprecated
 */
 "first"(): long
 "comparator"(): $Comparator<(any)>
 "subSet"(arg0: long, arg1: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "subSet"(arg0: any, arg1: any): $SortedSet<(any)>
/**
 * 
 * @deprecated
 */
 "subSet"(arg0: long, arg1: long): $LongSortedSet
 "headSet"(arg0: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "headSet"(arg0: any): $SortedSet<(any)>
/**
 * 
 * @deprecated
 */
 "headSet"(arg0: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "tailSet"(arg0: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "tailSet"(arg0: any): $SortedSet<(any)>
 "tailSet"(arg0: long): $LongSortedSet
 "lastLong"(): long
 "firstLong"(): long
 "remove"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
static "of"(arg0: long, arg1: long): $LongSet
static "of"(): $LongSet
static "of"(...arg0: (long)[]): $LongSet
static "of"(arg0: long): $LongSet
static "of"(arg0: long, arg1: long, arg2: long): $LongSet
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "rem"(arg0: long): boolean
 "getFirst"(): long
 "getLast"(): long
 "addFirst"(arg0: long): void
 "addLast"(arg0: long): void
 "removeFirst"(): long
 "removeLast"(): long
 "reversed"(): $SequencedSet<(any)>
 "add"(arg0: long): boolean
 "toArray"(arg0: (long)[]): (long)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
 "addAll"(arg0: $LongCollection$$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(long)>): boolean
 "removeIf"(arg0: $LongPredicate$$Type): boolean
 "removeAll"(arg0: $LongCollection$$Type): boolean
 "retainAll"(arg0: $LongCollection$$Type): boolean
 "containsAll"(arg0: $LongCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "longStream"(): $LongStream
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "toLongArray"(): (long)[]
 "longIterator"(): $LongIterator
 "longParallelStream"(): $LongStream
 "longSpliterator"(): $LongSpliterator
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<E>(arg0: $Collection$$Type<(long)>): $Set<(long)>
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $Set<(long)>
static "of"<E>(...arg0: (long)[]): $Set<(long)>
static "of"<E>(arg0: long, arg1: long, arg2: long): $Set<(long)>
static "of"<E>(arg0: long): $Set<(long)>
static "of"<E>(arg0: long, arg1: long): $Set<(long)>
 "addAll"(arg0: $Collection$$Type<(long)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "forEach"(arg0: $LongConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(long)>): void
 "forEach"(arg0: $LongConsumer$$Type): void
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongSortedSet$$Type = ($LongSortedSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongSortedSet_ = $LongSortedSet$$Type;
}}
declare module "it.unimi.dsi.fastutil.BidirectionalIterator" {
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $BidirectionalIterator<K> extends $Iterator<(K)> {

 "hasPrevious"(): boolean
 "previous"(): K
 "remove"(): void
 "forEachRemaining"(arg0: $Consumer$$Type<(K)>): void
 "hasNext"(): boolean
 "next"(): K
}

export namespace $BidirectionalIterator {
const probejs$$marker: never
}
export class $BidirectionalIterator$$Static<K> implements $BidirectionalIterator {


 "hasPrevious"(): boolean
 "previous"(): K
 "remove"(): void
 "forEachRemaining"(arg0: $Consumer$$Type<(K)>): void
 "hasNext"(): boolean
 "next"(): K
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BidirectionalIterator$$Type<K> = ($BidirectionalIterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BidirectionalIterator_<K> = $BidirectionalIterator$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.chars.Char2IntFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Char2IntFunction extends $Function<(character), (integer)>, $IntUnaryOperator {

 "remove"(arg0: character): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: integer): integer
 "put"(arg0: character, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: character, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): integer
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: character): integer
}

export namespace $Char2IntFunction {
function identity(): $IntUnaryOperator
const probejs$$marker: never
}
export class $Char2IntFunction$$Static implements $Char2IntFunction {


 "remove"(arg0: character): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: integer): integer
 "put"(arg0: character, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: character, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): integer
static "identity"(): $IntUnaryOperator
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2IntFunction$$Type = ((arg0: character) => integer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2IntFunction_ = $Char2IntFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.floats.Float2CharFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$DoubleToIntFunction, $DoubleToIntFunction$$Type} from "java.util.function.DoubleToIntFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"

export interface $Float2CharFunction extends $Function<(float), (character)>, $DoubleToIntFunction {

 "remove"(arg0: float): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: character): character
 "put"(arg0: float, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: float, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): character

(arg0: float): character
}

export namespace $Float2CharFunction {
function identity<T>(): $Function$0<(float), (float)>
const probejs$$marker: never
}
export class $Float2CharFunction$$Static implements $Float2CharFunction {


 "remove"(arg0: float): character
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: character): character
 "put"(arg0: float, arg1: character): character
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: float, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2CharFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2CharFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2CharFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): character
static "identity"<T>(): $Function$0<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2CharFunction$$Type = ((arg0: float) => character);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2CharFunction_ = $Float2CharFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.ObjectSpliterator" {
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ObjectSpliterator<K> extends $Spliterator<(K)> {

 "skip"(arg0: long): long
 "trySplit"(): $Spliterator<(any)>
 "forEachRemaining"(arg0: $Consumer$$Type<(K)>): void
 "characteristics"(): integer
 "tryAdvance"(arg0: $Consumer$$Type<(K)>): boolean
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
 "getComparator"(): $Comparator<(K)>
get "exactSizeIfKnown"(): long
get "comparator"(): $Comparator<(K)>
}

export namespace $ObjectSpliterator {
const probejs$$marker: never
}
export class $ObjectSpliterator$$Static<K> implements $ObjectSpliterator {


 "skip"(arg0: long): long
 "trySplit"(): $Spliterator<(any)>
 "forEachRemaining"(arg0: $Consumer$$Type<(K)>): void
 "characteristics"(): integer
 "tryAdvance"(arg0: $Consumer$$Type<(K)>): boolean
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
 "getComparator"(): $Comparator<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectSpliterator$$Type<K> = ($ObjectSpliterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectSpliterator_<K> = $ObjectSpliterator$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.longs.Long2IntFunction" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$LongToIntFunction, $LongToIntFunction$$Type} from "java.util.function.LongToIntFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Long2IntFunction extends $Function<(long), (integer)>, $LongToIntFunction {

 "remove"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: integer): integer
 "put"(arg0: long, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: long, arg1: integer): integer
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): integer

(arg0: long): integer
}

export namespace $Long2IntFunction {
function identity<T>(): $Function$0<(long), (long)>
const probejs$$marker: never
}
export class $Long2IntFunction$$Static implements $Long2IntFunction {


 "remove"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: integer): integer
 "put"(arg0: long, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: long, arg1: integer): integer
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): integer
static "identity"<T>(): $Function$0<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2IntFunction$$Type = ((arg0: long) => integer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2IntFunction_ = $Long2IntFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.doubles.DoubleDoubleImmutablePair" {
import {$Pair, $Pair$$Type} from "it.unimi.dsi.fastutil.Pair"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$DoubleDoublePair, $DoubleDoublePair$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleDoublePair"

export class $DoubleDoubleImmutablePair implements $DoubleDoublePair, $Serializable {

constructor(arg0: double, arg1: double)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "of"(arg0: double, arg1: double): $DoubleDoubleImmutablePair
public "leftDouble"(): double
public "rightDouble"(): double
public "value"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
public "value"(): double
/**
 * 
 * @deprecated
 */
public "value"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
public "value"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
public "first"(): any
/**
 * 
 * @deprecated
 */
public "first"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
public "first"(arg0: any): $Pair<(any), (any)>
public "first"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
public "second"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
public "second"(): double
public "second"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
public "second"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
public "key"(arg0: double): $DoubleDoublePair
public "key"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
public "key"(): any
/**
 * 
 * @deprecated
 */
public "key"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
public "left"(): double
public "left"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
public "left"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
public "left"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
public "right"(arg0: double): $DoubleDoublePair
/**
 * 
 * @deprecated
 */
public "right"(arg0: any): $Pair<(any), (any)>
/**
 * 
 * @deprecated
 */
public "right"(): double
public "right"(arg0: double): $DoubleDoublePair
public "firstDouble"(): double
public "secondDouble"(): double
public "valueDouble"(): double
public static "lexComparator"(): $Comparator<($DoubleDoublePair)>
public "keyDouble"(): double
public static "of"<L, R>(arg0: double, arg1: double): $Pair<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleDoubleImmutablePair$$Type = ($DoubleDoubleImmutablePair);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleDoubleImmutablePair_ = $DoubleDoubleImmutablePair$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2DoubleMap" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$ToDoubleFunction, $ToDoubleFunction$$Type} from "java.util.function.ToDoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$DoubleBinaryOperator, $DoubleBinaryOperator$$Type} from "java.util.function.DoubleBinaryOperator"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Object2DoubleMap$Entry, $Object2DoubleMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleMap$Entry"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$DoubleBinaryOperator as $DoubleBinaryOperator$0, $DoubleBinaryOperator$$Type as $DoubleBinaryOperator$0$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleBinaryOperator"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Object2DoubleMap<K> extends $Object2DoubleFunction<(K)>, $Map<(K), (double)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
 "remove"(arg0: any, arg1: double): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: double): double
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: double): double
 "replace"(arg0: K, arg1: double, arg2: double): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: double, arg2: double): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: double, arg2: $BiFunction$$Type<(double), (double), (double)>): double
 "merge"(arg0: K, arg1: double, arg2: $BiFunction$$Type<(double), (double), (double)>): double
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (double)>)>
 "putIfAbsent"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
 "forEach"(arg0: $BiConsumer$$Type<(K), (double)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToDoubleFunction$$Type<(K)>): double
 "computeIfAbsent"(arg0: K, arg1: $Object2DoubleFunction$$Type<(K)>): double
 "keySet"(): $ObjectSet<(K)>
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: double): boolean
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
/**
 * 
 * @deprecated
 */
 "computeDoubleIfAbsentPartial"(arg0: K, arg1: $Object2DoubleFunction$$Type<(K)>): double
 "object2DoubleEntrySet"(): $ObjectSet<($Object2DoubleMap$Entry<(K)>)>
 "computeDoubleIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (double), (double)>): double
/**
 * 
 * @deprecated
 */
 "computeDoubleIfAbsent"(arg0: K, arg1: $ToDoubleFunction$$Type<(K)>): double
/**
 * 
 * @deprecated
 */
 "mergeDouble"(arg0: K, arg1: double, arg2: $BiFunction$$Type<(double), (double), (double)>): double
 "mergeDouble"(arg0: K, arg1: double, arg2: $DoubleBinaryOperator$0$$Type): double
 "mergeDouble"(arg0: K, arg1: double, arg2: $DoubleBinaryOperator$$Type): double
 "computeDouble"(arg0: K, arg1: $BiFunction$$Type<(K), (double), (double)>): double
 "put"(arg0: K, arg1: double): double
 "getDouble"(arg0: any): double
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(double), (T)>): $Function<(K), (T)>
 "removeDouble"(arg0: any): double
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2DoubleFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (double), (double)>): void
 "putAll"(arg0: $Map$$Type<(K), (double)>): void
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (double), (double)>): double
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (double)>): double
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (double), (double)>): double
 "apply"(arg0: K): double
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (double)>
[index: string | number]: double
get "empty"(): boolean
}

export namespace $Object2DoubleMap {
function copyOf<K, V>(arg0: $Map$$Type<(K), (double)>): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double): $Map<(K), (double)>
function of<K, V>(): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double, arg12: K, arg13: double, arg14: K, arg15: double, arg16: K, arg17: double, arg18: K, arg19: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double, arg12: K, arg13: double, arg14: K, arg15: double, arg16: K, arg17: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double, arg12: K, arg13: double, arg14: K, arg15: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double, arg12: K, arg13: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double): $Map<(K), (double)>
function of<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double): $Map<(K), (double)>
function entry<K, V>(arg0: K, arg1: double): $Map$Entry<(K), (double)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(K), (double)>)[]): $Map<(K), (double)>
function identity<T>(): $Function<(K), (K)>
const probejs$$marker: never
}
export class $Object2DoubleMap$$Static<K> implements $Object2DoubleMap {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
 "remove"(arg0: any, arg1: double): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: double): double
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: double): double
 "replace"(arg0: K, arg1: double, arg2: double): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: double, arg2: double): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: any, arg1: any, arg2: any): boolean
/**
 * 
 * @deprecated
 */
 "merge"(arg0: any, arg1: any, arg2: $BiFunction$$Type<(any), (any), (any)>): any
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: double, arg2: $BiFunction$$Type<(double), (double), (double)>): double
 "merge"(arg0: K, arg1: double, arg2: $BiFunction$$Type<(double), (double), (double)>): double
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (double)>)>
 "putIfAbsent"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: any, arg1: any): any
 "forEach"(arg0: $BiConsumer$$Type<(K), (double)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToDoubleFunction$$Type<(K)>): double
 "computeIfAbsent"(arg0: K, arg1: $Object2DoubleFunction$$Type<(K)>): double
 "keySet"(): $ObjectSet<(K)>
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: double): boolean
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
/**
 * 
 * @deprecated
 */
 "computeDoubleIfAbsentPartial"(arg0: K, arg1: $Object2DoubleFunction$$Type<(K)>): double
 "object2DoubleEntrySet"(): $ObjectSet<($Object2DoubleMap$Entry<(K)>)>
 "computeDoubleIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (double), (double)>): double
/**
 * 
 * @deprecated
 */
 "computeDoubleIfAbsent"(arg0: K, arg1: $ToDoubleFunction$$Type<(K)>): double
/**
 * 
 * @deprecated
 */
 "mergeDouble"(arg0: K, arg1: double, arg2: $BiFunction$$Type<(double), (double), (double)>): double
 "mergeDouble"(arg0: K, arg1: double, arg2: $DoubleBinaryOperator$0$$Type): double
 "mergeDouble"(arg0: K, arg1: double, arg2: $DoubleBinaryOperator$$Type): double
 "computeDouble"(arg0: K, arg1: $BiFunction$$Type<(K), (double), (double)>): double
 "put"(arg0: K, arg1: double): double
 "getDouble"(arg0: any): double
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$$Type<(double), (T)>): $Function<(K), (T)>
 "removeDouble"(arg0: any): double
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2DoubleFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(K), (double)>): $Map<(K), (double)>
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (double), (double)>): void
static "of"<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double): $Map<(K), (double)>
static "of"<K, V>(): $Map<(K), (double)>
static "of"<K, V>(arg0: K, arg1: double): $Map<(K), (double)>
static "of"<K, V>(arg0: K, arg1: double, arg2: K, arg3: double): $Map<(K), (double)>
static "of"<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double): $Map<(K), (double)>
static "of"<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double, arg12: K, arg13: double, arg14: K, arg15: double, arg16: K, arg17: double, arg18: K, arg19: double): $Map<(K), (double)>
static "of"<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double, arg12: K, arg13: double, arg14: K, arg15: double, arg16: K, arg17: double): $Map<(K), (double)>
static "of"<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double, arg12: K, arg13: double, arg14: K, arg15: double): $Map<(K), (double)>
static "of"<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double, arg12: K, arg13: double): $Map<(K), (double)>
static "of"<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double, arg10: K, arg11: double): $Map<(K), (double)>
static "of"<K, V>(arg0: K, arg1: double, arg2: K, arg3: double, arg4: K, arg5: double, arg6: K, arg7: double, arg8: K, arg9: double): $Map<(K), (double)>
 "putAll"(arg0: $Map$$Type<(K), (double)>): void
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (double), (double)>): double
static "entry"<K, V>(arg0: K, arg1: double): $Map$Entry<(K), (double)>
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (double)>): double
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (double), (double)>): double
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (double)>)[]): $Map<(K), (double)>
 "apply"(arg0: K): double
static "identity"<T>(): $Function<(K), (K)>
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2DoubleMap$$Type<K> = ($Object2DoubleMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2DoubleMap_<K> = $Object2DoubleMap$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2ByteFunction" {
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"

export interface $Int2ByteFunction extends $Function<(integer), (byte)>, $IntUnaryOperator {

 "remove"(arg0: integer): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: byte): byte
 "put"(arg0: integer, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: integer, arg1: byte): byte
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): byte
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: integer): byte
}

export namespace $Int2ByteFunction {
function identity(): $IntUnaryOperator
const probejs$$marker: never
}
export class $Int2ByteFunction$$Static implements $Int2ByteFunction {


 "remove"(arg0: integer): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: integer): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: byte): byte
 "put"(arg0: integer, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: integer, arg1: byte): byte
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (integer)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(integer), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Int2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Int2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: integer): byte
static "identity"(): $IntUnaryOperator
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ByteFunction$$Type = ((arg0: integer) => byte);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ByteFunction_ = $Int2ByteFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2IntFunction" {
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Object2IntFunction<K> extends $Function<(K), (integer)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getInt"(arg0: any): integer
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2IntFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2IntFunction
 "removeInt"(arg0: any): integer
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): integer
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (integer)>

(arg0: any): integer
}

export namespace $Object2IntFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Object2IntFunction$$Static<K> implements $Object2IntFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getInt"(arg0: any): integer
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2IntFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2IntFunction
 "removeInt"(arg0: any): integer
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): integer
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2IntFunction$$Type<K> = ((arg0: any) => integer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2IntFunction_<K> = $Object2IntFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterable" {
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator"
import {$ObjectSpliterator, $ObjectSpliterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSpliterator"
import {$ObjectIterable, $ObjectIterable$$Type} from "it.unimi.dsi.fastutil.objects.ObjectIterable"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ObjectBidirectionalIterable<K> extends $ObjectIterable<(K)> {

 "iterator"(): $ObjectBidirectionalIterator<(K)>
 "spliterator"(): $ObjectSpliterator<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void

(): $ObjectBidirectionalIterator$$Type<(K)>
[Symbol.iterator](): IterableIterator<K>;
}

export namespace $ObjectBidirectionalIterable {
const probejs$$marker: never
}
export class $ObjectBidirectionalIterable$$Static<K> implements $ObjectBidirectionalIterable {


 "iterator"(): $ObjectBidirectionalIterator<(K)>
 "spliterator"(): $ObjectSpliterator<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectBidirectionalIterable$$Type<K> = (() => $ObjectBidirectionalIterator$$Type<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectBidirectionalIterable_<K> = $ObjectBidirectionalIterable$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$$Type} from "java.util.function.DoubleUnaryOperator"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Double2DoubleFunction extends $Function<(double), (double)>, $DoubleUnaryOperator {

 "remove"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: double, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: double, arg1: double): double
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): double
 "compose"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator

(arg0: double): double
}

export namespace $Double2DoubleFunction {
function identity(): $Double2DoubleFunction
const probejs$$marker: never
}
export class $Double2DoubleFunction$$Static implements $Double2DoubleFunction {


 "remove"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: double, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: double): double
static "identity"(): $Double2DoubleFunction
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: double, arg1: double): double
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): double
 "compose"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2DoubleFunction$$Type = ((arg0: double) => double);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2DoubleFunction_ = $Double2DoubleFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2ByteFunction" {
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Object2ByteFunction<K> extends $Function<(K), (byte)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getByte"(arg0: any): byte
 "getOrDefault"(arg0: any, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2ByteFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2ByteFunction
 "removeByte"(arg0: any): byte
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): byte
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (byte)>

(arg0: any): byte
}

export namespace $Object2ByteFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Object2ByteFunction$$Static<K> implements $Object2ByteFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getByte"(arg0: any): byte
 "getOrDefault"(arg0: any, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2ByteFunction
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Object2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2ByteFunction
 "removeByte"(arg0: any): byte
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): byte
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ByteFunction$$Type<K> = ((arg0: any) => byte);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ByteFunction_<K> = $Object2ByteFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2ShortFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Reference2ShortFunction<K> extends $Function<(K), (short)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getShort"(arg0: any): short
 "getOrDefault"(arg0: any, arg1: short): short
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2ShortFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2ShortFunction
 "removeShort"(arg0: any): short
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): short
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (short)>

(arg0: any): short
}

export namespace $Reference2ShortFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Reference2ShortFunction$$Static<K> implements $Reference2ShortFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getShort"(arg0: any): short
 "getOrDefault"(arg0: any, arg1: short): short
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2ShortFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2ShortFunction
 "removeShort"(arg0: any): short
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): short
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ShortFunction$$Type<K> = ((arg0: any) => short);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ShortFunction_<K> = $Reference2ShortFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.shorts.ShortBidirectionalIterator" {
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator"
import {$ShortConsumer, $ShortConsumer$$Type} from "it.unimi.dsi.fastutil.shorts.ShortConsumer"
import {$IntConsumer, $IntConsumer$$Type} from "java.util.function.IntConsumer"
import {$ShortIterator, $ShortIterator$$Type} from "it.unimi.dsi.fastutil.shorts.ShortIterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ShortBidirectionalIterator extends $ShortIterator, $ObjectBidirectionalIterator<(short)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): short
 "back"(arg0: integer): integer
 "previousShort"(): short
 "forEachRemaining"(arg0: $IntConsumer$$Type): void
 "forEachRemaining"(arg0: $ShortConsumer$$Type): void
 "forEachRemaining"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(short)>): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "nextShort"(): short
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $ShortBidirectionalIterator {
const probejs$$marker: never
}
export class $ShortBidirectionalIterator$$Static implements $ShortBidirectionalIterator {


 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): short
 "back"(arg0: integer): integer
 "previousShort"(): short
 "forEachRemaining"(arg0: $IntConsumer$$Type): void
 "forEachRemaining"(arg0: $ShortConsumer$$Type): void
 "forEachRemaining"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(short)>): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "nextShort"(): short
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortBidirectionalIterator$$Type = ($ShortBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortBidirectionalIterator_ = $ShortBidirectionalIterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.Long2ShortFunction" {
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$LongToIntFunction, $LongToIntFunction$$Type} from "java.util.function.LongToIntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Long2ShortFunction extends $Function<(long), (short)>, $LongToIntFunction {

 "remove"(arg0: long): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: short): short
 "put"(arg0: long, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: long, arg1: short): short
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): short

(arg0: long): short
}

export namespace $Long2ShortFunction {
function identity<T>(): $Function$0<(long), (long)>
const probejs$$marker: never
}
export class $Long2ShortFunction$$Static implements $Long2ShortFunction {


 "remove"(arg0: long): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: short): short
 "put"(arg0: long, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: long, arg1: short): short
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): short
static "identity"<T>(): $Function$0<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ShortFunction$$Type = ((arg0: long) => short);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ShortFunction_ = $Long2ShortFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.doubles.Double2LongFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"
import {$DoubleToLongFunction, $DoubleToLongFunction$$Type} from "java.util.function.DoubleToLongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Double2LongFunction extends $Function<(double), (long)>, $DoubleToLongFunction {

 "remove"(arg0: double): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: long): long
 "put"(arg0: double, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: double, arg1: long): long
 "applyAsLong"(arg0: double): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): long

(arg0: double): long
}

export namespace $Double2LongFunction {
function identity<T>(): $Function$0<(double), (double)>
const probejs$$marker: never
}
export class $Double2LongFunction$$Static implements $Double2LongFunction {


 "remove"(arg0: double): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: long): long
 "put"(arg0: double, arg1: long): long
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: double, arg1: long): long
 "applyAsLong"(arg0: double): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): long
static "identity"<T>(): $Function$0<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2LongFunction$$Type = ((arg0: double) => long);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2LongFunction_ = $Double2LongFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.doubles.Double2IntFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$DoubleToIntFunction, $DoubleToIntFunction$$Type} from "java.util.function.DoubleToIntFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Double2IntFunction extends $Function<(double), (integer)>, $DoubleToIntFunction {

 "remove"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: integer): integer
 "put"(arg0: double, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: double, arg1: integer): integer
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): integer

(arg0: double): integer
}

export namespace $Double2IntFunction {
function identity<T>(): $Function$0<(double), (double)>
const probejs$$marker: never
}
export class $Double2IntFunction$$Static implements $Double2IntFunction {


 "remove"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: integer): integer
 "put"(arg0: double, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: double, arg1: integer): integer
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): integer
static "identity"<T>(): $Function$0<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2IntFunction$$Type = ((arg0: double) => integer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2IntFunction_ = $Double2IntFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.Short2IntFunction" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Short2IntFunction extends $Function<(short), (integer)>, $IntUnaryOperator {

 "remove"(arg0: short): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: integer): integer
 "put"(arg0: short, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: short, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): integer
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: short): integer
}

export namespace $Short2IntFunction {
function identity(): $IntUnaryOperator
const probejs$$marker: never
}
export class $Short2IntFunction$$Static implements $Short2IntFunction {


 "remove"(arg0: short): integer
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: integer): integer
 "put"(arg0: short, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: short, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2IntFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2IntFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): integer
static "identity"(): $IntUnaryOperator
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2IntFunction$$Type = ((arg0: short) => integer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2IntFunction_ = $Short2IntFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.IntCollection" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$IntStream, $IntStream$$Type} from "java.util.stream.IntStream"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$$Type as $IntPredicate$0$$Type} from "java.util.function.IntPredicate"
import {$IntSpliterator, $IntSpliterator$$Type} from "it.unimi.dsi.fastutil.ints.IntSpliterator"
import {$IntIterable, $IntIterable$$Type} from "it.unimi.dsi.fastutil.ints.IntIterable"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$IntIterator, $IntIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntIterator"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$$Type as $IntConsumer$0$$Type} from "java.util.function.IntConsumer"
import {$IntPredicate, $IntPredicate$$Type} from "it.unimi.dsi.fastutil.ints.IntPredicate"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$IntConsumer, $IntConsumer$$Type} from "it.unimi.dsi.fastutil.ints.IntConsumer"

export interface $IntCollection extends $Collection<(integer)>, $IntIterable {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
 "toArray"(arg0: (integer)[]): (integer)[]
 "iterator"(): $IntIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "contains"(arg0: integer): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(integer)>): boolean
 "removeIf"(arg0: $IntPredicate$0$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $IntCollection$$Type): boolean
 "retainAll"(arg0: $IntCollection$$Type): boolean
 "containsAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
 "rem"(arg0: integer): boolean
 "toIntArray"(): (integer)[]
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$$Type<(integer)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "forEach"(arg0: $IntConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(integer)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
get "empty"(): boolean
}

export namespace $IntCollection {
const probejs$$marker: never
}
export class $IntCollection$$Static implements $IntCollection {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
 "toArray"(arg0: (integer)[]): (integer)[]
 "iterator"(): $IntIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "contains"(arg0: integer): boolean
 "spliterator"(): $Spliterator<(any)>
 "addAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(integer)>): boolean
 "removeIf"(arg0: $IntPredicate$0$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $IntCollection$$Type): boolean
 "retainAll"(arg0: $IntCollection$$Type): boolean
 "containsAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
 "rem"(arg0: integer): boolean
 "toIntArray"(): (integer)[]
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$$Type<(integer)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "forEach"(arg0: $IntConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(integer)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntCollection$$Type = ($IntCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntCollection_ = $IntCollection$$Type;
}}
declare module "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$IntPredicate, $IntPredicate$$Type} from "java.util.function.IntPredicate"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Byte2BooleanFunction extends $Function<(byte), (boolean)>, $IntPredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: byte, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
 "getOrDefault"(arg0: byte, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): boolean
 "or"(arg0: $IntPredicate$$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$$Type): $IntPredicate

(arg0: byte): boolean
}

export namespace $Byte2BooleanFunction {
function identity<T>(): $Function$0<(byte), (byte)>
const probejs$$marker: never
}
export class $Byte2BooleanFunction$$Static implements $Byte2BooleanFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: byte, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
 "getOrDefault"(arg0: byte, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (byte)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(byte), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Byte2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Byte2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Byte2ByteFunction
 "composeByte"(arg0: $Byte2ByteFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2ByteFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2ByteFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Byte2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Byte2FloatFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2ByteFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Byte2CharFunction
 "composeReference"<T>(arg0: $Reference2ByteFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2ByteFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Byte2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Byte2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Byte2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ByteFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: byte): boolean
 "or"(arg0: $IntPredicate$$Type): $IntPredicate
 "negate"(): $IntPredicate
 "and"(arg0: $IntPredicate$$Type): $IntPredicate
static "identity"<T>(): $Function$0<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2BooleanFunction$$Type = ((arg0: byte) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2BooleanFunction_ = $Byte2BooleanFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator" {
import {$ObjectIterator, $ObjectIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectIterator"
import {$BidirectionalIterator, $BidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.BidirectionalIterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ObjectBidirectionalIterator<K> extends $ObjectIterator<(K)>, $BidirectionalIterator<(K)> {

 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "hasPrevious"(): boolean
 "previous"(): K
 "remove"(): void
 "forEachRemaining"(arg0: $Consumer$$Type<(K)>): void
 "hasNext"(): boolean
 "next"(): K
}

export namespace $ObjectBidirectionalIterator {
const probejs$$marker: never
}
export class $ObjectBidirectionalIterator$$Static<K> implements $ObjectBidirectionalIterator {


 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "hasPrevious"(): boolean
 "previous"(): K
 "remove"(): void
 "forEachRemaining"(arg0: $Consumer$$Type<(K)>): void
 "hasNext"(): boolean
 "next"(): K
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectBidirectionalIterator$$Type<K> = ($ObjectBidirectionalIterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectBidirectionalIterator_<K> = $ObjectBidirectionalIterator$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.longs.LongSpliterator" {
import {$Spliterator$OfPrimitive, $Spliterator$OfPrimitive$$Type} from "java.util.Spliterator$OfPrimitive"
import {$Spliterator$OfLong, $Spliterator$OfLong$$Type} from "java.util.Spliterator$OfLong"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$$Type as $LongConsumer$0$$Type} from "java.util.function.LongConsumer"
import {$LongConsumer, $LongConsumer$$Type} from "it.unimi.dsi.fastutil.longs.LongConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $LongSpliterator extends $Spliterator$OfLong {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(long)>): void
 "forEachRemaining"(arg0: $LongConsumer$$Type): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$$Type<(long)>): boolean
 "tryAdvance"(arg0: $LongConsumer$$Type): boolean
 "trySplit"(): $Spliterator$OfPrimitive<(any), (any), (any)>
 "getComparator"(): $Comparator<(any)>
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $LongConsumer$0$$Type): void
 "tryAdvance"(arg0: any): boolean
 "tryAdvance"(arg0: $LongConsumer$0$$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
get "comparator"(): $Comparator<(any)>
get "exactSizeIfKnown"(): long
}

export namespace $LongSpliterator {
const probejs$$marker: never
}
export class $LongSpliterator$$Static implements $LongSpliterator {


/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(long)>): void
 "forEachRemaining"(arg0: $LongConsumer$$Type): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$$Type<(long)>): boolean
 "tryAdvance"(arg0: $LongConsumer$$Type): boolean
 "trySplit"(): $Spliterator$OfPrimitive<(any), (any), (any)>
 "getComparator"(): $Comparator<(any)>
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $LongConsumer$0$$Type): void
 "tryAdvance"(arg0: any): boolean
 "tryAdvance"(arg0: $LongConsumer$0$$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongSpliterator$$Type = ($LongSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongSpliterator_ = $LongSpliterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"

export interface $Boolean2FloatFunction extends $Function<(boolean), (float)> {

 "remove"(arg0: boolean): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
 "get"(arg0: boolean): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: float): float
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): float

(arg0: boolean): float
}

export namespace $Boolean2FloatFunction {
function identity<T>(): $Function$0<(boolean), (boolean)>
const probejs$$marker: never
}
export class $Boolean2FloatFunction$$Static implements $Boolean2FloatFunction {


 "remove"(arg0: boolean): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
 "get"(arg0: boolean): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: float): float
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): float
static "identity"<T>(): $Function$0<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2FloatFunction$$Type = ((arg0: boolean) => float);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2FloatFunction_ = $Boolean2FloatFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.Int2ObjectMap" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Int2ObjectMap$Entry, $Int2ObjectMap$Entry$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectMap$Entry"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$ObjectCollection, $ObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.ObjectCollection"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Int2ObjectMap<V> extends $Int2ObjectFunction<(V)>, $Map<(integer), (V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: integer, arg1: any): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "values"(): $ObjectCollection<(V)>
 "clear"(): void
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "replace"(arg0: integer, arg1: V): V
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
/**
 * 
 * @deprecated
 */
 "entrySet"(): $Set<(any)>
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(integer), (V)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $Int2ObjectFunction$$Type<(V)>): V
 "computeIfAbsent"(arg0: integer, arg1: $IntFunction$$Type<(V)>): V
 "keySet"(): $Set<(any)>
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "int2ObjectEntrySet"(): $ObjectSet<($Int2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2ObjectFunction$$Type<(V)>): V
 "remove"(arg0: integer): V
 "get"(arg0: integer): V
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (integer)>): $Function<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Int2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Int2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Int2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "replace"(arg0: integer, arg1: V): V
 "replaceAll"(arg0: $BiFunction$$Type<(integer), (V), (V)>): void
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "putAll"(arg0: $Map$$Type<(integer), (V)>): void
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
 "computeIfAbsent"(arg0: integer, arg1: $Function$$Type<(integer), (V)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
 "apply"(arg0: integer): V
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(integer), (V)>
[index: string | number]: V
get "empty"(): boolean
}

export namespace $Int2ObjectMap {
function copyOf<K, V>(arg0: $Map$$Type<(integer), (V)>): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V): $Map<(integer), (V)>
function of<K, V>(): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V, arg18: integer, arg19: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V): $Map<(integer), (V)>
function entry<K, V>(arg0: integer, arg1: V): $Map$Entry<(integer), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(integer), (V)>)[]): $Map<(integer), (V)>
function identity<T>(): $Function<(integer), (integer)>
const probejs$$marker: never
}
export class $Int2ObjectMap$$Static<V> implements $Int2ObjectMap {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: integer, arg1: any): boolean
 "size"(): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "values"(): $ObjectCollection<(V)>
 "clear"(): void
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "replace"(arg0: integer, arg1: V): V
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
/**
 * 
 * @deprecated
 */
 "entrySet"(): $Set<(any)>
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(integer), (V)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $Int2ObjectFunction$$Type<(V)>): V
 "computeIfAbsent"(arg0: integer, arg1: $IntFunction$$Type<(V)>): V
 "keySet"(): $Set<(any)>
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "int2ObjectEntrySet"(): $ObjectSet<($Int2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2ObjectFunction$$Type<(V)>): V
 "remove"(arg0: integer): V
 "get"(arg0: integer): V
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$$Type<(T), (integer)>): $Function<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Int2IntFunction
 "composeInt"(arg0: $Int2IntFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Int2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Int2ByteFunction
 "composeByte"(arg0: $Byte2IntFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2IntFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2IntFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Int2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Int2FloatFunction
 "composeObject"<T>(arg0: $Object2IntFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2IntFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Int2CharFunction
 "composeReference"<T>(arg0: $Reference2IntFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2IntFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Int2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Int2ReferenceFunction<(T)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Int2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2IntFunction$$Type): $Char2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(integer), (V)>): $Map<(integer), (V)>
 "isEmpty"(): boolean
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "replace"(arg0: integer, arg1: V): V
 "replaceAll"(arg0: $BiFunction$$Type<(integer), (V), (V)>): void
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V): $Map<(integer), (V)>
static "of"<K, V>(): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V, arg18: integer, arg19: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V): $Map<(integer), (V)>
static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V): $Map<(integer), (V)>
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "putAll"(arg0: $Map$$Type<(integer), (V)>): void
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
static "entry"<K, V>(arg0: integer, arg1: V): $Map$Entry<(integer), (V)>
 "computeIfAbsent"(arg0: integer, arg1: $Function$$Type<(integer), (V)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$$Type<(integer), (V), (V)>): V
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(integer), (V)>)[]): $Map<(integer), (V)>
 "apply"(arg0: integer): V
static "identity"<T>(): $Function<(integer), (integer)>
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(integer), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ObjectMap$$Type<V> = ($Int2ObjectMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ObjectMap_<V> = $Int2ObjectMap$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.doubles.DoubleBidirectionalIterator" {
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator"
import {$DoubleConsumer, $DoubleConsumer$$Type} from "java.util.function.DoubleConsumer"
import {$DoubleIterator, $DoubleIterator$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleIterator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$$Type as $DoubleConsumer$0$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $DoubleBidirectionalIterator extends $DoubleIterator, $ObjectBidirectionalIterator<(double)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): double
 "back"(arg0: integer): integer
 "previousDouble"(): double
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(double)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "nextDouble"(): double
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $DoubleConsumer$$Type): void
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $DoubleBidirectionalIterator {
const probejs$$marker: never
}
export class $DoubleBidirectionalIterator$$Static implements $DoubleBidirectionalIterator {


 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): double
 "back"(arg0: integer): integer
 "previousDouble"(): double
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(double)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "nextDouble"(): double
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $DoubleConsumer$$Type): void
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleBidirectionalIterator$$Type = ($DoubleBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleBidirectionalIterator_ = $DoubleBidirectionalIterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.Long2FloatFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$LongToDoubleFunction, $LongToDoubleFunction$$Type} from "java.util.function.LongToDoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Long2FloatFunction extends $Function<(long), (float)>, $LongToDoubleFunction {

 "remove"(arg0: long): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: float): float
 "put"(arg0: long, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: long, arg1: float): float
 "applyAsDouble"(arg0: long): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): float

(arg0: long): float
}

export namespace $Long2FloatFunction {
function identity<T>(): $Function$0<(long), (long)>
const probejs$$marker: never
}
export class $Long2FloatFunction$$Static implements $Long2FloatFunction {


 "remove"(arg0: long): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: float): float
 "put"(arg0: long, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: long, arg1: float): float
 "applyAsDouble"(arg0: long): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): float
static "identity"<T>(): $Function$0<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2FloatFunction$$Type = ((arg0: long) => float);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2FloatFunction_ = $Long2FloatFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Boolean2DoubleFunction extends $Function<(boolean), (double)> {

 "remove"(arg0: boolean): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
 "get"(arg0: boolean): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: double): double
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): double

(arg0: boolean): double
}

export namespace $Boolean2DoubleFunction {
function identity<T>(): $Function$0<(boolean), (boolean)>
const probejs$$marker: never
}
export class $Boolean2DoubleFunction$$Static implements $Boolean2DoubleFunction {


 "remove"(arg0: boolean): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
 "get"(arg0: boolean): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: double): double
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): double
static "identity"<T>(): $Function$0<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2DoubleFunction$$Type = ((arg0: boolean) => double);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2DoubleFunction_ = $Boolean2DoubleFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.ints.IntPredicate" {
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$$Type as $IntPredicate$0$$Type} from "java.util.function.IntPredicate"

export interface $IntPredicate extends $Predicate<(integer)>, $IntPredicate$0 {

/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$$Type<(integer)>): $Predicate<(integer)>
 "or"(arg0: $IntPredicate$0$$Type): $IntPredicate
 "or"(arg0: $IntPredicate$$Type): $IntPredicate
 "negate"(): $IntPredicate$0
 "and"(arg0: $IntPredicate$0$$Type): $IntPredicate$0
 "and"(arg0: $IntPredicate$$Type): $IntPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$$Type<(integer)>): $Predicate<(integer)>
 "test"(arg0: integer): boolean

(arg0: integer): boolean
}

export namespace $IntPredicate {
function not<T>(arg0: $Predicate$$Type<(integer)>): $Predicate<(integer)>
function isEqual<T>(arg0: any): $Predicate<(integer)>
const probejs$$marker: never
}
export class $IntPredicate$$Static implements $IntPredicate {


/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$$Type<(integer)>): $Predicate<(integer)>
 "or"(arg0: $IntPredicate$0$$Type): $IntPredicate
 "or"(arg0: $IntPredicate$$Type): $IntPredicate
 "negate"(): $IntPredicate$0
 "and"(arg0: $IntPredicate$0$$Type): $IntPredicate$0
 "and"(arg0: $IntPredicate$$Type): $IntPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$$Type<(integer)>): $Predicate<(integer)>
static "not"<T>(arg0: $Predicate$$Type<(integer)>): $Predicate<(integer)>
static "isEqual"<T>(arg0: any): $Predicate<(integer)>
 "test"(arg0: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntPredicate$$Type = ((arg0: integer) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntPredicate_ = $IntPredicate$$Type;
}}
declare module "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Boolean2ObjectFunction<V> extends $Function<(boolean), (V)> {

 "remove"(arg0: boolean): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: boolean): V
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: boolean): boolean
 "getOrDefault"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Boolean2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(boolean), (V)>

(arg0: boolean): V
}

export namespace $Boolean2ObjectFunction {
function identity<T>(): $Function$0<(boolean), (boolean)>
const probejs$$marker: never
}
export class $Boolean2ObjectFunction$$Static<V> implements $Boolean2ObjectFunction {


 "remove"(arg0: boolean): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: boolean): V
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: boolean): boolean
 "getOrDefault"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Boolean2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): V
static "identity"<T>(): $Function$0<(boolean), (boolean)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(boolean), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2ObjectFunction$$Type<V> = ((arg0: boolean) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2ObjectFunction_<V> = $Boolean2ObjectFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.objects.AbstractObjectList" {
import {$UnaryOperator, $UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$ObjectIterator, $ObjectIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectIterator"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$Stack, $Stack$$Type} from "it.unimi.dsi.fastutil.Stack"
import {$ObjectList, $ObjectList$$Type} from "it.unimi.dsi.fastutil.objects.ObjectList"
import {$AbstractObjectCollection, $AbstractObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.AbstractObjectCollection"
import {$ObjectListIterator, $ObjectListIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectListIterator"

export class $AbstractObjectList<K> extends $AbstractObjectCollection<(K)> implements $ObjectList<(K)>, $Stack<(K)> {


public "remove"(arg0: integer): K
public "size"(arg0: integer): void
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(arg0: any): integer
public "compareTo"(arg0: $List$$Type<(K)>): integer
public "indexOf"(arg0: any): integer
public "clear"(): void
public "lastIndexOf"(arg0: any): integer
public "add"(arg0: integer, arg1: K): void
public "add"(arg0: K): boolean
public "subList"(arg0: integer, arg1: integer): $ObjectList<(K)>
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "iterator"(): $ObjectIterator<(any)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$$Type<(K)>): boolean
public "addAll"(arg0: integer, arg1: $Collection$$Type<(K)>): boolean
public "set"(arg0: integer, arg1: K): K
public "forEach"(arg0: $Consumer$$Type<(K)>): void
public "top"(): K
public "peek"(arg0: integer): K
public "listIterator"(): $ObjectListIterator<(K)>
public "listIterator"(arg0: integer): $ObjectListIterator<(K)>
public "push"(arg0: K): void
public "pop"(): K
public "getElements"(arg0: integer, arg1: (any)[], arg2: integer, arg3: integer): void
public "setElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public "addElements"(arg0: integer, arg1: (K)[]): void
public "addElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public "removeElements"(arg0: integer, arg1: integer): void
public static "of"<K>(...arg0: (K)[]): $ObjectList<(K)>
public static "of"<K>(arg0: K, arg1: K, arg2: K): $ObjectList<(K)>
public static "of"<K>(arg0: K, arg1: K): $ObjectList<(K)>
public static "of"<K>(): $ObjectList<(K)>
public static "of"<K>(arg0: K): $ObjectList<(K)>
public "spliterator"(): $Spliterator<(any)>
public "addAll"(arg0: $ObjectList$$Type<(K)>): boolean
public "addAll"(arg0: integer, arg1: $ObjectList$$Type<(K)>): boolean
public "sort"(arg0: $Comparator$$Type<(K)>): void
public "unstableSort"(arg0: $Comparator$$Type<(K)>): void
public "setElements"(arg0: integer, arg1: (K)[]): void
public "setElements"(arg0: (K)[]): void
public "isEmpty"(): boolean
public "remove"(arg0: any): boolean
public "size"(): integer
public "get"(arg0: integer): K
public static "copyOf"<E>(arg0: $Collection$$Type<(K)>): $List<(K)>
public "replaceAll"(arg0: $UnaryOperator$$Type<(K)>): void
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $List<(K)>
public "getFirst"(): K
public "getLast"(): K
public "addFirst"(arg0: K): void
public "addLast"(arg0: K): void
public "removeFirst"(): K
public "removeLast"(): K
public "removeAll"(arg0: $Collection$$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$$Type<(any)>): boolean
public "reversed"(): $SequencedCollection<(any)>
public "containsAll"(arg0: $Collection$$Type<(any)>): boolean
[index: number]: any
set "elements"(value: (K)[])
get "empty"(): boolean
get "first"(): K
get "last"(): K
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObjectList$$Type<K> = ($AbstractObjectList<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObjectList_<K> = $AbstractObjectList$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.shorts.ShortListIterator" {
import {$ShortConsumer, $ShortConsumer$$Type} from "it.unimi.dsi.fastutil.shorts.ShortConsumer"
import {$ListIterator, $ListIterator$$Type} from "java.util.ListIterator"
import {$IntConsumer, $IntConsumer$$Type} from "java.util.function.IntConsumer"
import {$ShortBidirectionalIterator, $ShortBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.shorts.ShortBidirectionalIterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ShortListIterator extends $ShortBidirectionalIterator, $ListIterator<(short)> {

 "remove"(): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): void
 "add"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "next"(): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: short): void
 "set"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "previous"(): any
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousShort"(): short
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
 "forEachRemaining"(arg0: $IntConsumer$$Type): void
 "forEachRemaining"(arg0: $ShortConsumer$$Type): void
 "forEachRemaining"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(short)>): void
 "nextShort"(): short
}

export namespace $ShortListIterator {
const probejs$$marker: never
}
export class $ShortListIterator$$Static implements $ShortListIterator {


 "remove"(): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): void
 "add"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "next"(): any
/**
 * 
 * @deprecated
 */
 "set"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: short): void
 "set"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "previous"(): any
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousShort"(): short
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
 "forEachRemaining"(arg0: $IntConsumer$$Type): void
 "forEachRemaining"(arg0: $ShortConsumer$$Type): void
 "forEachRemaining"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(short)>): void
 "nextShort"(): short
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortListIterator$$Type = ($ShortListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortListIterator_ = $ShortListIterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2CharFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"

export interface $Reference2CharFunction<K> extends $Function<(K), (character)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getChar"(arg0: any): character
 "getOrDefault"(arg0: any, arg1: character): character
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2CharFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2CharFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2CharFunction
 "removeChar"(arg0: any): character
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): character
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (character)>

(arg0: any): character
}

export namespace $Reference2CharFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Reference2CharFunction$$Static<K> implements $Reference2CharFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getChar"(arg0: any): character
 "getOrDefault"(arg0: any, arg1: character): character
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(character), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Char2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2CharFunction
 "andThenDouble"(arg0: $Char2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Char2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2CharFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2CharFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Char2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2CharFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2CharFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2CharFunction
 "andThenShort"(arg0: $Char2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "andThenObject"<T>(arg0: $Char2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2CharFunction
 "removeChar"(arg0: any): character
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): character
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2CharFunction$$Type<K> = ((arg0: any) => character);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2CharFunction_<K> = $Reference2CharFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.longs.LongIterable" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$$Type as $LongConsumer$0$$Type} from "java.util.function.LongConsumer"
import {$LongSpliterator, $LongSpliterator$$Type} from "it.unimi.dsi.fastutil.longs.LongSpliterator"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$LongIterator, $LongIterator$$Type} from "it.unimi.dsi.fastutil.longs.LongIterator"
import {$LongConsumer, $LongConsumer$$Type} from "it.unimi.dsi.fastutil.longs.LongConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $LongIterable extends $Iterable<(long)> {

 "iterator"(): $Iterator<(any)>
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $LongConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(long)>): void
 "forEach"(arg0: $LongConsumer$$Type): void
 "longIterator"(): $LongIterator
 "longSpliterator"(): $LongSpliterator
[Symbol.iterator](): IterableIterator<any>;
}

export namespace $LongIterable {
const probejs$$marker: never
}
export class $LongIterable$$Static implements $LongIterable {


 "iterator"(): $Iterator<(any)>
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $LongConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(long)>): void
 "forEach"(arg0: $LongConsumer$$Type): void
 "longIterator"(): $LongIterator
 "longSpliterator"(): $LongSpliterator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongIterable$$Type = ($LongIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongIterable_ = $LongIterable$$Type;
}}
declare module "it.unimi.dsi.fastutil.Stack" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Stack<K> {

 "isEmpty"(): boolean
 "top"(): K
 "peek"(arg0: integer): K
 "push"(arg0: K): void
 "pop"(): K
get "empty"(): boolean
}

export namespace $Stack {
const probejs$$marker: never
}
export class $Stack$$Static<K> implements $Stack {


 "isEmpty"(): boolean
 "top"(): K
 "peek"(arg0: integer): K
 "push"(arg0: K): void
 "pop"(): K
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Stack$$Type<K> = ($Stack<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Stack_<K> = $Stack$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.objects.ObjectArrayList" {
import {$RandomAccess, $RandomAccess$$Type} from "java.util.RandomAccess"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$SequencedCollection, $SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$ObjectIterator, $ObjectIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectIterator"
import {$List, $List$$Type} from "java.util.List"
import {$AbstractObjectList, $AbstractObjectList$$Type} from "it.unimi.dsi.fastutil.objects.AbstractObjectList"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ObjectList, $ObjectList$$Type} from "it.unimi.dsi.fastutil.objects.ObjectList"
import {$ObjectSpliterator, $ObjectSpliterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSpliterator"
import {$ObjectCollection, $ObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.ObjectCollection"
import {$ListIterator, $ListIterator$$Type} from "java.util.ListIterator"
import {$Serializable, $Serializable$$Type} from "java.io.Serializable"
import {$Cloneable, $Cloneable$$Type} from "java.lang.Cloneable"
import {$Collector, $Collector$$Type} from "java.util.stream.Collector"

export class $ObjectArrayList<K> extends $AbstractObjectList<(K)> implements $RandomAccess, $Cloneable, $Serializable {
static readonly "DEFAULT_INITIAL_CAPACITY": integer

constructor()
constructor(arg0: $Collection$$Type<(K)>)
constructor(arg0: (K)[], arg1: integer, arg2: integer)
constructor(arg0: $ObjectList$$Type<(K)>)
constructor(arg0: (K)[])
constructor(arg0: $ObjectCollection$$Type<(K)>)
constructor(arg0: $ObjectIterator$$Type<(K)>)
constructor(arg0: $Iterator$$Type<(K)>)
constructor(arg0: integer)

public "remove"(arg0: any): boolean
public "remove"(arg0: integer): K
public "size"(): integer
public "size"(arg0: integer): void
public "get"(arg0: integer): K
public "equals"(arg0: any): boolean
public "equals"(arg0: $ObjectArrayList$$Type<(K)>): boolean
public "clone"(): any
public "compareTo"(arg0: $List$$Type<(K)>): integer
public "compareTo"(arg0: any): integer
public "compareTo"(arg0: $ObjectArrayList$$Type<(K)>): integer
public "indexOf"(arg0: any): integer
public "clear"(): void
public static "wrap"<K>(arg0: (K)[], arg1: integer): $ObjectArrayList<(K)>
public static "wrap"<K>(arg0: (K)[]): $ObjectArrayList<(K)>
public "lastIndexOf"(arg0: any): integer
public "isEmpty"(): boolean
public "add"(arg0: K): boolean
public "add"(arg0: integer, arg1: K): void
public "subList"(arg0: integer, arg1: integer): $List<(any)>
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "trim"(arg0: integer): void
public "trim"(): void
public static "toList"<K>(): $Collector<(K), (any), ($ObjectArrayList<(K)>)>
public static "of"<K>(): $ObjectArrayList<(K)>
public static "of"<K>(...arg0: (K)[]): $ObjectArrayList<(K)>
public "elements"(): (K)[]
public "spliterator"(): $ObjectSpliterator<(K)>
public "addAll"(arg0: integer, arg1: $Collection$$Type<(K)>): boolean
public "addAll"(arg0: integer, arg1: $ObjectList$$Type<(K)>): boolean
public "set"(arg0: integer, arg1: K): K
public "forEach"(arg0: $Consumer$$Type<(K)>): void
public "sort"(arg0: $Comparator$$Type<(K)>): void
public "ensureCapacity"(arg0: integer): void
public "removeAll"(arg0: $Collection$$Type<(any)>): boolean
public "listIterator"(arg0: integer): $ListIterator<(any)>
public "getElements"(arg0: integer, arg1: (any)[], arg2: integer, arg3: integer): void
public "unstableSort"(arg0: $Comparator$$Type<(K)>): void
public static "toListWithExpectedSize"<K>(arg0: integer): $Collector<(K), (any), ($ObjectArrayList<(K)>)>
public "setElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public "addElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public "removeElements"(arg0: integer, arg1: integer): void
public "iterator"(): $ObjectIterator<(any)>
public static "of"<K>(arg0: K, arg1: K, arg2: K): $ObjectList<(K)>
public static "of"<K>(arg0: K, arg1: K): $ObjectList<(K)>
public static "of"<K>(arg0: K): $ObjectList<(K)>
public static "copyOf"<E>(arg0: $Collection$$Type<(E)>): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public "retainAll"(arg0: $Collection$$Type<(any)>): boolean
public "reversed"(): $SequencedCollection<(any)>
public "containsAll"(arg0: $Collection$$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectArrayList$$Type<K> = ($ObjectArrayList<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectArrayList_<K> = $ObjectArrayList$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.objects.Reference2IntFunction" {
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2IntFunction, $Int2IntFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2IntFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"

export interface $Reference2IntFunction<K> extends $Function<(K), (integer)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getInt"(arg0: any): integer
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2IntFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2IntFunction
 "removeInt"(arg0: any): integer
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): integer
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (integer)>

(arg0: any): integer
}

export namespace $Reference2IntFunction {
function identity<T>(): $Function$0<(K), (K)>
const probejs$$marker: never
}
export class $Reference2IntFunction$$Static<K> implements $Reference2IntFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "put"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "getInt"(arg0: any): integer
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(integer), (T)>): $Function$0<(K), (T)>
 "andThenInt"(arg0: $Int2IntFunction$$Type): $Reference2IntFunction<(K)>
 "composeInt"(arg0: $Int2ReferenceFunction$$Type<(K)>): $Int2IntFunction
 "andThenDouble"(arg0: $Int2DoubleFunction$$Type): $Reference2DoubleFunction<(K)>
 "andThenByte"(arg0: $Int2ByteFunction$$Type): $Reference2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$$Type<(K)>): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ReferenceFunction$$Type<(K)>): $Double2IntFunction
 "composeFloat"(arg0: $Float2ReferenceFunction$$Type<(K)>): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$$Type): $Reference2LongFunction<(K)>
 "andThenFloat"(arg0: $Int2FloatFunction$$Type): $Reference2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$$Type<(T), (K)>): $Object2IntFunction<(T)>
 "composeLong"(arg0: $Long2ReferenceFunction$$Type<(K)>): $Long2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$$Type): $Reference2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(T), (K)>): $Reference2IntFunction<(T)>
 "composeShort"(arg0: $Short2ReferenceFunction$$Type<(K)>): $Short2IntFunction
 "andThenShort"(arg0: $Int2ShortFunction$$Type): $Reference2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$$Type<(T)>): $Reference2ReferenceFunction<(K), (T)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "andThenObject"<T>(arg0: $Int2ObjectFunction$$Type<(T)>): $Reference2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ReferenceFunction$$Type<(K)>): $Char2IntFunction
 "removeInt"(arg0: any): integer
 "size"(): integer
 "clear"(): void
 "apply"(arg0: K): integer
 "containsKey"(arg0: any): boolean
static "identity"<T>(): $Function$0<(K), (K)>
 "compose"<V>(arg0: $Function$0$$Type<(V), (K)>): $Function$0<(V), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2IntFunction$$Type<K> = ((arg0: any) => integer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2IntFunction_<K> = $Reference2IntFunction$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.ints.IntSortedSet" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$SortedSet, $SortedSet$$Type} from "java.util.SortedSet"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$IntStream, $IntStream$$Type} from "java.util.stream.IntStream"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$IntCollection, $IntCollection$$Type} from "it.unimi.dsi.fastutil.ints.IntCollection"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$$Type as $IntPredicate$0$$Type} from "java.util.function.IntPredicate"
import {$IntSpliterator, $IntSpliterator$$Type} from "it.unimi.dsi.fastutil.ints.IntSpliterator"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$IntSet, $IntSet$$Type} from "it.unimi.dsi.fastutil.ints.IntSet"
import {$IntIterator, $IntIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntIterator"
import {$IntBidirectionalIterable, $IntBidirectionalIterable$$Type} from "it.unimi.dsi.fastutil.ints.IntBidirectionalIterable"
import {$SequencedSet, $SequencedSet$$Type} from "java.util.SequencedSet"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$$Type as $IntConsumer$0$$Type} from "java.util.function.IntConsumer"
import {$IntPredicate, $IntPredicate$$Type} from "it.unimi.dsi.fastutil.ints.IntPredicate"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$IntConsumer, $IntConsumer$$Type} from "it.unimi.dsi.fastutil.ints.IntConsumer"
import {$IntBidirectionalIterator, $IntBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.ints.IntBidirectionalIterator"

export interface $IntSortedSet extends $IntSet, $SortedSet<(integer)>, $IntBidirectionalIterable {

 "iterator"(): $IntIterator
 "iterator"(arg0: integer): $IntBidirectionalIterator
/**
 * 
 * @deprecated
 */
 "last"(): any
 "spliterator"(): $Spliterator<(any)>
/**
 * 
 * @deprecated
 */
 "first"(): integer
 "comparator"(): $Comparator<(any)>
 "subSet"(arg0: integer, arg1: integer): $IntSortedSet
/**
 * 
 * @deprecated
 */
 "subSet"(arg0: any, arg1: any): $SortedSet<(any)>
/**
 * 
 * @deprecated
 */
 "subSet"(arg0: integer, arg1: integer): $IntSortedSet
 "headSet"(arg0: integer): $IntSortedSet
/**
 * 
 * @deprecated
 */
 "headSet"(arg0: any): $SortedSet<(any)>
/**
 * 
 * @deprecated
 */
 "headSet"(arg0: integer): $IntSortedSet
/**
 * 
 * @deprecated
 */
 "tailSet"(arg0: integer): $IntSortedSet
/**
 * 
 * @deprecated
 */
 "tailSet"(arg0: any): $SortedSet<(any)>
 "tailSet"(arg0: integer): $IntSortedSet
 "firstInt"(): integer
 "lastInt"(): integer
 "remove"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "rem"(arg0: integer): boolean
 "getFirst"(): integer
 "getLast"(): integer
 "addFirst"(arg0: integer): void
 "addLast"(arg0: integer): void
 "removeFirst"(): integer
 "removeLast"(): integer
 "reversed"(): $SequencedSet<(any)>
 "add"(arg0: integer): boolean
 "toArray"(arg0: (integer)[]): (integer)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
 "contains"(arg0: integer): boolean
 "addAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(integer)>): boolean
 "removeIf"(arg0: $IntPredicate$0$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $IntCollection$$Type): boolean
 "retainAll"(arg0: $IntCollection$$Type): boolean
 "containsAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
 "toIntArray"(): (integer)[]
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: $Collection$$Type<(integer)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "forEach"(arg0: $IntConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(integer)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
get "empty"(): boolean
}

export namespace $IntSortedSet {
function of(arg0: integer, arg1: integer): $IntSet
function of(): $IntSet
function of(...arg0: (integer)[]): $IntSet
function of(arg0: integer): $IntSet
function of(arg0: integer, arg1: integer, arg2: integer): $IntSet
function copyOf<E>(arg0: $Collection$$Type<(integer)>): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $Set<(integer)>
function of<E>(...arg0: (integer)[]): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer): $Set<(integer)>
function of<E>(arg0: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer): $Set<(integer)>
const probejs$$marker: never
}
export class $IntSortedSet$$Static implements $IntSortedSet {


 "iterator"(): $IntIterator
 "iterator"(arg0: integer): $IntBidirectionalIterator
/**
 * 
 * @deprecated
 */
 "last"(): any
 "spliterator"(): $Spliterator<(any)>
/**
 * 
 * @deprecated
 */
 "first"(): integer
 "comparator"(): $Comparator<(any)>
 "subSet"(arg0: integer, arg1: integer): $IntSortedSet
/**
 * 
 * @deprecated
 */
 "subSet"(arg0: any, arg1: any): $SortedSet<(any)>
/**
 * 
 * @deprecated
 */
 "subSet"(arg0: integer, arg1: integer): $IntSortedSet
 "headSet"(arg0: integer): $IntSortedSet
/**
 * 
 * @deprecated
 */
 "headSet"(arg0: any): $SortedSet<(any)>
/**
 * 
 * @deprecated
 */
 "headSet"(arg0: integer): $IntSortedSet
/**
 * 
 * @deprecated
 */
 "tailSet"(arg0: integer): $IntSortedSet
/**
 * 
 * @deprecated
 */
 "tailSet"(arg0: any): $SortedSet<(any)>
 "tailSet"(arg0: integer): $IntSortedSet
 "firstInt"(): integer
 "lastInt"(): integer
 "remove"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: any): boolean
static "of"(arg0: integer, arg1: integer): $IntSet
static "of"(): $IntSet
static "of"(...arg0: (integer)[]): $IntSet
static "of"(arg0: integer): $IntSet
static "of"(arg0: integer, arg1: integer, arg2: integer): $IntSet
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "rem"(arg0: integer): boolean
 "getFirst"(): integer
 "getLast"(): integer
 "addFirst"(arg0: integer): void
 "addLast"(arg0: integer): void
 "removeFirst"(): integer
 "removeLast"(): integer
 "reversed"(): $SequencedSet<(any)>
 "add"(arg0: integer): boolean
 "toArray"(arg0: (integer)[]): (integer)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
 "contains"(arg0: integer): boolean
 "addAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$$Type<(integer)>): boolean
 "removeIf"(arg0: $IntPredicate$0$$Type): boolean
 "removeIf"(arg0: $IntPredicate$$Type): boolean
 "removeAll"(arg0: $IntCollection$$Type): boolean
 "retainAll"(arg0: $IntCollection$$Type): boolean
 "containsAll"(arg0: $IntCollection$$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
 "toIntArray"(): (integer)[]
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "intIterator"(): $IntIterator
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "size"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<E>(arg0: $Collection$$Type<(integer)>): $Set<(integer)>
 "clear"(): void
 "isEmpty"(): boolean
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $Set<(integer)>
static "of"<E>(...arg0: (integer)[]): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer, arg2: integer): $Set<(integer)>
static "of"<E>(arg0: integer): $Set<(integer)>
static "of"<E>(arg0: integer, arg1: integer): $Set<(integer)>
 "addAll"(arg0: $Collection$$Type<(integer)>): boolean
 "removeAll"(arg0: $Collection$$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$$Type<(any)>): boolean
 "forEach"(arg0: $IntConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(integer)>): void
 "forEach"(arg0: $IntConsumer$$Type): void
 "toArray"<T>(arg0: $IntFunction$$Type<((T)[])>): (T)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntSortedSet$$Type = ($IntSortedSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntSortedSet_ = $IntSortedSet$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.Short2ByteFunction" {
import {$Byte2ByteFunction, $Byte2ByteFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Short2ByteFunction extends $Function<(short), (byte)>, $IntUnaryOperator {

 "remove"(arg0: short): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: byte): byte
 "put"(arg0: short, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: short, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): byte
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: short): byte
}

export namespace $Short2ByteFunction {
function identity(): $IntUnaryOperator
const probejs$$marker: never
}
export class $Short2ByteFunction$$Static implements $Short2ByteFunction {


 "remove"(arg0: short): byte
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: byte): byte
 "put"(arg0: short, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: short, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(byte), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Byte2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2ByteFunction
 "andThenDouble"(arg0: $Byte2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Byte2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2ByteFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2ByteFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2ByteFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2ByteFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2ByteFunction
 "andThenShort"(arg0: $Byte2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2ByteFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): byte
static "identity"(): $IntUnaryOperator
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2ByteFunction$$Type = ((arg0: short) => byte);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2ByteFunction_ = $Short2ByteFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.chars.Char2ObjectFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$IntFunction, $IntFunction$$Type} from "java.util.function.IntFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Char2ObjectFunction<V> extends $Function<(character), (V)>, $IntFunction<(V)> {

 "remove"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Char2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Char2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(character), (V)>

(arg0: character): V
}

export namespace $Char2ObjectFunction {
function identity<T>(): $Function$0<(character), (character)>
const probejs$$marker: never
}
export class $Char2ObjectFunction$$Static<V> implements $Char2ObjectFunction {


 "remove"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Char2DoubleFunction
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Char2LongFunction
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2ObjectFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): V
static "identity"<T>(): $Function$0<(character), (character)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(character), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ObjectFunction$$Type<V> = ((arg0: character) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ObjectFunction_<V> = $Char2ObjectFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.objects.ObjectIterable" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$ObjectSpliterator, $ObjectSpliterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSpliterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ObjectIterable<K> extends $Iterable<(K)> {

 "iterator"(): $Iterator<(any)>
 "spliterator"(): $ObjectSpliterator<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
[Symbol.iterator](): IterableIterator<any>;
}

export namespace $ObjectIterable {
const probejs$$marker: never
}
export class $ObjectIterable$$Static<K> implements $ObjectIterable {


 "iterator"(): $Iterator<(any)>
 "spliterator"(): $ObjectSpliterator<(K)>
 "forEach"(arg0: $Consumer$$Type<(K)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectIterable$$Type<K> = ($ObjectIterable<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectIterable_<K> = $ObjectIterable$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.objects.Object2ObjectMap" {
import {$Object2IntFunction, $Object2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntFunction"
import {$Object2ObjectMap$Entry, $Object2ObjectMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectMap$Entry"
import {$Object2ObjectFunction, $Object2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ObjectFunction"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$Int2ObjectFunction, $Int2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ObjectFunction"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ByteFunction"
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Object2ObjectMap<K, V> extends $Object2ObjectFunction<(K), (V)>, $Map<(K), (V)> {

 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "size"(): integer
 "put"(arg0: K, arg1: V): V
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: V): V
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(K), (V)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Object2ObjectFunction$$Type<(K), (V)>): V
 "keySet"(): $Set<(any)>
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "object2ObjectEntrySet"(): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
/**
 * 
 * @deprecated
 */
 "computeObjectIfAbsentPartial"(arg0: K, arg1: $Object2ObjectFunction$$Type<(K), (V)>): V
 "get"(arg0: any): V
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Object2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2ObjectFunction<(V)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (V), (V)>): void
 "putAll"(arg0: $Map$$Type<(K), (V)>): void
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (V)>): V
 "containsValue"(arg0: any): boolean
 "apply"(arg0: K): V
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(K), (V)>
[index: string | number]: V
get "empty"(): boolean
}

export namespace $Object2ObjectMap {
function copyOf<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
function of<K, V>(): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
function entry<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
function identity<T>(): $Function<(K), (K)>
const probejs$$marker: never
}
export class $Object2ObjectMap$$Static<K, V> implements $Object2ObjectMap {


 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "size"(): integer
 "put"(arg0: K, arg1: V): V
 "values"(): $Collection<(any)>
 "clear"(): void
 "replace"(arg0: K, arg1: V): V
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$$Type<(V), (V), (V)>): V
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
 "forEach"(arg0: $BiConsumer$$Type<(K), (V)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Object2ObjectFunction$$Type<(K), (V)>): V
 "keySet"(): $Set<(any)>
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$$Type<(K), (V), (V)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "object2ObjectEntrySet"(): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
/**
 * 
 * @deprecated
 */
 "computeObjectIfAbsentPartial"(arg0: K, arg1: $Object2ObjectFunction$$Type<(K), (V)>): V
 "get"(arg0: any): V
 "andThenInt"(arg0: $Object2IntFunction$$Type<(V)>): $Object2IntFunction<(K)>
 "composeInt"(arg0: $Int2ObjectFunction$$Type<(K)>): $Int2ObjectFunction<(V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$$Type<(V)>): $Object2DoubleFunction<(K)>
 "andThenByte"(arg0: $Object2ByteFunction$$Type<(V)>): $Object2ByteFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$$Type<(K)>): $Byte2ObjectFunction<(V)>
 "composeDouble"(arg0: $Double2ObjectFunction$$Type<(K)>): $Double2ObjectFunction<(V)>
 "composeFloat"(arg0: $Float2ObjectFunction$$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$$Type<(V)>): $Object2LongFunction<(K)>
 "andThenFloat"(arg0: $Object2FloatFunction$$Type<(V)>): $Object2FloatFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$$Type<(T), (K)>): $Object2ObjectFunction<(T), (V)>
 "composeLong"(arg0: $Long2ObjectFunction$$Type<(K)>): $Long2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$$Type<(V)>): $Object2CharFunction<(K)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$$Type<(T), (K)>): $Reference2ObjectFunction<(T), (V)>
 "composeShort"(arg0: $Short2ObjectFunction$$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenShort"(arg0: $Object2ShortFunction$$Type<(V)>): $Object2ShortFunction<(K)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$$Type<(V), (T)>): $Object2ReferenceFunction<(K), (T)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$$Type<(V), (T)>): $Object2ObjectFunction<(K), (T)>
 "composeChar"(arg0: $Char2ObjectFunction$$Type<(K)>): $Char2ObjectFunction<(V)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$$Type<(K), (V), (V)>): void
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
static "of"<K, V>(): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
 "putAll"(arg0: $Map$$Type<(K), (V)>): void
static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
 "computeIfAbsent"(arg0: K, arg1: $Function$$Type<(K), (V)>): V
 "containsValue"(arg0: any): boolean
static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
 "apply"(arg0: K): V
static "identity"<T>(): $Function<(K), (K)>
 "compose"<V>(arg0: $Function$$Type<(V), (K)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$$Type<(V), (V)>): $Function<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectMap$$Type<K, V> = ($Object2ObjectMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectMap_<K, V> = $Object2ObjectMap$$Type<(K), (V)>;
}}
declare module "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Reference2IntFunction, $Reference2IntFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ReferenceFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ReferenceFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"

export interface $Boolean2ReferenceFunction<V> extends $Function<(boolean), (V)> {

 "remove"(arg0: boolean): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: boolean): V
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: boolean): boolean
 "getOrDefault"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Boolean2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): V
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(boolean), (V)>

(arg0: boolean): V
}

export namespace $Boolean2ReferenceFunction {
function identity<T>(): $Function$0<(boolean), (boolean)>
const probejs$$marker: never
}
export class $Boolean2ReferenceFunction$$Static<V> implements $Boolean2ReferenceFunction {


 "remove"(arg0: boolean): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: boolean): V
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: boolean): boolean
 "getOrDefault"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (V)>
 "andThenInt"(arg0: $Reference2IntFunction$$Type<(V)>): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2ReferenceFunction<(V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$$Type<(V)>): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Reference2ByteFunction$$Type<(V)>): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2ReferenceFunction<(V)>
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2ReferenceFunction<(V)>
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$$Type<(V)>): $Boolean2LongFunction
 "andThenFloat"(arg0: $Reference2FloatFunction$$Type<(V)>): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2ReferenceFunction<(T), (V)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$$Type<(V)>): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2ReferenceFunction<(T), (V)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2ReferenceFunction<(V)>
 "andThenShort"(arg0: $Reference2ShortFunction$$Type<(V)>): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$$Type<(V), (T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$$Type<(V), (T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2ReferenceFunction<(V)>
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): V
static "identity"<T>(): $Function$0<(boolean), (boolean)>
 "andThen"<V>(arg0: $Function$0$$Type<(V), (V)>): $Function$0<(boolean), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2ReferenceFunction$$Type<V> = ((arg0: boolean) => V);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2ReferenceFunction_<V> = $Boolean2ReferenceFunction$$Type<(V)>;
}}
declare module "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$DoublePredicate, $DoublePredicate$$Type} from "java.util.function.DoublePredicate"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Double2BooleanFunction extends $Function<(double), (boolean)>, $DoublePredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: double, arg1: boolean): boolean
 "test"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
 "getOrDefault"(arg0: double, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): boolean
 "or"(arg0: $DoublePredicate$$Type): $DoublePredicate
 "negate"(): $DoublePredicate
 "and"(arg0: $DoublePredicate$$Type): $DoublePredicate

(arg0: double): boolean
}

export namespace $Double2BooleanFunction {
function identity<T>(): $Function$0<(double), (double)>
const probejs$$marker: never
}
export class $Double2BooleanFunction$$Static implements $Double2BooleanFunction {


/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: double, arg1: boolean): boolean
 "test"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
 "getOrDefault"(arg0: double, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (double)>): $Function$0<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(boolean), (T)>): $Function$0<(double), (T)>
 "andThenInt"(arg0: $Boolean2IntFunction$$Type): $Double2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$$Type): $Int2BooleanFunction
 "andThenDouble"(arg0: $Boolean2DoubleFunction$$Type): $Double2DoubleFunction
 "andThenByte"(arg0: $Boolean2ByteFunction$$Type): $Double2ByteFunction
 "composeByte"(arg0: $Byte2DoubleFunction$$Type): $Byte2BooleanFunction
 "composeDouble"(arg0: $Double2DoubleFunction$$Type): $Double2BooleanFunction
 "composeFloat"(arg0: $Float2DoubleFunction$$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$$Type): $Double2LongFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$$Type): $Double2FloatFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$$Type<(T)>): $Object2BooleanFunction<(T)>
 "composeLong"(arg0: $Long2DoubleFunction$$Type): $Long2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$$Type): $Double2CharFunction
 "composeReference"<T>(arg0: $Reference2DoubleFunction$$Type<(T)>): $Reference2BooleanFunction<(T)>
 "composeShort"(arg0: $Short2DoubleFunction$$Type): $Short2BooleanFunction
 "andThenShort"(arg0: $Boolean2ShortFunction$$Type): $Double2ShortFunction
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$$Type<(T)>): $Double2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$$Type<(T)>): $Double2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2DoubleFunction$$Type): $Char2BooleanFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: double): boolean
 "or"(arg0: $DoublePredicate$$Type): $DoublePredicate
 "negate"(): $DoublePredicate
 "and"(arg0: $DoublePredicate$$Type): $DoublePredicate
static "identity"<T>(): $Function$0<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2BooleanFunction$$Type = ((arg0: double) => boolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2BooleanFunction_ = $Double2BooleanFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.chars.Char2FloatFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$$Type} from "java.util.function.IntToDoubleFunction"
import {$Byte2CharFunction, $Byte2CharFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2CharFunction"
import {$Object2CharFunction, $Object2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2CharFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Char2CharFunction, $Char2CharFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2CharFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Char2ByteFunction, $Char2ByteFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2CharFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ReferenceFunction"
import {$Char2IntFunction, $Char2IntFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2IntFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"

export interface $Char2FloatFunction extends $Function<(character), (float)>, $IntToDoubleFunction {

 "remove"(arg0: character): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: float): float
 "put"(arg0: character, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: character, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): float

(arg0: character): float
}

export namespace $Char2FloatFunction {
function identity<T>(): $Function$0<(character), (character)>
const probejs$$marker: never
}
export class $Char2FloatFunction$$Static implements $Char2FloatFunction {


 "remove"(arg0: character): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: character): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: float): float
 "put"(arg0: character, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: character, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (character)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(character), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Char2IntFunction
 "composeInt"(arg0: $Int2CharFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Char2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Char2ByteFunction
 "composeByte"(arg0: $Byte2CharFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2CharFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2CharFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Char2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Char2FloatFunction
 "composeObject"<T>(arg0: $Object2CharFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2CharFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Char2CharFunction
 "composeReference"<T>(arg0: $Reference2CharFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2CharFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Char2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Char2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Char2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2CharFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: character): float
static "identity"<T>(): $Function$0<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2FloatFunction$$Type = ((arg0: character) => float);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2FloatFunction_ = $Char2FloatFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.AbstractObjectCollection" {
import {$ObjectSpliterator, $ObjectSpliterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSpliterator"
import {$ObjectCollection, $ObjectCollection$$Type} from "it.unimi.dsi.fastutil.objects.ObjectCollection"
import {$ObjectIterator, $ObjectIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectIterator"
import {$AbstractCollection, $AbstractCollection$$Type} from "java.util.AbstractCollection"

export class $AbstractObjectCollection<K> extends $AbstractCollection<(K)> implements $ObjectCollection<(K)> {


public "toString"(): string
public "iterator"(): $ObjectIterator<(K)>
public "spliterator"(): $ObjectSpliterator<(K)>
public "equals"(arg0: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObjectCollection$$Type<K> = ($AbstractObjectCollection<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObjectCollection_<K> = $AbstractObjectCollection$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.objects.ObjectListIterator" {
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator"
import {$ListIterator, $ListIterator$$Type} from "java.util.ListIterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ObjectListIterator<K> extends $ObjectBidirectionalIterator<(K)>, $ListIterator<(K)> {

 "remove"(): void
 "add"(arg0: K): void
 "set"(arg0: K): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "hasNext"(): boolean
 "next"(): K
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
 "previous"(): K
 "forEachRemaining"(arg0: $Consumer$$Type<(K)>): void
}

export namespace $ObjectListIterator {
const probejs$$marker: never
}
export class $ObjectListIterator$$Static<K> implements $ObjectListIterator {


 "remove"(): void
 "add"(arg0: K): void
 "set"(arg0: K): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "hasNext"(): boolean
 "next"(): K
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
 "previous"(): K
 "forEachRemaining"(arg0: $Consumer$$Type<(K)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectListIterator$$Type<K> = ($ObjectListIterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectListIterator_<K> = $ObjectListIterator$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.ints.IntConsumer" {
import {$IntConsumer as $IntConsumer$0, $IntConsumer$$Type as $IntConsumer$0$$Type} from "java.util.function.IntConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $IntConsumer extends $Consumer<(integer)>, $IntConsumer$0 {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: integer): void
 "andThen"(arg0: $IntConsumer$0$$Type): $IntConsumer$0
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$$Type<(integer)>): $Consumer<(integer)>
 "andThen"(arg0: $IntConsumer$$Type): $IntConsumer
 "accept"(arg0: integer): void

(arg0: integer): void
}

export namespace $IntConsumer {
const probejs$$marker: never
}
export class $IntConsumer$$Static implements $IntConsumer {


/**
 * 
 * @deprecated
 */
 "accept"(arg0: any): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: integer): void
 "andThen"(arg0: $IntConsumer$0$$Type): $IntConsumer$0
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$$Type<(integer)>): $Consumer<(integer)>
 "andThen"(arg0: $IntConsumer$$Type): $IntConsumer
 "accept"(arg0: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntConsumer$$Type = ((arg0: integer) => void);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntConsumer_ = $IntConsumer$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.LongBidirectionalIterable" {
import {$LongConsumer as $LongConsumer$0, $LongConsumer$$Type as $LongConsumer$0$$Type} from "java.util.function.LongConsumer"
import {$LongSpliterator, $LongSpliterator$$Type} from "it.unimi.dsi.fastutil.longs.LongSpliterator"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$LongBidirectionalIterator, $LongBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.longs.LongBidirectionalIterator"
import {$LongIterator, $LongIterator$$Type} from "it.unimi.dsi.fastutil.longs.LongIterator"
import {$LongIterable, $LongIterable$$Type} from "it.unimi.dsi.fastutil.longs.LongIterable"
import {$LongConsumer, $LongConsumer$$Type} from "it.unimi.dsi.fastutil.longs.LongConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $LongBidirectionalIterable extends $LongIterable {

 "iterator"(): $LongBidirectionalIterator
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $LongConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(long)>): void
 "forEach"(arg0: $LongConsumer$$Type): void
 "longIterator"(): $LongIterator
 "longSpliterator"(): $LongSpliterator

(): $LongBidirectionalIterator$$Type
}

export namespace $LongBidirectionalIterable {
const probejs$$marker: never
}
export class $LongBidirectionalIterable$$Static implements $LongBidirectionalIterable {


 "iterator"(): $LongBidirectionalIterator
 "spliterator"(): $Spliterator<(any)>
 "forEach"(arg0: $LongConsumer$0$$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$$Type<(long)>): void
 "forEach"(arg0: $LongConsumer$$Type): void
 "longIterator"(): $LongIterator
 "longSpliterator"(): $LongSpliterator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongBidirectionalIterable$$Type = (() => $LongBidirectionalIterator$$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongBidirectionalIterable_ = $LongBidirectionalIterable$$Type;
}}
declare module "it.unimi.dsi.fastutil.longs.LongIterator" {
import {$LongConsumer as $LongConsumer$0, $LongConsumer$$Type as $LongConsumer$0$$Type} from "java.util.function.LongConsumer"
import {$PrimitiveIterator$OfLong, $PrimitiveIterator$OfLong$$Type} from "java.util.PrimitiveIterator$OfLong"
import {$LongConsumer, $LongConsumer$$Type} from "it.unimi.dsi.fastutil.longs.LongConsumer"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $LongIterator extends $PrimitiveIterator$OfLong {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(long)>): void
 "forEachRemaining"(arg0: $LongConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "skip"(arg0: integer): integer
 "nextLong"(): long
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $LongConsumer$0$$Type): void
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $LongIterator {
const probejs$$marker: never
}
export class $LongIterator$$Static implements $LongIterator {


/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$$Type<(long)>): void
 "forEachRemaining"(arg0: $LongConsumer$$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): any
 "skip"(arg0: integer): integer
 "nextLong"(): long
 "forEachRemaining"(arg0: any): void
 "forEachRemaining"(arg0: $LongConsumer$0$$Type): void
 "remove"(): void
 "hasNext"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongIterator$$Type = ($LongIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongIterator_ = $LongIterator$$Type;
}}
declare module "it.unimi.dsi.fastutil.floats.Float2FloatFunction" {
import {$DoubleUnaryOperator, $DoubleUnaryOperator$$Type} from "java.util.function.DoubleUnaryOperator"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ReferenceFunction"
import {$Float2ByteFunction, $Float2ByteFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ByteFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2FloatFunction, $Int2FloatFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2FloatFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Float2IntFunction, $Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ObjectFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Object2FloatFunction, $Object2FloatFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2FloatFunction"
import {$Char2FloatFunction, $Char2FloatFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Float2CharFunction, $Float2CharFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2CharFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"

export interface $Float2FloatFunction extends $Function<(float), (float)>, $DoubleUnaryOperator {

 "remove"(arg0: float): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: float, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: float): float
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: float, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): float
 "compose"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator

(arg0: float): float
}

export namespace $Float2FloatFunction {
function identity(): $Float2FloatFunction
const probejs$$marker: never
}
export class $Float2FloatFunction$$Static implements $Float2FloatFunction {


 "remove"(arg0: float): float
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: float, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: float): float
static "identity"(): $Float2FloatFunction
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: float, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (float)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(float), (T)>): $Function$0<(float), (T)>
 "andThenInt"(arg0: $Float2IntFunction$$Type): $Float2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$$Type): $Int2FloatFunction
 "andThenDouble"(arg0: $Float2DoubleFunction$$Type): $Float2DoubleFunction
 "andThenByte"(arg0: $Float2ByteFunction$$Type): $Float2ByteFunction
 "composeByte"(arg0: $Byte2FloatFunction$$Type): $Byte2FloatFunction
 "composeDouble"(arg0: $Double2FloatFunction$$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2FloatFunction$$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$$Type): $Float2LongFunction
 "andThenFloat"(arg0: $Float2FloatFunction$$Type): $Float2FloatFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$$Type<(T)>): $Object2FloatFunction<(T)>
 "composeLong"(arg0: $Long2FloatFunction$$Type): $Long2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$$Type): $Float2CharFunction
 "composeReference"<T>(arg0: $Reference2FloatFunction$$Type<(T)>): $Reference2FloatFunction<(T)>
 "composeShort"(arg0: $Short2FloatFunction$$Type): $Short2FloatFunction
 "andThenShort"(arg0: $Float2ShortFunction$$Type): $Float2ShortFunction
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$$Type<(T)>): $Float2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenObject"<T>(arg0: $Float2ObjectFunction$$Type<(T)>): $Float2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2FloatFunction$$Type): $Char2FloatFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: float): float
 "compose"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$$Type): $DoubleUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2FloatFunction$$Type = ((arg0: float) => float);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2FloatFunction_ = $Float2FloatFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2DoubleFunction, $Long2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2DoubleFunction"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export interface $Boolean2LongFunction extends $Function<(boolean), (long)> {

 "remove"(arg0: boolean): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
 "get"(arg0: boolean): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: long): long
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): long

(arg0: boolean): long
}

export namespace $Boolean2LongFunction {
function identity<T>(): $Function$0<(boolean), (boolean)>
const probejs$$marker: never
}
export class $Boolean2LongFunction$$Static implements $Boolean2LongFunction {


 "remove"(arg0: boolean): long
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
 "get"(arg0: boolean): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: long): long
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(long), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Long2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2LongFunction
 "andThenDouble"(arg0: $Long2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Long2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2LongFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2LongFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2LongFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2LongFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2LongFunction
 "andThenShort"(arg0: $Long2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): long
 "defaultReturnValue"(arg0: long): void
 "andThenObject"<T>(arg0: $Long2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2LongFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): long
static "identity"<T>(): $Function$0<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2LongFunction$$Type = ((arg0: boolean) => long);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2LongFunction_ = $Boolean2LongFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.shorts.Short2ShortFunction" {
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$IntUnaryOperator, $IntUnaryOperator$$Type} from "java.util.function.IntUnaryOperator"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Short2ShortFunction extends $Function<(short), (short)>, $IntUnaryOperator {

 "remove"(arg0: short): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: short, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: short): short
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: short, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): short
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator

(arg0: short): short
}

export namespace $Short2ShortFunction {
function identity(): $Short2ShortFunction
const probejs$$marker: never
}
export class $Short2ShortFunction$$Static implements $Short2ShortFunction {


 "remove"(arg0: short): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: short, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: short): short
static "identity"(): $Short2ShortFunction
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: short, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (short)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(short), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Short2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Short2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Short2ByteFunction
 "composeByte"(arg0: $Byte2ShortFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2ShortFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2ShortFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Short2FloatFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2ShortFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Short2CharFunction
 "composeReference"<T>(arg0: $Reference2ShortFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2ShortFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Short2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Short2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Short2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2ShortFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: short): short
 "compose"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$$Type): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2ShortFunction$$Type = ((arg0: short) => short);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2ShortFunction_ = $Short2ShortFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.booleans.Boolean2ShortFunction" {
import {$Reference2BooleanFunction, $Reference2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2BooleanFunction"
import {$Float2BooleanFunction, $Float2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2BooleanFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2BooleanFunction"
import {$Short2IntFunction, $Short2IntFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2IntFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2CharFunction"
import {$Char2ShortFunction, $Char2ShortFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2ShortFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Short2ShortFunction, $Short2ShortFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ShortFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2FloatFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2ShortFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Boolean2CharFunction, $Boolean2CharFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2CharFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2BooleanFunction"
import {$Int2ShortFunction, $Int2ShortFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2ShortFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ReferenceFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2ShortFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2BooleanFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ByteFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2IntFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2BooleanFunction"
import {$Short2FloatFunction, $Short2FloatFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2FloatFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ByteFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$$Type} from "it.unimi.dsi.fastutil.booleans.Boolean2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Boolean2ShortFunction extends $Function<(boolean), (short)> {

 "remove"(arg0: boolean): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): short
 "get"(arg0: boolean): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: short): short
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: short): short
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): short

(arg0: boolean): short
}

export namespace $Boolean2ShortFunction {
function identity<T>(): $Function$0<(boolean), (boolean)>
const probejs$$marker: never
}
export class $Boolean2ShortFunction$$Static implements $Boolean2ShortFunction {


 "remove"(arg0: boolean): short
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): short
 "get"(arg0: boolean): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
 "put"(arg0: boolean, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: short): short
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: short): short
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (boolean)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(short), (T)>): $Function$0<(boolean), (T)>
 "andThenInt"(arg0: $Short2IntFunction$$Type): $Boolean2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$$Type): $Int2ShortFunction
 "andThenDouble"(arg0: $Short2DoubleFunction$$Type): $Boolean2DoubleFunction
 "andThenByte"(arg0: $Short2ByteFunction$$Type): $Boolean2ByteFunction
 "composeByte"(arg0: $Byte2BooleanFunction$$Type): $Byte2ShortFunction
 "composeDouble"(arg0: $Double2BooleanFunction$$Type): $Double2ShortFunction
 "composeFloat"(arg0: $Float2BooleanFunction$$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$$Type): $Boolean2LongFunction
 "andThenFloat"(arg0: $Short2FloatFunction$$Type): $Boolean2FloatFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$$Type<(T)>): $Object2ShortFunction<(T)>
 "composeLong"(arg0: $Long2BooleanFunction$$Type): $Long2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$$Type): $Boolean2CharFunction
 "composeReference"<T>(arg0: $Reference2BooleanFunction$$Type<(T)>): $Reference2ShortFunction<(T)>
 "composeShort"(arg0: $Short2BooleanFunction$$Type): $Short2ShortFunction
 "andThenShort"(arg0: $Short2ShortFunction$$Type): $Boolean2ShortFunction
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$$Type<(T)>): $Boolean2ReferenceFunction<(T)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "andThenObject"<T>(arg0: $Short2ObjectFunction$$Type<(T)>): $Boolean2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2BooleanFunction$$Type): $Char2ShortFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: boolean): short
static "identity"<T>(): $Function$0<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2ShortFunction$$Type = ((arg0: boolean) => short);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2ShortFunction_ = $Boolean2ShortFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.AbstractObjectSortedSet" {
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$$Type} from "it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator"
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$SequencedSet, $SequencedSet$$Type} from "java.util.SequencedSet"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$ObjectSet, $ObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$SortedSet, $SortedSet$$Type} from "java.util.SortedSet"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Spliterator, $Spliterator$$Type} from "java.util.Spliterator"
import {$ObjectSortedSet, $ObjectSortedSet$$Type} from "it.unimi.dsi.fastutil.objects.ObjectSortedSet"
import {$AbstractObjectSet, $AbstractObjectSet$$Type} from "it.unimi.dsi.fastutil.objects.AbstractObjectSet"
import {$Set, $Set$$Type} from "java.util.Set"

export class $AbstractObjectSortedSet<K> extends $AbstractObjectSet<(K)> implements $ObjectSortedSet<(K)> {


public "iterator"(): $Iterator<(any)>
public "iterator"(arg0: K): $ObjectBidirectionalIterator<(K)>
public "spliterator"(): $Spliterator<(any)>
public "subSet"(arg0: any, arg1: any): $SortedSet<(any)>
public "headSet"(arg0: any): $SortedSet<(any)>
public "tailSet"(arg0: any): $SortedSet<(any)>
public static "of"<K>(arg0: K, arg1: K): $ObjectSet<(K)>
public static "of"<K>(...arg0: (K)[]): $ObjectSet<(K)>
public static "of"<K>(arg0: K, arg1: K, arg2: K): $ObjectSet<(K)>
public static "of"<K>(): $ObjectSet<(K)>
public static "of"<K>(arg0: K): $ObjectSet<(K)>
public "last"(): K
public "first"(): K
public "getFirst"(): K
public "getLast"(): K
public "addFirst"(arg0: K): void
public "addLast"(arg0: K): void
public "removeFirst"(): K
public "removeLast"(): K
public "reversed"(): $SequencedSet<(any)>
public "comparator"(): $Comparator<(K)>
public "remove"(arg0: any): boolean
public "size"(): integer
public static "copyOf"<E>(arg0: $Collection$$Type<(K)>): $Set<(K)>
public "clear"(): void
public "isEmpty"(): boolean
public "add"(arg0: K): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$$Type<(K)>): boolean
public "removeAll"(arg0: $Collection$$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObjectSortedSet$$Type<K> = ($AbstractObjectSortedSet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObjectSortedSet_<K> = $AbstractObjectSortedSet$$Type<(K)>;
}}
declare module "it.unimi.dsi.fastutil.longs.Long2DoubleFunction" {
import {$Char2DoubleFunction, $Char2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2DoubleFunction"
import {$Long2CharFunction, $Long2CharFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2CharFunction"
import {$Long2IntFunction, $Long2IntFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2IntFunction"
import {$Long2ByteFunction, $Long2ByteFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ByteFunction"
import {$Reference2LongFunction, $Reference2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2LongFunction"
import {$Double2FloatFunction, $Double2FloatFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2FloatFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ReferenceFunction"
import {$Long2ShortFunction, $Long2ShortFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ShortFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2DoubleFunction"
import {$LongToDoubleFunction, $LongToDoubleFunction$$Type} from "java.util.function.LongToDoubleFunction"
import {$Function as $Function$0, $Function$$Type as $Function$0$$Type} from "java.util.function.Function"
import {$Int2DoubleFunction, $Int2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2DoubleFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2DoubleFunction"
import {$Function, $Function$$Type} from "it.unimi.dsi.fastutil.Function"
import {$Long2LongFunction, $Long2LongFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2LongFunction"
import {$Float2LongFunction, $Float2LongFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2CharFunction"
import {$Byte2LongFunction, $Byte2LongFunction$$Type} from "it.unimi.dsi.fastutil.bytes.Byte2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$$Type} from "it.unimi.dsi.fastutil.chars.Char2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$$Type} from "it.unimi.dsi.fastutil.shorts.Short2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$$Type} from "it.unimi.dsi.fastutil.ints.Int2LongFunction"
import {$Long2FloatFunction, $Long2FloatFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2FloatFunction"
import {$Double2IntFunction, $Double2IntFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ObjectFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.objects.Reference2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2DoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$$Type} from "it.unimi.dsi.fastutil.doubles.Double2ShortFunction"

export interface $Long2DoubleFunction extends $Function<(long), (double)>, $LongToDoubleFunction {

 "remove"(arg0: long): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: double): double
 "put"(arg0: long, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: long, arg1: double): double
 "applyAsDouble"(arg0: long): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): double

(arg0: long): double
}

export namespace $Long2DoubleFunction {
function identity<T>(): $Function$0<(long), (long)>
const probejs$$marker: never
}
export class $Long2DoubleFunction$$Static implements $Long2DoubleFunction {


 "remove"(arg0: long): double
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): any
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): any
 "get"(arg0: long): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: double): double
 "put"(arg0: long, arg1: double): double
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: any): any
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: long, arg1: double): double
 "applyAsDouble"(arg0: long): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$$Type<(T), (long)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$$Type<(double), (T)>): $Function$0<(long), (T)>
 "andThenInt"(arg0: $Double2IntFunction$$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$$Type): $Int2DoubleFunction
 "andThenDouble"(arg0: $Double2DoubleFunction$$Type): $Long2DoubleFunction
 "andThenByte"(arg0: $Double2ByteFunction$$Type): $Long2ByteFunction
 "composeByte"(arg0: $Byte2LongFunction$$Type): $Byte2DoubleFunction
 "composeDouble"(arg0: $Double2LongFunction$$Type): $Double2DoubleFunction
 "composeFloat"(arg0: $Float2LongFunction$$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$$Type): $Long2LongFunction
 "andThenFloat"(arg0: $Double2FloatFunction$$Type): $Long2FloatFunction
 "composeObject"<T>(arg0: $Object2LongFunction$$Type<(T)>): $Object2DoubleFunction<(T)>
 "composeLong"(arg0: $Long2LongFunction$$Type): $Long2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$$Type): $Long2CharFunction
 "composeReference"<T>(arg0: $Reference2LongFunction$$Type<(T)>): $Reference2DoubleFunction<(T)>
 "composeShort"(arg0: $Short2LongFunction$$Type): $Short2DoubleFunction
 "andThenShort"(arg0: $Double2ShortFunction$$Type): $Long2ShortFunction
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$$Type<(T)>): $Long2ReferenceFunction<(T)>
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenObject"<T>(arg0: $Double2ObjectFunction$$Type<(T)>): $Long2ObjectFunction<(T)>
 "composeChar"(arg0: $Char2LongFunction$$Type): $Char2DoubleFunction
 "size"(): integer
 "clear"(): void
 "apply"(arg0: long): double
static "identity"<T>(): $Function$0<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2DoubleFunction$$Type = ((arg0: long) => double);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2DoubleFunction_ = $Long2DoubleFunction$$Type;
}}
declare module "it.unimi.dsi.fastutil.objects.ObjectIterator" {
import {$Iterator, $Iterator$$Type} from "java.util.Iterator"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $ObjectIterator<K> extends $Iterator<(K)> {

 "skip"(arg0: integer): integer
 "remove"(): void
 "forEachRemaining"(arg0: $Consumer$$Type<(K)>): void
 "hasNext"(): boolean
 "next"(): K
}

export namespace $ObjectIterator {
const probejs$$marker: never
}
export class $ObjectIterator$$Static<K> implements $ObjectIterator {


 "skip"(arg0: integer): integer
 "remove"(): void
 "forEachRemaining"(arg0: $Consumer$$Type<(K)>): void
 "hasNext"(): boolean
 "next"(): K
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectIterator$$Type<K> = ($ObjectIterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectIterator_<K> = $ObjectIterator$$Type<(K)>;
}}
